"use strict";(self.webpackChunkblog_demo=self.webpackChunkblog_demo||[]).push([[143],{6396:(n,s,a)=>{a.d(s,{g:()=>u});var t=a(7478),e=a(5748),p=a(1598),l=a(8949),o=a(1843),r=a(9146),c=a(287);const i=(0,a(7621).vW)((({app:n,router:s,siteData:a})=>{})),u=[t.Z,e.Z,p.Z,l.Z,o.Z,r.Z,c.Z,i]},9947:(n,s,a)=>{a.d(s,{p:()=>t});const t=[a(3051).Z]},4611:(n,s,a)=>{a.d(s,{l:()=>o});var t=a(1263),e=a(6243),p=a(7593),l=a(4817);const o=[t.Z,e.Z,p.Z,l.Z]},4150:(n,s,a)=>{a.d(s,{Z:()=>e});var t=a(6252);const e={404:(0,t.RC)((()=>Promise.all([a.e(973),a.e(431)]).then(a.bind(a,2431)))),Layout:(0,t.RC)((()=>a.e(887).then(a.bind(a,8887))))}},6056:(n,s,a)=>{a.d(s,{b:()=>e});var t=a(6252);const e={"v-ef444906":(0,t.RC)((()=>a.e(717).then(a.bind(a,9054)))),"v-3d2f7822":(0,t.RC)((()=>a.e(175).then(a.bind(a,5952)))),"v-7e88feb6":(0,t.RC)((()=>a.e(83).then(a.bind(a,6894)))),"v-c11452c2":(0,t.RC)((()=>a.e(708).then(a.bind(a,9073)))),"v-41c2a7b8":(0,t.RC)((()=>a.e(107).then(a.bind(a,5939)))),"v-7e7a417e":(0,t.RC)((()=>a.e(720).then(a.bind(a,9596)))),"v-a25da32e":(0,t.RC)((()=>a.e(811).then(a.bind(a,2634)))),"v-1054ac98":(0,t.RC)((()=>a.e(399).then(a.bind(a,7488)))),"v-1e97db11":(0,t.RC)((()=>a.e(444).then(a.bind(a,157)))),"v-0a97e47a":(0,t.RC)((()=>a.e(434).then(a.bind(a,6634)))),"v-3706649a":(0,t.RC)((()=>a.e(88).then(a.bind(a,8109)))),"v-8daa1a0e":(0,t.RC)((()=>a.e(509).then(a.bind(a,1829)))),"v-74bc627b":(0,t.RC)((()=>a.e(5).then(a.bind(a,9085)))),"v-14f724bf":(0,t.RC)((()=>a.e(69).then(a.bind(a,8784)))),"v-14e6501c":(0,t.RC)((()=>a.e(713).then(a.bind(a,779)))),"v-744d024e":(0,t.RC)((()=>a.e(146).then(a.bind(a,7034)))),"v-705c21a6":(0,t.RC)((()=>a.e(888).then(a.bind(a,8099)))),"v-3279cf61":(0,t.RC)((()=>a.e(118).then(a.bind(a,1973))))}},9706:(n,s,a)=>{a.d(s,{T:()=>t});const t={"v-ef444906":()=>a.e(717).then(a.bind(a,9234)).then((({data:n})=>n)),"v-3d2f7822":()=>a.e(175).then(a.bind(a,8687)).then((({data:n})=>n)),"v-7e88feb6":()=>a.e(83).then(a.bind(a,8816)).then((({data:n})=>n)),"v-c11452c2":()=>a.e(708).then(a.bind(a,6635)).then((({data:n})=>n)),"v-41c2a7b8":()=>a.e(107).then(a.bind(a,3188)).then((({data:n})=>n)),"v-7e7a417e":()=>a.e(720).then(a.bind(a,1577)).then((({data:n})=>n)),"v-a25da32e":()=>a.e(811).then(a.bind(a,8561)).then((({data:n})=>n)),"v-1054ac98":()=>a.e(399).then(a.bind(a,1177)).then((({data:n})=>n)),"v-1e97db11":()=>a.e(444).then(a.bind(a,6080)).then((({data:n})=>n)),"v-0a97e47a":()=>a.e(434).then(a.bind(a,3170)).then((({data:n})=>n)),"v-3706649a":()=>a.e(88).then(a.bind(a,1801)).then((({data:n})=>n)),"v-8daa1a0e":()=>a.e(509).then(a.bind(a,6464)).then((({data:n})=>n)),"v-74bc627b":()=>a.e(5).then(a.bind(a,2988)).then((({data:n})=>n)),"v-14f724bf":()=>a.e(69).then(a.bind(a,4770)).then((({data:n})=>n)),"v-14e6501c":()=>a.e(713).then(a.bind(a,4502)).then((({data:n})=>n)),"v-744d024e":()=>a.e(146).then(a.bind(a,6041)).then((({data:n})=>n)),"v-705c21a6":()=>a.e(888).then(a.bind(a,6762)).then((({data:n})=>n)),"v-3279cf61":()=>a.e(118).then(a.bind(a,8588)).then((({data:n})=>n))}},4634:(n,s,a)=>{a.d(s,{g:()=>e});var t=a(4802);const e=[["v-ef444906","/Git/git.html",{},["/Git/git","/Git/git.md"]],["v-3d2f7822","/JAVA/1Java%E5%9F%BA%E7%A1%80.html",{},["/JAVA/1Java基础.html","/JAVA/1Java%E5%9F%BA%E7%A1%80","/JAVA/1Java基础.md","/JAVA/1Java%E5%9F%BA%E7%A1%80.md"]],["v-7e88feb6","/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",{},["/JAVA/2Java基础语法.html","/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95","/JAVA/2Java基础语法.md","/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.md"]],["v-c11452c2","/Vue/vuex%E5%85%A5%E9%97%A8.html",{},["/Vue/vuex入门.html","/Vue/vuex%E5%85%A5%E9%97%A8","/Vue/vuex入门.md","/Vue/vuex%E5%85%A5%E9%97%A8.md"]],["v-41c2a7b8","/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.html",{},["/Vue/基础概念+vuecli+指令上.html","/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A","/Vue/基础概念+vuecli+指令上.md","/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.md"]],["v-7e7a417e","/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.html",{},["/Vue/指令下+计算属性+侦听器.html","/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8","/Vue/指令下+计算属性+侦听器.md","/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.md"]],["v-a25da32e","/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.html",{},["/Vue/生命周期+路由+组件缓存.html","/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98","/Vue/生命周期+路由+组件缓存.md","/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.md"]],["v-1054ac98","/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",{},["/Vue/组件基础+组件通讯.html","/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF","/Vue/组件基础+组件通讯.md","/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.md"]],["v-1e97db11","/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.html",{},["/Vue/组件进阶.html","/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6","/Vue/组件进阶.md","/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.md"]],["v-0a97e47a","/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.html",{},["/前端面试手册/前端面试手册.html","/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C","/前端面试手册/前端面试手册.md","/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.md"]],["v-3706649a","/404.html",{},["/404"]],["v-8daa1a0e","/",{},["/index.html"]],["v-74bc627b","/about/",{},["/about/index.html"]],["v-14f724bf","/mood/",{},["/mood/index.html"]],["v-14e6501c","/link/",{},["/link/index.html"]],["v-744d024e","/tag/",{},["/tag/index.html"]],["v-705c21a6","/archive/",{},["/archive/index.html"]],["v-3279cf61","/aurora-archive/",{},["/aurora-archive/index.html"]]].reduce(((n,[s,a,e,p])=>(n.push({name:s,path:a,component:t.Y,meta:e},...p.map((n=>({path:n,redirect:a})))),n)),[{name:"404",path:"/:catchAll(.*)",component:t.Y}])},5472:(n,s,a)=>{a.d(s,{D:()=>t});const t=[{title:"Git",headers:[{level:2,title:"git基础入门",slug:"git基础入门",children:[{level:3,title:"git的安装",slug:"git的安装",children:[]},{level:3,title:"git三个区",slug:"git三个区",children:[]},{level:3,title:"git基本命令",slug:"git基本命令",children:[]},{level:3,title:"git重置",slug:"git重置",children:[]},{level:3,title:"git忽视文件",slug:"git忽视文件",children:[]}]},{level:2,title:"git分支操作",slug:"git分支操作",children:[{level:3,title:"为什么要有分支？",slug:"为什么要有分支",children:[]},{level:3,title:"git分支命令",slug:"git分支命令",children:[]},{level:3,title:"git合并冲突",slug:"git合并冲突",children:[]}]},{level:2,title:"git远程仓库",slug:"git远程仓库",children:[{level:3,title:"github、gitee、gitlab",slug:"github、gitee、gitlab",children:[]},{level:3,title:"码云创建远程仓库",slug:"码云创建远程仓库",children:[]},{level:3,title:"SSH免密码登陆",slug:"ssh免密码登陆",children:[]},{level:3,title:"SSH免密码登录配置",slug:"ssh免密码登录配置",children:[]},{level:3,title:"git push",slug:"git-push",children:[]},{level:3,title:"git remote",slug:"git-remote",children:[]},{level:3,title:"git clone",slug:"git-clone",children:[]},{level:3,title:"git pull",slug:"git-pull",children:[]},{level:3,title:"下载远端分支本地",slug:"下载远端分支本地",children:[]}]}],path:"/Git/git.html",pathLocale:"/",extraFields:[]},{title:"Java基础",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Java语言的发展",slug:"_1-6-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",children:[]}]}],path:"/JAVA/1Java%E5%9F%BA%E7%A1%80.html",pathLocale:"/",extraFields:[]},{title:"day02 - Java基础语法",headers:[{level:2,title:"1. 注释",slug:"_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",children:[]}]}],path:"/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",pathLocale:"/",extraFields:[]},{title:"vuex 概述",headers:[{level:2,title:"回顾-组件之间共享状态 (组件通信方案)",slug:"回顾-组件之间共享状态-组件通信方案",children:[]},{level:2,title:"vuex基本概念",slug:"vuex基本概念",children:[]},{level:2,title:"vuex的优点: 方便的解决多组件的共享状态",slug:"vuex的优点-方便的解决多组件的共享状态",children:[]},{level:2,title:"什么数据适合存到vuex中",slug:"什么数据适合存到vuex中",children:[]},{level:2,title:"概述小结:",slug:"概述小结",children:[]},{level:2,title:"需求: 多组件共享数据",slug:"需求-多组件共享数据",children:[]},{level:2,title:"vuex 的使用 - 创建仓库",slug:"vuex-的使用-创建仓库",children:[]},{level:2,title:"核心概念 - state 状态",slug:"核心概念-state-状态",children:[]},{level:2,title:"核心概念 - mutations",slug:"核心概念-mutations",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"带参数的 mutation",slug:"带参数的-mutation",children:[]},{level:3,title:"辅助函数 - mapMutations",slug:"辅助函数-mapmutations",children:[]}]},{level:2,title:"核心概念-actions",slug:"核心概念-actions",children:[]},{level:2,title:"核心概念-getters",slug:"核心概念-getters",children:[]},{level:2,title:"核心概念 - 模块 module (进阶拓展)",slug:"核心概念-模块-module-进阶拓展",children:[{level:3,title:"模块定义 - 准备 state",slug:"模块定义-准备-state",children:[]},{level:3,title:"命名空间 namespaced",slug:"命名空间-namespaced",children:[]}]}],path:"/Vue/vuex%E5%85%A5%E9%97%A8.html",pathLocale:"/",extraFields:[]},{title:"vue基本概念",headers:[{level:2,title:"vue介绍",slug:"vue介绍",children:[{level:3,title:"渐进式的概念",slug:"渐进式的概念",children:[]},{level:3,title:"框架的概念",slug:"框架的概念",children:[]},{level:3,title:"vue是 MVVM 的框架",slug:"vue是-mvvm-的框架",children:[]}]},{level:2,title:"开发vue的方式",slug:"开发vue的方式",children:[]},{level:2,title:"基本使用",slug:"基本使用",children:[]},{level:2,title:"如何覆盖webpack配置",slug:"如何覆盖webpack配置",children:[]},{level:2,title:"目录分析与清理",slug:"目录分析与清理",children:[]},{level:2,title:"vue单文件组件的说明",slug:"vue单文件组件的说明",children:[]},{level:2,title:"vue通过data提供数据",slug:"vue通过data提供数据",children:[]},{level:2,title:"通过插值表达式显示数据",slug:"通过插值表达式显示数据",children:[]},{level:2,title:"安装vue开发者工具",slug:"安装vue开发者工具",children:[]},{level:2,title:"v-bind指令",slug:"v-bind指令",children:[]},{level:2,title:"v-on指令",slug:"v-on指令",children:[{level:3,title:"基本使用",slug:"基本使用-1",children:[]},{level:3,title:"vue中获取事件对象(了解)",slug:"vue中获取事件对象-了解",children:[]},{level:3,title:"v-on 事件修饰符",slug:"v-on-事件修饰符",children:[]},{level:3,title:"按键修饰符",slug:"按键修饰符",children:[]}]},{level:2,title:"v-if 和 v-show",slug:"v-if-和-v-show",children:[{level:3,title:"基本使用",slug:"基本使用-2",children:[]},{level:3,title:"v-else 和 v-else-if",slug:"v-else-和-v-else-if",children:[]}]},{level:2,title:"v-model",slug:"v-model",children:[{level:3,title:"基本使用",slug:"基本使用-3",children:[]},{level:3,title:"v-model 处理其他表单元素",slug:"v-model-处理其他表单元素",children:[]},{level:3,title:"v-model 修饰符",slug:"v-model-修饰符",children:[]}]},{level:2,title:"v-text 和 v-html",slug:"v-text-和-v-html",children:[{level:3,title:"v-text指令",slug:"v-text指令",children:[]},{level:3,title:"v-html指令",slug:"v-html指令",children:[]}]}],path:"/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.html",pathLocale:"/",extraFields:[]},{title:"vue指令（下）",headers:[{level:2,title:"v-for",slug:"v-for",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"虚拟DOM 和 diff算法",slug:"虚拟dom-和-diff算法",children:[]},{level:3,title:"v-for 的key的说明",slug:"v-for-的key的说明",children:[]}]},{level:2,title:"样式处理",slug:"样式处理",children:[{level:3,title:"v-bind 对于class的增强",slug:"v-bind-对于class的增强",children:[]},{level:3,title:"v-bind对于style 的增强",slug:"v-bind对于style-的增强",children:[]}]},{level:2,title:"基本使用",slug:"基本使用-1",children:[]},{level:2,title:"计算属性的缓存的问题",slug:"计算属性的缓存的问题",children:[]},{level:2,title:"计算属性的完整写法",slug:"计算属性的完整写法",children:[]},{level:2,title:"基本使用",slug:"基本使用-2",children:[]},{level:2,title:"复杂类型的监听-监听的完整写法",slug:"复杂类型的监听-监听的完整写法",children:[]},{level:2,title:"成绩案例-监听数据进行缓存",slug:"成绩案例-监听数据进行缓存",children:[]},{level:2,title:"配置步骤 （两步）",slug:"配置步骤-两步",children:[]}],path:"/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.html",pathLocale:"/",extraFields:[]},{title:"生命周期",headers:[{level:2,title:"研究生命周期的意义",slug:"研究生命周期的意义",children:[]},{level:2,title:"生命周期函数(钩子函数)",slug:"生命周期函数-钩子函数",children:[]},{level:2,title:"组件生命周期分类",slug:"组件生命周期分类",children:[]},{level:2,title:"SPA - 单页应用程序",slug:"spa-单页应用程序",children:[{level:3,title:"优势",slug:"优势",children:[]},{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"路由介绍",slug:"路由介绍",children:[]},{level:2,title:"vue-router介绍",slug:"vue-router介绍",children:[{level:3,title:"路由 - 组件分类",slug:"路由-组件分类",children:[]}]},{level:2,title:"vue-router使用",slug:"vue-router使用",children:[]},{level:2,title:"配置路由规则",slug:"配置路由规则",children:[]},{level:2,title:"路由的封装",slug:"路由的封装",children:[]},{level:2,title:"vue路由 - 声明式导航",slug:"vue路由-声明式导航",children:[{level:3,title:"声明式导航 - 基础使用",slug:"声明式导航-基础使用",children:[]},{level:3,title:"导航高亮",slug:"导航高亮",children:[]},{level:3,title:"路由使用巩固 - 练习",slug:"路由使用巩固-练习",children:[]},{level:3,title:"声明式导航 - 跳转传参",slug:"声明式导航-跳转传参",children:[]}]},{level:2,title:"vue路由 - 重定向和模式",slug:"vue路由-重定向和模式",children:[{level:3,title:"路由 - 重定向",slug:"路由-重定向",children:[]},{level:3,title:"路由 - 404页面",slug:"路由-404页面",children:[]},{level:3,title:"路由 - 模式设置",slug:"路由-模式设置",children:[]}]},{level:2,title:"vue路由 - 编程式导航",slug:"vue路由-编程式导航",children:[{level:3,title:"编程式导航 - 基础使用",slug:"编程式导航-基础使用",children:[]},{level:3,title:"编程式导航 - 跳转传参",slug:"编程式导航-跳转传参",children:[]}]},{level:2,title:"组件缓存 keep-alive",slug:"组件缓存-keep-alive",children:[{level:3,title:"基本语法",slug:"基本语法",children:[]},{level:3,title:"keep-alive对应的两个钩子",slug:"keep-alive对应的两个钩子",children:[]}]}],path:"/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.html",pathLocale:"/",extraFields:[]},{title:"组件化开发",headers:[{level:2,title:"什么是组件化开发",slug:"什么是组件化开发",children:[]},{level:2,title:"组件的注册",slug:"组件的注册",children:[{level:3,title:"局部注册",slug:"局部注册",children:[]}]},{level:2,title:"全局注册组件",slug:"全局注册组件",children:[{level:3,title:"组件名的大小写",slug:"组件名的大小写",children:[]},{level:3,title:"通过 name 注册组件 (了解)",slug:"通过-name-注册组件-了解",children:[]}]},{level:2,title:"组件的样式冲突  scoped",slug:"组件的样式冲突-scoped",children:[]},{level:2,title:"组件通信 - 父传子 props 传值",slug:"组件通信-父传子-props-传值",children:[]},{level:2,title:"v-for 遍历展示组件练习",slug:"v-for-遍历展示组件练习",children:[]},{level:2,title:"单向数据流",slug:"单向数据流",children:[]},{level:2,title:"组件通信 - 子传父",slug:"组件通信-子传父",children:[]},{level:2,title:"props 校验",slug:"props-校验",children:[]}],path:"/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",pathLocale:"/",extraFields:[]},{title:"v-model",headers:[{level:2,title:"v-model 语法糖",slug:"v-model-语法糖",children:[]},{level:2,title:"v-model给组件使用",slug:"v-model给组件使用",children:[]},{level:2,title:"动态组件的基本使用",slug:"动态组件的基本使用",children:[]},{level:2,title:"自定义指令说明",slug:"自定义指令说明",children:[]},{level:2,title:"自定义指令 - 局部注册",slug:"自定义指令-局部注册",children:[]},{level:2,title:"自定义指令 - 全局注册",slug:"自定义指令-全局注册",children:[]},{level:2,title:"自定义指令 - 指令的值",slug:"自定义指令-指令的值",children:[]},{level:2,title:"默认插槽 slot",slug:"默认插槽-slot",children:[]},{level:2,title:"后备内容 (默认值)",slug:"后备内容-默认值",children:[]},{level:2,title:"具名插槽",slug:"具名插槽",children:[{level:3,title:"插槽的分类:",slug:"插槽的分类",children:[]},{level:3,title:"具名插槽的使用步骤",slug:"具名插槽的使用步骤",children:[]},{level:3,title:"具名插槽的简写",slug:"具名插槽的简写",children:[]}]},{level:2,title:"作用域插槽",slug:"作用域插槽",children:[]}],path:"/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.html",pathLocale:"/",extraFields:[]},{title:"HTML基础",headers:[{level:2,title:"1. HTML 文件中的 DOCTYPE 是什么作用？",slug:"_1-html-文件中的-doctype-是什么作用",children:[]},{level:2,title:"2. HTML、XML、XHTML 之间有什么区别？",slug:"_2-html、xml、xhtml-之间有什么区别",children:[]},{level:2,title:"3. 前缀为 data- 开头的元素属性是什么？",slug:"_3-前缀为-data-开头的元素属性是什么",children:[]},{level:2,title:"4. 谈谈你对 HTML 语义化的理解？",slug:"_4-谈谈你对-html-语义化的理解",children:[]},{level:2,title:"5. HTML5 对比 HTML4 有哪些不同之处？",slug:"_5-html5-对比-html4-有哪些不同之处",children:[]},{level:2,title:"6. meta 标签有哪些常用用法？",slug:"_6-meta-标签有哪些常用用法",children:[]},{level:2,title:"7. img 标签的 srcset 的作用是什么？",slug:"_7-img-标签的-srcset-的作用是什么",children:[]},{level:2,title:"8. 响应式图片处理优化: Picture 标签",slug:"_8-响应式图片处理优化-picture-标签",children:[]},{level:2,title:"9. 在 script 标签上使用 defer 和 async 的区别是什么？",slug:"_9-在-script-标签上使用-defer-和-async-的区别是什么",children:[]},{level:2,title:"10. 前端做本地数据存储的方式有哪些？",slug:"_10-前端做本地数据存储的方式有哪些",children:[]},{level:2,title:"11. 以上几种前端存储的区别是什么？",slug:"_11-以上几种前端存储的区别是什么",children:[]},{level:2,title:"1. CSS选择器的优先级是怎么样的？",slug:"_1-css选择器的优先级是怎么样的",children:[]},{level:2,title:"2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？",slug:"_2-通过-css-的哪些方式可以实现隐藏页面上的元素",children:[]},{level:2,title:"3. px、em、rem之间有什么区别？",slug:"_3-px、em、rem之间有什么区别",children:[]},{level:2,title:"4. 让元素水平居中的方法有哪些？",slug:"_4-让元素水平居中的方法有哪些",children:[]},{level:2,title:"5. 在 CSS 中有哪些定位方式？",slug:"_5-在-css-中有哪些定位方式",children:[]},{level:2,title:"6. 如何理解 z-index？",slug:"_6-如何理解-z-index",children:[]},{level:2,title:"7. 如何清除浮动 ？",slug:"_7-如何清除浮动",children:[]},{level:2,title:"8. 谈谈你对 BFC 的理解？",slug:"_8-谈谈你对-bfc-的理解",children:[]},{level:2,title:"9. 什么是CSS Sprites以及它的好处？",slug:"_9-什么是css-sprites以及它的好处",children:[]},{level:2,title:"10. 你对媒体查询的理解是什么样的？",slug:"_10-你对媒体查询的理解是什么样的",children:[]},{level:2,title:"11. 你对盒子模型的理解是什么样的？",slug:"_11-你对盒子模型的理解是什么样的",children:[]},{level:2,title:"12. 标准盒模型和怪异盒模型有哪些区别？",slug:"_12-标准盒模型和怪异盒模型有哪些区别",children:[]},{level:2,title:"13. 说说伪类和伪元素的区别？",slug:"_13-说说伪类和伪元素的区别",children:[]},{level:2,title:"14. 谈谈你对 flex 的理解？",slug:"_14-谈谈你对-flex-的理解",children:[]},{level:2,title:"1. 解释下什么是变量声明提升？",slug:"_1-解释下什么是变量声明提升",children:[]},{level:2,title:"2. JS 的参数是以什么方式进行传递的？",slug:"_2-js-的参数是以什么方式进行传递的",children:[]},{level:2,title:"3. JavaScript垃圾回收是怎么做的？",slug:"_3-javascript垃圾回收是怎么做的",children:[{level:3,title:"3.1 内存的生命周期",slug:"_3-1-内存的生命周期",children:[]},{level:3,title:"3.2 垃圾回收算法说明",slug:"_3-2-垃圾回收算法说明",children:[]},{level:3,title:"3.3 引用计数",slug:"_3-3-引用计数",children:[]},{level:3,title:"3.4 标记清除算法",slug:"_3-4-标记清除算法",children:[]}]},{level:2,title:"4. 谈谈你对 JavaScript 作用域链的理解？",slug:"_4-谈谈你对-javascript-作用域链的理解",children:[]},{level:2,title:"5. 谈谈你对闭包的理解？",slug:"_5-谈谈你对闭包的理解",children:[]},{level:2,title:"6. JavaScript中数据类型的隐式转换规则(了解)",slug:"_6-javascript中数据类型的隐式转换规则-了解",children:[]},{level:2,title:"7. 谈谈你对原型链的理解？",slug:"_7-谈谈你对原型链的理解",children:[]},{level:2,title:"6. 谈谈对于继承的理解",slug:"_6-谈谈对于继承的理解",children:[{level:3,title:"6.1 继承 - 原型继承",slug:"_6-1-继承-原型继承",children:[]},{level:3,title:"6.2 继承 - 组合继承",slug:"_6-2-继承-组合继承",children:[]},{level:3,title:"6.3 继承 - 寄生组合继承",slug:"_6-3-继承-寄生组合继承",children:[]},{level:3,title:"6.4 es6 - class 实现继承 extends",slug:"_6-4-es6-class-实现继承-extends",children:[]}]},{level:2,title:"8. 如何判断是否是数组？",slug:"_8-如何判断是否是数组",children:[]},{level:2,title:"9. 谈谈你对this的理解？",slug:"_9-谈谈你对this的理解",children:[]},{level:2,title:"10. 箭头函数中的this指向什么？",slug:"_10-箭头函数中的this指向什么",children:[]},{level:2,title:"11. Promise 的静态方法",slug:"_11-promise-的静态方法",children:[]},{level:2,title:"12. 宏任务 微任务 是什么",slug:"_12-宏任务-微任务-是什么",children:[]},{level:2,title:"13. async/await是什么？",slug:"_13-async-await是什么",children:[]},{level:2,title:"14. 相较于 Promise，async/await有何优势？",slug:"_14-相较于-promise-async-await有何优势",children:[]},{level:2,title:"15. 深拷贝 浅拷贝",slug:"_15-深拷贝-浅拷贝",children:[]},{level:2,title:"1. HTTP有哪些⽅法？",slug:"_1-http有哪些方法",children:[]},{level:2,title:"2. 各个HTTP方法的具体作用是什么？",slug:"_2-各个http方法的具体作用是什么",children:[]},{level:2,title:"3. GET方法和POST方法有何区别？",slug:"_3-get方法和post方法有何区别",children:[]},{level:2,title:"4. HTTP请求报文是什么样的？",slug:"_4-http请求报文是什么样的",children:[]},{level:2,title:"5. HTTP响应报文是什么样的？",slug:"_5-http响应报文是什么样的",children:[]},{level:2,title:"6. 你了解的HTTP状态码有哪些？",slug:"_6-你了解的http状态码有哪些",children:[]},{level:2,title:"7. HTTP的keep-alive是什么作用？",slug:"_7-http的keep-alive是什么作用",children:[]},{level:2,title:"8. 为什么需要HTTPS？",slug:"_8-为什么需要https",children:[]},{level:2,title:"9. HTTPS是如何保证安全的？",slug:"_9-https是如何保证安全的",children:[{level:3,title:"9.1 什么是对称加密？",slug:"_9-1-什么是对称加密",children:[]},{level:3,title:"9.2 什么是⾮对称加密？",slug:"_9-2-什么是非对称加密",children:[]},{level:3,title:"9.3 HTTPS 加密解决⽅案",slug:"_9-3-https-加密解决方案",children:[]},{level:3,title:"9.4 数字证书",slug:"_9-4-数字证书",children:[]},{level:3,title:"9.5 数字签名",slug:"_9-5-数字签名",children:[]}]},{level:2,title:"10. HTTP2和HTTP1.x比，有什么优势和特点？",slug:"_10-http2和http1-x比-有什么优势和特点",children:[]},{level:2,title:"11. http缓存控制",slug:"_11-http缓存控制",children:[{level:3,title:"11.1 基本认知",slug:"_11-1-基本认知",children:[]},{level:3,title:"11.2 强缓存  (食品过期时间判断)",slug:"_11-2-强缓存-食品过期时间判断",children:[]},{level:3,title:"11.3 协商缓存 (找供货商专家协商)",slug:"_11-3-协商缓存-找供货商专家协商",children:[]},{level:3,title:"11.4 整体请求缓存流程",slug:"_11-4-整体请求缓存流程",children:[]}]},{level:2,title:"TCP的特性",slug:"tcp的特性",children:[]},{level:2,title:"简述 TCP 和 UDP 的区别",slug:"简述-tcp-和-udp-的区别",children:[]},{level:2,title:"什么是 TCP 粘包，怎么处理？",slug:"什么是-tcp-粘包-怎么处理",children:[]},{level:2,title:"你知道哪些常用的端口号，以及它们对应的服务？",slug:"你知道哪些常用的端口号-以及它们对应的服务",children:[]},{level:2,title:"一次完整的HTTP服务过程是什么",slug:"一次完整的http服务过程是什么",children:[]},{level:2,title:"什么是DNS 解析",slug:"什么是dns-解析",children:[]},{level:2,title:"什么是三次握手？",slug:"什么是三次握手",children:[]},{level:2,title:"什么是四次挥手？",slug:"什么是四次挥手",children:[]},{level:2,title:"TCP 三次握手理解 (双方确认)",slug:"tcp-三次握手理解-双方确认",children:[]},{level:2,title:"关闭TCP连接四次挥手的理解 (客气挽留)",slug:"关闭tcp连接四次挥手的理解-客气挽留",children:[]},{level:2,title:"浏览器解析响应",slug:"浏览器解析响应",children:[]},{level:2,title:"DOM的事件模型是什么？",slug:"dom的事件模型是什么",children:[]},{level:2,title:"DOM的事件流是什么？",slug:"dom的事件流是什么",children:[]},{level:2,title:"说说什么是事件委托？",slug:"说说什么是事件委托",children:[]},{level:2,title:"常见的浏览器内核有哪些？",slug:"常见的浏览器内核有哪些",children:[]},{level:2,title:"浏览器是如何进行界面渲染的？",slug:"浏览器是如何进行界面渲染的",children:[]},{level:2,title:"浏览器是如何解析CSS选择器的？",slug:"浏览器是如何解析css选择器的",children:[]},{level:2,title:"DOM树是如何构建的？",slug:"dom树是如何构建的",children:[]},{level:2,title:"浏览器重绘与重排的区别是什么？",slug:"浏览器重绘与重排的区别是什么",children:[]},{level:2,title:"如何触发重排和重绘？",slug:"如何触发重排和重绘",children:[]},{level:2,title:"如何避免重排或重绘？",slug:"如何避免重排或重绘",children:[]},{level:2,title:"前端如何实现即时通讯？",slug:"前端如何实现即时通讯",children:[]},{level:2,title:"什么是浏览器的同源策略？",slug:"什么是浏览器的同源策略",children:[]},{level:2,title:"如何实现跨域？",slug:"如何实现跨域",children:[]},{level:2,title:"Babel的原理是什么？",slug:"babel的原理是什么",children:[]},{level:2,title:"如何编写一个Babel插件？",slug:"如何编写一个babel插件",children:[]},{level:2,title:"你们的Git工作流是什么样的？",slug:"你们的git工作流是什么样的",children:[]},{level:2,title:"Git的rebase和merge的区别是什么？",slug:"git的rebase和merge的区别是什么",children:[]},{level:2,title:"什么是MVVM？",slug:"什么是mvvm",children:[]},{level:2,title:"MVVM的优缺点有哪些？",slug:"mvvm的优缺点有哪些",children:[]},{level:2,title:"谈谈对Vue生命周期的理解？",slug:"谈谈对vue生命周期的理解",children:[]},{level:2,title:"在Vue中网络请求应该放在哪个生命周期中发起？",slug:"在vue中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"Vue组件之间如何进行通信？",slug:"vue组件之间如何进行通信",children:[]},{level:2,title:"computed和watch的区别是什么？",slug:"computed和watch的区别是什么",children:[]},{level:2,title:"Vue双向绑定原理？",slug:"vue双向绑定原理",children:[]},{level:2,title:"Object.defineProperty和Proxy的优缺点？",slug:"object-defineproperty和proxy的优缺点",children:[]},{level:2,title:"如何理解Vue的响应式系统？",slug:"如何理解vue的响应式系统",children:[{level:3,title:"基本原理",slug:"基本原理",children:[]},{level:3,title:"观察者模式",slug:"观察者模式",children:[]}]},{level:2,title:"Vue中的key到底有什么用？",slug:"vue中的key到底有什么用",children:[{level:3,title:"diff算法",slug:"diff算法",children:[]},{level:3,title:"key的常见应用场景",slug:"key的常见应用场景",children:[]}]},{level:2,title:"React最新的生命周期是怎么样的？",slug:"react最新的生命周期是怎么样的",children:[]},{level:2,title:"在React中网络请求应该放在哪个生命周期中发起？",slug:"在react中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"setState是同步的还是异步的？",slug:"setstate是同步的还是异步的",children:[]},{level:2,title:"React中如何实现组件间的通信？",slug:"react中如何实现组件间的通信",children:[]},{level:2,title:"React存在哪些性能优化手段？",slug:"react存在哪些性能优化手段",children:[]},{level:2,title:"React中如何进行组件和逻辑的复用？",slug:"react中如何进行组件和逻辑的复用",children:[]},{level:2,title:"Mixin、HoC、Render props、React Hooks的优缺点分别是什么？",slug:"mixin、hoc、render-props、react-hooks的优缺点分别是什么",children:[]},{level:2,title:"Redux的工作流程是怎么样的？",slug:"redux的工作流程是怎么样的",children:[]},{level:2,title:"react-redux这个库是如何工作的？",slug:"react-redux这个库是如何工作的",children:[]},{level:2,title:"Redux和Mobx的区别？",slug:"redux和mobx的区别",children:[]},{level:2,title:"在Redux中如何进行异步操作？",slug:"在redux中如何进行异步操作",children:[]}],path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.html",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/about/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/mood/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/link/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/tag/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/archive/",pathLocale:"/",extraFields:[]},{title:"",headers:[],path:"/aurora-archive/",pathLocale:"/",extraFields:[]}]},5220:(n,s,a)=>{a.d(s,{H:()=>t});const t={base:"/",lang:"zh-CN",title:"YCMGG",description:"",head:[["script",{src:"https://at.alicdn.com/t/font_2849934_v6y652peian.js"}],["link",{href:"/favicon.ico",rel:"icon"}],["link",{rel:"stylesheet",type:"text/css",href:"//at.alicdn.com/t/font_2932340_r7zitafg82.css"}]],locales:{}}},2232:(n,s,a)=>{a.d(s,{f:()=>t});const t={navbar:[{text:"JAVA",children:[{text:"Java基础",link:"/JAVA/1Java基础"},{text:"Java基础语法",link:"/JAVA/2Java基础语法"}]},{text:"前端面试手册",link:"/前端面试手册/前端面试手册.md"},{text:"Vue",children:[{text:"基础概念+vuecli+指令上",link:"/Vue/基础概念+vuecli+指令上.md"},{text:"指令下+计算属性+侦听器",link:"/Vue/指令下+计算属性+侦听器.md"},{text:"组件基础+组件通讯",link:"/Vue/组件基础+组件通讯.md"},{text:"组件进阶",link:"/Vue/组件进阶.md"},{text:"生命周期+路由+组件缓存",link:"/Vue/生命周期+路由+组件缓存.md"},{text:"vuex入门.",link:"/Vue/vuex入门..md"}]},{text:"Git",link:"/Git/git.md"},{text:"YCMGG",link:"https://github.com/ycmgg/ycmgg.github.io",iconClass:"aurora-navbar-github1"}],darkMode:!1,repo:"https://github.com/",repoIconClass:"aurora-navbar-github",docsRepo:"https://github.com/",githubActions:!1,docsBranch:"master",repoLabel:"YCMGG",editLink:!1,editLinkText:"edit",lastUpdated:!0,lastUpdatedText:"lastTime",logoColor:"#2c3e50",showFont:"程",heroImg:"/avatar.jpg",logo:"/avatar.png",lazyLoadingImg:"/ljz.gif",homePageLazyLoadingImg:"/aurora-loading.gif",customRandomSay:!1,customRandomValue:"Vuepress-theme-Aurora",socials:[{aHref:"https://github.com/",isHome:!0,show:!0,sidebar:!0,symbol:"#icon-github-fill"},{aHref:"https://space.bilibili.com/259080133?spm_id_from=333.1007.0.0",isHome:!0,show:!0,sidebar:!0,symbol:"#icon-bilibili-1"}],logoTitle:"YCMGG",headTitle:"this is headTitle",description:"vuepress-theme-Aurora是一款简洁，美观，功能强大的静态主题",keyword:"vuepress主题,vuepress theme,生活琐事,二次元博客,简约博客,博客主题,静态主题",slideTime:3e5,randomSaw:"https://international.v1.hitokoto.cn/?c=b&max_length=45",about:[],randomColor:["#ffcad4","#d8e2dc","#8d99ae","#b8f2e6","#84c7d0","#aed9e0","#00b4d8","#caf0f8","#fbc4ab","#fdc5f5","#84dcc6","#a9def9","#fcf6bd","#f0a6ca","#b9faf8","#42a5f5","#ff9800","#b39ddb","#6d45bb","#b388ff","#1565c0","#26c6da","#5e548e","#90f1ef","#5b5f97","#bbe6e4","#42bfdd","#72ddf7","#8093f1","#9ed8d8","#7ea8be","#ef90b3","#b892ef","#c0b9dd","#c0d9dd","#75c9c8","#ded9e2","#b5e2fa","#62b6cb","#5fa8d3","#0fa3b1","#b5e2fa","#5fa8d3","#62b6cb","#b892ff"],maxFontColorArr:8,fontColor:["#2c3e50","#42a5f5","#8093f1","#FF6EC7","#FF7F00","#8FBC8F","#EAADEA","#3299CC","#CDCDCD","#CC3299","#FF7F00","#2F4F4F"],friendLinks:[],siteInformation:{title:"YCMGG",url:"https://ycmgg.github.io/",logo:"/avatar.jpg",describe:"vuepress-theme-Aurora是一款简洁，美观，功能强大的静态主题",cover:"/my-cover.png",contact:"email: cqycco@gmail.com, qq:2291308094",otherDescribe:["申请友链请按照下面格式，在此页面留言，我看到就会进行添加","博客名称    博客地址      博客描述      博客logo","友链申请要求","拒绝涉政/涉黄/太多广告/盈利性站点","站点能正常访问",'这是一个html的测试<a href="https://aurora.xcye.xyz" target="_blank">这是一个a标签</a>']},fontFamily:["-apple-system","hlt","tzt","sst","lf","xsf","lsf","cgt"],footer:["Copyright © by qsyyke All Rights Reserved.","<a target='_blank' href='http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=53060202000142' style='display:inline-block;text-decoration:none;height:20px;line-height:20px;'><img src='' style='float:left;'/><p style='float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px;'>滇公网安备 53060202000142号</p></a>"],isShowFooter:!1,isShowThemeCopyright:!1,isShowRunTime:!1,startRunTime:"8/7/2021 12:22:00",prefixRuntime:"小破站已运行",message:["峰峦如聚，波涛如怒，山河表里潼关路。望西都，意踌蹰。伤心秦汉经行处，宫阙万间都做了土."],recommendPageLength:30,recommendNoTitle:"`╮(￣▽￣)╭`",tagNoTitle:"暂时还没有标题哟",mood:"青衫烟雨客",isFitter:!0,defaultBorderRadius:10,defaultOpacity:1,isHomePageFollow:!1,defaultBlur:1,split:"~",donate:{},comment:{showComment:!1,serverURL:"https://aurora-local-7hrjb6mp8-qsyyke.vercel.app/",emojis:["https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/alus","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo"],avatar:"monsterid"},poster:{description:"vuepress-theme-Aurora是一款简洁，美观，功能强大的静态主题",author:"qsyyke",preBlog:"Aurora",suffixBlog:" theme",avatar:"/avatar.jpg"},showOnlineMood:!1,showMoodEdit:!1,addMood:{siteName:"localhost:8080",appId:"q4LlYVTTk2r39sNrJr7BL9A6p",appKey:"VxezWTppppyX2LTx4TUK8w6e2"},customTopImg:{custom:!0,page:[]},homeWps:["/bg/1.png"],homeWpsMobile:["/bg/1.png"],pageSize:4,githubUrl:"https://github.com/",latestPageSize:6,showHomePageImg:!1,sidebarCatalogLevel:3,homePageImgApi:"/bg/1.png",mobileCutText:"YCMGG",sidebarTag:"categories",showAddMood:!1,postImgApi:"",articleH2Icon:"🌸",articleH3Icon:"🐳",articleH4Icon:"⛄",sidebarAvatar:"/avatar.jpg",sugCountPerMin:300,showRecommend:!0,articlePagination:!0,global:{sidebar:{showStatus:!0,perData:!1,social:!1,friendLink:!0,navbar:!1,latestPage:!0,message:!1,tag:!0,siteData:!1},footer:!1},excludePath:["/footer.html","/v1.3.0/","/plugin/","/node.html","/style.html"],categoriesIncludeFolderName:!1,wave:{showWave:!1},bubble:{show:!1,bubbleNumber:.14,bubbleAlpha:.6,alphaChangeSpeed:1e-5,size:.4,sizeChangeSpeed:2e-4,riseSpeed:.4,color:"255,255,255"},leanCloud:{appId:"2A2Dyd2AffrnldhwftlEddVn-MdYXbMMI",appKey:"qHYTbb91iOPLelyC9lpbXxLH",masterKey:"eUwfvS3luIPnPiHS5SpEhDYr"},showPageMeta:!0,randomSayApi:{method:"GET",urlApi:"https://v1.hitokoto.cn/?encode=text&c=a"},afDianUrl:"https://afdian.net/@qsyyke",homeTopText:"置顶",sidebarDesc:"当年焚烬旧人间, 正逢金秋. 又逢金秋, 往日红船往日舟. 长天总是不自由, 难见娇阳, 长歌声中桂花香.",showAboutPageBubble:!1,locales:{"/":{selectLanguageName:"English"}},selectLanguageText:"Languages",selectLanguageAriaLabel:"Select language",sidebar:"auto",sidebarDepth:2,contributors:!0,contributorsText:"Contributors",notFound:["There's nothing here.","How did we get here?","That's a Four-Oh-Four.","Looks like we've got some broken links."],backToHome:"Take me home",openInNewWindow:"open in new window"}},4125:(n,s,a)=>{a.d(s,{Z:()=>t});const t=[{data:{key:"v-ef444906",path:"/Git/git.html",title:"Git",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git基础入门",slug:"git基础入门",children:[{level:3,title:"git的安装",slug:"git的安装",children:[]},{level:3,title:"git三个区",slug:"git三个区",children:[]},{level:3,title:"git基本命令",slug:"git基本命令",children:[]},{level:3,title:"git重置",slug:"git重置",children:[]},{level:3,title:"git忽视文件",slug:"git忽视文件",children:[]}]},{level:2,title:"git分支操作",slug:"git分支操作",children:[{level:3,title:"为什么要有分支？",slug:"为什么要有分支",children:[]},{level:3,title:"git分支命令",slug:"git分支命令",children:[]},{level:3,title:"git合并冲突",slug:"git合并冲突",children:[]}]},{level:2,title:"git远程仓库",slug:"git远程仓库",children:[{level:3,title:"github、gitee、gitlab",slug:"github、gitee、gitlab",children:[]},{level:3,title:"码云创建远程仓库",slug:"码云创建远程仓库",children:[]},{level:3,title:"SSH免密码登陆",slug:"ssh免密码登陆",children:[]},{level:3,title:"SSH免密码登录配置",slug:"ssh免密码登录配置",children:[]},{level:3,title:"git push",slug:"git-push",children:[]},{level:3,title:"git remote",slug:"git-remote",children:[]},{level:3,title:"git clone",slug:"git-clone",children:[]},{level:3,title:"git pull",slug:"git-pull",children:[]},{level:3,title:"下载远端分支本地",slug:"下载远端分支本地",children:[]}]}],git:{}},key:"v-ef444906",path:"/Git/git.html",title:"Git",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git基础入门",slug:"git基础入门",children:[{level:3,title:"git的安装",slug:"git的安装",children:[]},{level:3,title:"git三个区",slug:"git三个区",children:[]},{level:3,title:"git基本命令",slug:"git基本命令",children:[]},{level:3,title:"git重置",slug:"git重置",children:[]},{level:3,title:"git忽视文件",slug:"git忽视文件",children:[]}]},{level:2,title:"git分支操作",slug:"git分支操作",children:[{level:3,title:"为什么要有分支？",slug:"为什么要有分支",children:[]},{level:3,title:"git分支命令",slug:"git分支命令",children:[]},{level:3,title:"git合并冲突",slug:"git合并冲突",children:[]}]},{level:2,title:"git远程仓库",slug:"git远程仓库",children:[{level:3,title:"github、gitee、gitlab",slug:"github、gitee、gitlab",children:[]},{level:3,title:"码云创建远程仓库",slug:"码云创建远程仓库",children:[]},{level:3,title:"SSH免密码登陆",slug:"ssh免密码登陆",children:[]},{level:3,title:"SSH免密码登录配置",slug:"ssh免密码登录配置",children:[]},{level:3,title:"git push",slug:"git-push",children:[]},{level:3,title:"git remote",slug:"git-remote",children:[]},{level:3,title:"git clone",slug:"git-clone",children:[]},{level:3,title:"git pull",slug:"git-pull",children:[]},{level:3,title:"下载远端分支本地",slug:"下载远端分支本地",children:[]}]}],content:"# Git\r\n\r\n## git基础入门\r\n\r\n> Git是一款免费、开源的**分布式** **版本控制系统** ，用于敏捷高效地处理任何或小或大的项目。\r\n\r\n> Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\r\n\r\n### git的安装\r\n\r\n[下载地址](https://git-scm.com/download/win)\r\n\r\n注意：\r\n\r\n1. 不要安装在中文目录\r\n2. 不要使用桌面管理软件\r\n\r\n安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。\r\n\r\n\r\n### git三个区\r\n\r\n要对某个项目使用git进行管理，需要使用`git init`命令初始化git仓库\r\n`git init`会在当前目录生成一个隐藏文件夹 .git  不要去修改这个文件夹下的任意东西。\r\n\r\ngit仓库会分成三个区\r\n\r\n工作区：我们书写代码的地方，工作的目录就叫工作区。\r\n\r\n暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。\r\n\r\n本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。\r\n\r\n### git基本命令\r\n\r\n#### git init\r\n\r\n+ 作用：初始化git仓库，想要使用git对某个项目进行管理，需要`git init`进行初始化\r\n\r\n```bash\r\n# 初始化仓库， 在当前目录下生成一个隐藏文件夹.git\r\ngit init\r\n```\r\n\r\n#### git add\r\n\r\n- 作用：将文件由 `工作区` 添加到 `暂存区`，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。\r\n- 命令：`git add 文件名/目录名`\r\n\r\n```bash\r\n# 将index.html添加到暂存区\r\ngit add index.html\r\n\r\n# 将css目录下所有的文件添加到暂存区\r\ngit add css\r\n\r\n# 将当前目录下所有的js文件添加到暂存区\r\ngit add *.js\r\n\r\n# 添加当前目录下所有的文件\r\ngit add .\r\ngit add -A\r\ngit add --all\r\n```\r\n\r\n#### git commit\r\n\r\n作用：将文件由 暂存区 添加到 仓库区，生成版本号\r\n\r\n```bash\r\n# 将文件从暂存区提交到仓库\r\ngit commit -m \"提交说明\"\r\n\r\n# 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。\r\ngit commit -a -m '提交说明'\r\n\r\n# 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令\r\ngit commit --amend -m \"提交说明\"\r\n```\r\n\r\n#### git config配置\r\n\r\n如果是第一次提交，需要配置提交者信息，推荐和公司邮箱一致（可以用QQ邮箱）\r\n\r\n```Bash\r\n# git config  user.name 你的目标用户名\r\n# git config  user.email 你的目标邮箱名\r\n\r\n# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可\r\ngit config  --global user.name jepson\r\ngit config  --global user.email jepsonpp@qq.com\r\n\r\n# 查看配置信息\r\ngit config --list\r\n\r\n# 取消配置\r\ngit config --unset --global user.name\r\ngit config --unset --global user.email \r\n```\r\n\r\n#### git status\r\n\r\n- 作用：查看文件的状态\r\n\r\n\r\n- 命令：`git status` \r\n  - 红色表示工作区中的文件需要提交\r\n  - 绿色表示暂存区中的文件需要提交\r\n- 命令：`git stauts -s` 简化日志输出格式\r\n\r\n#### git log\r\n\r\n- 作用：查看提交日志\r\n- `git log` 查看提交的日志\r\n- `git log --oneline` 简洁的日志信息\r\n\r\n![](./assets/git01.png)\r\n\r\n\r\n\r\n### git重置\r\n\r\n#### git reset\r\n\r\n- 作用：版本回退，将代码恢复到已经提交的某一个版本中。\r\n- `git reset --hard 版本号` 将代码回退到某个指定的版本(版本号只要有前几位即可)\r\n- `git reset --hard head~1`将版本回退到上一次提交\r\n  - ~1:上一次提交\r\n  - ~2:上上次提交\r\n  - ~0:当前提交\r\n\r\n\r\n- 当使用了`git reset`命令后，版本会回退，使用`git log`只能看到当前版本之前的信息。使用`git reflog`可以查看所有的版本信息\r\n\r\n###  git忽视文件\r\n\r\n> 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。\r\n\r\n- 在仓库的根目录创建一个`.gitignore`的文件，文件名是固定的。\r\n- 将不需要被git管理的文件路径添加到`.gitignore`中\r\n\r\n```bash\r\n# 忽视idea.txt文件\r\nidea.txt\r\n\r\n# 忽视css下的index.js文件\r\ncss/index.js\r\n\r\n# 忽视css下的所有的js文件\r\ncss/*.js\r\n\r\n# 忽视css文件夹\r\ncss\r\n```\r\n\r\n## git分支操作\r\n\r\n分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\r\n\r\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\r\n\r\n![](./assets/fenzhi.png)\r\n\r\n### 为什么要有分支？\r\n\r\n- 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。\r\n- 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。\r\n\r\n\r\n### git分支命令\r\n\r\n> 在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支\r\n\r\n#### 创建分支\r\n\r\n- `git branch 分支名称`创建分支，分支中的代码，在创建时与当前分支的内容完全相同。\r\n- git在第一次提交时，就有了一个叫`master`的主分支。\r\n- `git branch dev`，创建了一个叫做dev的分支\r\n\r\n#### 查看分支\r\n\r\n- `git branch`可以查看所有的分支，\r\n- 在当前分支的前面会有一个`*`\r\n- 在git中，有一个特殊指针`HEAD`,永远会指向当前分支\r\n\r\n#### 切换分支\r\n\r\n- `git checkout 分支名称`切换分支  HEAD指针指向了另一个分支\r\n- 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。\r\n- 提交代码时，会生产版本号，当前分支会指向最新的版本号。\r\n\r\n#### 创建并切换分支\r\n\r\n- `git checkout -b 分支名称` 创建并切换分支\r\n- 切换分支会做两件事情\r\n  - 创建一个新分支\r\n  - 把head指针指向当前的分支\r\n\r\n#### 删除分支\r\n\r\n- `git branch -d 分支名称` 可以删除分支\r\n- 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。\r\n- 注意：`master`分支是可以删除的，但是不推荐那么做。\r\n\r\n#### 合并分支\r\n\r\n- `git merge 分支名称` 将其他分支的内容合并到当前分支。\r\n- 在`master`分支中执行`git merge dev` 将`dev`分支中的代码合并到`master`分支\r\n- [分支合并](https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)\r\n\r\n### git合并冲突\r\n\r\n- 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。\r\n- 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。\r\n\r\n\r\n> \r\n\r\n```jsx\r\ndocument.querySelector('#btn-login').addEventListener('click', async function() {\r\n  const data = serialize(document.querySelector('form'), { hash: true })\r\n  // 非空校验\r\n  if (!data.username) return tip('请输入用户名')\r\n  if (!data.password) return tip('请输入密码')\r\n  if (data.password.length < 6) return tip('密码的长度不能小于6位')\r\n\r\n  try {\r\n    const res = await axios.post('/login', data)\r\n    localStorage.setItem('user-token', res.data.data.token)\r\n    localStorage.setItem('user-name', res.data.data.username)\r\n    tip('登录成功')\r\n    location.href = './index.html'\r\n  }\r\n  catch (e) {\r\n    tip('用户名或者密码错误')\r\n  }\r\n})\r\n```\r\n\r\n## git远程仓库\r\n\r\n### github、gitee、gitlab\r\n\r\n- git是一个版本控制工具。\r\n- github是一个代码托管平台，开源社区，是git的一个远程代码仓库平台。\r\n\r\n```javascript\r\n//1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。\r\n//2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。\r\n//3. 创建git项目时，不能有中文。\r\n```\r\n\r\n[github官网](https://github.com/)： 国外开源 git 代码托管平台\r\n\r\n[开源中国-git](https://git.oschina.net/):  国内开源 git 代码托管平台\r\n\r\n[gitlab](https://about.gitlab.com/)：企业级 git 代码托管平台\r\n\r\n\r\n\r\n### 码云创建远程仓库\r\n\r\n1. 新建右上角仓库\r\n\r\n   ![image-20220514184557788](assets/image-20220514184557788.png)\r\n\r\n\r\n2. 输入仓库名  **不勾初始化！！！**\r\n\r\n   ![image-20220514184702951](assets/image-20220514184702951.png)\r\n\r\n\r\n\r\n3. 点击创建\r\n\r\n![image-20220514184807839](assets/image-20220514184807839.png)\r\n\r\n\r\n\r\n\r\n\r\n### SSH免密码登陆\r\n\r\ngit支持多种数据传输协议：\r\n\r\n- https协议：`https://gitee.com/jepsonpp/test.git`  需要输入用户名和密码\r\n- ssh协议：`git@gitee.com:jepsonpp/test.git`   可以配置免密码登录\r\n\r\n每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。\r\n\r\n- github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push\r\n- 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码\r\n\r\n\r\n\r\n### SSH免密码登录配置\r\n\r\n- 1 创建SSH Key：`ssh-keygen -t rsa`    （注意：这些命令需要在bash中敲）\r\n- 2 在文件路径 `C:\\用户\\当前用户名\\` 找到 `.ssh` 文件夹\r\n- 3 文件夹中有两个文件：\r\n  - 私钥：`id_rsa`\r\n  - 公钥：`id_rsa.pub`\r\n- 4 在 `码云-> 设置 -> SSH公钥`页面中\r\n- 5 粘贴 公钥 `id_rsa.pub` 内容到对应文本框中， 添加公钥\r\n\r\n\r\n\r\n### git push\r\n\r\n- 作用：将本地仓库中代码提交到远程仓库\r\n- `git push 仓库地址 分支名`   将代码提交到远程仓库对应分支\r\n- 例子：`git push git@gitee.com:jepsonpp/test.git master` \r\n\r\n```\r\ngit push <远程主机名> <本地分支名>:<远程分支名>\r\n如果本地分支名与远程分支名相同，则可以省略冒号\r\n```\r\n\r\n\r\n\r\n### git remote\r\n\r\n每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名\r\n\r\n```bash\r\n# 给远程仓库设置一个别名\r\ngit remote add 仓库别名 仓库地址\r\ngit remote add origin git@gitee.com:jepsonpp/test.git\r\n\r\n# 删除origin这个别名\r\ngit remote remove origin\r\n```\r\n\r\n演示命令：`git push -u 仓库别名 分支名`\r\n\r\n\r\n\r\n### git clone\r\n\r\n- 作用：克隆远程仓库的代码到本地\r\n- git clone [远程仓库地址]\r\n- `git clone git@gitee.com:jepsonpp/test.git`会在本地新建一个`test`文件夹\r\n- 在test中包含了一个`.git`目录，用于保存所有的版本记录，同时test文件中还有最新的代码，可以进行后续的开发。\r\n- git克隆默认会使用远程仓库的项目名字，也可以自己指定。命令：`git clone [远程仓库地址] [本地项目名]`\r\n\r\ntips: `git branch -a`  查看分支\r\n\r\n\r\n\r\n### git pull\r\n\r\n- 作用：拉取更新，将远程的代码下载合并到本地的分支\r\n\r\n\r\n- 通常在push前，需要先pull一次。\r\n\r\n```bash\r\n# 获取远程仓库的更新，并且与本地的分支进行合并\r\ngit pull\r\ngit pull <远程主机名> <分支名>\r\ngit pull origin login  # 获取远程分支的更新，并更新合并到login分支\r\n```\r\n\r\n### 下载远端分支本地\r\n\r\n`checkout` 的 `-t `(或) `--track `)选项仅在创建新的(本地)分支时使用\r\n\r\n先在本地建立一个分支，并切换到该分支，然后从远程分支上同步代码到该分支上，并建立关联\r\n\r\n```git\r\ngit checkout -t origin/develop     #远端分支名和本地新建分支名同名\r\n```\r\n\r\n**后续拉取该分支的更新，就是切换到该分支，git  pull  origin 分支名**\r\n\r\n1. 将数据可视化项目上传到码云仓库,  主分支与开发分支均要上传\r\n\r\n```git\r\ngit push origin master\r\n\r\ngit push origin develop\r\n```\r\n\r\n2. 删除本地项目，通过克隆把远端仓库项目拉取下来，切换到develop分支\r\n\r\n```git\r\ngit clone 仓库地址\r\n\r\ngit checkout -t origin/develop\r\n```\r\n",contentRendered:'<h1 id="git" tabindex="-1"><a class="header-anchor" href="#git" aria-hidden="true">#</a> Git</h1>\n<h2 id="git基础入门" tabindex="-1"><a class="header-anchor" href="#git基础入门" aria-hidden="true">#</a> git基础入门</h2>\n<blockquote>\n<p>Git是一款免费、开源的<strong>分布式</strong> <strong>版本控制系统</strong> ，用于敏捷高效地处理任何或小或大的项目。</p>\n</blockquote>\n<blockquote>\n<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>\n</blockquote>\n<h3 id="git的安装" tabindex="-1"><a class="header-anchor" href="#git的安装" aria-hidden="true">#</a> git的安装</h3>\n<p><a href="https://git-scm.com/download/win" target="_blank" rel="noopener noreferrer">下载地址<ExternalLinkIcon/></a></p>\n<p>注意：</p>\n<ol>\n<li>不要安装在中文目录</li>\n<li>不要使用桌面管理软件</li>\n</ol>\n<p>安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。</p>\n<h3 id="git三个区" tabindex="-1"><a class="header-anchor" href="#git三个区" aria-hidden="true">#</a> git三个区</h3>\n<p>要对某个项目使用git进行管理，需要使用<code>git init</code>命令初始化git仓库\n<code>git init</code>会在当前目录生成一个隐藏文件夹 .git  不要去修改这个文件夹下的任意东西。</p>\n<p>git仓库会分成三个区</p>\n<p>工作区：我们书写代码的地方，工作的目录就叫工作区。</p>\n<p>暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。</p>\n<p>本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。</p>\n<h3 id="git基本命令" tabindex="-1"><a class="header-anchor" href="#git基本命令" aria-hidden="true">#</a> git基本命令</h3>\n<h4 id="git-init" tabindex="-1"><a class="header-anchor" href="#git-init" aria-hidden="true">#</a> git init</h4>\n<ul>\n<li>作用：初始化git仓库，想要使用git对某个项目进行管理，需要<code>git init</code>进行初始化</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 初始化仓库， 在当前目录下生成一个隐藏文件夹.git</span>\n<span class="token function">git</span> init\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="git-add" tabindex="-1"><a class="header-anchor" href="#git-add" aria-hidden="true">#</a> git add</h4>\n<ul>\n<li>作用：将文件由 <code>工作区</code> 添加到 <code>暂存区</code>，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。</li>\n<li>命令：<code>git add 文件名/目录名</code></li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 将index.html添加到暂存区</span>\n<span class="token function">git</span> <span class="token function">add</span> index.html\n\n<span class="token comment"># 将css目录下所有的文件添加到暂存区</span>\n<span class="token function">git</span> <span class="token function">add</span> css\n\n<span class="token comment"># 将当前目录下所有的js文件添加到暂存区</span>\n<span class="token function">git</span> <span class="token function">add</span> *.js\n\n<span class="token comment"># 添加当前目录下所有的文件</span>\n<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>\n<span class="token function">git</span> <span class="token function">add</span> -A\n<span class="token function">git</span> <span class="token function">add</span> --all\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="git-commit" tabindex="-1"><a class="header-anchor" href="#git-commit" aria-hidden="true">#</a> git commit</h4>\n<p>作用：将文件由 暂存区 添加到 仓库区，生成版本号</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 将文件从暂存区提交到仓库</span>\n<span class="token function">git</span> commit -m <span class="token string">"提交说明"</span>\n\n<span class="token comment"># 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。</span>\n<span class="token function">git</span> commit -a -m <span class="token string">\'提交说明\'</span>\n\n<span class="token comment"># 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令</span>\n<span class="token function">git</span> commit --amend -m <span class="token string">"提交说明"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="git-config配置" tabindex="-1"><a class="header-anchor" href="#git-config配置" aria-hidden="true">#</a> git config配置</h4>\n<p>如果是第一次提交，需要配置提交者信息，推荐和公司邮箱一致（可以用QQ邮箱）</p>\n<div class="language-Bash ext-Bash line-numbers-mode"><pre v-pre class="language-Bash"><code># git config  user.name 你的目标用户名\n# git config  user.email 你的目标邮箱名\n\n# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可\ngit config  --global user.name jepson\ngit config  --global user.email jepsonpp@qq.com\n\n# 查看配置信息\ngit config --list\n\n# 取消配置\ngit config --unset --global user.name\ngit config --unset --global user.email \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="git-status" tabindex="-1"><a class="header-anchor" href="#git-status" aria-hidden="true">#</a> git status</h4>\n<ul>\n<li>\n<p>作用：查看文件的状态</p>\n</li>\n<li>\n<p>命令：<code>git status</code></p>\n<ul>\n<li>红色表示工作区中的文件需要提交</li>\n<li>绿色表示暂存区中的文件需要提交</li>\n</ul>\n</li>\n<li>\n<p>命令：<code>git stauts -s</code> 简化日志输出格式</p>\n</li>\n</ul>\n<h4 id="git-log" tabindex="-1"><a class="header-anchor" href="#git-log" aria-hidden="true">#</a> git log</h4>\n<ul>\n<li>作用：查看提交日志</li>\n<li><code>git log</code> 查看提交的日志</li>\n<li><code>git log --oneline</code> 简洁的日志信息</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="" originSrc="./assets/git01.png" data="aurora"></p>\n<h3 id="git重置" tabindex="-1"><a class="header-anchor" href="#git重置" aria-hidden="true">#</a> git重置</h3>\n<h4 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h4>\n<ul>\n<li>\n<p>作用：版本回退，将代码恢复到已经提交的某一个版本中。</p>\n</li>\n<li>\n<p><code>git reset --hard 版本号</code> 将代码回退到某个指定的版本(版本号只要有前几位即可)</p>\n</li>\n<li>\n<p><code>git reset --hard head~1</code>将版本回退到上一次提交</p>\n<ul>\n<li>~1:上一次提交</li>\n<li>~2:上上次提交</li>\n<li>~0:当前提交</li>\n</ul>\n</li>\n<li>\n<p>当使用了<code>git reset</code>命令后，版本会回退，使用<code>git log</code>只能看到当前版本之前的信息。使用<code>git reflog</code>可以查看所有的版本信息</p>\n</li>\n</ul>\n<h3 id="git忽视文件" tabindex="-1"><a class="header-anchor" href="#git忽视文件" aria-hidden="true">#</a> git忽视文件</h3>\n<blockquote>\n<p>在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。</p>\n</blockquote>\n<ul>\n<li>在仓库的根目录创建一个<code>.gitignore</code>的文件，文件名是固定的。</li>\n<li>将不需要被git管理的文件路径添加到<code>.gitignore</code>中</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 忽视idea.txt文件</span>\nidea.txt\n\n<span class="token comment"># 忽视css下的index.js文件</span>\ncss/index.js\n\n<span class="token comment"># 忽视css下的所有的js文件</span>\ncss/*.js\n\n<span class="token comment"># 忽视css文件夹</span>\ncss\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="git分支操作" tabindex="-1"><a class="header-anchor" href="#git分支操作" aria-hidden="true">#</a> git分支操作</h2>\n<p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>\n<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="" originSrc="./assets/fenzhi.png" data="aurora"></p>\n<h3 id="为什么要有分支" tabindex="-1"><a class="header-anchor" href="#为什么要有分支" aria-hidden="true">#</a> 为什么要有分支？</h3>\n<ul>\n<li>如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。</li>\n<li>有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。</li>\n</ul>\n<h3 id="git分支命令" tabindex="-1"><a class="header-anchor" href="#git分支命令" aria-hidden="true">#</a> git分支命令</h3>\n<blockquote>\n<p>在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支</p>\n</blockquote>\n<h4 id="创建分支" tabindex="-1"><a class="header-anchor" href="#创建分支" aria-hidden="true">#</a> 创建分支</h4>\n<ul>\n<li><code>git branch 分支名称</code>创建分支，分支中的代码，在创建时与当前分支的内容完全相同。</li>\n<li>git在第一次提交时，就有了一个叫<code>master</code>的主分支。</li>\n<li><code>git branch dev</code>，创建了一个叫做dev的分支</li>\n</ul>\n<h4 id="查看分支" tabindex="-1"><a class="header-anchor" href="#查看分支" aria-hidden="true">#</a> 查看分支</h4>\n<ul>\n<li><code>git branch</code>可以查看所有的分支，</li>\n<li>在当前分支的前面会有一个<code>*</code></li>\n<li>在git中，有一个特殊指针<code>HEAD</code>,永远会指向当前分支</li>\n</ul>\n<h4 id="切换分支" tabindex="-1"><a class="header-anchor" href="#切换分支" aria-hidden="true">#</a> 切换分支</h4>\n<ul>\n<li><code>git checkout 分支名称</code>切换分支  HEAD指针指向了另一个分支</li>\n<li>在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。</li>\n<li>提交代码时，会生产版本号，当前分支会指向最新的版本号。</li>\n</ul>\n<h4 id="创建并切换分支" tabindex="-1"><a class="header-anchor" href="#创建并切换分支" aria-hidden="true">#</a> 创建并切换分支</h4>\n<ul>\n<li><code>git checkout -b 分支名称</code> 创建并切换分支</li>\n<li>切换分支会做两件事情\n<ul>\n<li>创建一个新分支</li>\n<li>把head指针指向当前的分支</li>\n</ul>\n</li>\n</ul>\n<h4 id="删除分支" tabindex="-1"><a class="header-anchor" href="#删除分支" aria-hidden="true">#</a> 删除分支</h4>\n<ul>\n<li><code>git branch -d 分支名称</code> 可以删除分支</li>\n<li>注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。</li>\n<li>注意：<code>master</code>分支是可以删除的，但是不推荐那么做。</li>\n</ul>\n<h4 id="合并分支" tabindex="-1"><a class="header-anchor" href="#合并分支" aria-hidden="true">#</a> 合并分支</h4>\n<ul>\n<li><code>git merge 分支名称</code> 将其他分支的内容合并到当前分支。</li>\n<li>在<code>master</code>分支中执行<code>git merge dev</code> 将<code>dev</code>分支中的代码合并到<code>master</code>分支</li>\n<li><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="noopener noreferrer">分支合并<ExternalLinkIcon/></a></li>\n</ul>\n<h3 id="git合并冲突" tabindex="-1"><a class="header-anchor" href="#git合并冲突" aria-hidden="true">#</a> git合并冲突</h3>\n<ul>\n<li>对于同一个文件，如果有多个分支需要合并时，容易出现冲突。</li>\n<li>合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。</li>\n</ul>\n<blockquote></blockquote>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#btn-login\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'form\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">hash</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token comment">// 非空校验</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span>username<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'请输入用户名\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span>password<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'请输入密码\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>password<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'密码的长度不能小于6位\'</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">\'/login\'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>\n    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'user-token\'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>token<span class="token punctuation">)</span>\n    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'user-name\'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>username<span class="token punctuation">)</span>\n    <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'登录成功\'</span><span class="token punctuation">)</span>\n    location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">\'./index.html\'</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'用户名或者密码错误\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="git远程仓库" tabindex="-1"><a class="header-anchor" href="#git远程仓库" aria-hidden="true">#</a> git远程仓库</h2>\n<h3 id="github、gitee、gitlab" tabindex="-1"><a class="header-anchor" href="#github、gitee、gitlab" aria-hidden="true">#</a> github、gitee、gitlab</h3>\n<ul>\n<li>git是一个版本控制工具。</li>\n<li>github是一个代码托管平台，开源社区，是git的一个远程代码仓库平台。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">//1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。</span>\n<span class="token comment">//2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。</span>\n<span class="token comment">//3. 创建git项目时，不能有中文。</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><a href="https://github.com/" target="_blank" rel="noopener noreferrer">github官网<ExternalLinkIcon/></a>： 国外开源 git 代码托管平台</p>\n<p><a href="https://git.oschina.net/" target="_blank" rel="noopener noreferrer">开源中国-git<ExternalLinkIcon/></a>:  国内开源 git 代码托管平台</p>\n<p><a href="https://about.gitlab.com/" target="_blank" rel="noopener noreferrer">gitlab<ExternalLinkIcon/></a>：企业级 git 代码托管平台</p>\n<h3 id="码云创建远程仓库" tabindex="-1"><a class="header-anchor" href="#码云创建远程仓库" aria-hidden="true">#</a> 码云创建远程仓库</h3>\n<ol>\n<li>\n<p>新建右上角仓库</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220514184557788" originSrc="assets/image-20220514184557788.png" data="aurora"></p>\n</li>\n<li>\n<p>输入仓库名  <strong>不勾初始化！！！</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220514184702951" originSrc="assets/image-20220514184702951.png" data="aurora"></p>\n</li>\n<li>\n<p>点击创建</p>\n</li>\n</ol>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220514184807839" originSrc="assets/image-20220514184807839.png" data="aurora"></p>\n<h3 id="ssh免密码登陆" tabindex="-1"><a class="header-anchor" href="#ssh免密码登陆" aria-hidden="true">#</a> SSH免密码登陆</h3>\n<p>git支持多种数据传输协议：</p>\n<ul>\n<li>https协议：<code>https://gitee.com/jepsonpp/test.git</code>  需要输入用户名和密码</li>\n<li>ssh协议：<code>git@gitee.com:jepsonpp/test.git</code>   可以配置免密码登录</li>\n</ul>\n<p>每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。</p>\n<ul>\n<li>github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push</li>\n<li>使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码</li>\n</ul>\n<h3 id="ssh免密码登录配置" tabindex="-1"><a class="header-anchor" href="#ssh免密码登录配置" aria-hidden="true">#</a> SSH免密码登录配置</h3>\n<ul>\n<li>1 创建SSH Key：<code>ssh-keygen -t rsa</code>    （注意：这些命令需要在bash中敲）</li>\n<li>2 在文件路径 <code>C:\\用户\\当前用户名\\</code> 找到 <code>.ssh</code> 文件夹</li>\n<li>3 文件夹中有两个文件：\n<ul>\n<li>私钥：<code>id_rsa</code></li>\n<li>公钥：<code>id_rsa.pub</code></li>\n</ul>\n</li>\n<li>4 在 <code>码云-&gt; 设置 -&gt; SSH公钥</code>页面中</li>\n<li>5 粘贴 公钥 <code>id_rsa.pub</code> 内容到对应文本框中， 添加公钥</li>\n</ul>\n<h3 id="git-push" tabindex="-1"><a class="header-anchor" href="#git-push" aria-hidden="true">#</a> git push</h3>\n<ul>\n<li>作用：将本地仓库中代码提交到远程仓库</li>\n<li><code>git push 仓库地址 分支名</code>   将代码提交到远程仓库对应分支</li>\n<li>例子：<code>git push git@gitee.com:jepsonpp/test.git master</code></li>\n</ul>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>git push &lt;远程主机名> &lt;本地分支名>:&lt;远程分支名>\n如果本地分支名与远程分支名相同，则可以省略冒号\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="git-remote" tabindex="-1"><a class="header-anchor" href="#git-remote" aria-hidden="true">#</a> git remote</h3>\n<p>每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 给远程仓库设置一个别名</span>\n<span class="token function">git</span> remote <span class="token function">add</span> 仓库别名 仓库地址\n<span class="token function">git</span> remote <span class="token function">add</span> origin git@gitee.com:jepsonpp/test.git\n\n<span class="token comment"># 删除origin这个别名</span>\n<span class="token function">git</span> remote remove origin\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>演示命令：<code>git push -u 仓库别名 分支名</code></p>\n<h3 id="git-clone" tabindex="-1"><a class="header-anchor" href="#git-clone" aria-hidden="true">#</a> git clone</h3>\n<ul>\n<li>作用：克隆远程仓库的代码到本地</li>\n<li>git clone [远程仓库地址]</li>\n<li><code>git clone git@gitee.com:jepsonpp/test.git</code>会在本地新建一个<code>test</code>文件夹</li>\n<li>在test中包含了一个<code>.git</code>目录，用于保存所有的版本记录，同时test文件中还有最新的代码，可以进行后续的开发。</li>\n<li>git克隆默认会使用远程仓库的项目名字，也可以自己指定。命令：<code>git clone [远程仓库地址] [本地项目名]</code></li>\n</ul>\n<p>tips: <code>git branch -a</code>  查看分支</p>\n<h3 id="git-pull" tabindex="-1"><a class="header-anchor" href="#git-pull" aria-hidden="true">#</a> git pull</h3>\n<ul>\n<li>\n<p>作用：拉取更新，将远程的代码下载合并到本地的分支</p>\n</li>\n<li>\n<p>通常在push前，需要先pull一次。</p>\n</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 获取远程仓库的更新，并且与本地的分支进行合并</span>\n<span class="token function">git</span> pull\n<span class="token function">git</span> pull <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span>\n<span class="token function">git</span> pull origin login  <span class="token comment"># 获取远程分支的更新，并更新合并到login分支</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="下载远端分支本地" tabindex="-1"><a class="header-anchor" href="#下载远端分支本地" aria-hidden="true">#</a> 下载远端分支本地</h3>\n<p><code>checkout</code> 的 <code>-t </code>(或) <code>--track </code>)选项仅在创建新的(本地)分支时使用</p>\n<p>先在本地建立一个分支，并切换到该分支，然后从远程分支上同步代码到该分支上，并建立关联</p>\n<div class="language-git ext-git line-numbers-mode"><pre v-pre class="language-git"><code>git checkout -t origin/develop     #远端分支名和本地新建分支名同名\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>后续拉取该分支的更新，就是切换到该分支，git  pull  origin 分支名</strong></p>\n<ol>\n<li>将数据可视化项目上传到码云仓库,  主分支与开发分支均要上传</li>\n</ol>\n<div class="language-git ext-git line-numbers-mode"><pre v-pre class="language-git"><code>git push origin master\n\ngit push origin develop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2">\n<li>删除本地项目，通过克隆把远端仓库项目拉取下来，切换到develop分支</li>\n</ol>\n<div class="language-git ext-git line-numbers-mode"><pre v-pre class="language-git"><code>git clone 仓库地址\n\ngit checkout -t origin/develop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Git/git.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"git",filePath:"D:/桌面文件/Blog/blog-demo/docs/Git/git.md",filePathRelative:"Git/git.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Git/git.html.vue",componentFilePathRelative:"pages/Git/git.html.vue",componentFileChunkName:"v-ef444906",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Git/git.html.js",dataFilePathRelative:"pages/Git/git.html.js",dataFileChunkName:"v-ef444906",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Git/git.html",htmlFilePathRelative:"Git/git.html"},{data:{key:"v-3d2f7822",path:"/JAVA/1Java%E5%9F%BA%E7%A1%80.html",title:"Java基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Java语言的发展",slug:"_1-6-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",children:[]}]}],git:{}},key:"v-3d2f7822",path:"/JAVA/1Java%E5%9F%BA%E7%A1%80.html",title:"Java基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Java语言的发展",slug:"_1-6-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",children:[]}]}],content:'\r\n\r\n# Java基础\r\n\r\n## 1. 人机交互\r\n\r\n### 1.1 什么是cmd？\r\n\r\n就是在windows操作系统中，利用命令行的方式去操作计算机。\r\n\r\n我们可以利用cmd命令去操作计算机，比如：打开文件，打开文件夹，创建文件夹等。\r\n\r\n### 1.2 如何打开CMD窗口？\r\n\r\n1. 按下快捷键：win + R。\r\n\r\n\t\t此时会出现运行窗口。\r\n\r\n2. 在运行窗口中输出cmd\r\n3. 输出回车。\r\n\r\n解惑：\r\n\r\n​\tcmd默认操作C盘下的users文件夹下的XXX文件夹。（XXX就是计算机名）\r\n\r\n### 1.3 常用CMD命令\r\n\r\n 扩展一个小点：\r\n\r\n​\t在很多资料中都说成是DOS命令，其实是不对的。真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。\r\n\r\n​\t而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做CMD命令会更准确一些。\r\n\r\n常见的CMD命令如下：\r\n\r\n| 操作               | 说明                              |\r\n| ------------------ | --------------------------------- |\r\n| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |\r\n| dir                | 查看当前路径下的内容。            |\r\n| cd 目录            | 进入单级目录。cd itheima          |\r\n| cd ..              | 回退到上一级目录。                |\r\n| cd 目录1\\目录2\\... | 进入多级目录。cd itheima\\JavaSE   |\r\n| cd \\               | 回退到盘符目录。                  |\r\n| cls                | 清屏。                            |\r\n| exit               | 退出命令提示符窗口。              |\r\n\r\n### 1.5 环境变量\r\n\r\n作用：\r\n\r\n​\t如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。\r\n\r\n​\t在启动软件的时候，操作系统会先在当前路径下找，如果在当前录课没有再到环境变量的路径中去找。如果都找不到就提示无法启动。\r\n\r\n步骤：\r\n\r\n- 右键我的电脑，选择属性。\r\n- 点击左侧的高级系统设置\r\n- 选择高级，再点击下面的环境变量。\r\n- 找系统变量里面的PATH\r\n- 把软件的完整路径，配置到PATH当中就可以了。\r\n- （可做可不做）就是把自己配置的路径，移动到最上面。\r\n\r\n图解示例如下：\r\n\r\n第一步：右键点击我的电脑并选择属性。\r\n\r\n（如果无法出现第二步界面，可以打开我的电脑之后右键点击空白处）\r\n\r\n第二步：点击高级系统设置。\r\n\r\n第三步：选择高级，再点击下面的环境变量。\r\n\r\n第四步：找系统变量里面的path\r\n\r\n第五步：点击新建，把软件的完整路径，配置到PATH当中，再点击确定即可。\r\n\r\n第六步：（可做可不做）点击上移，把当前配置的路径移动到最上面。\r\n\r\n移动的好处：在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上面查找的速度比较快。\r\n\r\n## 2. Java概述\r\n\r\n### 1.1 Java是什么？\r\n\r\n语言：人与人交流沟通的表达方式\r\n\r\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\r\n\r\nJava是一门非常火的计算机语言。（也叫做编程语言）\r\n\r\n我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了\r\n\r\n### 1.2下载和安装\r\n\r\n#### 1.2.1 下载\r\n\r\n通过官方网站获取JDK\r\n\r\n[http://www.oracle.com](http://www.oracle.com/)\r\n\r\n**注意1**：针对不同的操作系统，需要下载对应版本的JDK。\r\n\r\n**注意2**：\r\n\r\n​\t如果你的电脑是windows32位的，建议重装系统，重装成64位的操作系统。\r\n\r\n​\t因为Java从9版本开始，就已经不提供32位版本的安装包了。\r\n\r\n​\t如果自己不愿意下载，到今天day01资料文件中，也有对应的安装包。\r\n\r\n#### 1.2.2 安装\r\n\r\n​\t傻瓜式安装，下一步即可。默认的安装路径是在C:\\Program Files下。\r\n\r\n建议：\r\n\r\n- 安装路径不要有中文，不要有空格等一些特殊的符号。\r\n- 以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。\r\n\r\n#### 1.2.3 JDK的安装目录介绍\r\n\r\n| 目录名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |\r\n| conf     | 该路径下存放了JDK的相关配置文件。                            |\r\n| include  | 该路径下存放了一些平台特定的头文件。                         |\r\n| jmods    | 该路径下存放了JDK的各种模块。                                |\r\n| legal    | 该路径下存放了JDK各模块的授权文档。                          |\r\n| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |\r\n\r\n#### 2.3.1 Java程序开发运行流程\r\n\r\n开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。\r\n\r\n#### 2.3.2 HelloWorld案例的编写\r\n\r\n1. 新建文本文档文件，修改名称为HelloWorld.java。\r\n\r\n**注意**：后缀名为java的才是java文件。\r\n\r\n2. 用记事本打开HelloWorld.java文件，输写程序内容。\r\n\r\n**注意**：代码要跟我编写的完全保持一致。\r\n\r\n```java\r\npublic class HelloWorld {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println("HelloWorld");\r\n\t}\r\n}\r\n```\r\n\r\n3. 保存\r\n\r\n**注意**：未保存的文件在左上角会有*符号标记\r\n\r\n4. 编译文件。编译后会产生一个class文件。\r\n\r\n   java文件：程序员自己编写的代码。\r\n\r\n   class文件：交给计算机执行的文件。\r\n\r\n5. 运行代码\r\n\r\n   **注意**：运行的是编译之后的class文件。\r\n\r\n> 用到两个命令：\r\n>\r\n> ​\tjavac + 文件名 + 后缀名 （就是编译java文件）\r\n>\r\n> ​\tjava + 文件名（运行编译之后的class文件）\r\n\r\n### 1.4 HelloWorld案例常见问题\r\n\r\n#### 1.4.1 BUG\r\n\r\n​\t在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\r\n\r\n#### 1.4.2 BUG的解决\r\n\r\n1. 具备识别BUG的能力：多看\r\n2. 具备分析BUG的能力：多思考，多查资料\r\n3. 具备解决BUG的能力：多尝试，多总结\r\n\r\n#### 1.4.3 HelloWorld常见问题\r\n\r\n1、非法字符问题。Java中的符号都是英文格式的。\r\n\r\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\r\n\r\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\r\n\r\n4、编译命令后的java文件名需要带文件后缀.java\r\n\r\n5、运行命令后的class文件名（类名）不带文件后缀.class\r\n\r\n...\r\n\r\n#### 常见错误代码1：\r\n\r\n```java\r\npublicclass HelloWorld{\r\n    public static void main(String[] args){\r\n        System.out.println("HelloWorld");\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\tpublic和class之间缺少一个空格。\r\n\r\n技巧：一般来讲在单词之间的空格是不能省略的。\r\n\r\n​\t如果是单词和符号之间的空格是可以省略的。\r\n\r\n#### 常见错误代码2：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    public static void main(String[] args){\r\n        system.out.println("HelloWorld");\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\tsystem首字母必须大写。\r\n\r\n技巧：\r\n\r\n​\tJava代码中，是严格区分大小写的。\r\n\r\n​\t所以该大写的地方一定要大写，该小写的地方一定要小写。多多练习。\r\n\r\n#### 常见错误代码3：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    public static void main(String[] args){\r\n        System.out.println(HelloWorld);\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\t第三行代码中的HelloWorld必须用双引号引起来，否则就会出现问题。\r\n\r\n#### 常见错误代码4：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    public static void main(String[] args){\r\n        System.out.println("HelloWorld")；\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\t在以后代码当中，所有的标点符号必须是英文状态下的。\r\n\r\n技巧：\r\n\r\n​\t可以在输入法中进行对应的设置。\r\n\r\n### 1.5 环境变量\r\n\r\n#### 1.5.1 为什么配置环境变量\r\n\r\n​\t开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。\r\n\r\n注意：现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。\r\n\r\n#### 1.5.2配置方式\r\n\r\n以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。\r\n\r\n①**JAVA_HOME**：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过这个找JDK）\r\n\r\n②**Path**：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置\r\n\r\n### 1.6 Java语言的发展\r\n\r\n三个版本：\r\n\r\n* Java5.0：这是Java的第一个大版本更新。\r\n* Java8.0：这个是目前绝大数公司正在使用的版本。因为这个版本最为稳定。\r\n* Java15.0：这个是我们课程中学习的版本。\r\n\r\n解惑：\r\n\r\n​\t我们学的跟工作中使用的版本不太一样啊。会不会影响以后工作呢？\r\n\r\n向下兼容。新的版本只是在原有的基础上添加了一些新的功能而已。\r\n\r\n举例：\r\n\r\n用8版本开发的代码，用11版本能运行吗？必须可以的。\r\n\r\n用11版本开发的代码，用8版本能运行吗？不一定。\r\n\r\n如果11版本开发的代码，没有用到9~11的新特性，那么用8是可以运行的。\r\n\r\n如果11版本开发的代码，用到了9~11的新特性，那么用8就无法运行了。\r\n\r\n### 1.8 Java的三大平台\r\n\r\n​\tJavaSE、JavaME、JavaEE\r\n\r\n#### 1.8.1 JavaSE\r\n\r\n​\t是其他两个版本的基础。\r\n\r\n#### 1.8.2 JavaME\r\n\r\n​\tJava语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。\r\n\r\n​\t其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。\r\n\r\n​\t但是，安卓也是可以用Java来开发的。\r\n\r\n#### 1.8.3 JavaEE\r\n\r\n​\t用于Web方向的网站开发。（主要从事后台服务器的开发）\r\n\r\n​\t在服务器领域，Java是当之无愧的龙头老大。\r\n\r\n### 1.9 Java的主要特性\r\n\r\n- 面向对象\r\n- 安全性\r\n- 多线程\r\n- 简单易用\r\n- 开源\r\n- 跨平台\r\n\r\n#### 1.9.1 Java语言跨平台的原理\r\n\r\n- 操作系统本身其实是不认识Java语言的。\r\n- 但是针对于不同的操作系统，Java提供了不同的虚拟机。\r\n\r\n虚拟机会把Java语言翻译成操作系统能看得懂的语言。\r\n\r\n### 1.10 JRE和JDK\r\n\r\nJVM（Java Virtual Machine），Java虚拟机\r\n\r\nJRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\r\n\r\nJDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\r\n\r\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\r\n',contentRendered:'<h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础" aria-hidden="true">#</a> Java基础</h1>\n<h2 id="_1-人机交互" tabindex="-1"><a class="header-anchor" href="#_1-人机交互" aria-hidden="true">#</a> 1. 人机交互</h2>\n<h3 id="_1-1-什么是cmd" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是cmd" aria-hidden="true">#</a> 1.1 什么是cmd？</h3>\n<p>就是在windows操作系统中，利用命令行的方式去操作计算机。</p>\n<p>我们可以利用cmd命令去操作计算机，比如：打开文件，打开文件夹，创建文件夹等。</p>\n<h3 id="_1-2-如何打开cmd窗口" tabindex="-1"><a class="header-anchor" href="#_1-2-如何打开cmd窗口" aria-hidden="true">#</a> 1.2 如何打开CMD窗口？</h3>\n<ol>\n<li>\n<p>按下快捷键：win + R。</p>\n<pre><code> 此时会出现运行窗口。\n</code></pre>\n</li>\n<li>\n<p>在运行窗口中输出cmd</p>\n</li>\n<li>\n<p>输出回车。</p>\n</li>\n</ol>\n<p>解惑：</p>\n<p>​\tcmd默认操作C盘下的users文件夹下的XXX文件夹。（XXX就是计算机名）</p>\n<h3 id="_1-3-常用cmd命令" tabindex="-1"><a class="header-anchor" href="#_1-3-常用cmd命令" aria-hidden="true">#</a> 1.3 常用CMD命令</h3>\n<p>扩展一个小点：</p>\n<p>​\t在很多资料中都说成是DOS命令，其实是不对的。真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。</p>\n<p>​\t而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做CMD命令会更准确一些。</p>\n<p>常见的CMD命令如下：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>盘符名称:</td>\n<td>盘符切换。E:回车，表示切换到E盘。</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>查看当前路径下的内容。</td>\n</tr>\n<tr>\n<td>cd 目录</td>\n<td>进入单级目录。cd itheima</td>\n</tr>\n<tr>\n<td>cd ..</td>\n<td>回退到上一级目录。</td>\n</tr>\n<tr>\n<td>cd 目录1\\目录2...</td>\n<td>进入多级目录。cd itheima\\JavaSE</td>\n</tr>\n<tr>\n<td>cd \\</td>\n<td>回退到盘符目录。</td>\n</tr>\n<tr>\n<td>cls</td>\n<td>清屏。</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>退出命令提示符窗口。</td>\n</tr>\n</tbody>\n</table>\n<h3 id="_1-5-环境变量" tabindex="-1"><a class="header-anchor" href="#_1-5-环境变量" aria-hidden="true">#</a> 1.5 环境变量</h3>\n<p>作用：</p>\n<p>​\t如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。</p>\n<p>​\t在启动软件的时候，操作系统会先在当前路径下找，如果在当前录课没有再到环境变量的路径中去找。如果都找不到就提示无法启动。</p>\n<p>步骤：</p>\n<ul>\n<li>右键我的电脑，选择属性。</li>\n<li>点击左侧的高级系统设置</li>\n<li>选择高级，再点击下面的环境变量。</li>\n<li>找系统变量里面的PATH</li>\n<li>把软件的完整路径，配置到PATH当中就可以了。</li>\n<li>（可做可不做）就是把自己配置的路径，移动到最上面。</li>\n</ul>\n<p>图解示例如下：</p>\n<p>第一步：右键点击我的电脑并选择属性。</p>\n<p>（如果无法出现第二步界面，可以打开我的电脑之后右键点击空白处）</p>\n<p>第二步：点击高级系统设置。</p>\n<p>第三步：选择高级，再点击下面的环境变量。</p>\n<p>第四步：找系统变量里面的path</p>\n<p>第五步：点击新建，把软件的完整路径，配置到PATH当中，再点击确定即可。</p>\n<p>第六步：（可做可不做）点击上移，把当前配置的路径移动到最上面。</p>\n<p>移动的好处：在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上面查找的速度比较快。</p>\n<h2 id="_2-java概述" tabindex="-1"><a class="header-anchor" href="#_2-java概述" aria-hidden="true">#</a> 2. Java概述</h2>\n<h3 id="_1-1-java是什么" tabindex="-1"><a class="header-anchor" href="#_1-1-java是什么" aria-hidden="true">#</a> 1.1 Java是什么？</h3>\n<p>语言：人与人交流沟通的表达方式</p>\n<p>计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言</p>\n<p>Java是一门非常火的计算机语言。（也叫做编程语言）</p>\n<p>我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了</p>\n<h3 id="_1-2下载和安装" tabindex="-1"><a class="header-anchor" href="#_1-2下载和安装" aria-hidden="true">#</a> 1.2下载和安装</h3>\n<h4 id="_1-2-1-下载" tabindex="-1"><a class="header-anchor" href="#_1-2-1-下载" aria-hidden="true">#</a> 1.2.1 下载</h4>\n<p>通过官方网站获取JDK</p>\n<p><a href="http://www.oracle.com/" target="_blank" rel="noopener noreferrer">http://www.oracle.com<ExternalLinkIcon/></a></p>\n<p><strong>注意1</strong>：针对不同的操作系统，需要下载对应版本的JDK。</p>\n<p><strong>注意2</strong>：</p>\n<p>​\t如果你的电脑是windows32位的，建议重装系统，重装成64位的操作系统。</p>\n<p>​\t因为Java从9版本开始，就已经不提供32位版本的安装包了。</p>\n<p>​\t如果自己不愿意下载，到今天day01资料文件中，也有对应的安装包。</p>\n<h4 id="_1-2-2-安装" tabindex="-1"><a class="header-anchor" href="#_1-2-2-安装" aria-hidden="true">#</a> 1.2.2 安装</h4>\n<p>​\t傻瓜式安装，下一步即可。默认的安装路径是在C:\\Program Files下。</p>\n<p>建议：</p>\n<ul>\n<li>安装路径不要有中文，不要有空格等一些特殊的符号。</li>\n<li>以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。</li>\n</ul>\n<h4 id="_1-2-3-jdk的安装目录介绍" tabindex="-1"><a class="header-anchor" href="#_1-2-3-jdk的安装目录介绍" aria-hidden="true">#</a> 1.2.3 JDK的安装目录介绍</h4>\n<table>\n<thead>\n<tr>\n<th>目录名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bin</td>\n<td>该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。</td>\n</tr>\n<tr>\n<td>conf</td>\n<td>该路径下存放了JDK的相关配置文件。</td>\n</tr>\n<tr>\n<td>include</td>\n<td>该路径下存放了一些平台特定的头文件。</td>\n</tr>\n<tr>\n<td>jmods</td>\n<td>该路径下存放了JDK的各种模块。</td>\n</tr>\n<tr>\n<td>legal</td>\n<td>该路径下存放了JDK各模块的授权文档。</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>该路径下存放了JDK工具的一些补充JAR包。</td>\n</tr>\n</tbody>\n</table>\n<h4 id="_2-3-1-java程序开发运行流程" tabindex="-1"><a class="header-anchor" href="#_2-3-1-java程序开发运行流程" aria-hidden="true">#</a> 2.3.1 Java程序开发运行流程</h4>\n<p>开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。</p>\n<h4 id="_2-3-2-helloworld案例的编写" tabindex="-1"><a class="header-anchor" href="#_2-3-2-helloworld案例的编写" aria-hidden="true">#</a> 2.3.2 HelloWorld案例的编写</h4>\n<ol>\n<li>新建文本文档文件，修改名称为HelloWorld.java。</li>\n</ol>\n<p><strong>注意</strong>：后缀名为java的才是java文件。</p>\n<ol start="2">\n<li>用记事本打开HelloWorld.java文件，输写程序内容。</li>\n</ol>\n<p><strong>注意</strong>：代码要跟我编写的完全保持一致。</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3">\n<li>保存</li>\n</ol>\n<p><strong>注意</strong>：未保存的文件在左上角会有*符号标记</p>\n<ol start="4">\n<li>\n<p>编译文件。编译后会产生一个class文件。</p>\n<p>java文件：程序员自己编写的代码。</p>\n<p>class文件：交给计算机执行的文件。</p>\n</li>\n<li>\n<p>运行代码</p>\n<p><strong>注意</strong>：运行的是编译之后的class文件。</p>\n</li>\n</ol>\n<blockquote>\n<p>用到两个命令：</p>\n<p>​\tjavac + 文件名 + 后缀名 （就是编译java文件）</p>\n<p>​\tjava + 文件名（运行编译之后的class文件）</p>\n</blockquote>\n<h3 id="_1-4-helloworld案例常见问题" tabindex="-1"><a class="header-anchor" href="#_1-4-helloworld案例常见问题" aria-hidden="true">#</a> 1.4 HelloWorld案例常见问题</h3>\n<h4 id="_1-4-1-bug" tabindex="-1"><a class="header-anchor" href="#_1-4-1-bug" aria-hidden="true">#</a> 1.4.1 BUG</h4>\n<p>​\t在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。</p>\n<h4 id="_1-4-2-bug的解决" tabindex="-1"><a class="header-anchor" href="#_1-4-2-bug的解决" aria-hidden="true">#</a> 1.4.2 BUG的解决</h4>\n<ol>\n<li>具备识别BUG的能力：多看</li>\n<li>具备分析BUG的能力：多思考，多查资料</li>\n<li>具备解决BUG的能力：多尝试，多总结</li>\n</ol>\n<h4 id="_1-4-3-helloworld常见问题" tabindex="-1"><a class="header-anchor" href="#_1-4-3-helloworld常见问题" aria-hidden="true">#</a> 1.4.3 HelloWorld常见问题</h4>\n<p>1、非法字符问题。Java中的符号都是英文格式的。</p>\n<p>2、大小写问题。Java语言对大小写敏感（区分大小写）。</p>\n<p>3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。</p>\n<p>4、编译命令后的java文件名需要带文件后缀.java</p>\n<p>5、运行命令后的class文件名（类名）不带文件后缀.class</p>\n<p>...</p>\n<h4 id="常见错误代码1" tabindex="-1"><a class="header-anchor" href="#常见错误代码1" aria-hidden="true">#</a> 常见错误代码1：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code>publicclass <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\tpublic和class之间缺少一个空格。</p>\n<p>技巧：一般来讲在单词之间的空格是不能省略的。</p>\n<p>​\t如果是单词和符号之间的空格是可以省略的。</p>\n<h4 id="常见错误代码2" tabindex="-1"><a class="header-anchor" href="#常见错误代码2" aria-hidden="true">#</a> 常见错误代码2：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\tsystem首字母必须大写。</p>\n<p>技巧：</p>\n<p>​\tJava代码中，是严格区分大小写的。</p>\n<p>​\t所以该大写的地方一定要大写，该小写的地方一定要小写。多多练习。</p>\n<h4 id="常见错误代码3" tabindex="-1"><a class="header-anchor" href="#常见错误代码3" aria-hidden="true">#</a> 常见错误代码3：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">HelloWorld</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\t第三行代码中的HelloWorld必须用双引号引起来，否则就会出现问题。</p>\n<h4 id="常见错误代码4" tabindex="-1"><a class="header-anchor" href="#常见错误代码4" aria-hidden="true">#</a> 常见错误代码4：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span>；\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\t在以后代码当中，所有的标点符号必须是英文状态下的。</p>\n<p>技巧：</p>\n<p>​\t可以在输入法中进行对应的设置。</p>\n<h3 id="_1-5-环境变量-1" tabindex="-1"><a class="header-anchor" href="#_1-5-环境变量-1" aria-hidden="true">#</a> 1.5 环境变量</h3>\n<h4 id="_1-5-1-为什么配置环境变量" tabindex="-1"><a class="header-anchor" href="#_1-5-1-为什么配置环境变量" aria-hidden="true">#</a> 1.5.1 为什么配置环境变量</h4>\n<p>​\t开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。</p>\n<p>注意：现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。</p>\n<h4 id="_1-5-2配置方式" tabindex="-1"><a class="header-anchor" href="#_1-5-2配置方式" aria-hidden="true">#</a> 1.5.2配置方式</h4>\n<p>以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。</p>\n<p>①<strong>JAVA_HOME</strong>：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过这个找JDK）</p>\n<p>②<strong>Path</strong>：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置</p>\n<h3 id="_1-6-java语言的发展" tabindex="-1"><a class="header-anchor" href="#_1-6-java语言的发展" aria-hidden="true">#</a> 1.6 Java语言的发展</h3>\n<p>三个版本：</p>\n<ul>\n<li>Java5.0：这是Java的第一个大版本更新。</li>\n<li>Java8.0：这个是目前绝大数公司正在使用的版本。因为这个版本最为稳定。</li>\n<li>Java15.0：这个是我们课程中学习的版本。</li>\n</ul>\n<p>解惑：</p>\n<p>​\t我们学的跟工作中使用的版本不太一样啊。会不会影响以后工作呢？</p>\n<p>向下兼容。新的版本只是在原有的基础上添加了一些新的功能而已。</p>\n<p>举例：</p>\n<p>用8版本开发的代码，用11版本能运行吗？必须可以的。</p>\n<p>用11版本开发的代码，用8版本能运行吗？不一定。</p>\n<p>如果11版本开发的代码，没有用到9~11的新特性，那么用8是可以运行的。</p>\n<p>如果11版本开发的代码，用到了9~11的新特性，那么用8就无法运行了。</p>\n<h3 id="_1-8-java的三大平台" tabindex="-1"><a class="header-anchor" href="#_1-8-java的三大平台" aria-hidden="true">#</a> 1.8 Java的三大平台</h3>\n<p>​\tJavaSE、JavaME、JavaEE</p>\n<h4 id="_1-8-1-javase" tabindex="-1"><a class="header-anchor" href="#_1-8-1-javase" aria-hidden="true">#</a> 1.8.1 JavaSE</h4>\n<p>​\t是其他两个版本的基础。</p>\n<h4 id="_1-8-2-javame" tabindex="-1"><a class="header-anchor" href="#_1-8-2-javame" aria-hidden="true">#</a> 1.8.2 JavaME</h4>\n<p>​\tJava语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p>\n<p>​\t其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。</p>\n<p>​\t但是，安卓也是可以用Java来开发的。</p>\n<h4 id="_1-8-3-javaee" tabindex="-1"><a class="header-anchor" href="#_1-8-3-javaee" aria-hidden="true">#</a> 1.8.3 JavaEE</h4>\n<p>​\t用于Web方向的网站开发。（主要从事后台服务器的开发）</p>\n<p>​\t在服务器领域，Java是当之无愧的龙头老大。</p>\n<h3 id="_1-9-java的主要特性" tabindex="-1"><a class="header-anchor" href="#_1-9-java的主要特性" aria-hidden="true">#</a> 1.9 Java的主要特性</h3>\n<ul>\n<li>面向对象</li>\n<li>安全性</li>\n<li>多线程</li>\n<li>简单易用</li>\n<li>开源</li>\n<li>跨平台</li>\n</ul>\n<h4 id="_1-9-1-java语言跨平台的原理" tabindex="-1"><a class="header-anchor" href="#_1-9-1-java语言跨平台的原理" aria-hidden="true">#</a> 1.9.1 Java语言跨平台的原理</h4>\n<ul>\n<li>操作系统本身其实是不认识Java语言的。</li>\n<li>但是针对于不同的操作系统，Java提供了不同的虚拟机。</li>\n</ul>\n<p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。</p>\n<h3 id="_1-10-jre和jdk" tabindex="-1"><a class="header-anchor" href="#_1-10-jre和jdk" aria-hidden="true">#</a> 1.10 JRE和JDK</h3>\n<p>JVM（Java Virtual Machine），Java虚拟机</p>\n<p>JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</p>\n<p>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</p>\n<p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/JAVA/1Java基础.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"1Java基础",filePath:"D:/桌面文件/Blog/blog-demo/docs/JAVA/1Java基础.md",filePathRelative:"JAVA/1Java基础.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/1Java基础.html.vue",componentFilePathRelative:"pages/JAVA/1Java基础.html.vue",componentFileChunkName:"v-3d2f7822",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/1Java基础.html.js",dataFilePathRelative:"pages/JAVA/1Java基础.html.js",dataFileChunkName:"v-3d2f7822",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/JAVA/1Java基础.html",htmlFilePathRelative:"JAVA/1Java基础.html"},{data:{key:"v-7e88feb6",path:"/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",title:"day02 - Java基础语法",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 注释",slug:"_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",children:[]}]}],git:{}},key:"v-7e88feb6",path:"/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",title:"day02 - Java基础语法",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 注释",slug:"_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",children:[]}]}],content:"# day02 - Java基础语法\r\n\r\n## 1. 注释\r\n\r\n​\t注释是对代码的解释和说明文字。\r\n\r\nJava中的注释分为三种：\r\n\r\n* 单行注释：\r\n\r\n~~~java\r\n// 这是单行注释文字\r\n~~~\r\n\r\n* 多行注释：\r\n\r\n~~~java\r\n/*\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n注意：多行注释不能嵌套使用。\r\n~~~\r\n\r\n* 文档注释（暂时用不到）：\r\n\r\n```java\r\n/**\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n```\r\n\r\n### 使用的技巧\r\n\r\n​\t如果我们要对代码进行解释，那么就可以使用注释。\r\n\r\n​\t当注释的内容比较少，一行就写完了，可以用单行注释。\r\n\r\n​\t如果注释的内容比较多，需要写在多行，那么可以使用多行注释。\r\n\r\n### 注意点\r\n\r\n​\t注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。\r\n\r\n​\t所以，不管在注释当中写什么内容，都不会影响代码运行的结果。\r\n\r\n## 2. 关键字\r\n\r\n### 2.1 概念\r\n\r\n​\t被Java赋予了特定含义的英文单词。\r\n\r\n​\t当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。\r\n\r\n注意：关键字很多，不用刻意去记。\r\n\r\n| **abstract**   | **assert**       | **boolean**   | **break**      | **byte**   |\r\n| -------------- | ---------------- | ------------- | -------------- | ---------- |\r\n| **case**       | **catch**        | **char**      | **class**      | **const**  |\r\n| **continue**   | **default**      | **do**        | **double**     | **else**   |\r\n| **enum**       | **extends**      | **final**     | **finally**    | **float**  |\r\n| **for**        | **goto**         | **if**        | **implements** | **import** |\r\n| **instanceof** | **int**          | **interface** | **long**       | **native** |\r\n| **new**        | **package**      | **private**   | **protected**  | **public** |\r\n| **return**     | **strictfp**     | **short**     | **static**     | **super**  |\r\n| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |\r\n| **transient**  | **try**          | **void**      | **volatile**   | **while**  |\r\n\r\n### 2.2 第一个关键字class\r\n\r\n​\t表示定义一个类。创建一个类。\r\n\r\n类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。\r\n\r\nclass后面跟随的就是这个类的名字，简称：类名。\r\n\r\n在类名后面会有一对大括号，表示这个类的内容。\r\n\r\n举例：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    \r\n   \r\n}\r\n```\r\n\r\n解释：class表示定义类。\r\n\r\n​\t类名：HelloWorld\r\n\r\n​\tHelloWorld后面的大括号表示这个类的范围。\r\n\r\n## 3. 字面量\r\n\r\n作用：告诉程序员，数据在程序中的书写格式。\r\n\r\n| **字面量类型** | **说明**                                  | **程序中的写法**           |\r\n| -------------- | ----------------------------------------- | -------------------------- |\r\n| 整数           | 不带小数的数字                            | 666，-88                   |\r\n| 小数           | 带小数的数字                              | 13.14，-5.21               |\r\n| 字符           | 必须使用单引号，有且仅能一个字符          | ‘A’，‘0’，   ‘我’          |\r\n| 字符串         | 必须使用双引号，内容可有可无              | “HelloWorld”，“黑马程序员” |\r\n| 布尔值         | 布尔值，表示真假，只有两个值：true，false | true 、false               |\r\n| 空值           | 一个特殊的值，空值                        | 值是：null                 |\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(10); // 输出一个整数\r\n        System.out.println(5.5); // 输出一个小数\r\n        System.out.println('a'); // 输出一个字符\r\n        System.out.println(true); // 输出boolean值true\r\n        System.out.println(\"欢迎来到黑马程序员\"); // 输出字符串\r\n    }\r\n}\r\n~~~\r\n\r\n### 区分技巧\r\n\r\n1. 不带小数点的数字都是整数类型的字面量。\r\n2. 只要带了小数点，那么就是小数类型的字面量。\r\n3. 只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。\r\n4. 字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。\r\n5. 字符类型的字面量只有两个值，true、false。\r\n6. 空类型的字面量只有一个值，null。\r\n\r\n## 4. 变量\r\n\r\n### 4.1 什么是变量？\r\n\r\n​\t变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。\r\n\r\n### 4.2 变量的定义格式\r\n\r\n​\t数据类型 变量名 = 数据值；\r\n\r\n#### 4.2.1 格式详解\r\n\r\n​\t数据类型：限定了变量当中能存储什么类型的数据。\r\n\r\n​\t\t\t   如果要存10，那么数据类型就需要写整数类型。\r\n\r\n​\t\t\t   如果要存10.0，那么数据类型就需要写小数类型。\r\n\r\n​\t变量名：其实就是这个容器的名字。\r\n\r\n​\t\t\t当以后想要使用变量里面的数据时，直接使用变量名就可以了。\r\n\r\n​\t数据值：真正存储在容器中的数据。\r\n\r\n​\t分号：表示语句的结束，就跟以前写作文时候的句号是一样的。\r\n\r\n#### 4.2.2 常用的数据类型\r\n\r\n​\t整数：int\r\n\r\n​\t小数：（浮点数）double\r\n\r\n​\t其他数据类型稍后讲解\r\n\r\n举例：\r\n\r\n```java\r\npublic class VariableDemo{\r\n\tpublic static void main(String[] args){\r\n\t\t//定义一个整数类型的变量\r\n\t\t//数据类型 变量名 = 数据值;\r\n\t\tint a = 16;\r\n\t\tSystem.out.println(a);//16\r\n\t\t\r\n\t\t//定义一个小数类型的变量\r\n\t\tdouble b = 10.1;\r\n\t\tSystem.out.println(b);//10.1\r\n\t}\r\n}\r\n```\r\n\r\n#### 4.2.3 变量的注意事项\r\n\r\n- 变量名不能重复\r\n- 在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。\r\n- 变量在使用之前必须要赋值。\r\n\r\n案例：\r\n\r\n```java\r\npublic class VariableDemo2{\r\n\tpublic static void main(String[] args){\r\n\t\t//1.变量名不允许重复\r\n\t\t//int a = 10;\r\n\t\t//int a = 20;\r\n\t\t//System.out.println(a);\r\n\t\t\r\n\t\t//2.一条语句可以定义多个变量\r\n\t\t//了解。\r\n\t\t//int a = 10, b = 20, c = 20,d = 20;\r\n\t\t//System.out.println(a);//?\r\n\t\t//System.out.println(b);//?\r\n\t\t\r\n\t\t\r\n\t\t//3.变量在使用之前必须要赋值\r\n\t\tint a = 30;\r\n\t\tSystem.out.println(a);\r\n\t}\r\n}\r\n```\r\n\r\n## 5. 数据类型\r\n\r\n### 5.1 Java语言数据类型的分类\r\n\r\n- 基本数据类型\r\n- 引用数据类型（面向对象的时候再深入学习）\r\n\r\n### 5.2 基本数据类型的四类八种\r\n\r\n| 数据类型 | 关键字  | 内存占用 |                 取值范围                  |\r\n| :------: | :-----: | :------: | :---------------------------------------: |\r\n|   整数   |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |\r\n|          |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |\r\n|          |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |\r\n|          |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |\r\n|  浮点数  |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |\r\n|          | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |\r\n|   字符   |  char   |    2     |                  0-65535                  |\r\n|   布尔   | boolean |    1     |                true，false                |\r\n\r\n#### 说明\r\n\r\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\r\n\r\n​\t在java中整数默认是int类型，浮点数默认是double类型。\r\n\r\n#### 需要记忆以下几点\r\n\r\nbyte类型的取值范围：\r\n\r\n​\t-128 ~ 127\r\n\r\nint类型的大概取值范围：\r\n\r\n​\t-21亿多  ~ 21亿多\r\n\r\n整数类型和小数类型的取值范围大小关系：\r\n\r\n​\tdouble > float > long > int > short > byte\r\n\r\n最为常用的数据类型选择：\r\n\r\n- 在定义变量的时候，要根据实际的情况来选择不同类型的变量。\r\n\r\n  比如：人的年龄，可以选择byte类型。\r\n\r\n  比如：地球的年龄，可以选择long类型。\r\n\r\n- 如果整数类型中，不太确定范围，那么默认使用int类型。\r\n\r\n- 如果小数类型中，不太确定范围，那么默认使用double类型。\r\n\r\n- 如果要定义字符类型的变量，那么使用char\r\n\r\n- 如果要定义布尔类型的变量，那么使用boolean\r\n\r\n### 5.3 定义8种基本数据类型变量\r\n\r\n```java\r\npublic class VariableDemo3{\r\n    public static void main(String[] args){\r\n        //1.定义byte类型的变量\r\n        //数据类型 变量名 = 数据值;\r\n        byte a = 10;\r\n        System.out.println(a);\r\n\r\n        //2.定义short类型的变量\r\n        short b = 20;\r\n        System.out.println(b);\r\n\r\n        //3.定义int类型的变量\r\n        int c = 30;\r\n        System.out.println(c);\r\n\r\n        //4.定义long类型的变量\r\n        long d = 123456789123456789L;\r\n        System.out.println(d);\r\n\r\n        //5.定义float类型的变量\r\n        float e = 10.1F;\r\n        System.out.println(e);\r\n\r\n        //6.定义double类型的变量\r\n        double f = 20.3;\r\n        System.out.println(f);\r\n\r\n        //7.定义char类型的变量\r\n        char g = 'a';\r\n        System.out.println(g);\r\n\r\n        //8.定义boolean类型的变量\r\n        boolean h = true;\r\n        System.out.println(h);\r\n\r\n    }\r\n}\r\n```\r\n\r\n#### **注意点**\r\n\r\n- 如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。\r\n- 如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。\r\n- 如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）\r\n- 如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）\r\n\r\n## 6. 标识符\r\n\r\n### 6.1 硬性要求：\r\n\r\n​\t必须要这么做，否则代码会报错。\r\n\r\n- 必须由数字、字母、下划线_、美元符号$组成。\r\n- 数字不能开头\r\n- 不能是关键字\r\n- 区分大小写的。\r\n\r\n### 6.2 软件建议：\r\n\r\n​\t如果不这么做，代码不会报错，但是会让代码显得比较low。\r\n\r\n### 6.2.1 小驼峰命名法\r\n\r\n适用于变量名和方法名\r\n\r\n* 如果是一个单词，那么全部小写，比如：name\r\n\r\n* 如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge\r\n\r\n### 6.2.2 大驼峰命名法\r\n\r\n适用于类名\r\n\r\n* 如果是一个单词，那么首字母大写。比如：Demo、Test。\r\n\r\n* 如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld\r\n\r\n不管起什么名字，都要做到见名知意。\r\n\r\n### 阿里巴巴命名规范细节：\r\n\r\n1. 尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。\r\n\r\n   正确：alibaba、hangzhou、nanjing\r\n\r\n   错误：jiage、dazhe\r\n\r\n2. 平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。\r\n\r\n   错误：_name\r\n\r\n   正确：name\r\n\r\n## 7. 键盘录入\r\n\r\n​\t键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。\r\n\r\n使用步骤：\r\n\r\n第一步：\r\n\r\n​\t导包：其实就是表示先找到Scanner这个类在哪。\r\n\r\n第二步：\r\n\r\n​\t创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。\r\n\r\n第三步：\r\n\r\n​\t接收数据：也是真正干活的代码。\r\n\r\n代码示例：\r\n\r\n```java\r\n//导包，其实就是先找到Scanner这个类在哪\r\nimport java.util.Scanner;\r\npublic class ScannerDemo1{\r\n\tpublic static void main(String[] args){\r\n\t\t//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t//3.接收数据\r\n\t\t//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了\r\n\t\tSystem.out.println(\"请输入一个数字\");\r\n\t\tint i = sc.nextInt();\r\n\t\tSystem.out.println(i);\r\n\t}\r\n}\r\n```\r\n\r\n## 8. IDEA\r\n\r\n### 8.1 IDEA概述\r\n\r\n​\tIDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。\r\n\r\n**集成环境：**\r\n\r\n​\t把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。\r\n\r\n### 8.2 IDEA的下载和安装\r\n\r\n#### 8.2.1 下载\r\n\r\n​\t可以到官方网站自行下载，网址为：https://www.jetbrains.com/idea\r\n\r\n​\t今天的资料中，对应的安装包也提高给大家了。\r\n",contentRendered:'<h1 id="day02-java基础语法" tabindex="-1"><a class="header-anchor" href="#day02-java基础语法" aria-hidden="true">#</a> day02 - Java基础语法</h1>\n<h2 id="_1-注释" tabindex="-1"><a class="header-anchor" href="#_1-注释" aria-hidden="true">#</a> 1. 注释</h2>\n<p>​\t注释是对代码的解释和说明文字。</p>\n<p>Java中的注释分为三种：</p>\n<ul>\n<li>单行注释：</li>\n</ul>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token comment">// 这是单行注释文字</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>多行注释：</li>\n</ul>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token comment">/*\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/</span>\n注意：多行注释不能嵌套使用。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul>\n<li>文档注释（暂时用不到）：</li>\n</ul>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token doc-comment comment">/**\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="使用的技巧" tabindex="-1"><a class="header-anchor" href="#使用的技巧" aria-hidden="true">#</a> 使用的技巧</h3>\n<p>​\t如果我们要对代码进行解释，那么就可以使用注释。</p>\n<p>​\t当注释的内容比较少，一行就写完了，可以用单行注释。</p>\n<p>​\t如果注释的内容比较多，需要写在多行，那么可以使用多行注释。</p>\n<h3 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h3>\n<p>​\t注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。</p>\n<p>​\t所以，不管在注释当中写什么内容，都不会影响代码运行的结果。</p>\n<h2 id="_2-关键字" tabindex="-1"><a class="header-anchor" href="#_2-关键字" aria-hidden="true">#</a> 2. 关键字</h2>\n<h3 id="_2-1-概念" tabindex="-1"><a class="header-anchor" href="#_2-1-概念" aria-hidden="true">#</a> 2.1 概念</h3>\n<p>​\t被Java赋予了特定含义的英文单词。</p>\n<p>​\t当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。</p>\n<p>注意：关键字很多，不用刻意去记。</p>\n<table>\n<thead>\n<tr>\n<th><strong>abstract</strong></th>\n<th><strong>assert</strong></th>\n<th><strong>boolean</strong></th>\n<th><strong>break</strong></th>\n<th><strong>byte</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>case</strong></td>\n<td><strong>catch</strong></td>\n<td><strong>char</strong></td>\n<td><strong>class</strong></td>\n<td><strong>const</strong></td>\n</tr>\n<tr>\n<td><strong>continue</strong></td>\n<td><strong>default</strong></td>\n<td><strong>do</strong></td>\n<td><strong>double</strong></td>\n<td><strong>else</strong></td>\n</tr>\n<tr>\n<td><strong>enum</strong></td>\n<td><strong>extends</strong></td>\n<td><strong>final</strong></td>\n<td><strong>finally</strong></td>\n<td><strong>float</strong></td>\n</tr>\n<tr>\n<td><strong>for</strong></td>\n<td><strong>goto</strong></td>\n<td><strong>if</strong></td>\n<td><strong>implements</strong></td>\n<td><strong>import</strong></td>\n</tr>\n<tr>\n<td><strong>instanceof</strong></td>\n<td><strong>int</strong></td>\n<td><strong>interface</strong></td>\n<td><strong>long</strong></td>\n<td><strong>native</strong></td>\n</tr>\n<tr>\n<td><strong>new</strong></td>\n<td><strong>package</strong></td>\n<td><strong>private</strong></td>\n<td><strong>protected</strong></td>\n<td><strong>public</strong></td>\n</tr>\n<tr>\n<td><strong>return</strong></td>\n<td><strong>strictfp</strong></td>\n<td><strong>short</strong></td>\n<td><strong>static</strong></td>\n<td><strong>super</strong></td>\n</tr>\n<tr>\n<td><strong>switch</strong></td>\n<td><strong>synchronized</strong></td>\n<td><strong>this</strong></td>\n<td><strong>throw</strong></td>\n<td><strong>throws</strong></td>\n</tr>\n<tr>\n<td><strong>transient</strong></td>\n<td><strong>try</strong></td>\n<td><strong>void</strong></td>\n<td><strong>volatile</strong></td>\n<td><strong>while</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id="_2-2-第一个关键字class" tabindex="-1"><a class="header-anchor" href="#_2-2-第一个关键字class" aria-hidden="true">#</a> 2.2 第一个关键字class</h3>\n<p>​\t表示定义一个类。创建一个类。</p>\n<p>类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。</p>\n<p>class后面跟随的就是这个类的名字，简称：类名。</p>\n<p>在类名后面会有一对大括号，表示这个类的内容。</p>\n<p>举例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    \n   \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>解释：class表示定义类。</p>\n<p>​\t类名：HelloWorld</p>\n<p>​\tHelloWorld后面的大括号表示这个类的范围。</p>\n<h2 id="_3-字面量" tabindex="-1"><a class="header-anchor" href="#_3-字面量" aria-hidden="true">#</a> 3. 字面量</h2>\n<p>作用：告诉程序员，数据在程序中的书写格式。</p>\n<table>\n<thead>\n<tr>\n<th><strong>字面量类型</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>程序中的写法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>整数</td>\n<td>不带小数的数字</td>\n<td>666，-88</td>\n</tr>\n<tr>\n<td>小数</td>\n<td>带小数的数字</td>\n<td>13.14，-5.21</td>\n</tr>\n<tr>\n<td>字符</td>\n<td>必须使用单引号，有且仅能一个字符</td>\n<td>‘A’，‘0’，   ‘我’</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>必须使用双引号，内容可有可无</td>\n<td>“HelloWorld”，“黑马程序员”</td>\n</tr>\n<tr>\n<td>布尔值</td>\n<td>布尔值，表示真假，只有两个值：true，false</td>\n<td>true 、false</td>\n</tr>\n<tr>\n<td>空值</td>\n<td>一个特殊的值，空值</td>\n<td>值是：null</td>\n</tr>\n</tbody>\n</table>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出一个整数</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出一个小数</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token char">\'a\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出一个字符</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出boolean值true</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"欢迎来到黑马程序员"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出字符串</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="区分技巧" tabindex="-1"><a class="header-anchor" href="#区分技巧" aria-hidden="true">#</a> 区分技巧</h3>\n<ol>\n<li>不带小数点的数字都是整数类型的字面量。</li>\n<li>只要带了小数点，那么就是小数类型的字面量。</li>\n<li>只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。</li>\n<li>字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。</li>\n<li>字符类型的字面量只有两个值，true、false。</li>\n<li>空类型的字面量只有一个值，null。</li>\n</ol>\n<h2 id="_4-变量" tabindex="-1"><a class="header-anchor" href="#_4-变量" aria-hidden="true">#</a> 4. 变量</h2>\n<h3 id="_4-1-什么是变量" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是变量" aria-hidden="true">#</a> 4.1 什么是变量？</h3>\n<p>​\t变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。</p>\n<h3 id="_4-2-变量的定义格式" tabindex="-1"><a class="header-anchor" href="#_4-2-变量的定义格式" aria-hidden="true">#</a> 4.2 变量的定义格式</h3>\n<p>​\t数据类型 变量名 = 数据值；</p>\n<h4 id="_4-2-1-格式详解" tabindex="-1"><a class="header-anchor" href="#_4-2-1-格式详解" aria-hidden="true">#</a> 4.2.1 格式详解</h4>\n<p>​\t数据类型：限定了变量当中能存储什么类型的数据。</p>\n<p>​\t\t\t   如果要存10，那么数据类型就需要写整数类型。</p>\n<p>​\t\t\t   如果要存10.0，那么数据类型就需要写小数类型。</p>\n<p>​\t变量名：其实就是这个容器的名字。</p>\n<p>​\t\t\t当以后想要使用变量里面的数据时，直接使用变量名就可以了。</p>\n<p>​\t数据值：真正存储在容器中的数据。</p>\n<p>​\t分号：表示语句的结束，就跟以前写作文时候的句号是一样的。</p>\n<h4 id="_4-2-2-常用的数据类型" tabindex="-1"><a class="header-anchor" href="#_4-2-2-常用的数据类型" aria-hidden="true">#</a> 4.2.2 常用的数据类型</h4>\n<p>​\t整数：int</p>\n<p>​\t小数：（浮点数）double</p>\n<p>​\t其他数据类型稍后讲解</p>\n<p>举例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableDemo</span><span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token comment">//定义一个整数类型的变量</span>\n\t\t<span class="token comment">//数据类型 变量名 = 数据值;</span>\n\t\t<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//16</span>\n\t\t\n\t\t<span class="token comment">//定义一个小数类型的变量</span>\n\t\t<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">10.1</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10.1</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_4-2-3-变量的注意事项" tabindex="-1"><a class="header-anchor" href="#_4-2-3-变量的注意事项" aria-hidden="true">#</a> 4.2.3 变量的注意事项</h4>\n<ul>\n<li>变量名不能重复</li>\n<li>在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。</li>\n<li>变量在使用之前必须要赋值。</li>\n</ul>\n<p>案例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableDemo2</span><span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token comment">//1.变量名不允许重复</span>\n\t\t<span class="token comment">//int a = 10;</span>\n\t\t<span class="token comment">//int a = 20;</span>\n\t\t<span class="token comment">//System.out.println(a);</span>\n\t\t\n\t\t<span class="token comment">//2.一条语句可以定义多个变量</span>\n\t\t<span class="token comment">//了解。</span>\n\t\t<span class="token comment">//int a = 10, b = 20, c = 20,d = 20;</span>\n\t\t<span class="token comment">//System.out.println(a);//?</span>\n\t\t<span class="token comment">//System.out.println(b);//?</span>\n\t\t\n\t\t\n\t\t<span class="token comment">//3.变量在使用之前必须要赋值</span>\n\t\t<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_5-数据类型" tabindex="-1"><a class="header-anchor" href="#_5-数据类型" aria-hidden="true">#</a> 5. 数据类型</h2>\n<h3 id="_5-1-java语言数据类型的分类" tabindex="-1"><a class="header-anchor" href="#_5-1-java语言数据类型的分类" aria-hidden="true">#</a> 5.1 Java语言数据类型的分类</h3>\n<ul>\n<li>基本数据类型</li>\n<li>引用数据类型（面向对象的时候再深入学习）</li>\n</ul>\n<h3 id="_5-2-基本数据类型的四类八种" tabindex="-1"><a class="header-anchor" href="#_5-2-基本数据类型的四类八种" aria-hidden="true">#</a> 5.2 基本数据类型的四类八种</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">数据类型</th>\n<th style="text-align:center">关键字</th>\n<th style="text-align:center">内存占用</th>\n<th style="text-align:center">取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">整数</td>\n<td style="text-align:center">byte</td>\n<td style="text-align:center">1</td>\n<td style="text-align:center">负的2的7次方 ~ 2的7次方-1(-128~127)</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">short</td>\n<td style="text-align:center">2</td>\n<td style="text-align:center">负的2的15次方 ~ 2的15次方-1(-32768~32767)</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">int</td>\n<td style="text-align:center">4</td>\n<td style="text-align:center">负的2的31次方 ~ 2的31次方-1</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">long</td>\n<td style="text-align:center">8</td>\n<td style="text-align:center">负的2的63次方 ~ 2的63次方-1</td>\n</tr>\n<tr>\n<td style="text-align:center">浮点数</td>\n<td style="text-align:center">float</td>\n<td style="text-align:center">4</td>\n<td style="text-align:center">1.401298e-45 ~ 3.402823e+38</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">double</td>\n<td style="text-align:center">8</td>\n<td style="text-align:center">4.9000000e-324 ~ 1.797693e+308</td>\n</tr>\n<tr>\n<td style="text-align:center">字符</td>\n<td style="text-align:center">char</td>\n<td style="text-align:center">2</td>\n<td style="text-align:center">0-65535</td>\n</tr>\n<tr>\n<td style="text-align:center">布尔</td>\n<td style="text-align:center">boolean</td>\n<td style="text-align:center">1</td>\n<td style="text-align:center">true，false</td>\n</tr>\n</tbody>\n</table>\n<h4 id="说明" tabindex="-1"><a class="header-anchor" href="#说明" aria-hidden="true">#</a> 说明</h4>\n<p>​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。</p>\n<p>​\t在java中整数默认是int类型，浮点数默认是double类型。</p>\n<h4 id="需要记忆以下几点" tabindex="-1"><a class="header-anchor" href="#需要记忆以下几点" aria-hidden="true">#</a> 需要记忆以下几点</h4>\n<p>byte类型的取值范围：</p>\n<p>​\t-128 ~ 127</p>\n<p>int类型的大概取值范围：</p>\n<p>​\t-21亿多  ~ 21亿多</p>\n<p>整数类型和小数类型的取值范围大小关系：</p>\n<p>​\tdouble &gt; float &gt; long &gt; int &gt; short &gt; byte</p>\n<p>最为常用的数据类型选择：</p>\n<ul>\n<li>\n<p>在定义变量的时候，要根据实际的情况来选择不同类型的变量。</p>\n<p>比如：人的年龄，可以选择byte类型。</p>\n<p>比如：地球的年龄，可以选择long类型。</p>\n</li>\n<li>\n<p>如果整数类型中，不太确定范围，那么默认使用int类型。</p>\n</li>\n<li>\n<p>如果小数类型中，不太确定范围，那么默认使用double类型。</p>\n</li>\n<li>\n<p>如果要定义字符类型的变量，那么使用char</p>\n</li>\n<li>\n<p>如果要定义布尔类型的变量，那么使用boolean</p>\n</li>\n</ul>\n<h3 id="_5-3-定义8种基本数据类型变量" tabindex="-1"><a class="header-anchor" href="#_5-3-定义8种基本数据类型变量" aria-hidden="true">#</a> 5.3 定义8种基本数据类型变量</h3>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableDemo3</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token comment">//1.定义byte类型的变量</span>\n        <span class="token comment">//数据类型 变量名 = 数据值;</span>\n        <span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//2.定义short类型的变量</span>\n        <span class="token keyword">short</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//3.定义int类型的变量</span>\n        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//4.定义long类型的变量</span>\n        <span class="token keyword">long</span> d <span class="token operator">=</span> <span class="token number">123456789123456789L</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//5.定义float类型的变量</span>\n        <span class="token keyword">float</span> e <span class="token operator">=</span> <span class="token number">10.1F</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//6.定义double类型的变量</span>\n        <span class="token keyword">double</span> f <span class="token operator">=</span> <span class="token number">20.3</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//7.定义char类型的变量</span>\n        <span class="token keyword">char</span> g <span class="token operator">=</span> <span class="token char">\'a\'</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//8.定义boolean类型的变量</span>\n        <span class="token keyword">boolean</span> h <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h4 id="注意点-1" tabindex="-1"><a class="header-anchor" href="#注意点-1" aria-hidden="true">#</a> <strong>注意点</strong></h4>\n<ul>\n<li>如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。</li>\n<li>如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。</li>\n<li>如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）</li>\n<li>如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）</li>\n</ul>\n<h2 id="_6-标识符" tabindex="-1"><a class="header-anchor" href="#_6-标识符" aria-hidden="true">#</a> 6. 标识符</h2>\n<h3 id="_6-1-硬性要求" tabindex="-1"><a class="header-anchor" href="#_6-1-硬性要求" aria-hidden="true">#</a> 6.1 硬性要求：</h3>\n<p>​\t必须要这么做，否则代码会报错。</p>\n<ul>\n<li>必须由数字、字母、下划线_、美元符号$组成。</li>\n<li>数字不能开头</li>\n<li>不能是关键字</li>\n<li>区分大小写的。</li>\n</ul>\n<h3 id="_6-2-软件建议" tabindex="-1"><a class="header-anchor" href="#_6-2-软件建议" aria-hidden="true">#</a> 6.2 软件建议：</h3>\n<p>​\t如果不这么做，代码不会报错，但是会让代码显得比较low。</p>\n<h3 id="_6-2-1-小驼峰命名法" tabindex="-1"><a class="header-anchor" href="#_6-2-1-小驼峰命名法" aria-hidden="true">#</a> 6.2.1 小驼峰命名法</h3>\n<p>适用于变量名和方法名</p>\n<ul>\n<li>\n<p>如果是一个单词，那么全部小写，比如：name</p>\n</li>\n<li>\n<p>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</p>\n</li>\n</ul>\n<h3 id="_6-2-2-大驼峰命名法" tabindex="-1"><a class="header-anchor" href="#_6-2-2-大驼峰命名法" aria-hidden="true">#</a> 6.2.2 大驼峰命名法</h3>\n<p>适用于类名</p>\n<ul>\n<li>\n<p>如果是一个单词，那么首字母大写。比如：Demo、Test。</p>\n</li>\n<li>\n<p>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</p>\n</li>\n</ul>\n<p>不管起什么名字，都要做到见名知意。</p>\n<h3 id="阿里巴巴命名规范细节" tabindex="-1"><a class="header-anchor" href="#阿里巴巴命名规范细节" aria-hidden="true">#</a> 阿里巴巴命名规范细节：</h3>\n<ol>\n<li>\n<p>尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。</p>\n<p>正确：alibaba、hangzhou、nanjing</p>\n<p>错误：jiage、dazhe</p>\n</li>\n<li>\n<p>平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。</p>\n<p>错误：_name</p>\n<p>正确：name</p>\n</li>\n</ol>\n<h2 id="_7-键盘录入" tabindex="-1"><a class="header-anchor" href="#_7-键盘录入" aria-hidden="true">#</a> 7. 键盘录入</h2>\n<p>​\t键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。</p>\n<p>使用步骤：</p>\n<p>第一步：</p>\n<p>​\t导包：其实就是表示先找到Scanner这个类在哪。</p>\n<p>第二步：</p>\n<p>​\t创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。</p>\n<p>第三步：</p>\n<p>​\t接收数据：也是真正干活的代码。</p>\n<p>代码示例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token comment">//导包，其实就是先找到Scanner这个类在哪</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token punctuation">;</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerDemo1</span><span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token comment">//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。</span>\n\t\t<span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token comment">//3.接收数据</span>\n\t\t<span class="token comment">//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入一个数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token keyword">int</span> i <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_8-idea" tabindex="-1"><a class="header-anchor" href="#_8-idea" aria-hidden="true">#</a> 8. IDEA</h2>\n<h3 id="_8-1-idea概述" tabindex="-1"><a class="header-anchor" href="#_8-1-idea概述" aria-hidden="true">#</a> 8.1 IDEA概述</h3>\n<p>​\tIDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。</p>\n<p><strong>集成环境：</strong></p>\n<p>​\t把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。</p>\n<h3 id="_8-2-idea的下载和安装" tabindex="-1"><a class="header-anchor" href="#_8-2-idea的下载和安装" aria-hidden="true">#</a> 8.2 IDEA的下载和安装</h3>\n<h4 id="_8-2-1-下载" tabindex="-1"><a class="header-anchor" href="#_8-2-1-下载" aria-hidden="true">#</a> 8.2.1 下载</h4>\n<p>​\t可以到官方网站自行下载，网址为：https://www.jetbrains.com/idea</p>\n<p>​\t今天的资料中，对应的安装包也提高给大家了。</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/JAVA/2Java基础语法.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"2Java基础语法",filePath:"D:/桌面文件/Blog/blog-demo/docs/JAVA/2Java基础语法.md",filePathRelative:"JAVA/2Java基础语法.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/2Java基础语法.html.vue",componentFilePathRelative:"pages/JAVA/2Java基础语法.html.vue",componentFileChunkName:"v-7e88feb6",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/2Java基础语法.html.js",dataFilePathRelative:"pages/JAVA/2Java基础语法.html.js",dataFileChunkName:"v-7e88feb6",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/JAVA/2Java基础语法.html",htmlFilePathRelative:"JAVA/2Java基础语法.html"},{data:{key:"v-c11452c2",path:"/Vue/vuex%E5%85%A5%E9%97%A8.html",title:"vuex 概述",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"回顾-组件之间共享状态 (组件通信方案)",slug:"回顾-组件之间共享状态-组件通信方案",children:[]},{level:2,title:"vuex基本概念",slug:"vuex基本概念",children:[]},{level:2,title:"vuex的优点: 方便的解决多组件的共享状态",slug:"vuex的优点-方便的解决多组件的共享状态",children:[]},{level:2,title:"什么数据适合存到vuex中",slug:"什么数据适合存到vuex中",children:[]},{level:2,title:"概述小结:",slug:"概述小结",children:[]},{level:2,title:"需求: 多组件共享数据",slug:"需求-多组件共享数据",children:[]},{level:2,title:"vuex 的使用 - 创建仓库",slug:"vuex-的使用-创建仓库",children:[]},{level:2,title:"核心概念 - state 状态",slug:"核心概念-state-状态",children:[]},{level:2,title:"核心概念 - mutations",slug:"核心概念-mutations",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"带参数的 mutation",slug:"带参数的-mutation",children:[]},{level:3,title:"辅助函数 - mapMutations",slug:"辅助函数-mapmutations",children:[]}]},{level:2,title:"核心概念-actions",slug:"核心概念-actions",children:[]},{level:2,title:"核心概念-getters",slug:"核心概念-getters",children:[]},{level:2,title:"核心概念 - 模块 module (进阶拓展)",slug:"核心概念-模块-module-进阶拓展",children:[{level:3,title:"模块定义 - 准备 state",slug:"模块定义-准备-state",children:[]},{level:3,title:"命名空间 namespaced",slug:"命名空间-namespaced",children:[]}]}],git:{}},key:"v-c11452c2",path:"/Vue/vuex%E5%85%A5%E9%97%A8.html",title:"vuex 概述",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"回顾-组件之间共享状态 (组件通信方案)",slug:"回顾-组件之间共享状态-组件通信方案",children:[]},{level:2,title:"vuex基本概念",slug:"vuex基本概念",children:[]},{level:2,title:"vuex的优点: 方便的解决多组件的共享状态",slug:"vuex的优点-方便的解决多组件的共享状态",children:[]},{level:2,title:"什么数据适合存到vuex中",slug:"什么数据适合存到vuex中",children:[]},{level:2,title:"概述小结:",slug:"概述小结",children:[]},{level:2,title:"需求: 多组件共享数据",slug:"需求-多组件共享数据",children:[]},{level:2,title:"vuex 的使用 - 创建仓库",slug:"vuex-的使用-创建仓库",children:[]},{level:2,title:"核心概念 - state 状态",slug:"核心概念-state-状态",children:[]},{level:2,title:"核心概念 - mutations",slug:"核心概念-mutations",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"带参数的 mutation",slug:"带参数的-mutation",children:[]},{level:3,title:"辅助函数 - mapMutations",slug:"辅助函数-mapmutations",children:[]}]},{level:2,title:"核心概念-actions",slug:"核心概念-actions",children:[]},{level:2,title:"核心概念-getters",slug:"核心概念-getters",children:[]},{level:2,title:"核心概念 - 模块 module (进阶拓展)",slug:"核心概念-模块-module-进阶拓展",children:[{level:3,title:"模块定义 - 准备 state",slug:"模块定义-准备-state",children:[]},{level:3,title:"命名空间 namespaced",slug:"命名空间-namespaced",children:[]}]}],content:"# vuex 概述 \r\n\r\n目标：\r\n\r\n- 了解vuex的应用场景  (在哪用)\r\n- 掌握vuex的基本使用  (怎么用)\r\n\r\n**vuex 是一个 vue 的状态管理工具,  状态就是数据**\r\n\r\n\r\n\r\nvuex是一个插件工具，可以帮我们vue管理通用的数据\r\n\r\n之前如果要进行跨组件的数据通信  =>  父传子，子传父  =>  一旦组件关系复杂，数据非常难以维护\r\n\r\n\r\n\r\n## 回顾-组件之间共享状态 (组件通信方案)\r\n\r\n默认组件的数据, 是独立的, 每个组件有着自己的状态(数据)\r\n\r\n>  状态 === 数据\r\n\r\n组件之间共享状态的两种典型方式：\r\n\r\n- 父子之间 : props + $emit\r\n\r\n  父传子：props属性绑定\r\n\r\n  ```\r\n  <son1 msg=\"msg\"></son1>\r\n  ```\r\n\r\n  子传父：$emit事件绑定\r\n\r\n  ```\r\n  <div>\r\n  \t<button @click=\"$emit('event-name')\">通知父组件</button>\r\n  </div>\r\n  ```\r\n\r\n如果某个状态需要在很多个组件来使用，或者要实现多个组件共同维护一份数据又应该怎么做呢 ？\r\n\r\n这里就要引入Vuex了。\r\n\r\n\r\n\r\n## vuex基本概念\r\n\r\n[中文文档](https://vuex.vuejs.org/zh/guide/)\r\n\r\nvuex是vue的状态管理工具，**状态即数据**。 状态管理就是集中管理vue中 **通用的** 一些数据\r\n\r\n注意（官方原文）：\r\n\r\n- 不是所有的场景都适用于vuex，只有在必要的时候才使用vuex\r\n- 使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）\r\n\r\nVuex就像《近视眼镜》, 你自然会知道什么时候需要用它~\r\n\r\n\r\n\r\n## vuex的优点: 方便的解决多组件的共享状态\r\n\r\n vuex的作用是解决《多组件状态共享》的问题。\r\n\r\n- 它是独立于组件而单独存在的，所有的组件都可以把它当作  **一座桥梁** 来进行通讯。\r\n\r\n- 特点：\r\n\r\n  - **响应式**： 只要仓库一变化，其他所有地方都更新 （太爽了！！！）\r\n  - 操作更简洁\r\n\r\n  代码量非常少, 但是需要熟悉\r\n\r\n## 什么数据适合存到vuex中\r\n\r\n一般情况下，只有  **多个组件均需要共享的数据** ，才有必要存储在vuex中，\r\n\r\n对于某个组件中的私有数据，依旧存储在组件自身的data中。\r\n\r\n例如：\r\n\r\n- 对于所有组件而言，当前登陆的   **用户信息**  是需要在全体组件之间共享的，则它可以放在vuex中\r\n- 对于文章详情页组件来说，当前的用户浏览的文章列表数据则应该属于这个组件的私有数据，应该要放在这个组件data中。\r\n\r\n\r\n\r\n## 概述小结:\r\n\r\n1. vuex解决什么问题?   vuex 能解决  **多组件共享数据**  的问题,  非常方便便捷\r\n2. 什么样的数据, 适合存放到vuex?   多组件的  **通用**  的共用数据, 适合存到 vuex\r\n\r\nvuex 两大优势:\r\n\r\n1. 响应式变化\r\n2. 操作简洁  (vuex提供了一些简化语法的辅助函数, 这些辅助函数, 需要熟练掌握)\r\n\r\n\r\n\r\n# vuex入门\r\n\r\n## 需求: 多组件共享数据\r\n\r\n对于如下三个组件（一个父组件，两个子组件）\r\n\r\n效果是三个组件共享一份数据:\r\n\r\n- 任意一个组件都可以修改数据\r\n- 三个组件的数据是同步的\r\n\r\n1 创建项目\r\n\r\n```\r\nvue create vuex-demo\r\n```\r\n\r\n2 创建三个组件, 目录如下\r\n\r\n```\r\n|-components\r\n|--add-item.vue\r\n|--sub-item.vue\r\n|-App.vue\r\n```\r\n\r\n3 源代码如下\r\n\r\n`App.vue`在入口组件中引入add-item和sub-item这两个子组件\r\n\r\n```html\r\n<template>\r\n  <div id=\"app\">\r\n    <h1>根组件</h1>\r\n    <input type=\"text\">\r\n    <add-item></add-item>\r\n    <hr>\r\n    <sub-item></sub-item>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport AddItem from './components/add-item.vue'\r\nimport SubItem from './components/sub-item.vue'\r\n\r\nexport default {\r\n  name: 'app',\r\n  data: function () {\r\n    return {\r\n      \r\n    }\r\n  },\r\n  components: {\r\n    AddItem,\r\n    SubItem\r\n  }\r\n}\r\n<\/script>\r\n\r\n<style>\r\n#app {\r\n  width: 600px;\r\n  margin: 20px auto;\r\n  border: 3px solid #ccc;\r\n  border-radius: 3px;\r\n  padding: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n`main.js`\r\n\r\n```js\r\nimport Vue from 'vue'\r\nimport App from './App.vue'\r\n\r\nVue.config.productionTip = false\r\n\r\nnew Vue({\r\n  render: h => h(App)\r\n}).$mount('#app')\r\n```\r\n\r\n`sub-item.vue`\r\n\r\n```html\r\n<template>\r\n  <div class=\"box\">\r\n    <h2>子组件 sub</h2>\r\n    从vuex中获取的值: <label></label>\r\n    <br>\r\n    <button>值-1</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'SubItem'\r\n}\r\n<\/script>\r\n\r\n<style lang=\"css\" scoped>\r\n.box{\r\n  border: 3px solid #ccc;\r\n  width: 400px;\r\n  padding: 10px;\r\n  margin: 20px;\r\n}\r\nh2 {\r\n  margin-top: 10px;\r\n}\r\n</style>\r\n\r\n```\r\n\r\n`add-item.vue`\r\n\r\n```html\r\n<template>\r\n  <div class=\"box\">\r\n    <h2>子组件 add</h2>\r\n    从vuex中获取的值:<label></label>\r\n    <br />\r\n    <button>值+1</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'AddItem'\r\n}\r\n<\/script>\r\n\r\n<style lang=\"css\" scoped>\r\n.box {\r\n  border: 3px solid #ccc;\r\n  width: 400px;\r\n  padding: 10px;\r\n  margin: 20px;\r\n}\r\nh2 {\r\n  margin-top: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n\r\n## vuex 的使用 - 创建仓库\r\n\r\n1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。\r\n\r\n```\r\nyarn add vuex@3.4.0\r\n```\r\n\r\n2 新建 `store/index.js` 专门存放 vuex\r\n\r\n​\t为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 `router/index.js` 类似)\r\n\r\n​\t![image-20201029064100611](images/image-20201029064100611.png)\r\n\r\n3 创建仓库 `store/index.js` \r\n\r\n```jsx\r\n// 导入 vue\r\nimport Vue from 'vue'\r\n// 导入 vuex\r\nimport Vuex from 'vuex'\r\n// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化\r\nVue.use(Vuex)\r\n\r\n// 创建仓库 store\r\nconst store = new Vuex.Store()\r\n\r\n// 导出仓库\r\nexport default store\r\n```\r\n\r\n4 在 main.js 中导入挂载到 Vue 实例上\r\n\r\n```js\r\nimport Vue from 'vue'\r\nimport App from './App.vue'\r\nimport store from './store'\r\n\r\nVue.config.productionTip = false\r\n\r\nnew Vue({\r\n  render: h => h(App),\r\n  store\r\n}).$mount('#app')\r\n```\r\n\r\n此刻起, 就成功创建了一个 **空仓库!!**\r\n\r\n\r\n\r\n## 核心概念 - state 状态\r\n\r\nState提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。\r\n\r\n打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。\r\n\r\n```jsx\r\n// 创建仓库 store\r\nconst store = new Vuex.Store({\r\n  // state 状态, 即数据, 类似于vue组件中的data,\r\n  // 区别在于 data 是组件自己的数据, 而 state 中的数据整个vue项目的组件都能访问到\r\n  state: {\r\n    count: 101\r\n  }\r\n})\r\n```\r\n\r\n问题: 如何在组件中获取count?\r\n\r\n1. 插值表达式 =》  {{  $store.state.count  }}\r\n2. mapState 映射计算属性 =》  {{ count  }}\r\n\r\n\r\n\r\n**1 原始形式- 插值表达式**\r\n\r\n**`App.vue`**\r\n\r\n组件中可以使用  **this.$store** 获取到vuex中的store对象实例，可通过**state**属性属性获取**count**， 如下\r\n\r\n```vue\r\n<h1>state的数据 - {{ $store.state.count }}</h1>\r\n```\r\n\r\n**计算属性** - 将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html\r\n\r\n```js\r\n// 把state中数据，定义在组件内的计算属性中\r\n  computed: {\r\n    count () {\r\n      return this.$store.state.count\r\n    }\r\n  }\r\n```\r\n\r\n```vue\r\n<h1>state的数据 - {{ count }}</h1>\r\n```\r\n\r\n但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法\r\n\r\n\r\n\r\n**2 辅助函数  - mapState**\r\n\r\n>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法\r\n\r\n用法 ： \r\n\r\n第一步：导入mapState (mapState是vuex中的一个函数)\r\n\r\n```js\r\nimport { mapState } from 'vuex'\r\n```\r\n\r\n第二步：采用数组形式引入state属性\r\n\r\n```js\r\nmapState(['count']) \r\n```\r\n\r\n> 上面代码的最终得到的是 **类似于**\r\n\r\n```js\r\ncount () {\r\n    return this.$store.state.count\r\n}\r\n```\r\n\r\n第三步：利用**展开运算符**将导出的状态映射给计算属性\r\n\r\n```js\r\n  computed: {\r\n    ...mapState(['count'])\r\n  }\r\n```\r\n\r\n```vue\r\n <div> state的数据：{{ count }}</div>\r\n```\r\n\r\n\r\n\r\n## 核心概念 - mutations\r\n\r\n### 基本使用\r\n\r\n通过 `strict: true` 可以开启严格模式\r\n\r\n> **state数据的修改只能通过mutations，并且mutations必须是同步的**\r\n\r\n**定义mutations**\r\n\r\n```js\r\nconst store  = new Vuex.Store({\r\n  state: {\r\n    count: 0\r\n  },\r\n  // 定义mutations\r\n  mutations: {\r\n     \r\n  }\r\n})\r\n```\r\n\r\n**格式说明**\r\n\r\nmutations是一个对象，对象中存放修改state的方法\r\n\r\n```js\r\nmutations: {\r\n    // 方法里参数 第一个参数是当前store的state属性\r\n    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷\r\n    addCount (state) {\r\n      state.count += 1\r\n    }\r\n  },\r\n```\r\n\r\n组件中提交 mutations\r\n\r\n```jsx\r\nthis.$store.commit('addCount')\r\n```\r\n\r\n**解决问题: 两个子组件, 添加操作 add,  addN 实现**\r\n\r\n\r\n\r\n### 带参数的 mutation\r\n\r\n需求: 父组件也希望能改到数据\r\n\r\n提交 mutation 是可以传递参数的  `this.$store.commit('xxx',  参数)`\r\n\r\n1 提供mutation函数\r\n\r\n```js\r\nmutations: {\r\n  ...\r\n  inputCount (state, count) {\r\n    state.count = count\r\n  }\r\n},\r\n```\r\n\r\n2 注册事件\r\n\r\n```jsx\r\n<input type=\"text\" :value=\"count\" @input=\"handleInput\">\r\n```\r\n\r\n3 提交mutation\r\n\r\n```jsx\r\nhandleInput (e) {\r\n  this.$store.commit('inputCount', +e.target.value)\r\n}\r\n```\r\n\r\n**小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象**\r\n\r\n```jsx\r\nthis.$store.commit('inputCount', {\r\n  count: e.target.value\r\n})\r\n```\r\n\r\n**解决问题:  addN 的实现**\r\n\r\n\r\n\r\n### **辅助函数** - mapMutations\r\n\r\n> mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入\r\n\r\n```js\r\nimport  { mapMutations } from 'vuex'\r\nmethods: {\r\n    ...mapMutations(['addCount'])\r\n}\r\n```\r\n\r\n> 上面代码的含义是将mutations的方法导入了methods中，等价于\r\n\r\n```js\r\nmethods: {\r\n      // commit(方法名, 载荷参数)\r\n      addCount () {\r\n          this.$store.commit('addCount')\r\n      }\r\n }\r\n```\r\n\r\n此时，就可以直接通过this.addCount调用了\r\n\r\n```jsx\r\n<button @click=\"addCount\">值+1</button>\r\n```\r\n\r\n但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中\r\n\r\n\r\n\r\n## 核心概念-actions\r\n\r\n> state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，\r\n>\r\n> actions则负责进行异步操作\r\n\r\n**需求: 一秒钟之后, 要给一个数 去修改state**\r\n\r\n**定义actions**\r\n\r\n```js\r\nactions: {\r\n  setAsyncCount (context, num) {\r\n    // 一秒后, 给一个数, 去修改 num\r\n    setTimeout(() => {\r\n      context.commit('inputCount', num)\r\n    }, 1000)\r\n  }\r\n},\r\n```\r\n\r\n**原始调用** - $store (支持传参)\r\n\r\n```js\r\nsetAsyncCount () {\r\n  this.$store.dispatch('setAsyncCount', 200)\r\n}\r\n```\r\n\r\n\r\n\r\n**辅助函数** -mapActions\r\n\r\n> actions也有辅助函数，可以将action导入到组件中\r\n\r\n```js\r\nimport { mapActions } from 'vuex'\r\nmethods: {\r\n    ...mapActions(['setAsyncCount'])\r\n}\r\n```\r\n\r\n直接通过 this.方法 就可以调用\r\n\r\n```vue\r\n<button @click=\"setAsyncCount(200)\">+异步</button>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 核心概念-getters\r\n\r\n> 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters\r\n\r\n例如，state中定义了list，为1-10的数组，\r\n\r\n```js\r\nstate: {\r\n    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n}\r\n```\r\n\r\n组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它\r\n\r\n**定义getters**\r\n\r\n```js\r\n  getters: {\r\n    // getters函数的第一个参数是 state\r\n    // 必须要有返回值\r\n     filterList:  state =>  state.list.filter(item => item > 5)\r\n  }\r\n```\r\n\r\n使用getters\r\n\r\n**原始方式** -$store\r\n\r\n```vue\r\n<div>{{ $store.getters.filterList }}</div>\r\n```\r\n\r\n**辅助函数** - mapGetters\r\n\r\n```js\r\ncomputed: {\r\n    ...mapGetters(['filterList'])\r\n}\r\n```\r\n\r\n```vue\r\n <div>{{ filterList }}</div>\r\n```\r\n\r\n\r\n\r\n## 核心概念 - 模块 module (**进阶拓展**)\r\n\r\n> **由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。**\r\n\r\n这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护\r\n\r\n由此，又有了Vuex的模块化\r\n\r\n\r\n\r\n### **模块定义** - 准备 state\r\n\r\n定义两个模块   **user** 和  **setting**\r\n\r\nuser中管理用户的信息状态  userInfo  `modules/user.js`\r\n\r\n```jsx\r\nconst state = {\r\n  userInfo: {\r\n    name: 'zs',\r\n    age: 18\r\n  }\r\n}\r\n\r\nconst mutations = {}\r\n\r\nconst actions = {}\r\n\r\nconst getters = {}\r\n\r\nexport default {\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters\r\n}\r\n\r\n```\r\n\r\nsetting中管理项目应用的名称 title, desc  `modules/setting.js`\r\n\r\n```jsx\r\nconst state = {\r\n  title: '这是大标题',\r\n  desc: '描述真呀真不错'\r\n}\r\n\r\nconst mutations = {}\r\n\r\nconst actions = {}\r\n\r\nconst getters = {}\r\n\r\nexport default {\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters\r\n}\r\n```\r\n\r\n使用模块中的数据,  可以直接通过模块名访问 `$store.state.模块名.xxx`  =>  `$store.state.setting.title`\r\n\r\n也可以通过 mapState 映射\r\n\r\n### 命名空间 namespaced\r\n\r\n默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的\r\n\r\n这句话的意思是 刚才的 user模块 还是 setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用,\r\n\r\n但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置\r\n\r\n`modules/user.js`\r\n\r\n```jsx\r\nconst state = {\r\n  userInfo: {\r\n    name: 'zs',\r\n    age: 18\r\n  },\r\n  myMsg: '我的数据'\r\n}\r\n\r\nconst mutations = {\r\n  updateMsg (state, msg) {\r\n    state.myMsg = msg\r\n  }\r\n}\r\n\r\nconst actions = {}\r\n\r\nconst getters = {}\r\n\r\nexport default {\r\n  namespaced: true,\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters\r\n}\r\n```\r\n\r\n提交模块中的mutation\r\n\r\n```jsx\r\n全局的:   this.$store.commit('mutation函数名', 参数)\r\n\r\n模块中的: this.$store.commit('模块名/mutation函数名', 参数)\r\n```\r\n\r\nnamespaced: true 后, 要添加映射, 可以加上模块名, 找对应模块的 state/mutations/actions/getters\r\n\r\n```jsx\r\ncomputed: {\r\n  // 全局的\r\n  ...mapState(['count']),\r\n  // 模块中的\r\n  ...mapState('user', ['myMsg']),\r\n},\r\nmethods: {\r\n  // 全局的\r\n  ...mapMutations(['addCount'])\r\n  // 模块中的\r\n  ...mapMutations('user', ['updateMsg'])\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",contentRendered:'<h1 id="vuex-概述" tabindex="-1"><a class="header-anchor" href="#vuex-概述" aria-hidden="true">#</a> vuex 概述</h1>\n<p>目标：</p>\n<ul>\n<li>了解vuex的应用场景  (在哪用)</li>\n<li>掌握vuex的基本使用  (怎么用)</li>\n</ul>\n<p><strong>vuex 是一个 vue 的状态管理工具,  状态就是数据</strong></p>\n<p>vuex是一个插件工具，可以帮我们vue管理通用的数据</p>\n<p>之前如果要进行跨组件的数据通信  =&gt;  父传子，子传父  =&gt;  一旦组件关系复杂，数据非常难以维护</p>\n<h2 id="回顾-组件之间共享状态-组件通信方案" tabindex="-1"><a class="header-anchor" href="#回顾-组件之间共享状态-组件通信方案" aria-hidden="true">#</a> 回顾-组件之间共享状态 (组件通信方案)</h2>\n<p>默认组件的数据, 是独立的, 每个组件有着自己的状态(数据)</p>\n<blockquote>\n<p>状态 === 数据</p>\n</blockquote>\n<p>组件之间共享状态的两种典型方式：</p>\n<ul>\n<li>\n<p>父子之间 : props + $emit</p>\n<p>父传子：props属性绑定</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>&lt;son1 msg="msg">&lt;/son1>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>子传父：$emit事件绑定</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>&lt;div>\n\t&lt;button @click="$emit(\'event-name\')">通知父组件&lt;/button>\n&lt;/div>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li>\n</ul>\n<p>如果某个状态需要在很多个组件来使用，或者要实现多个组件共同维护一份数据又应该怎么做呢 ？</p>\n<p>这里就要引入Vuex了。</p>\n<h2 id="vuex基本概念" tabindex="-1"><a class="header-anchor" href="#vuex基本概念" aria-hidden="true">#</a> vuex基本概念</h2>\n<p><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">中文文档<ExternalLinkIcon/></a></p>\n<p>vuex是vue的状态管理工具，<strong>状态即数据</strong>。 状态管理就是集中管理vue中 <strong>通用的</strong> 一些数据</p>\n<p>注意（官方原文）：</p>\n<ul>\n<li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li>\n<li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）</li>\n</ul>\n<p>Vuex就像《近视眼镜》, 你自然会知道什么时候需要用它~</p>\n<h2 id="vuex的优点-方便的解决多组件的共享状态" tabindex="-1"><a class="header-anchor" href="#vuex的优点-方便的解决多组件的共享状态" aria-hidden="true">#</a> vuex的优点: 方便的解决多组件的共享状态</h2>\n<p>vuex的作用是解决《多组件状态共享》的问题。</p>\n<ul>\n<li>\n<p>它是独立于组件而单独存在的，所有的组件都可以把它当作  <strong>一座桥梁</strong> 来进行通讯。</p>\n</li>\n<li>\n<p>特点：</p>\n<ul>\n<li><strong>响应式</strong>： 只要仓库一变化，其他所有地方都更新 （太爽了！！！）</li>\n<li>操作更简洁</li>\n</ul>\n<p>代码量非常少, 但是需要熟悉</p>\n</li>\n</ul>\n<h2 id="什么数据适合存到vuex中" tabindex="-1"><a class="header-anchor" href="#什么数据适合存到vuex中" aria-hidden="true">#</a> 什么数据适合存到vuex中</h2>\n<p>一般情况下，只有  <strong>多个组件均需要共享的数据</strong> ，才有必要存储在vuex中，</p>\n<p>对于某个组件中的私有数据，依旧存储在组件自身的data中。</p>\n<p>例如：</p>\n<ul>\n<li>对于所有组件而言，当前登陆的   <strong>用户信息</strong>  是需要在全体组件之间共享的，则它可以放在vuex中</li>\n<li>对于文章详情页组件来说，当前的用户浏览的文章列表数据则应该属于这个组件的私有数据，应该要放在这个组件data中。</li>\n</ul>\n<h2 id="概述小结" tabindex="-1"><a class="header-anchor" href="#概述小结" aria-hidden="true">#</a> 概述小结:</h2>\n<ol>\n<li>vuex解决什么问题?   vuex 能解决  <strong>多组件共享数据</strong>  的问题,  非常方便便捷</li>\n<li>什么样的数据, 适合存放到vuex?   多组件的  <strong>通用</strong>  的共用数据, 适合存到 vuex</li>\n</ol>\n<p>vuex 两大优势:</p>\n<ol>\n<li>响应式变化</li>\n<li>操作简洁  (vuex提供了一些简化语法的辅助函数, 这些辅助函数, 需要熟练掌握)</li>\n</ol>\n<h1 id="vuex入门" tabindex="-1"><a class="header-anchor" href="#vuex入门" aria-hidden="true">#</a> vuex入门</h1>\n<h2 id="需求-多组件共享数据" tabindex="-1"><a class="header-anchor" href="#需求-多组件共享数据" aria-hidden="true">#</a> 需求: 多组件共享数据</h2>\n<p>对于如下三个组件（一个父组件，两个子组件）</p>\n<p>效果是三个组件共享一份数据:</p>\n<ul>\n<li>任意一个组件都可以修改数据</li>\n<li>三个组件的数据是同步的</li>\n</ul>\n<p>1 创建项目</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>vue create vuex-demo\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2 创建三个组件, 目录如下</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>|-components\n|--add-item.vue\n|--sub-item.vue\n|-App.vue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>3 源代码如下</p>\n<p><code>App.vue</code>在入口组件中引入add-item和sub-item这两个子组件</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>根组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>add-item</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>add-item</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub-item</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub-item</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> AddItem <span class="token keyword">from</span> <span class="token string">\'./components/add-item.vue\'</span>\n<span class="token keyword">import</span> SubItem <span class="token keyword">from</span> <span class="token string">\'./components/sub-item.vue\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'app\'</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      \n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    AddItem<span class="token punctuation">,</span>\n    SubItem\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">#app</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 20px auto<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #ccc<span class="token punctuation">;</span>\n  <span class="token property">border-radius</span><span class="token punctuation">:</span> 3px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p><code>main.js</code></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">\'./App.vue\'</span>\n\nVue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>sub-item.vue</code></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>子组件 sub<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>\n    从vuex中获取的值: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>值-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'SubItem\'</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.box</span><span class="token punctuation">{</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #ccc<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">h2</span> <span class="token punctuation">{</span>\n  <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>add-item.vue</code></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>子组件 add<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>\n    从vuex中获取的值:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>值+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'AddItem\'</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #ccc<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">h2</span> <span class="token punctuation">{</span>\n  <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="vuex-的使用-创建仓库" tabindex="-1"><a class="header-anchor" href="#vuex-的使用-创建仓库" aria-hidden="true">#</a> vuex 的使用 - 创建仓库</h2>\n<p>1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>yarn add vuex@3.4.0\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2 新建 <code>store/index.js</code> 专门存放 vuex</p>\n<p>​\t为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p>\n<p>​\t<img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201029064100611" originSrc="images/image-20201029064100611.png" data="aurora"></p>\n<p>3 创建仓库 <code>store/index.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 导入 vue</span>\n<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token comment">// 导入 vuex</span>\n<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token comment">// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>\n\n<span class="token comment">// 创建仓库 store</span>\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 导出仓库</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> store\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>4 在 main.js 中导入挂载到 Vue 实例上</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">\'./App.vue\'</span>\n<span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">\'./store\'</span>\n\nVue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  store\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p>\n<h2 id="核心概念-state-状态" tabindex="-1"><a class="header-anchor" href="#核心概念-state-状态" aria-hidden="true">#</a> 核心概念 - state 状态</h2>\n<p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p>\n<p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 创建仓库 store</span>\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// state 状态, 即数据, 类似于vue组件中的data,</span>\n  <span class="token comment">// 区别在于 data 是组件自己的数据, 而 state 中的数据整个vue项目的组件都能访问到</span>\n  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">101</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>问题: 如何在组件中获取count?</p>\n<ol>\n<li>插值表达式 =》  {{  $store.state.count  }}</li>\n<li>mapState 映射计算属性 =》  {{ count  }}</li>\n</ol>\n<p><strong>1 原始形式- 插值表达式</strong></p>\n<p><strong><code>App.vue</code></strong></p>\n<p>组件中可以使用  <strong>this.$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>state的数据 - {{ $store.state.count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>计算属性</strong> - 将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 把state中数据，定义在组件内的计算属性中</span>\n  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>state的数据 - {{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法</p>\n<p><strong>2 辅助函数  - mapState</strong></p>\n<blockquote>\n<p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p>\n</blockquote>\n<p>用法 ：</p>\n<p>第一步：导入mapState (mapState是vuex中的一个函数)</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>第二步：采用数组形式引入state属性</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'count\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote>\n<p>上面代码的最终得到的是 <strong>类似于</strong></p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'count\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span> state的数据：{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="核心概念-mutations" tabindex="-1"><a class="header-anchor" href="#核心概念-mutations" aria-hidden="true">#</a> 核心概念 - mutations</h2>\n<h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h3>\n<p>通过 <code>strict: true</code> 可以开启严格模式</p>\n<blockquote>\n<p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p>\n</blockquote>\n<p><strong>定义mutations</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> store  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 定义mutations</span>\n  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n     \n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>格式说明</strong></p>\n<p>mutations是一个对象，对象中存放修改state的方法</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 方法里参数 第一个参数是当前store的state属性</span>\n    <span class="token comment">// payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷</span>\n    <span class="token function">addCount</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>组件中提交 mutations</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'addCount\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>解决问题: 两个子组件, 添加操作 add,  addN 实现</strong></p>\n<h3 id="带参数的-mutation" tabindex="-1"><a class="header-anchor" href="#带参数的-mutation" aria-hidden="true">#</a> 带参数的 mutation</h3>\n<p>需求: 父组件也希望能改到数据</p>\n<p>提交 mutation 是可以传递参数的  <code>this.$store.commit(\'xxx\',  参数)</code></p>\n<p>1 提供mutation函数</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  <span class="token function">inputCount</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> count</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span>count <span class="token operator">=</span> count\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>2 注册事件</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"count"</span> @input<span class="token operator">=</span><span class="token string">"handleInput"</span><span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>3 提交mutation</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token function">handleInput</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'inputCount\'</span><span class="token punctuation">,</span> <span class="token operator">+</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'inputCount\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">count</span><span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解决问题:  addN 的实现</strong></p>\n<h3 id="辅助函数-mapmutations" tabindex="-1"><a class="header-anchor" href="#辅助函数-mapmutations" aria-hidden="true">#</a> <strong>辅助函数</strong> - mapMutations</h3>\n<blockquote>\n<p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span>  <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'addCount\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote>\n<p>上面代码的含义是将mutations的方法导入了methods中，等价于</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// commit(方法名, 载荷参数)</span>\n      <span class="token function">addCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'addCount\'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>此时，就可以直接通过this.addCount调用了</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"addCount"</span><span class="token operator">></span>值<span class="token operator">+</span><span class="token number">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p>\n<h2 id="核心概念-actions" tabindex="-1"><a class="header-anchor" href="#核心概念-actions" aria-hidden="true">#</a> 核心概念-actions</h2>\n<blockquote>\n<p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p>\n<p>actions则负责进行异步操作</p>\n</blockquote>\n<p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p>\n<p><strong>定义actions</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">setAsyncCount</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 一秒后, 给一个数, 去修改 num</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'inputCount\'</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>原始调用</strong> - $store (支持传参)</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">setAsyncCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'setAsyncCount\'</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>辅助函数</strong> -mapActions</p>\n<blockquote>\n<p>actions也有辅助函数，可以将action导入到组件中</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'setAsyncCount\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>直接通过 this.方法 就可以调用</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>setAsyncCount(200)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+异步<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="核心概念-getters" tabindex="-1"><a class="header-anchor" href="#核心概念-getters" aria-hidden="true">#</a> 核心概念-getters</h2>\n<blockquote>\n<p>除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters</p>\n</blockquote>\n<p>例如，state中定义了list，为1-10的数组，</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p>\n<p><strong>定义getters</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// getters函数的第一个参数是 state</span>\n    <span class="token comment">// 必须要有返回值</span>\n     <span class="token function-variable function">filterList</span><span class="token operator">:</span>  <span class="token parameter">state</span> <span class="token operator">=></span>  state<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用getters</p>\n<p><strong>原始方式</strong> -$store</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ $store.getters.filterList }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>辅助函数</strong> - mapGetters</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'filterList\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ filterList }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="核心概念-模块-module-进阶拓展" tabindex="-1"><a class="header-anchor" href="#核心概念-模块-module-进阶拓展" aria-hidden="true">#</a> 核心概念 - 模块 module (<strong>进阶拓展</strong>)</h2>\n<blockquote>\n<p><strong>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</strong></p>\n</blockquote>\n<p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p>\n<p>由此，又有了Vuex的模块化</p>\n<h3 id="模块定义-准备-state" tabindex="-1"><a class="header-anchor" href="#模块定义-准备-state" aria-hidden="true">#</a> <strong>模块定义</strong> - 准备 state</h3>\n<p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p>\n<p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">,</span>\n  mutations<span class="token punctuation">,</span>\n  actions<span class="token punctuation">,</span>\n  getters\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>setting中管理项目应用的名称 title, desc  <code>modules/setting.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">\'这是大标题\'</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">\'描述真呀真不错\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">,</span>\n  mutations<span class="token punctuation">,</span>\n  actions<span class="token punctuation">,</span>\n  getters\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  =&gt;  <code>$store.state.setting.title</code></p>\n<p>也可以通过 mapState 映射</p>\n<h3 id="命名空间-namespaced" tabindex="-1"><a class="header-anchor" href="#命名空间-namespaced" aria-hidden="true">#</a> 命名空间 namespaced</h3>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的</p>\n<p>这句话的意思是 刚才的 user模块 还是 setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用,</p>\n<p>但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置</p>\n<p><code>modules/user.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">myMsg</span><span class="token operator">:</span> <span class="token string">\'我的数据\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">updateMsg</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span>myMsg <span class="token operator">=</span> msg\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">namespaced</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  state<span class="token punctuation">,</span>\n  mutations<span class="token punctuation">,</span>\n  actions<span class="token punctuation">,</span>\n  getters\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>提交模块中的mutation</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">全局的</span><span class="token operator">:</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'mutation函数名\'</span><span class="token punctuation">,</span> 参数<span class="token punctuation">)</span>\n\n<span class="token literal-property property">模块中的</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'模块名/mutation函数名\'</span><span class="token punctuation">,</span> 参数<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>namespaced: true 后, 要添加映射, 可以加上模块名, 找对应模块的 state/mutations/actions/getters</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 全局的</span>\n  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'count\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token comment">// 模块中的</span>\n  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token string">\'user\'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'myMsg\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 全局的</span>\n  <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'addCount\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token comment">// 模块中的</span>\n  <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">\'user\'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'updateMsg\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/vuex入门.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"vuex入门",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/vuex入门.md",filePathRelative:"Vue/vuex入门.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/vuex入门.html.vue",componentFilePathRelative:"pages/Vue/vuex入门.html.vue",componentFileChunkName:"v-c11452c2",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/vuex入门.html.js",dataFilePathRelative:"pages/Vue/vuex入门.html.js",dataFileChunkName:"v-c11452c2",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/vuex入门.html",htmlFilePathRelative:"Vue/vuex入门.html"},{data:{key:"v-41c2a7b8",path:"/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.html",title:"vue基本概念",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"vue介绍",slug:"vue介绍",children:[{level:3,title:"渐进式的概念",slug:"渐进式的概念",children:[]},{level:3,title:"框架的概念",slug:"框架的概念",children:[]},{level:3,title:"vue是 MVVM 的框架",slug:"vue是-mvvm-的框架",children:[]}]},{level:2,title:"开发vue的方式",slug:"开发vue的方式",children:[]},{level:2,title:"基本使用",slug:"基本使用",children:[]},{level:2,title:"如何覆盖webpack配置",slug:"如何覆盖webpack配置",children:[]},{level:2,title:"目录分析与清理",slug:"目录分析与清理",children:[]},{level:2,title:"vue单文件组件的说明",slug:"vue单文件组件的说明",children:[]},{level:2,title:"vue通过data提供数据",slug:"vue通过data提供数据",children:[]},{level:2,title:"通过插值表达式显示数据",slug:"通过插值表达式显示数据",children:[]},{level:2,title:"安装vue开发者工具",slug:"安装vue开发者工具",children:[]},{level:2,title:"v-bind指令",slug:"v-bind指令",children:[]},{level:2,title:"v-on指令",slug:"v-on指令",children:[{level:3,title:"基本使用",slug:"基本使用-1",children:[]},{level:3,title:"vue中获取事件对象(了解)",slug:"vue中获取事件对象-了解",children:[]},{level:3,title:"v-on 事件修饰符",slug:"v-on-事件修饰符",children:[]},{level:3,title:"按键修饰符",slug:"按键修饰符",children:[]}]},{level:2,title:"v-if 和 v-show",slug:"v-if-和-v-show",children:[{level:3,title:"基本使用",slug:"基本使用-2",children:[]},{level:3,title:"v-else 和 v-else-if",slug:"v-else-和-v-else-if",children:[]}]},{level:2,title:"v-model",slug:"v-model",children:[{level:3,title:"基本使用",slug:"基本使用-3",children:[]},{level:3,title:"v-model 处理其他表单元素",slug:"v-model-处理其他表单元素",children:[]},{level:3,title:"v-model 修饰符",slug:"v-model-修饰符",children:[]}]},{level:2,title:"v-text 和 v-html",slug:"v-text-和-v-html",children:[{level:3,title:"v-text指令",slug:"v-text指令",children:[]},{level:3,title:"v-html指令",slug:"v-html指令",children:[]}]}],git:{}},key:"v-41c2a7b8",path:"/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.html",title:"vue基本概念",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"vue介绍",slug:"vue介绍",children:[{level:3,title:"渐进式的概念",slug:"渐进式的概念",children:[]},{level:3,title:"框架的概念",slug:"框架的概念",children:[]},{level:3,title:"vue是 MVVM 的框架",slug:"vue是-mvvm-的框架",children:[]}]},{level:2,title:"开发vue的方式",slug:"开发vue的方式",children:[]},{level:2,title:"基本使用",slug:"基本使用",children:[]},{level:2,title:"如何覆盖webpack配置",slug:"如何覆盖webpack配置",children:[]},{level:2,title:"目录分析与清理",slug:"目录分析与清理",children:[]},{level:2,title:"vue单文件组件的说明",slug:"vue单文件组件的说明",children:[]},{level:2,title:"vue通过data提供数据",slug:"vue通过data提供数据",children:[]},{level:2,title:"通过插值表达式显示数据",slug:"通过插值表达式显示数据",children:[]},{level:2,title:"安装vue开发者工具",slug:"安装vue开发者工具",children:[]},{level:2,title:"v-bind指令",slug:"v-bind指令",children:[]},{level:2,title:"v-on指令",slug:"v-on指令",children:[{level:3,title:"基本使用",slug:"基本使用-1",children:[]},{level:3,title:"vue中获取事件对象(了解)",slug:"vue中获取事件对象-了解",children:[]},{level:3,title:"v-on 事件修饰符",slug:"v-on-事件修饰符",children:[]},{level:3,title:"按键修饰符",slug:"按键修饰符",children:[]}]},{level:2,title:"v-if 和 v-show",slug:"v-if-和-v-show",children:[{level:3,title:"基本使用",slug:"基本使用-2",children:[]},{level:3,title:"v-else 和 v-else-if",slug:"v-else-和-v-else-if",children:[]}]},{level:2,title:"v-model",slug:"v-model",children:[{level:3,title:"基本使用",slug:"基本使用-3",children:[]},{level:3,title:"v-model 处理其他表单元素",slug:"v-model-处理其他表单元素",children:[]},{level:3,title:"v-model 修饰符",slug:"v-model-修饰符",children:[]}]},{level:2,title:"v-text 和 v-html",slug:"v-text-和-v-html",children:[{level:3,title:"v-text指令",slug:"v-text指令",children:[]},{level:3,title:"v-html指令",slug:"v-html指令",children:[]}]}],content:'# vue基本概念 \r\n\r\n## vue介绍\r\n\r\n- [vue 中文网](https://cn.vuejs.org/)  尤雨溪 \r\n- [Vue.js 是什么](https://cn.vuejs.org/v2/guide/index.html#Vue-js-%E6%98%AF%E4%BB%80%E4%B9%88)\r\n- Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式javascript框架**。  \r\n\r\n### 渐进式的概念\r\n\r\n渐进式：逐渐增强，可以在项目中使用vue的一部分功能，也可以使用vue的全家桶来管理整个项目。\r\n\r\nangular: 全家桶 \r\n\r\n![](images/渐进式.png)\r\n\r\n### 框架的概念\r\n\r\n- [我们所说的前端框架与库的区别？](https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120)\r\n\r\n**Library**\r\n\r\n+ 代表：moment  axios\r\n\r\n+ 库，本质上是一些函数的集合。每次调用函数，实现一个特定的功能   工具箱\r\n\r\n- 使用库的时候，把库当成工具使用，需要自己控制代码的执行逻辑。\r\n\r\n**Framework**\r\n\r\n+ 代表：vue、angular、react、bootstrap\r\n\r\n+ 框架，是一套完整的解决方案\r\n\r\n- 使用框架的时候，框架实现了大部分的功能，我们只需要按照框架的规则写代码\r\n\r\n**库和框架的区别**\r\n\r\n+ 使用库的时候，很自由，只要调用库提供的各种各样的方法就行，也可以不用其他的一些方法\r\n+ 使用框架的时候，需要按照框架的规则写代码，限制会非常多，但同时框架的功能也很强大，可以极大的提升开发的效率。\r\n\r\n\r\n\r\n### vue是 MVVM 的框架\r\n\r\n+ MVVM思想：一种软件架构模式，决定了写代码的方式。\r\n  + M：model数据模型(ajax获取到的数据)\t\r\n  + V：view视图（页面）\r\n  + VM：ViewModel 视图模型\r\n\r\n- MVVM通过`数据双向绑定`让数据自动地双向同步  **不在需要操作DOM**\r\n  - V（修改视图） -> M（数据自动同步）\r\n  - M（修改数据） -> V（视图自动同步）\r\n\r\n**1. 在vue中，不推荐直接手动操作DOM！！！**     \r\n\r\n**2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！**\r\n\r\n## 开发vue的方式\r\n\r\n开发vue有两种方式   \r\n\r\n+ 传统开发模式：基于html/css/js文件开发vue \r\n+ 工程化开发方式：在webpack环境中开发vue，这是最推荐的方式。\r\n+ 现代化的项目也都是在webpack环境下进行开发的。\r\n\r\n\r\n\r\n# vue-cli的使用\r\n\r\n> `vue-cli`也叫vue脚手架,`vue-cli`是vue官方提供的一个全局命令工具，这个命令可以帮助我们快速的创建一个vue项目的基础架子。\r\n\r\n+ 开箱即用\r\n+ 零配置\r\n+ webpack、babel\r\n\r\n## 基本使用\r\n\r\n+ 全局安装命令 \r\n\r\n```bash\r\nnpm install -g @vue/cli\r\n# OR\r\nyarn global add @vue/cli\r\n```\r\n\r\n+ 查看版本`vue`\r\n\r\n```js\r\nvue --version\r\n```\r\n\r\n+ 初始化一个vue项目\r\n\r\n```js\r\nvue create 项目名(不能用中文)\r\n```\r\n\r\n+ 启动项目\r\n\r\n```\r\nyarn serve\r\nyarn build\r\n```\r\n\r\n\r\n\r\n## 如何覆盖webpack配置\r\n\r\n> 注意：我们在项目无法找到webpack.config.js文件，因为vue把它隐藏。\r\n\r\n如果需要覆盖webpack的配置，可以修改vue.config.js文件，覆盖webpack配置文件\r\n\r\n```jsx\r\nconst { defineConfig } = require(\'@vue/cli-service\')\r\nmodule.exports = defineConfig({\r\n  transpileDependencies: true,\r\n  // 配置端口号\r\n  devServer: {\r\n    port: 3000\r\n  }\r\n})\r\n```\r\n\r\n\r\n\r\n## 目录分析与清理\r\n\r\n+ public/index.html不用动，提供一个最基础的页面\r\n+ src/main.js不用动，  渲染了App.vue组件\r\n+ src/App.vue默认有很多的内容，可以全部删除\r\n\r\n```jsx\r\n<template>\r\n  <div>123</div>\r\n</template>\r\n```\r\n\r\n+ assets文件夹与components直接删除\r\n\r\n## vue单文件组件的说明\r\n\r\n一个`.vue`文件就是一个组件,后续开发vue，所有的功能都是基于组件实现。\r\n\r\n安装插件\r\n\r\n一个单文件组件由三部分构成\r\n\r\n+ template(必须)  影响组件渲染的结构  html\r\n  + 只能有一个根元素\r\n+ script                     逻辑   js\r\n+ style                       样式   css less scss\r\n  + style用于提供组件的样式，默认只能用css\r\n  + 可以通过`lang="less"`开启less的功能，需要安装依赖包\r\n\r\n```\r\nyarn add less-loader@7.2.1 less -D\r\n```\r\n\r\n\r\n\r\n# vue的插值表达式\r\n\r\n## vue通过data提供数据\r\n\r\n> vue中通过template可以提供模板，但是这样的数据是写死的。\r\n\r\nvue可以通过data提供数据，注意：`data必须是一个函数，并且返回一个对象`\r\n\r\n```jsx\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      money: 100,\r\n      msg: \'hello\'\r\n    }\r\n  }    \r\n}\r\n<\/script>\r\n```\r\n\r\n## 通过插值表达式显示数据\r\n\r\n插值表达式, 小胡子语法  mustach语法` {{  }}`\r\n\r\n1. 作用:  使用 data 中的数据渲染视图（模板）\r\n\r\n2. 基本语法, 支持三元运算符\r\n\r\n   ```jsx\r\n   {{ msg }}\r\n   {{ obj.name }}\r\n   {{ msg.toUpperCase() }}\r\n   {{ obj.age > 18 ? \'成年\' : \'未成年\' }}\r\n   ```\r\n\r\n3. vue中插值表达式的注意点\r\n\r\n   (1)  使用的数据在 data 中要存在\r\n\r\n   ```jsx\r\n   <h1>{{ gaga }}</h1>\r\n   ```\r\n\r\n   (2)  能使用表达式, 但是不能使用 if  for\r\n\r\n   ```jsx\r\n   <h1>{{ if (obj.age > 18 ) { }   }}</h1>\r\n   ```\r\n\r\n   (3)  不能在标签属性中使用\r\n\r\n   ```jsx\r\n   <h1 id="box" class="box" title="{{ msg }}"></h1>\r\n   ```\r\n\r\n## 安装vue开发者工具\r\n\r\n+ 直接通过谷歌应用商店安装  需要梯子\r\n+ 通过极简插件下载插件，本地安装。 https://chrome.zzzmh.cn/index\r\n\r\n# vue指令\r\n\r\n**vue指令, 实质上就是特殊的 html 标签属性, 特点:  v- 开头**\r\n\r\n每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能\r\n\r\n## v-bind指令\r\n\r\n- 描述：插值表达式不能用在html的属性上，如果想要动态的设置html元素的属性，需要使用v-bind指令\r\n- 作用：动态的设置html的属性\r\n- 语法：`v-bind:title="msg"`\r\n- 简写：`:title="msg"`\r\n\r\n```html\r\n\x3c!-- 完整语法 --\x3e\r\n<a v-bind:href="url"></a>\r\n\x3c!-- 缩写 --\x3e\r\n<a :href="url"></a>\r\n```\r\n\r\n## v-on指令\r\n\r\n### 基本使用\r\n\r\n语法：\r\n       1. v-on:事件名=“要执行的少量代码"\r\n       2. v-on:事件名=“methods中的函数名"\r\n       3. v-on:事件名=“methods中的函数名(实参)" \r\n\r\n+ 最基本的语法\r\n\r\n  + `<button v-on:事件名="事件函数">按钮</button>`，需要在methods中提供事件处理函数\r\n\r\n  ```jsx\r\n  <button v-on:click="fn">搬砖</button>\r\n  <button v-on:click="fn1">卖房</button>\r\n  \r\n    // 提供方法\r\n    methods: {\r\n      fn () {\r\n        console.log(\'你好啊\')\r\n        // console.log(this)\r\n        this.money++\r\n      },\r\n      fn1 () {\r\n        this.money += 10000\r\n      },\r\n    }\r\n  ```\r\n\r\n+ 需要传递参数\r\n\r\n  + `<button v-on:事件名="事件函数(参数)">按钮</button>`，需要在methods中提供事件函数，接受参数\r\n\r\n  ```jsx\r\n  <button v-on:click="addMoney(1)">搬砖</button>\r\n  <button v-on:click="addMoney(10000)">卖房</button>\r\n  \r\n  methods: {\r\n    addMoney (money) {\r\n      this.money += money\r\n    }\r\n  }\r\n  ```\r\n\r\n+ 如果事件的逻辑足够简单，可以不提供函数\r\n\r\n```jsx\r\n<button v-on:click="money++">搬砖</button>\r\n<button v-on:click="money += 10000">卖房</button>\r\n```\r\n\r\n### vue中获取事件对象(了解)\r\n\r\n需求: 默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()\r\n\r\nvue中获取事件对象\r\n\r\n(1) 没有传参, 通过形参接收 e\r\n\r\n(2) 传参了, 通过$event指代事件对象 e\r\n\r\n```jsx\r\n<template>\r\n  <div id="app">\r\n    <a @click="fn" href="http://www.baidu.com">去百度</a>\r\n    <a @click="fn2(100, $event)" href="http://www.baidu.com">去百度2</a>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  methods: {\r\n    fn(e) {\r\n      e.preventDefault()\r\n    },\r\n    fn2(num, e) {\r\n      e.preventDefault()\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n### v-on 事件修饰符\r\n\r\n- vue中提供的事件修饰符\r\n\r\n  .prevent 阻止默认行为\r\n\r\n  .stop 阻止冒泡\r\n\r\n```html\r\n<div id="app">\r\n  <a @click.prevent="fn" href="http://www.baidu.com">去百度</a>\r\n</div>\r\n```\r\n\r\n### 按键修饰符\r\n\r\n需求: 用户输入内容, 回车, 打印输入的内容\r\n\r\n在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符\r\n\r\n- @keyup.enter  回车\r\n\r\n- @keyup.esc  返回\r\n\r\n```html\r\n<div id="app">\r\n  <input type="text" @keyup="fn"> <hr>\r\n  <input type="text" @keyup.enter="fn2">\r\n</div>\r\n\r\n```\r\n\r\n## v-if 和 v-show\r\n\r\n### 基本使用\r\n\r\nv-show 和 v-if 功能: 控制盒子的显示隐藏\r\n\r\n1. v-show\r\n\r\n   语法:  v-show="布尔值"    (true显示, false隐藏)\r\n\r\n   原理:  实质是在控制元素的 css 样式,  `display: none;`\r\n\r\n2. v-if   \r\n\r\n   语法: v-if="布尔值"   (true显示, false隐藏)\r\n\r\n   原理:  实质是在动态的创建 或者 删除元素节点\r\n\r\n应用场景: \r\n\r\n- 如果是频繁的切换显示隐藏, 用 v-show\r\n\r\n  v-if, 频繁切换会大量的创建和删除元素, 消耗性能\r\n\r\n- 如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if\r\n\r\n  v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销\r\n\r\n```html\r\n<template>\r\n  <div id="app">\r\n    <h1 v-show="isShow">v-show盒子-{{ msg }}</h1>\r\n    <h1 v-if="isShow">v-if盒子-{{ msg }}</h1>\r\n  </div>\r\n</template>\r\n```\r\n\r\n### v-else 和 v-else-if\r\n\r\n```html\r\n<div id="app">\r\n  <h1 v-if="isLogin">尊敬的超级vip, 你好</h1>\r\n  <h1 v-else>你谁呀, 赶紧登陆~</h1>\r\n\r\n  <hr>\r\n  \r\n  <h1 v-if="age >= 60">60岁以上, 广场舞</h1>\r\n  <h1 v-else-if="age >= 30">30岁以上, 搓麻将</h1>\r\n  <h1 v-else-if="age >= 20">20岁以上, 蹦迪</h1>\r\n  <h1 v-else>20岁以下, 唱跳rap篮球</h1>\r\n</div>\r\n\r\n```\r\n\r\n## v-model\r\n\r\n### 基本使用\r\n\r\n**作用: 给表单元素使用, 双向数据绑定 ** \r\n\r\n1. 数据变化了, 视图会跟着变\r\n\r\n2. 视图变化了, 数据要跟着变\r\n\r\n   输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变\r\n\r\n语法: v-model=\'值\'\r\n\r\n```jsx\r\n<input type="text" v-model="msg">\r\n```\r\n\r\n\r\n\r\n### v-model 处理其他表单元素\r\n\r\n**v-model 会忽略掉表单元素原本的value, checked等初始值**\r\n\r\ntextarea, select, checkbox\r\n\r\n### v-model 修饰符\r\n\r\n- number\r\n\r\n  如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 `v-model` 添加 `number` 修饰符：\r\n\r\n  ```html\r\n  <input v-model.number="age" type="number">\r\n  ```\r\n\r\n  如果这个值如果这个值无法转数字，则会返回原始的值。\r\n\r\n- trim\r\n\r\n  如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\r\n\r\n  ```html\r\n  <input v-model.trim="msg">\r\n  ```\r\n\r\n- lazy\r\n\r\n  在`change`时而非`input`时更新，可以给 `v-model` 添加 `lazy` 修饰符：\r\n\r\n  ```html\r\n  <input v-model.lazy="msg">\r\n  ```\r\n\r\n\r\n\r\n## v-text 和 v-html\r\n\r\n### v-text指令\r\n\r\n- 解释：更新元素的 `textContent/innerText`。如果要更新部分的 `textContent` ，需要使用 `{{ Mustache }}` 插值。 \r\n\r\n```html\r\n<h1 v-text="msg"></h1>\r\n```\r\n\r\n### v-html指令\r\n\r\n- 解释：更新DOM对象的` innerHTML`,html标签会生效\r\n\r\n```html\r\n<h1 v-html="msg"></h1>\r\n```\r\n\r\n**在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。** \r\n\r\n**只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。** \r\n',contentRendered:'<h1 id="vue基本概念" tabindex="-1"><a class="header-anchor" href="#vue基本概念" aria-hidden="true">#</a> vue基本概念</h1>\n<h2 id="vue介绍" tabindex="-1"><a class="header-anchor" href="#vue介绍" aria-hidden="true">#</a> vue介绍</h2>\n<ul>\n<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener noreferrer">vue 中文网<ExternalLinkIcon/></a>  尤雨溪</li>\n<li><a href="https://cn.vuejs.org/v2/guide/index.html#Vue-js-%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">Vue.js 是什么<ExternalLinkIcon/></a></li>\n<li>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式javascript框架</strong>。</li>\n</ul>\n<h3 id="渐进式的概念" tabindex="-1"><a class="header-anchor" href="#渐进式的概念" aria-hidden="true">#</a> 渐进式的概念</h3>\n<p>渐进式：逐渐增强，可以在项目中使用vue的一部分功能，也可以使用vue的全家桶来管理整个项目。</p>\n<p>angular: 全家桶</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="" originSrc="images/%E6%B8%90%E8%BF%9B%E5%BC%8F.png" data="aurora"></p>\n<h3 id="框架的概念" tabindex="-1"><a class="header-anchor" href="#框架的概念" aria-hidden="true">#</a> 框架的概念</h3>\n<ul>\n<li><a href="https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120" target="_blank" rel="noopener noreferrer">我们所说的前端框架与库的区别？<ExternalLinkIcon/></a></li>\n</ul>\n<p><strong>Library</strong></p>\n<ul>\n<li>\n<p>代表：moment  axios</p>\n</li>\n<li>\n<p>库，本质上是一些函数的集合。每次调用函数，实现一个特定的功能   工具箱</p>\n</li>\n</ul>\n<ul>\n<li>使用库的时候，把库当成工具使用，需要自己控制代码的执行逻辑。</li>\n</ul>\n<p><strong>Framework</strong></p>\n<ul>\n<li>\n<p>代表：vue、angular、react、bootstrap</p>\n</li>\n<li>\n<p>框架，是一套完整的解决方案</p>\n</li>\n</ul>\n<ul>\n<li>使用框架的时候，框架实现了大部分的功能，我们只需要按照框架的规则写代码</li>\n</ul>\n<p><strong>库和框架的区别</strong></p>\n<ul>\n<li>使用库的时候，很自由，只要调用库提供的各种各样的方法就行，也可以不用其他的一些方法</li>\n<li>使用框架的时候，需要按照框架的规则写代码，限制会非常多，但同时框架的功能也很强大，可以极大的提升开发的效率。</li>\n</ul>\n<h3 id="vue是-mvvm-的框架" tabindex="-1"><a class="header-anchor" href="#vue是-mvvm-的框架" aria-hidden="true">#</a> vue是 MVVM 的框架</h3>\n<ul>\n<li>MVVM思想：一种软件架构模式，决定了写代码的方式。\n<ul>\n<li>M：model数据模型(ajax获取到的数据)</li>\n<li>V：view视图（页面）</li>\n<li>VM：ViewModel 视图模型</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>MVVM通过<code>数据双向绑定</code>让数据自动地双向同步  <strong>不在需要操作DOM</strong>\n<ul>\n<li>V（修改视图） -&gt; M（数据自动同步）</li>\n<li>M（修改数据） -&gt; V（视图自动同步）</li>\n</ul>\n</li>\n</ul>\n<p><strong>1. 在vue中，不推荐直接手动操作DOM！！！</strong></p>\n<p><strong>2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！</strong></p>\n<h2 id="开发vue的方式" tabindex="-1"><a class="header-anchor" href="#开发vue的方式" aria-hidden="true">#</a> 开发vue的方式</h2>\n<p>开发vue有两种方式</p>\n<ul>\n<li>传统开发模式：基于html/css/js文件开发vue</li>\n<li>工程化开发方式：在webpack环境中开发vue，这是最推荐的方式。</li>\n<li>现代化的项目也都是在webpack环境下进行开发的。</li>\n</ul>\n<h1 id="vue-cli的使用" tabindex="-1"><a class="header-anchor" href="#vue-cli的使用" aria-hidden="true">#</a> vue-cli的使用</h1>\n<blockquote>\n<p><code>vue-cli</code>也叫vue脚手架,<code>vue-cli</code>是vue官方提供的一个全局命令工具，这个命令可以帮助我们快速的创建一个vue项目的基础架子。</p>\n</blockquote>\n<ul>\n<li>开箱即用</li>\n<li>零配置</li>\n<li>webpack、babel</li>\n</ul>\n<h2 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h2>\n<ul>\n<li>全局安装命令</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli\n<span class="token comment"># OR</span>\n<span class="token function">yarn</span> global <span class="token function">add</span> @vue/cli\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>查看版本<code>vue</code></li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>vue <span class="token operator">--</span>version\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>初始化一个vue项目</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>vue create <span class="token function">项目名</span><span class="token punctuation">(</span>不能用中文<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>启动项目</li>\n</ul>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>yarn serve\nyarn build\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="如何覆盖webpack配置" tabindex="-1"><a class="header-anchor" href="#如何覆盖webpack配置" aria-hidden="true">#</a> 如何覆盖webpack配置</h2>\n<blockquote>\n<p>注意：我们在项目无法找到webpack.config.js文件，因为vue把它隐藏。</p>\n</blockquote>\n<p>如果需要覆盖webpack的配置，可以修改vue.config.js文件，覆盖webpack配置文件</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'@vue/cli-service\'</span><span class="token punctuation">)</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">transpileDependencies</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token comment">// 配置端口号</span>\n  <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">3000</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="目录分析与清理" tabindex="-1"><a class="header-anchor" href="#目录分析与清理" aria-hidden="true">#</a> 目录分析与清理</h2>\n<ul>\n<li>public/index.html不用动，提供一个最基础的页面</li>\n<li>src/main.js不用动，  渲染了App.vue组件</li>\n<li>src/App.vue默认有很多的内容，可以全部删除</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>assets文件夹与components直接删除</li>\n</ul>\n<h2 id="vue单文件组件的说明" tabindex="-1"><a class="header-anchor" href="#vue单文件组件的说明" aria-hidden="true">#</a> vue单文件组件的说明</h2>\n<p>一个<code>.vue</code>文件就是一个组件,后续开发vue，所有的功能都是基于组件实现。</p>\n<p>安装插件</p>\n<p>一个单文件组件由三部分构成</p>\n<ul>\n<li>template(必须)  影响组件渲染的结构  html\n<ul>\n<li>只能有一个根元素</li>\n</ul>\n</li>\n<li>script                     逻辑   js</li>\n<li>style                       样式   css less scss\n<ul>\n<li>style用于提供组件的样式，默认只能用css</li>\n<li>可以通过<code>lang=&quot;less&quot;</code>开启less的功能，需要安装依赖包</li>\n</ul>\n</li>\n</ul>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>yarn add less-loader@7.2.1 less -D\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h1 id="vue的插值表达式" tabindex="-1"><a class="header-anchor" href="#vue的插值表达式" aria-hidden="true">#</a> vue的插值表达式</h1>\n<h2 id="vue通过data提供数据" tabindex="-1"><a class="header-anchor" href="#vue通过data提供数据" aria-hidden="true">#</a> vue通过data提供数据</h2>\n<blockquote>\n<p>vue中通过template可以提供模板，但是这样的数据是写死的。</p>\n</blockquote>\n<p>vue可以通过data提供数据，注意：<code>data必须是一个函数，并且返回一个对象</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token plain-text">\nexport default {\n  data () {\n    return {\n      money: 100,\n      msg: \'hello\'\n    }\n  }    \n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="通过插值表达式显示数据" tabindex="-1"><a class="header-anchor" href="#通过插值表达式显示数据" aria-hidden="true">#</a> 通过插值表达式显示数据</h2>\n<p>插值表达式, 小胡子语法  mustach语法<code> {{  }}</code></p>\n<ol>\n<li>\n<p>作用:  使用 data 中的数据渲染视图（模板）</p>\n</li>\n<li>\n<p>基本语法, 支持三元运算符</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span><span class="token punctuation">{</span> msg<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>age <span class="token operator">></span> <span class="token number">18</span> <span class="token operator">?</span> <span class="token string">\'成年\'</span> <span class="token operator">:</span> <span class="token string">\'未成年\'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li>\n<li>\n<p>vue中插值表达式的注意点</p>\n<p>(1)  使用的数据在 data 中要存在</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> gaga <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>(2)  能使用表达式, 但是不能使用 if  for</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>age <span class="token operator">></span> <span class="token number">18</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>(3)  不能在标签属性中使用</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{{ msg }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n</ol>\n<h2 id="安装vue开发者工具" tabindex="-1"><a class="header-anchor" href="#安装vue开发者工具" aria-hidden="true">#</a> 安装vue开发者工具</h2>\n<ul>\n<li>直接通过谷歌应用商店安装  需要梯子</li>\n<li>通过极简插件下载插件，本地安装。 https://chrome.zzzmh.cn/index</li>\n</ul>\n<h1 id="vue指令" tabindex="-1"><a class="header-anchor" href="#vue指令" aria-hidden="true">#</a> vue指令</h1>\n<p><strong>vue指令, 实质上就是特殊的 html 标签属性, 特点:  v- 开头</strong></p>\n<p>每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能</p>\n<h2 id="v-bind指令" tabindex="-1"><a class="header-anchor" href="#v-bind指令" aria-hidden="true">#</a> v-bind指令</h2>\n<ul>\n<li>描述：插值表达式不能用在html的属性上，如果想要动态的设置html元素的属性，需要使用v-bind指令</li>\n<li>作用：动态的设置html的属性</li>\n<li>语法：<code>v-bind:title=&quot;msg&quot;</code></li>\n<li>简写：<code>:title=&quot;msg&quot;</code></li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 完整语法 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token comment">&lt;!-- 缩写 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="v-on指令" tabindex="-1"><a class="header-anchor" href="#v-on指令" aria-hidden="true">#</a> v-on指令</h2>\n<h3 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1" aria-hidden="true">#</a> 基本使用</h3>\n<p>语法：\n1. v-on:事件名=“要执行的少量代码&quot;\n2. v-on:事件名=“methods中的函数名&quot;\n3. v-on:事件名=“methods中的函数名(实参)&quot;</p>\n<ul>\n<li>\n<p>最基本的语法</p>\n<ul>\n<li><code>&lt;button v-on:事件名=&quot;事件函数&quot;&gt;按钮&lt;/button&gt;</code>，需要在methods中提供事件处理函数</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">搬砖</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">卖房</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n  <span class="token comment">// 提供方法</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'你好啊\'</span><span class="token punctuation">)</span>\n      <span class="token comment">// console.log(this)</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>money<span class="token operator">++</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">fn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">+=</span> <span class="token number">10000</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li>\n<li>\n<p>需要传递参数</p>\n<ul>\n<li><code>&lt;button v-on:事件名=&quot;事件函数(参数)&quot;&gt;按钮&lt;/button&gt;</code>，需要在methods中提供事件函数，接受参数</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addMoney(1)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">搬砖</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addMoney(10000)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">卖房</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">addMoney</span> <span class="token punctuation">(</span><span class="token parameter">money</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">+=</span> money\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li>\n<li>\n<p>如果事件的逻辑足够简单，可以不提供函数</p>\n</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>money++<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">搬砖</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>money += 10000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">卖房</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="vue中获取事件对象-了解" tabindex="-1"><a class="header-anchor" href="#vue中获取事件对象-了解" aria-hidden="true">#</a> vue中获取事件对象(了解)</h3>\n<p>需求: 默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()</p>\n<p>vue中获取事件对象</p>\n<p>(1) 没有传参, 通过形参接收 e</p>\n<p>(2) 传参了, 通过$event指代事件对象 e</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;a @click="fn" href="http://www.baidu.com">去百度</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;a @click="fn2(100, $event)" href="http://www.baidu.com">去百度2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token plain-text">\nexport default {\n  methods: {\n    fn(e) {\n      e.preventDefault()\n    },\n    fn2(num, e) {\n      e.preventDefault()\n    }\n  }\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="v-on-事件修饰符" tabindex="-1"><a class="header-anchor" href="#v-on-事件修饰符" aria-hidden="true">#</a> v-on 事件修饰符</h3>\n<ul>\n<li>\n<p>vue中提供的事件修饰符</p>\n<p>.prevent 阻止默认行为</p>\n<p>.stop 阻止冒泡</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@click.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>去百度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="按键修饰符" tabindex="-1"><a class="header-anchor" href="#按键修饰符" aria-hidden="true">#</a> 按键修饰符</h3>\n<p>需求: 用户输入内容, 回车, 打印输入的内容</p>\n<p>在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符</p>\n<ul>\n<li>\n<p>@keyup.enter  回车</p>\n</li>\n<li>\n<p>@keyup.esc  返回</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@keyup</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@keyup.enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="v-if-和-v-show" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-show" aria-hidden="true">#</a> v-if 和 v-show</h2>\n<h3 id="基本使用-2" tabindex="-1"><a class="header-anchor" href="#基本使用-2" aria-hidden="true">#</a> 基本使用</h3>\n<p>v-show 和 v-if 功能: 控制盒子的显示隐藏</p>\n<ol>\n<li>\n<p>v-show</p>\n<p>语法:  v-show=&quot;布尔值&quot;    (true显示, false隐藏)</p>\n<p>原理:  实质是在控制元素的 css 样式,  <code>display: none;</code></p>\n</li>\n<li>\n<p>v-if</p>\n<p>语法: v-if=&quot;布尔值&quot;   (true显示, false隐藏)</p>\n<p>原理:  实质是在动态的创建 或者 删除元素节点</p>\n</li>\n</ol>\n<p>应用场景:</p>\n<ul>\n<li>\n<p>如果是频繁的切换显示隐藏, 用 v-show</p>\n<p>v-if, 频繁切换会大量的创建和删除元素, 消耗性能</p>\n</li>\n<li>\n<p>如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if</p>\n<p>v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>v-show盒子-{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>v-if盒子-{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="v-else-和-v-else-if" tabindex="-1"><a class="header-anchor" href="#v-else-和-v-else-if" aria-hidden="true">#</a> v-else 和 v-else-if</h3>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isLogin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>尊敬的超级vip, 你好<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>你谁呀, 赶紧登陆~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age >= 60<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>60岁以上, 广场舞<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age >= 30<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>30岁以上, 搓麻将<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age >= 20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>20岁以上, 蹦迪<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>20岁以下, 唱跳rap篮球<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model" aria-hidden="true">#</a> v-model</h2>\n<h3 id="基本使用-3" tabindex="-1"><a class="header-anchor" href="#基本使用-3" aria-hidden="true">#</a> 基本使用</h3>\n<p>**作用: 给表单元素使用, 双向数据绑定 **</p>\n<ol>\n<li>\n<p>数据变化了, 视图会跟着变</p>\n</li>\n<li>\n<p>视图变化了, 数据要跟着变</p>\n<p>输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变</p>\n</li>\n</ol>\n<p>语法: v-model=\'值\'</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n</span></code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="v-model-处理其他表单元素" tabindex="-1"><a class="header-anchor" href="#v-model-处理其他表单元素" aria-hidden="true">#</a> v-model 处理其他表单元素</h3>\n<p><strong>v-model 会忽略掉表单元素原本的value, checked等初始值</strong></p>\n<p>textarea, select, checkbox</p>\n<h3 id="v-model-修饰符" tabindex="-1"><a class="header-anchor" href="#v-model-修饰符" aria-hidden="true">#</a> v-model 修饰符</h3>\n<ul>\n<li>\n<p>number</p>\n<p>如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.number</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果这个值如果这个值无法转数字，则会返回原始的值。</p>\n</li>\n<li>\n<p>trim</p>\n<p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.trim</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n<li>\n<p>lazy</p>\n<p>在<code>change</code>时而非<code>input</code>时更新，可以给 <code>v-model</code> 添加 <code>lazy</code> 修饰符：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.lazy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n</ul>\n<h2 id="v-text-和-v-html" tabindex="-1"><a class="header-anchor" href="#v-text-和-v-html" aria-hidden="true">#</a> v-text 和 v-html</h2>\n<h3 id="v-text指令" tabindex="-1"><a class="header-anchor" href="#v-text指令" aria-hidden="true">#</a> v-text指令</h3>\n<ul>\n<li>解释：更新元素的 <code>textContent/innerText</code>。如果要更新部分的 <code>textContent</code> ，需要使用 <code>{{ Mustache }}</code> 插值。</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="v-html指令" tabindex="-1"><a class="header-anchor" href="#v-html指令" aria-hidden="true">#</a> v-html指令</h3>\n<ul>\n<li>解释：更新DOM对象的<code> innerHTML</code>,html标签会生效</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener noreferrer">XSS 攻击<ExternalLinkIcon/></a>。</strong></p>\n<p><strong>只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</strong></p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/基础概念+vuecli+指令上.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"基础概念+vuecli+指令上",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/基础概念+vuecli+指令上.md",filePathRelative:"Vue/基础概念+vuecli+指令上.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/基础概念+vuecli+指令上.html.vue",componentFilePathRelative:"pages/Vue/基础概念+vuecli+指令上.html.vue",componentFileChunkName:"v-41c2a7b8",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/基础概念+vuecli+指令上.html.js",dataFilePathRelative:"pages/Vue/基础概念+vuecli+指令上.html.js",dataFileChunkName:"v-41c2a7b8",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/基础概念+vuecli+指令上.html",htmlFilePathRelative:"Vue/基础概念+vuecli+指令上.html"},{data:{key:"v-7e7a417e",path:"/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.html",title:"vue指令（下）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-for",slug:"v-for",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"虚拟DOM 和 diff算法",slug:"虚拟dom-和-diff算法",children:[]},{level:3,title:"v-for 的key的说明",slug:"v-for-的key的说明",children:[]}]},{level:2,title:"样式处理",slug:"样式处理",children:[{level:3,title:"v-bind 对于class的增强",slug:"v-bind-对于class的增强",children:[]},{level:3,title:"v-bind对于style 的增强",slug:"v-bind对于style-的增强",children:[]}]},{level:2,title:"基本使用",slug:"基本使用-1",children:[]},{level:2,title:"计算属性的缓存的问题",slug:"计算属性的缓存的问题",children:[]},{level:2,title:"计算属性的完整写法",slug:"计算属性的完整写法",children:[]},{level:2,title:"基本使用",slug:"基本使用-2",children:[]},{level:2,title:"复杂类型的监听-监听的完整写法",slug:"复杂类型的监听-监听的完整写法",children:[]},{level:2,title:"成绩案例-监听数据进行缓存",slug:"成绩案例-监听数据进行缓存",children:[]},{level:2,title:"配置步骤 （两步）",slug:"配置步骤-两步",children:[]}],git:{}},key:"v-7e7a417e",path:"/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.html",title:"vue指令（下）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-for",slug:"v-for",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"虚拟DOM 和 diff算法",slug:"虚拟dom-和-diff算法",children:[]},{level:3,title:"v-for 的key的说明",slug:"v-for-的key的说明",children:[]}]},{level:2,title:"样式处理",slug:"样式处理",children:[{level:3,title:"v-bind 对于class的增强",slug:"v-bind-对于class的增强",children:[]},{level:3,title:"v-bind对于style 的增强",slug:"v-bind对于style-的增强",children:[]}]},{level:2,title:"基本使用",slug:"基本使用-1",children:[]},{level:2,title:"计算属性的缓存的问题",slug:"计算属性的缓存的问题",children:[]},{level:2,title:"计算属性的完整写法",slug:"计算属性的完整写法",children:[]},{level:2,title:"基本使用",slug:"基本使用-2",children:[]},{level:2,title:"复杂类型的监听-监听的完整写法",slug:"复杂类型的监听-监听的完整写法",children:[]},{level:2,title:"成绩案例-监听数据进行缓存",slug:"成绩案例-监听数据进行缓存",children:[]},{level:2,title:"配置步骤 （两步）",slug:"配置步骤-两步",children:[]}],content:'# vue指令（下）\n\n## v-for \n\n### 基本使用\n\n v-for 作用: 遍历对象和数组\n\n1. 遍历数组 (常用)\n\n```jsx\nv-for="item in 数组名"  item每一项\nv-for="(item, index) in 数组名"  item每一项 index下标\n\n注意：item和index不是定死的，可以是任意的名字，但是需要注意 第一项是值  第二项是下标\n```\n\n2. 遍历对象 (一般不用)\n\n```jsx\n\x3c!--\n  v-for也可以遍历对象（不常用）\n  v-for="(值, 键) in 对象"\n--\x3e\n<ul>\n  <li v-for="value in user" :key="value">{{value}}</li>\n</ul>\n<ul>\n  <li v-for="(value, key) in user" :key="key">{{value}} ---{{key}}</li>\n</ul>\n```\n\n3. 遍历数字\n\n```jsx\n\x3c!-- \n  遍历数字\n  语法： v-for="(item, index) in 数字"\n  作用：遍历具体的次数 item从1开始  index下标从0开始的\n--\x3e\n<ul>\n  <li v-for="(item, index) in 10" :key="item">{{item}} ---{{index}}</li>\n</ul>\n```\n\n### 虚拟DOM 和 diff算法\n\n**vue就地复用策略：**Vue会尽可能的就地（同层级，同位置），对比虚拟dom，复用旧dom结构，进行差异化更新。\n\n**虚拟dom**: 本质就是一个个保存节点信息, 属性和内容的 描述真实dom的 JS 对象\n\n**diff算法：**\n\n- 策略1：\n\n  先同层级根元素比较，如果根元素变化，那么不考虑复用，整个dom树删除重建\n\n  先同层级根元素比较，如果根元素不变，对比出属性的变化更新，并考虑往下递归复用。\n\n- 策略2：\n\n  对比同级兄弟元素时，默认按照**下标**进行对比复用。\n\n  对比同级兄弟元素时，如果指定了 key，就会 **按照相同 key 的元素** 来进行对比。\n\n### v-for 的key的说明\n\n1. 设置 和 不设置 key 有什么区别？\n\n   - 不设置 key， 默认同级兄弟元素按照下标进行比较。\n   - 设置了key，按照相同key的新旧元素比较。\n\n2. key值要求是?\n\n   - 字符串或者数值，唯一不重复\n   - 有 id 用 id,  有唯一值用唯一值，实在都没有，才用索引\n\n3. key的好处?\n\n   key的作用：提高虚拟DOM的对比复用性能\n\n以后：只要是写到列表渲染，都推荐加上 key 属性。且 key 推荐是设置成 id， 实在没有，就设置成 index\n\n\n\n## 样式处理\n\n###  v-bind 对于class的增强\n\nv-bind 对于类名操作的增强, 注意点, :class 不会影响到原来的 class 属性\n\n:class="对象/数组"\n\n```jsx\n<template>\n  <div>\n    \x3c!-- \n      v-bind： 作用：设置动态属性\n      v-bind针对 class和style 进行增强\n      允许使用对象或者数组\n        对象：如果键值对的值为true，那么就有这个，否则没有这个类\n        数组：数组中所有的类都会添加到盒子上\n    --\x3e\n    \x3c!-- <div class="box" :class="isRed ? \'red\': \'\'">123</div> --\x3e\n    \x3c!-- <div class="box" :class="{red: isRed, pink: isPink}">123</div> --\x3e\n    <div class="box" :class="arr">123</div>\n  </div>\n</template>\n```\n\n### v-bind对于style 的增强\n\n```jsx\n<template>\n  <div>\n    \x3c!-- \n      :style也可以使用对象或者数组\n     --\x3e\n    <div class="box" :style="[styleObj1, styleObj2]">123</div>\n  </div>\n</template>\n```\n\n# 计算属性\n\n## 基本使用\n\n需求：翻转字符串案例\n\n> 计算属性是一个属性，写法上是一个函数，这个函数的返回值就是计算属性最终的值。\n\n> 1. 计算属性必须定义在 computed 节点中\n\n> 2. 计算属性必须是一个 function,计算属性必须有返回值\n\n> 3. 计算属性不能被当作方法调用,当成属性来用\n\n定义计算属性\n\n```jsx\n// 组件的数据： 需要计算的属性\ncomputed: {\n  reverseMsg () {\n    return this.msg.split(\'\').reverse().join(\'\')\n  }\n}\n```\n\n使用计算属性\n\n```jsx\n<p>{{ reverseMsg }}</p>\n```\n\n## 计算属性的缓存的问题\n\n计算属性： 缓存\n\n计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。\n\n计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存\n\n```jsx\n// 计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。\n// 计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存\nexport default {\n  data () {\n    return {\n      msg: \'hello\'\n    }\n  },\n  computed: {\n    reverseMsg() {\n      console.log(\'我执行了\')\n      return this.msg.split(\'\').reverse().join(\'\')\n    }\n  }\n}\n```\n\n## 计算属性的完整写法\n\n```jsx\n// 1. 计算属性默认情况下只能获取，不能修改。\n// 2. 计算属性的完整写法\n/* \n  computed: {\n    full() {},\n    full: {\n      get() {\n        return this.first + \' \' + this.last\n      },\n      set(value) {\n\n      }\n    }\n  }\n*/\ncomputed: {\n  full: {\n    get () {\n      ...\n    },\n    set (value) {\n      ...\n    }\n  }\n}\n```\n\n\n\n# 属性监听\n\n## 基本使用\n\n当需要监听某个数据是否发生改变，就要用到watch\n\n```jsx\n/* \n  watch: {\n    // 只要属性发生了改变，这个函数就会执行\n    属性: function () {\n\n    }\n  }\n*/\nwatch: {\n  // 参数1： value    变化后的值\n  // 参数2： oldValue 变化前的值\n  msg (value, oldValue) {\n    console.log(\'你变了\', value, oldValue)\n  }\n}\n```\n\n## 复杂类型的监听-监听的完整写法\n\n> 如果监听的是复杂数据类型，需要深度监听，需要指定deep为true,需要用到监听的完整的写法\n\n```jsx\n// 1. 默认情况下，watch只能监听到简单类型的数据变化,如果监听的是复杂类型，只会监听地址是否发生改变，不会监听对象内部属性的变化。\n// 2. 需要使用监听的完整写法 是一个对象\nwatch: {\n  // friend (value) {\n  //   console.log(\'你变了\', value)\n  // }\n  friend: {\n    // handler 数据发生变化，需要执行的处理程序\n    // deep: true  如果true,代表深度监听，不仅会监听地址的变化，还会监听对象内部属性的变化\n    // immediate: 立即 立刻  是否立即监听 默认是false  如果是true,代表页面一加载，会先执行一次处理程序\n    handler (value) {\n      console.log(\'你变了\', value)\n    },\n    deep: true,\n    immediate: true\n  }\n},\n```\n\n## 成绩案例-监听数据进行缓存\n\n+ 监听list的变化\n\n```jsx\nwatch: {\n  list: {\n    deep: true,\n    handler() {\n      localStorage.setItem(\'score-case\', JSON.stringify(this.list))\n    }\n  }\n},\n```\n\n+ 获取list数据的时候不能写死，从localStorage中获取\n\n```jsx\ndata() {\n  return {\n    list: JSON.parse(localStorage.getItem(\'score-case\')) || [],\n    subject: \'\',\n    score: \'\',\n  }\n},\n```\n\n\n\n\n\n# vscode断点调试\n\n前言：作为前端开发，我们经常会遇到代码错误，需要进行调试\n\n常见的调试方案：\n\n- 不调试，直接看代码找问题\n- console.log 打印日志\n- **用 VSCode 的 debugger 来调试** （**断点调试**）\n\n前两种，适合找一些简易的错误，如果短时间错误没有排查出来，建议使用 **vscode断点调试**。\n\n## 配置步骤 （两步）\n\n1. 新建 `.vscode` 目录,  `launch.json` 文件， 填入配置内容\n\n   注意：`端口号` 需要和 启动服务器 `端口号` 统一\n\n```jsx\n{\n  "configurations": [\n    {\n      "name": "Launch Chrome",\n      "request": "launch",\n      "type": "pwa-chrome",\n      "url": "http://localhost:8080",\n      "sourceMapPathOverrides": {\n        "webpack://src/*": "${workspaceFolder}/src/*"\n      }\n    }\n  ]\n}\n```\n\n\n\n2. `vue.config.js` 填入配置内容\n\n```jsx\nconst { defineConfig } = require(\'@vue/cli-service\')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  // -----------------------------------------------------------\n  configureWebpack: config => {\n    // 配置断点调试，实际上线时，可删除\n    config.output.devtoolModuleFilenameTemplate = info => {\n      const resPath = info.resourcePath\n      return `webpack://${resPath}`\n    }\n  }\n  // -----------------------------------------------------------\n})\n```\n',contentRendered:'<h1 id="vue指令-下" tabindex="-1"><a class="header-anchor" href="#vue指令-下" aria-hidden="true">#</a> vue指令（下）</h1>\n<h2 id="v-for" tabindex="-1"><a class="header-anchor" href="#v-for" aria-hidden="true">#</a> v-for</h2>\n<h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h3>\n<p>v-for 作用: 遍历对象和数组</p>\n<ol>\n<li>遍历数组 (常用)</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in 数组名"</span>  item每一项\nv<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(item, index) in 数组名"</span>  item每一项 index下标\n\n注意：item和index不是定死的，可以是任意的名字，但是需要注意 第一项是值  第二项是下标\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="2">\n<li>遍历对象 (一般不用)</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>\n  v<span class="token operator">-</span><span class="token keyword">for</span>也可以遍历对象（不常用）\n  v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(值, 键) in 对象"</span>\n<span class="token operator">--</span><span class="token operator">></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value in user<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(value, key) in user<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token plain-text"> ---</span><span class="token punctuation">{</span><span class="token punctuation">{</span>key<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="3">\n<li>遍历数字</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> \n  遍历数字\n  语法： v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(item, index) in 数字"</span>\n  作用：遍历具体的次数 item从<span class="token number">1</span>开始  index下标从<span class="token number">0</span>开始的\n<span class="token operator">--</span><span class="token operator">></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(item, index) in 10<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token plain-text"> ---</span><span class="token punctuation">{</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="虚拟dom-和-diff算法" tabindex="-1"><a class="header-anchor" href="#虚拟dom-和-diff算法" aria-hidden="true">#</a> 虚拟DOM 和 diff算法</h3>\n<p>**vue就地复用策略：**Vue会尽可能的就地（同层级，同位置），对比虚拟dom，复用旧dom结构，进行差异化更新。</p>\n<p><strong>虚拟dom</strong>: 本质就是一个个保存节点信息, 属性和内容的 描述真实dom的 JS 对象</p>\n<p><strong>diff算法：</strong></p>\n<ul>\n<li>\n<p>策略1：</p>\n<p>先同层级根元素比较，如果根元素变化，那么不考虑复用，整个dom树删除重建</p>\n<p>先同层级根元素比较，如果根元素不变，对比出属性的变化更新，并考虑往下递归复用。</p>\n</li>\n<li>\n<p>策略2：</p>\n<p>对比同级兄弟元素时，默认按照<strong>下标</strong>进行对比复用。</p>\n<p>对比同级兄弟元素时，如果指定了 key，就会 <strong>按照相同 key 的元素</strong> 来进行对比。</p>\n</li>\n</ul>\n<h3 id="v-for-的key的说明" tabindex="-1"><a class="header-anchor" href="#v-for-的key的说明" aria-hidden="true">#</a> v-for 的key的说明</h3>\n<ol>\n<li>\n<p>设置 和 不设置 key 有什么区别？</p>\n<ul>\n<li>不设置 key， 默认同级兄弟元素按照下标进行比较。</li>\n<li>设置了key，按照相同key的新旧元素比较。</li>\n</ul>\n</li>\n<li>\n<p>key值要求是?</p>\n<ul>\n<li>字符串或者数值，唯一不重复</li>\n<li>有 id 用 id,  有唯一值用唯一值，实在都没有，才用索引</li>\n</ul>\n</li>\n<li>\n<p>key的好处?</p>\n<p>key的作用：提高虚拟DOM的对比复用性能</p>\n</li>\n</ol>\n<p>以后：只要是写到列表渲染，都推荐加上 key 属性。且 key 推荐是设置成 id， 实在没有，就设置成 index</p>\n<h2 id="样式处理" tabindex="-1"><a class="header-anchor" href="#样式处理" aria-hidden="true">#</a> 样式处理</h2>\n<h3 id="v-bind-对于class的增强" tabindex="-1"><a class="header-anchor" href="#v-bind-对于class的增强" aria-hidden="true">#</a> v-bind 对于class的增强</h3>\n<p>v-bind 对于类名操作的增强, 注意点, :class 不会影响到原来的 class 属性</p>\n<p>:class=&quot;对象/数组&quot;</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- \n      v-bind： 作用：设置动态属性\n      v-bind针对 class和style 进行增强\n      允许使用对象或者数组\n        对象：如果键值对的值为true，那么就有这个，否则没有这个类\n        数组：数组中所有的类都会添加到盒子上\n    --\x3e\n    &lt;!-- </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isRed ? <span class="token punctuation">\'</span>red<span class="token punctuation">\'</span>: <span class="token punctuation">\'</span><span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"> --\x3e\n    &lt;!-- </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{red: isRed, pink: isPink}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"> --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>arr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="v-bind对于style-的增强" tabindex="-1"><a class="header-anchor" href="#v-bind对于style-的增强" aria-hidden="true">#</a> v-bind对于style 的增强</h3>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- \n      :style也可以使用对象或者数组\n     --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[styleObj1, styleObj2]<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="计算属性" tabindex="-1"><a class="header-anchor" href="#计算属性" aria-hidden="true">#</a> 计算属性</h1>\n<h2 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1" aria-hidden="true">#</a> 基本使用</h2>\n<p>需求：翻转字符串案例</p>\n<blockquote>\n<p>计算属性是一个属性，写法上是一个函数，这个函数的返回值就是计算属性最终的值。</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>计算属性必须定义在 computed 节点中</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start="2">\n<li>计算属性必须是一个 function,计算属性必须有返回值</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start="3">\n<li>计算属性不能被当作方法调用,当成属性来用</li>\n</ol>\n</blockquote>\n<p>定义计算属性</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 组件的数据： 需要计算的属性</span>\n<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">reverseMsg</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用计算属性</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> reverseMsg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="计算属性的缓存的问题" tabindex="-1"><a class="header-anchor" href="#计算属性的缓存的问题" aria-hidden="true">#</a> 计算属性的缓存的问题</h2>\n<p>计算属性： 缓存</p>\n<p>计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。</p>\n<p>计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。</span>\n<span class="token comment">// 计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">\'hello\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">reverseMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'我执行了\'</span><span class="token punctuation">)</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="计算属性的完整写法" tabindex="-1"><a class="header-anchor" href="#计算属性的完整写法" aria-hidden="true">#</a> 计算属性的完整写法</h2>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 1. 计算属性默认情况下只能获取，不能修改。</span>\n<span class="token comment">// 2. 计算属性的完整写法</span>\n<span class="token comment">/* \n  computed: {\n    full() {},\n    full: {\n      get() {\n        return this.first + \' \' + this.last\n      },\n      set(value) {\n\n      }\n    }\n  }\n*/</span>\n<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">full</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token operator">...</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token operator">...</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="属性监听" tabindex="-1"><a class="header-anchor" href="#属性监听" aria-hidden="true">#</a> 属性监听</h1>\n<h2 id="基本使用-2" tabindex="-1"><a class="header-anchor" href="#基本使用-2" aria-hidden="true">#</a> 基本使用</h2>\n<p>当需要监听某个数据是否发生改变，就要用到watch</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">/* \n  watch: {\n    // 只要属性发生了改变，这个函数就会执行\n    属性: function () {\n\n    }\n  }\n*/</span>\n<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 参数1： value    变化后的值</span>\n  <span class="token comment">// 参数2： oldValue 变化前的值</span>\n  <span class="token function">msg</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'你变了\'</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="复杂类型的监听-监听的完整写法" tabindex="-1"><a class="header-anchor" href="#复杂类型的监听-监听的完整写法" aria-hidden="true">#</a> 复杂类型的监听-监听的完整写法</h2>\n<blockquote>\n<p>如果监听的是复杂数据类型，需要深度监听，需要指定deep为true,需要用到监听的完整的写法</p>\n</blockquote>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 1. 默认情况下，watch只能监听到简单类型的数据变化,如果监听的是复杂类型，只会监听地址是否发生改变，不会监听对象内部属性的变化。</span>\n<span class="token comment">// 2. 需要使用监听的完整写法 是一个对象</span>\n<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// friend (value) {</span>\n  <span class="token comment">//   console.log(\'你变了\', value)</span>\n  <span class="token comment">// }</span>\n  <span class="token literal-property property">friend</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// handler 数据发生变化，需要执行的处理程序</span>\n    <span class="token comment">// deep: true  如果true,代表深度监听，不仅会监听地址的变化，还会监听对象内部属性的变化</span>\n    <span class="token comment">// immediate: 立即 立刻  是否立即监听 默认是false  如果是true,代表页面一加载，会先执行一次处理程序</span>\n    <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'你变了\'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="成绩案例-监听数据进行缓存" tabindex="-1"><a class="header-anchor" href="#成绩案例-监听数据进行缓存" aria-hidden="true">#</a> 成绩案例-监听数据进行缓存</h2>\n<ul>\n<li>监听list的变化</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'score-case\'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul>\n<li>获取list数据的时候不能写死，从localStorage中获取</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">\'score-case\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">subject</span><span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">score</span><span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h1 id="vscode断点调试" tabindex="-1"><a class="header-anchor" href="#vscode断点调试" aria-hidden="true">#</a> vscode断点调试</h1>\n<p>前言：作为前端开发，我们经常会遇到代码错误，需要进行调试</p>\n<p>常见的调试方案：</p>\n<ul>\n<li>不调试，直接看代码找问题</li>\n<li>console.log 打印日志</li>\n<li><strong>用 VSCode 的 debugger 来调试</strong> （<strong>断点调试</strong>）</li>\n</ul>\n<p>前两种，适合找一些简易的错误，如果短时间错误没有排查出来，建议使用 <strong>vscode断点调试</strong>。</p>\n<h2 id="配置步骤-两步" tabindex="-1"><a class="header-anchor" href="#配置步骤-两步" aria-hidden="true">#</a> 配置步骤 （两步）</h2>\n<ol>\n<li>\n<p>新建 <code>.vscode</code> 目录,  <code>launch.json</code> 文件， 填入配置内容</p>\n<p>注意：<code>端口号</code> 需要和 启动服务器 <code>端口号</code> 统一</p>\n</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token punctuation">{</span>\n  <span class="token string-property property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"Launch Chrome"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"pwa-chrome"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"url"</span><span class="token operator">:</span> <span class="token string">"http://localhost:8080"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"sourceMapPathOverrides"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token string-property property">"webpack://src/*"</span><span class="token operator">:</span> <span class="token string">"${workspaceFolder}/src/*"</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ol start="2">\n<li><code>vue.config.js</code> 填入配置内容</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'@vue/cli-service\'</span><span class="token punctuation">)</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">transpileDependencies</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token comment">// -----------------------------------------------------------</span>\n  <span class="token function-variable function">configureWebpack</span><span class="token operator">:</span> <span class="token parameter">config</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 配置断点调试，实际上线时，可删除</span>\n    config<span class="token punctuation">.</span>output<span class="token punctuation">.</span><span class="token function-variable function">devtoolModuleFilenameTemplate</span> <span class="token operator">=</span> <span class="token parameter">info</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> resPath <span class="token operator">=</span> info<span class="token punctuation">.</span>resourcePath\n      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">webpack://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>resPath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// -----------------------------------------------------------</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/指令下+计算属性+侦听器.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"指令下+计算属性+侦听器",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/指令下+计算属性+侦听器.md",filePathRelative:"Vue/指令下+计算属性+侦听器.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/指令下+计算属性+侦听器.html.vue",componentFilePathRelative:"pages/Vue/指令下+计算属性+侦听器.html.vue",componentFileChunkName:"v-7e7a417e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/指令下+计算属性+侦听器.html.js",dataFilePathRelative:"pages/Vue/指令下+计算属性+侦听器.html.js",dataFileChunkName:"v-7e7a417e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/指令下+计算属性+侦听器.html",htmlFilePathRelative:"Vue/指令下+计算属性+侦听器.html"},{data:{key:"v-a25da32e",path:"/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.html",title:"生命周期",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"研究生命周期的意义",slug:"研究生命周期的意义",children:[]},{level:2,title:"生命周期函数(钩子函数)",slug:"生命周期函数-钩子函数",children:[]},{level:2,title:"组件生命周期分类",slug:"组件生命周期分类",children:[]},{level:2,title:"SPA - 单页应用程序",slug:"spa-单页应用程序",children:[{level:3,title:"优势",slug:"优势",children:[]},{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"路由介绍",slug:"路由介绍",children:[]},{level:2,title:"vue-router介绍",slug:"vue-router介绍",children:[{level:3,title:"路由 - 组件分类",slug:"路由-组件分类",children:[]}]},{level:2,title:"vue-router使用",slug:"vue-router使用",children:[]},{level:2,title:"配置路由规则",slug:"配置路由规则",children:[]},{level:2,title:"路由的封装",slug:"路由的封装",children:[]},{level:2,title:"vue路由 - 声明式导航",slug:"vue路由-声明式导航",children:[{level:3,title:"声明式导航 - 基础使用",slug:"声明式导航-基础使用",children:[]},{level:3,title:"导航高亮",slug:"导航高亮",children:[]},{level:3,title:"路由使用巩固 - 练习",slug:"路由使用巩固-练习",children:[]},{level:3,title:"声明式导航 - 跳转传参",slug:"声明式导航-跳转传参",children:[]}]},{level:2,title:"vue路由 - 重定向和模式",slug:"vue路由-重定向和模式",children:[{level:3,title:"路由 - 重定向",slug:"路由-重定向",children:[]},{level:3,title:"路由 - 404页面",slug:"路由-404页面",children:[]},{level:3,title:"路由 - 模式设置",slug:"路由-模式设置",children:[]}]},{level:2,title:"vue路由 - 编程式导航",slug:"vue路由-编程式导航",children:[{level:3,title:"编程式导航 - 基础使用",slug:"编程式导航-基础使用",children:[]},{level:3,title:"编程式导航 - 跳转传参",slug:"编程式导航-跳转传参",children:[]}]},{level:2,title:"组件缓存 keep-alive",slug:"组件缓存-keep-alive",children:[{level:3,title:"基本语法",slug:"基本语法",children:[]},{level:3,title:"keep-alive对应的两个钩子",slug:"keep-alive对应的两个钩子",children:[]}]}],git:{}},key:"v-a25da32e",path:"/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.html",title:"生命周期",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"研究生命周期的意义",slug:"研究生命周期的意义",children:[]},{level:2,title:"生命周期函数(钩子函数)",slug:"生命周期函数-钩子函数",children:[]},{level:2,title:"组件生命周期分类",slug:"组件生命周期分类",children:[]},{level:2,title:"SPA - 单页应用程序",slug:"spa-单页应用程序",children:[{level:3,title:"优势",slug:"优势",children:[]},{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"路由介绍",slug:"路由介绍",children:[]},{level:2,title:"vue-router介绍",slug:"vue-router介绍",children:[{level:3,title:"路由 - 组件分类",slug:"路由-组件分类",children:[]}]},{level:2,title:"vue-router使用",slug:"vue-router使用",children:[]},{level:2,title:"配置路由规则",slug:"配置路由规则",children:[]},{level:2,title:"路由的封装",slug:"路由的封装",children:[]},{level:2,title:"vue路由 - 声明式导航",slug:"vue路由-声明式导航",children:[{level:3,title:"声明式导航 - 基础使用",slug:"声明式导航-基础使用",children:[]},{level:3,title:"导航高亮",slug:"导航高亮",children:[]},{level:3,title:"路由使用巩固 - 练习",slug:"路由使用巩固-练习",children:[]},{level:3,title:"声明式导航 - 跳转传参",slug:"声明式导航-跳转传参",children:[]}]},{level:2,title:"vue路由 - 重定向和模式",slug:"vue路由-重定向和模式",children:[{level:3,title:"路由 - 重定向",slug:"路由-重定向",children:[]},{level:3,title:"路由 - 404页面",slug:"路由-404页面",children:[]},{level:3,title:"路由 - 模式设置",slug:"路由-模式设置",children:[]}]},{level:2,title:"vue路由 - 编程式导航",slug:"vue路由-编程式导航",children:[{level:3,title:"编程式导航 - 基础使用",slug:"编程式导航-基础使用",children:[]},{level:3,title:"编程式导航 - 跳转传参",slug:"编程式导航-跳转传参",children:[]}]},{level:2,title:"组件缓存 keep-alive",slug:"组件缓存-keep-alive",children:[{level:3,title:"基本语法",slug:"基本语法",children:[]},{level:3,title:"keep-alive对应的两个钩子",slug:"keep-alive对应的两个钩子",children:[]}]}],content:'# 生命周期\n\n## 研究生命周期的意义\n\n生命周期 => 一个事物从出生 到 消亡的全部过程 \n\n生命周期（Life Cycle）是指一个组件从`创建`-> `运行` -> `销毁`的整个阶段，强调的是一个时间段\n\n- 张三出生，表示这个人生命周期的开始\n- 张三离世，表示这个人生命周期的结束\n- 中间张三的一生，就是张三的生命周期\n\n我们可以把`每个 vue 组件运行的过程`，也概括为生命周期：\n\n- vue 组件的初始化，表示生命周期的开始\n- vue 组件的销毁，表示生命周期的结束\n- vue 组件中间运行的过程，就是组件的生命周期\n\n## 生命周期函数(钩子函数)\n\n**生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。**\n\n生命周期函数的作用：允许程序员在`特定的时间点`，执行某些特定的操作。\n\n例如，组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据。\n\n## 组件生命周期分类\n\nvue 组件的生命周期函数，可以分为 3 大类：\n\n- 组件`初始化阶段`的生命周期函数\n- 组件`运行阶段`的生命周期函数\n- 组件`销毁阶段`的生命周期函数\n\n```js\n1. beforeCreate：data数据初始化之前，组件还没有数据\n2. created: data数据初始化之后，可以获取到组件的数据\n3. beforeMount：DOM渲染之前，DOM还没渲染\n4. mounted：DOM渲染之后，可以操作DOM了\n5. beforeUpdate: 数据更新，DOM更新前\n6. updated: 数据更新，DOM更新后\n7. beforeDestroy: 组件销毁前\n8. destroyed: 组件销毁后\n```\n\n\n\n\n\n# 单页应用程序与路由\n\n## SPA - 单页应用程序\n\n- SPA： `Single Page Application`  单页面应用程序\n- MPA : `Multiple Page Application`多页面应用程序 \n\n[SPA ](https://baike.baidu.com/item/SPA/17536313?fr=aladdin)\n\n[网易云音乐](https://music.163.com/)\n\n### 优势\n\n- 传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面\n- 单页面应用程序只有第一次会加载完整的页面\n- 以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力\n- SPA更好的用户体验，运行更加流畅\n\n### 缺点\n\n1. 开发成本高 (需要学习路由)  `vue-router   react-router`\n2. **不利于 SEO** 搜索引擎优化    谷歌浏览器在解决这个问题    ssr:服务端渲染 server side rendering\n\n## 路由介绍\n\n- **路由** : 是浏览器 **URL 中的哈希值**( # hash) 与 **展示视图内容(组件)** 之间的对应规则\n  - 简单来说,路由就是一套映射规则(一对一的对应规则), 由开发人员制定规则.- \n  - 当 URL 中的哈希值( `#` hash) 发生改变后,路由会根据制定好的**规则**, 展示对应的视图内容(组件)\n- **为什么要学习路由?**\n  - 渐进式 =>vue => vuer-router (管理组件之间的跳转)\n  - 在 web App 中, 经常会出现通过一个页面来展示和管理整个应用的功能.\n  - SPA 往往是功能复杂的应用,为了有效管理所有视图内容,前端路由 应运而生.\n- **vue 中的路由** : 是 **hash** 和 **component** 的对应关系, **一个哈希值对应一个组件**\n\n> 目标: 设备和ip的映射关系\n\n\n\n> 目标: 路径和组件的映射关系\n\n\n\n# vue-router\n\n## vue-router介绍\n\n> 目标: 如何在Vue项目中集成路由\n\n官网: https://router.vuejs.org/zh/\n\n### 路由 - 组件分类\n\n> 目标:  .vue文件分2类, 一个是页面组件, 一个是复用组件\n\n.vue文件本质无区别, 方便大家学习和理解, 总结的一个经验\n\nsrc/views(或pages) 文件夹 和 src/components文件夹\n\n* 页面组件 - 页面展示 - 配合路由用\n* 复用组件 - 展示数据/常用于复用\n\n\n\n> 总结: views下的页面组件, 配合路由切换, components下的一般引入到views下的vue中复用展示数据\n\n## vue-router使用\n\n> 目标: 学会vue官方提供的vue-router路由系统功能模块使用\n\nApp.vue - 页面标签和样式准备(==可复制继续写==)\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <a href="#/find">发现音乐</a>\n      <a href="#/my">我的音乐</a>\n      <a href="#/part">朋友</a>\n    </div>\n    <div class="top">\n      \n    </div>\n  </div>\n</template>\n\n<script>\nexport default {};\n<\/script>\n\n<style scoped>\n.footer_wrap {\n  position: fixed;\n  left: 0;\n  top: 0;\n  display: flex;\n  width: 100%;\n  text-align: center;\n  background-color: #333;\n  color: #ccc;\n}\n.footer_wrap a {\n  flex: 1;\n  text-decoration: none;\n  padding: 20px 0;\n  line-height: 20px;\n  background-color: #333;\n  color: #ccc;\n  border: 1px solid black;\n}\n.footer_wrap a:hover {\n  background-color: #555;\n}\n.top {\n  padding-top: 62px;\n}\n</style>\n```\n\n[vue-router文档](https://router.vuejs.org/zh/)\n\n- 安装\n\n```bash\nyarn add vue-router@3.5.3\n```\n\n+ 导入路由 `main.js`中\n\n```js\nimport VueRouter from \'vue-router\'\n```\n\n+ 使用路由插件\n\n```jsx\n// 在vue中，使用使用vue的插件，都需要调用Vue.use()\nVue.use(VueRouter)\n```\n\n+ 创建路由对象\n\n```jsx\nconst router = new VueRouter({\n})\n```\n\n+ 关联到vue实例\n\n```jsx\nnew Vue({\n  router\n})\n```\n\n==效果：地址栏中自动增加了 #==\n\n## 配置路由规则\n\n```js\n// 4. 创建一个路由对象\nconst router = new VueRouter({\n  // 路由的规则\n  // route: 一条路由规则\n  routes: [\n    {\n      // 路径 锚点\n      // 组件\n      path: \'/find\',\n      component: Find,\n    },\n    {\n      path: \'/my\',\n      component: My,\n    },\n    {\n      path: \'/friend\',\n      component: Friend,\n    },\n  ],\n})\n```\n\n==必须指定路由的出口==\n\n```js\n<div class="top">\n  \x3c!-- 路由的出口 --\x3e\n  <router-view></router-view>\n</div>\n```\n\n## 路由的封装\n\n+ 新建文件`router/index.js`\n\n```js\nimport Vue from \'vue\'\n// 2. 导入VueRouter\nimport VueRouter from \'vue-router\'\n\nimport Find from \'../views/Find\'\nimport My from \'../views/My\'\nimport Friend from \'../views/Friend\'\n\n// 3. 使用vue插件  vue的插件想要生效必须调用一个方法  Vue.use(XXXX)\nVue.use(VueRouter)\n\n// 4. 创建一个路由对象\nconst router = new VueRouter({\n  // 路由的规则\n  // route: 一条路由规则\n  routes: [\n    {\n      // 路径 锚点\n      // 组件\n      path: \'/find\',\n      component: Find,\n    },\n    {\n      path: \'/my\',\n      component: My,\n    },\n    {\n      path: \'/friend\',\n      component: Friend,\n    },\n  ],\n})\n\nexport default router\n\n```\n\n+ main.js中\n\n```js\nimport router from \'./router\'\n\nnew Vue({\n  // 5. 关联路由对象和vue实例 data methods\n  render: (h) => h(App),\n  router,\n}).$mount(\'#app\')\n```\n\n\n\n## vue路由 - 声明式导航\n\n### 声明式导航 - 基础使用\n\n> 目标: 可用全局组件router-link来替代a标签\n\n1.  vue-router提供了一个全局组件 router-link\n2.  router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#)\n3.  router-link提供了声明式导航高亮的功能(自带类名)\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <router-link to="/find">发现音乐</router-link>\n      <router-link to="/my">我的音乐</router-link>\n      <router-link to="/part">朋友</router-link>\n    </div>\n    <div class="top">\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {};\n<\/script>\n\n<style scoped>\n/* 省略了 其他样式 */\n.router-link-exact-active,\n.router-link-active {\n  background-color: #555 !important;\n}\n</style>\n```\n\n> 总结: 链接导航, 用router-link配合to, 实现点击切换路由\n\n### 导航高亮\n\n> RouterLink会自动给当前导航添加两个类名\n\n```jsx\n\x3c!-- \n  RouterLink会自动给当前的链接添加两个类名\n    router-link-active: 激活的导航链接   模糊匹配\n    router-link-exact-active:  激活的导航链接 精确匹配\n\n    exact: 必须要精确匹配\n  --\x3e\n <RouterLink to="/" exact>发现音乐</RouterLink>\n<RouterLink to="/my">我的音乐</RouterLink>\n<RouterLink to="/friend">朋友</RouterLink>\n      \n```\n\n可以修改默认高亮的类名\n\n```js\nconst router = new VueRouter({\n  linkActiveClass: \'aa\',\n  linkExactActiveClass: \'aa\',\n  // route: 一条规则\n}\n```\n\n\n\n\n\n### 路由使用巩固 - 练习\n\n目标：实现以下切换效果\n\n### 声明式导航 - 跳转传参\n\n> 目标: 在跳转路由时, 可以给路由对应的组件内传值\n\n在router-link上的to属性传值, 语法格式如下\n\n* /path?参数名=值\n\n* /path/:id – 需要路由对象提前配置 path: “/path/参数名”\n\n对应页面组件接收传递过来的值\n\n* $route.query.参数名\n\n* $route.params.参数名\n\n1. 创建views/Part.vue - 准备接收路由上传递的参数和值\n\n   ```vue\n   <template>\n     <div>\n         <p>关注明星</p>\n         <p>发现精彩</p>\n         <p>寻找伙伴</p>\n         <p>加入我们</p>\n         <p>人名: {{ $route.query.name }} -- {{ $route.params.username }}</p>\n     </div>\n   </template>\n   ```\n\n2. 路由定义\n\n   ```js\n   {\n       path: "/part",\n       component: Part\n     },\n     {\n       path: "/part/:username", // 有:的路径代表要接收具体的值\n       component: Part\n     },\n   ```\n\n3. 导航跳转, 传值给MyGoods.vue组件\n\n   ```vue\n   <router-link to="/part?name=小传">朋友-小传</router-link>\n   <router-link to="/part/小智">朋友-小智</router-link>\n   ```\n\n\n\n## vue路由 - 重定向和模式\n\n### 路由 - 重定向\n\n> 目标: 匹配path后, 强制切换到目标path上\n\n* 网页打开url默认hash值是/路径\n* redirect是设置要重定向到哪个路由路径\n\n例如: 网页默认打开, 匹配路由"/", 强制切换到"/find"上\n\n```js\nconst routes = [\n  {\n    path: "/", // 默认hash值路径\n    redirect: "/find" // 重定向到/find\n    // 浏览器url中#后的路径被改变成/find-重新匹配数组规则\n  }\n]\n```\n\n> 总结: 强制重定向后, 还会重新来数组里匹配一次规则\n\n### 路由 - 404页面\n\n> 目标: 如果路由hash值, 没有和数组里规则匹配\n\n默认给一个404页面\n\n语法: 路由最后, path匹配*(任意路径) – 前面不匹配就命中最后这个, 显示对应组件页面\n\n1. 创建NotFound页面\n\n   ```vue\n   <template>\n     <img src="../assets/404.png" alt="">\n   </template>\n   \n   <script>\n   export default {\n   \n   }\n   <\/script>\n   \n   <style scoped>\n       img{\n           width: 100%;\n       }\n   </style>\n   ```\n\n2. 在main.js - 修改路由配置\n\n   ```js\n   import NotFound from \'@/views/NotFound\'\n   \n   const routes = [\n     // ...省略了其他配置\n     // 404在最后(规则是从前往后逐个比较path)\n     {\n       path: "*",\n       component: NotFound\n     }\n   ]\n   ```\n\n> 总结: 如果路由未命中任何规则, 给出一个兜底的404页面\n\n### 路由 - 模式设置\n\n> 目标: 修改路由在地址栏的模式\n\nhash路由例如:  http://localhost:8080/#/home\n\nhistory路由例如: http://localhost:8080/home  (以后上线需要服务器端支持)\n\n[模式文档](https://router.vuejs.org/zh/api/#mode)\n\nrouter/index.js\n\n```js\nconst router = new VueRouter({\n  routes,\n  mode: "history" // 打包上线后需要后台支持, 模式是hash\n})\n```\n\n## vue路由 - 编程式导航\n\n> 编程式导航用JS代码跳转\n>\n> 声明式导航用a标签\n\n### 编程式导航 - 基础使用\n\n> 目标: 用JS代码来进行跳转\n\n语法:\n\n```js\nthis.$router.push({\n    path: "路由路径", // 都去 router/index.js定义\n    name: "路由名"\n})\n```\n\n1. main.js - 路由数组里, 给路由起名字\n\n```json\n{\n    path: "/find",\n    name: "Find",\n    component: Find\n},\n{\n    path: "/my",\n    name: "My",\n    component: My\n},\n{\n    path: "/part",\n    name: "Part",\n    component: Part\n},\n```\n\n2. App.vue - 换成span 配合js的编程式导航跳转\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <span @click="btn(\'/find\', \'Find\')">发现音乐</span>\n      <span @click="btn(\'/my\', \'My\')">我的音乐</span>\n      <span @click="btn(\'/part\', \'Part\')">朋友</span>\n    </div>\n    <div class="top">\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\n// 目标: 编程式导航 - js方式跳转路由\n// 语法:\n// this.$router.push({path: "路由路径"})\n// this.$router.push({name: "路由名"})\n// 注意:\n// 虽然用name跳转, 但是url的hash值还是切换path路径值\n// 场景:\n// 方便修改: name路由名(在页面上看不见随便定义)\n// path可以在url的hash值看到(尽量符合组内规范)\nexport default {\n  methods: {\n    btn(targetPath, targetName){\n      // 方式1: path跳转\n      this.$router.push({\n        // path: targetPath,\n        name: targetName\n      })\n    }\n  }\n};\n<\/script>\n```\n\n### 编程式导航 - 跳转传参\n\n> 目标: JS跳转路由, 传参\n\n语法 query / params 任选 一个\n\n```js\nthis.$router.push({\n    path: "路由路径"\n    name: "路由名",\n    query: {\n    \t"参数名": 值\n    }\n    params: {\n\t\t"参数名": 值\n    }\n})\n\n// 对应路由接收   $route.params.参数名   取值\n// 对应路由接收   $route.query.参数名    取值\n```\n\n==格外注意: 使用path会自动忽略params==\n\nApp.vue\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <span @click="btn(\'/find\', \'Find\')">发现音乐</span>\n      <span @click="btn(\'/my\', \'My\')">我的音乐</span>\n      <span @click="oneBtn">朋友-小传</span>\n      <span @click="twoBtn">朋友-小智</span>\n    </div>\n    <div class="top">\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\n// 目标: 编程式导航 - 跳转路由传参\n// 方式1:\n// params => $route.params.参数名\n// 方式2:\n// query => $route.query.参数名\n// 重要: path会自动忽略params\n// 推荐: name+query方式传参\n// 注意: 如果当前url上"hash值和?参数"与你要跳转到的"hash值和?参数"一致, 爆出冗余导航的问题, 不会跳转路由\nexport default {\n  methods: {\n    btn(targetPath, targetName){\n      // 方式1: path跳转\n      this.$router.push({\n        // path: targetPath,\n        name: targetName\n      })\n    },\n    oneBtn(){\n      this.$router.push({\n        name: \'Part\',\n        params: {\n          username: \'小传\'\n        }\n      })\n    },\n    twoBtn(){\n      this.$router.push({\n        name: \'Part\',\n        query: {\n          name: \'小智\'\n        }\n      })\n    }\n  }\n};\n<\/script>\n```\n\n## 组件缓存 keep-alive\n\n### 基本语法\n\n思考：从面经 点到 收藏，又点回 面经，面经的数据需要重新加载么？不需要，希望缓存下来！\n\n如果希望组件被缓存下来，可以在外面包一个 keep-alive 组件 ~\n\n![image-20220613022957478](images/image-20220613022957478.png)\n\n`src/views/Layout.vue`\n\n```jsx\n<template>\n  <div class="h5-wrapper">\n    <div class="content">\n      <keep-alive>\n        <router-view></router-view>\n      </keep-alive>\n    </div>\n    <nav class="tabbar">\n      <router-link to="/article">面经</router-link>\n      <router-link to="/collect">收藏</router-link>\n      <router-link to="/like">喜欢</router-link>\n      <router-link to="/user">我的</router-link>\n    </nav>\n  </div>\n</template>\n```\n\n\n\n### keep-alive对应的两个钩子\n\n当组件被keep-alive管理时，会多出两个生命周期钩子，activated  /  deactivated\n\n`src/views/Article.vue`\n\n```jsx\nexport default {\n  name: \'ArticlePage\',\n  data() {\n    return {\n      articles: []\n    };\n  },\n  async created() {\n    const { data } = await axios.get(\n      \'https://mock.boxuegu.com/mock/3083/articles\',\n    );\n    this.articles = data.result.rows;\n    console.log(this.articles)\n  },\n  activated() {\n    console.log(\'缓存组件被激活\')\n  },\n  deactivated() {\n    console.log(\'缓存组件被隐藏\')\n  }\n};\n```\n\n\n\n\n\n',contentRendered:'<h1 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h1>\n<h2 id="研究生命周期的意义" tabindex="-1"><a class="header-anchor" href="#研究生命周期的意义" aria-hidden="true">#</a> 研究生命周期的意义</h2>\n<p>生命周期 =&gt; 一个事物从出生 到 消亡的全部过程</p>\n<p>生命周期（Life Cycle）是指一个组件从<code>创建</code>-&gt; <code>运行</code> -&gt; <code>销毁</code>的整个阶段，强调的是一个时间段</p>\n<ul>\n<li>张三出生，表示这个人生命周期的开始</li>\n<li>张三离世，表示这个人生命周期的结束</li>\n<li>中间张三的一生，就是张三的生命周期</li>\n</ul>\n<p>我们可以把<code>每个 vue 组件运行的过程</code>，也概括为生命周期：</p>\n<ul>\n<li>vue 组件的初始化，表示生命周期的开始</li>\n<li>vue 组件的销毁，表示生命周期的结束</li>\n<li>vue 组件中间运行的过程，就是组件的生命周期</li>\n</ul>\n<h2 id="生命周期函数-钩子函数" tabindex="-1"><a class="header-anchor" href="#生命周期函数-钩子函数" aria-hidden="true">#</a> 生命周期函数(钩子函数)</h2>\n<p><strong>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。</strong></p>\n<p>生命周期函数的作用：允许程序员在<code>特定的时间点</code>，执行某些特定的操作。</p>\n<p>例如，组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据。</p>\n<h2 id="组件生命周期分类" tabindex="-1"><a class="header-anchor" href="#组件生命周期分类" aria-hidden="true">#</a> 组件生命周期分类</h2>\n<p>vue 组件的生命周期函数，可以分为 3 大类：</p>\n<ul>\n<li>组件<code>初始化阶段</code>的生命周期函数</li>\n<li>组件<code>运行阶段</code>的生命周期函数</li>\n<li>组件<code>销毁阶段</code>的生命周期函数</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">1.</span> beforeCreate：data数据初始化之前，组件还没有数据\n<span class="token number">2.</span> <span class="token literal-property property">created</span><span class="token operator">:</span> data数据初始化之后，可以获取到组件的数据\n<span class="token number">3.</span> beforeMount：<span class="token constant">DOM</span>渲染之前，<span class="token constant">DOM</span>还没渲染\n<span class="token number">4.</span> mounted：<span class="token constant">DOM</span>渲染之后，可以操作<span class="token constant">DOM</span>了\n<span class="token number">5.</span> <span class="token literal-property property">beforeUpdate</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新前\n<span class="token number">6.</span> <span class="token literal-property property">updated</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新后\n<span class="token number">7.</span> <span class="token literal-property property">beforeDestroy</span><span class="token operator">:</span> 组件销毁前\n<span class="token number">8.</span> <span class="token literal-property property">destroyed</span><span class="token operator">:</span> 组件销毁后\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="单页应用程序与路由" tabindex="-1"><a class="header-anchor" href="#单页应用程序与路由" aria-hidden="true">#</a> 单页应用程序与路由</h1>\n<h2 id="spa-单页应用程序" tabindex="-1"><a class="header-anchor" href="#spa-单页应用程序" aria-hidden="true">#</a> SPA - 单页应用程序</h2>\n<ul>\n<li>SPA： <code>Single Page Application</code>  单页面应用程序</li>\n<li>MPA : <code>Multiple Page Application</code>多页面应用程序</li>\n</ul>\n<p><a href="https://baike.baidu.com/item/SPA/17536313?fr=aladdin" target="_blank" rel="noopener noreferrer">SPA <ExternalLinkIcon/></a></p>\n<p><a href="https://music.163.com/" target="_blank" rel="noopener noreferrer">网易云音乐<ExternalLinkIcon/></a></p>\n<h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h3>\n<ul>\n<li>传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面</li>\n<li>单页面应用程序只有第一次会加载完整的页面</li>\n<li>以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>\n<li>SPA更好的用户体验，运行更加流畅</li>\n</ul>\n<h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3>\n<ol>\n<li>开发成本高 (需要学习路由)  <code>vue-router   react-router</code></li>\n<li><strong>不利于 SEO</strong> 搜索引擎优化    谷歌浏览器在解决这个问题    ssr:服务端渲染 server side rendering</li>\n</ol>\n<h2 id="路由介绍" tabindex="-1"><a class="header-anchor" href="#路由介绍" aria-hidden="true">#</a> 路由介绍</h2>\n<ul>\n<li><strong>路由</strong> : 是浏览器 <strong>URL 中的哈希值</strong>( # hash) 与 <strong>展示视图内容(组件)</strong> 之间的对应规则\n<ul>\n<li>简单来说,路由就是一套映射规则(一对一的对应规则), 由开发人员制定规则.-</li>\n<li>当 URL 中的哈希值( <code>#</code> hash) 发生改变后,路由会根据制定好的<strong>规则</strong>, 展示对应的视图内容(组件)</li>\n</ul>\n</li>\n<li><strong>为什么要学习路由?</strong>\n<ul>\n<li>渐进式 =&gt;vue =&gt; vuer-router (管理组件之间的跳转)</li>\n<li>在 web App 中, 经常会出现通过一个页面来展示和管理整个应用的功能.</li>\n<li>SPA 往往是功能复杂的应用,为了有效管理所有视图内容,前端路由 应运而生.</li>\n</ul>\n</li>\n<li><strong>vue 中的路由</strong> : 是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系, <strong>一个哈希值对应一个组件</strong></li>\n</ul>\n<blockquote>\n<p>目标: 设备和ip的映射关系</p>\n</blockquote>\n<blockquote>\n<p>目标: 路径和组件的映射关系</p>\n</blockquote>\n<h1 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> vue-router</h1>\n<h2 id="vue-router介绍" tabindex="-1"><a class="header-anchor" href="#vue-router介绍" aria-hidden="true">#</a> vue-router介绍</h2>\n<blockquote>\n<p>目标: 如何在Vue项目中集成路由</p>\n</blockquote>\n<p>官网: https://router.vuejs.org/zh/</p>\n<h3 id="路由-组件分类" tabindex="-1"><a class="header-anchor" href="#路由-组件分类" aria-hidden="true">#</a> 路由 - 组件分类</h3>\n<blockquote>\n<p>目标:  .vue文件分2类, 一个是页面组件, 一个是复用组件</p>\n</blockquote>\n<p>.vue文件本质无区别, 方便大家学习和理解, 总结的一个经验</p>\n<p>src/views(或pages) 文件夹 和 src/components文件夹</p>\n<ul>\n<li>页面组件 - 页面展示 - 配合路由用</li>\n<li>复用组件 - 展示数据/常用于复用</li>\n</ul>\n<blockquote>\n<p>总结: views下的页面组件, 配合路由切换, components下的一般引入到views下的vue中复用展示数据</p>\n</blockquote>\n<h2 id="vue-router使用" tabindex="-1"><a class="header-anchor" href="#vue-router使用" aria-hidden="true">#</a> vue-router使用</h2>\n<blockquote>\n<p>目标: 学会vue官方提供的vue-router路由系统功能模块使用</p>\n</blockquote>\n<p>App.vue - 页面标签和样式准备(==可复制继续写==)</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/find<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/my<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/part<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      \n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.footer_wrap</span> <span class="token punctuation">{</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> #ccc<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.footer_wrap a</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n  <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 20px 0<span class="token punctuation">;</span>\n  <span class="token property">line-height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> #ccc<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.footer_wrap a:hover</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #555<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.top</span> <span class="token punctuation">{</span>\n  <span class="token property">padding-top</span><span class="token punctuation">:</span> 62px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">vue-router文档<ExternalLinkIcon/></a></p>\n<ul>\n<li>安装</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> vue-router@3.5.3\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>导入路由 <code>main.js</code>中</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">\'vue-router\'</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>使用路由插件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 在vue中，使用使用vue的插件，都需要调用Vue.use()</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul>\n<li>创建路由对象</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul>\n<li>关联到vue实例</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  router\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>==效果：地址栏中自动增加了 #==</p>\n<h2 id="配置路由规则" tabindex="-1"><a class="header-anchor" href="#配置路由规则" aria-hidden="true">#</a> 配置路由规则</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 4. 创建一个路由对象</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 路由的规则</span>\n  <span class="token comment">// route: 一条路由规则</span>\n  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token comment">// 路径 锚点</span>\n      <span class="token comment">// 组件</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/find\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Find<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/my\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> My<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/friend\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Friend<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>==必须指定路由的出口==</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"top"</span><span class="token operator">></span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 路由的出口 <span class="token operator">--</span><span class="token operator">></span>\n  <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="路由的封装" tabindex="-1"><a class="header-anchor" href="#路由的封装" aria-hidden="true">#</a> 路由的封装</h2>\n<ul>\n<li>新建文件<code>router/index.js</code></li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token comment">// 2. 导入VueRouter</span>\n<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">\'vue-router\'</span>\n\n<span class="token keyword">import</span> Find <span class="token keyword">from</span> <span class="token string">\'../views/Find\'</span>\n<span class="token keyword">import</span> My <span class="token keyword">from</span> <span class="token string">\'../views/My\'</span>\n<span class="token keyword">import</span> Friend <span class="token keyword">from</span> <span class="token string">\'../views/Friend\'</span>\n\n<span class="token comment">// 3. 使用vue插件  vue的插件想要生效必须调用一个方法  Vue.use(XXXX)</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>\n\n<span class="token comment">// 4. 创建一个路由对象</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 路由的规则</span>\n  <span class="token comment">// route: 一条路由规则</span>\n  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token comment">// 路径 锚点</span>\n      <span class="token comment">// 组件</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/find\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Find<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/my\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> My<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/friend\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Friend<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> router\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><ul>\n<li>main.js中</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">\'./router\'</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 5. 关联路由对象和vue实例 data methods</span>\n  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  router<span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="vue路由-声明式导航" tabindex="-1"><a class="header-anchor" href="#vue路由-声明式导航" aria-hidden="true">#</a> vue路由 - 声明式导航</h2>\n<h3 id="声明式导航-基础使用" tabindex="-1"><a class="header-anchor" href="#声明式导航-基础使用" aria-hidden="true">#</a> 声明式导航 - 基础使用</h3>\n<blockquote>\n<p>目标: 可用全局组件router-link来替代a标签</p>\n</blockquote>\n<ol>\n<li>vue-router提供了一个全局组件 router-link</li>\n<li>router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#)</li>\n<li>router-link提供了声明式导航高亮的功能(自带类名)</li>\n</ol>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/find<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/my<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/part<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token comment">/* 省略了 其他样式 */</span>\n<span class="token selector">.router-link-exact-active,\n.router-link-active</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #555 <span class="token important">!important</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote>\n<p>总结: 链接导航, 用router-link配合to, 实现点击切换路由</p>\n</blockquote>\n<h3 id="导航高亮" tabindex="-1"><a class="header-anchor" href="#导航高亮" aria-hidden="true">#</a> 导航高亮</h3>\n<blockquote>\n<p>RouterLink会自动给当前导航添加两个类名</p>\n</blockquote>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> \n  RouterLink会自动给当前的链接添加两个类名\n    router<span class="token operator">-</span>link<span class="token operator">-</span>active<span class="token operator">:</span> 激活的导航链接   模糊匹配\n    router<span class="token operator">-</span>link<span class="token operator">-</span>exact<span class="token operator">-</span>active<span class="token operator">:</span>  激活的导航链接 精确匹配\n\n    <span class="token literal-property property">exact</span><span class="token operator">:</span> 必须要精确匹配\n  <span class="token operator">--</span><span class="token operator">></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RouterLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span> <span class="token attr-name">exact</span><span class="token punctuation">></span></span><span class="token plain-text">发现音乐</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RouterLink</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RouterLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/my<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我的音乐</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RouterLink</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RouterLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/friend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">朋友</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RouterLink</span></span><span class="token punctuation">></span></span>\n      \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以修改默认高亮的类名</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">linkActiveClass</span><span class="token operator">:</span> <span class="token string">\'aa\'</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">linkExactActiveClass</span><span class="token operator">:</span> <span class="token string">\'aa\'</span><span class="token punctuation">,</span>\n  <span class="token comment">// route: 一条规则</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="路由使用巩固-练习" tabindex="-1"><a class="header-anchor" href="#路由使用巩固-练习" aria-hidden="true">#</a> 路由使用巩固 - 练习</h3>\n<p>目标：实现以下切换效果</p>\n<h3 id="声明式导航-跳转传参" tabindex="-1"><a class="header-anchor" href="#声明式导航-跳转传参" aria-hidden="true">#</a> 声明式导航 - 跳转传参</h3>\n<blockquote>\n<p>目标: 在跳转路由时, 可以给路由对应的组件内传值</p>\n</blockquote>\n<p>在router-link上的to属性传值, 语法格式如下</p>\n<ul>\n<li>\n<p>/path?参数名=值</p>\n</li>\n<li>\n<p>/path/:id – 需要路由对象提前配置 path: “/path/参数名”</p>\n</li>\n</ul>\n<p>对应页面组件接收传递过来的值</p>\n<ul>\n<li>\n<p>$route.query.参数名</p>\n</li>\n<li>\n<p>$route.params.参数名</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>创建views/Part.vue - 准备接收路由上传递的参数和值</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>关注明星<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>发现精彩<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>寻找伙伴<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>加入我们<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>人名: {{ $route.query.name }} -- {{ $route.params.username }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li>\n<li>\n<p>路由定义</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/part"</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">component</span><span class="token operator">:</span> Part\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/part/:username"</span><span class="token punctuation">,</span> <span class="token comment">// 有:的路径代表要接收具体的值</span>\n    <span class="token literal-property property">component</span><span class="token operator">:</span> Part\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li>\n<li>\n<p>导航跳转, 传值给MyGoods.vue组件</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/part?name=小传<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小传<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/part/小智<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小智<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li>\n</ol>\n<h2 id="vue路由-重定向和模式" tabindex="-1"><a class="header-anchor" href="#vue路由-重定向和模式" aria-hidden="true">#</a> vue路由 - 重定向和模式</h2>\n<h3 id="路由-重定向" tabindex="-1"><a class="header-anchor" href="#路由-重定向" aria-hidden="true">#</a> 路由 - 重定向</h3>\n<blockquote>\n<p>目标: 匹配path后, 强制切换到目标path上</p>\n</blockquote>\n<ul>\n<li>网页打开url默认hash值是/路径</li>\n<li>redirect是设置要重定向到哪个路由路径</li>\n</ul>\n<p>例如: 网页默认打开, 匹配路由&quot;/&quot;, 强制切换到&quot;/find&quot;上</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token comment">// 默认hash值路径</span>\n    <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">"/find"</span> <span class="token comment">// 重定向到/find</span>\n    <span class="token comment">// 浏览器url中#后的路径被改变成/find-重新匹配数组规则</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote>\n<p>总结: 强制重定向后, 还会重新来数组里匹配一次规则</p>\n</blockquote>\n<h3 id="路由-404页面" tabindex="-1"><a class="header-anchor" href="#路由-404页面" aria-hidden="true">#</a> 路由 - 404页面</h3>\n<blockquote>\n<p>目标: 如果路由hash值, 没有和数组里规则匹配</p>\n</blockquote>\n<p>默认给一个404页面</p>\n<p>语法: 路由最后, path匹配*(任意路径) – 前面不匹配就命中最后这个, 显示对应组件页面</p>\n<ol>\n<li>\n<p>创建NotFound页面</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../assets/404.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n    <span class="token selector">img</span><span class="token punctuation">{</span>\n        <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li>\n<li>\n<p>在main.js - 修改路由配置</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> NotFound <span class="token keyword">from</span> <span class="token string">\'@/views/NotFound\'</span>\n\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token comment">// ...省略了其他配置</span>\n  <span class="token comment">// 404在最后(规则是从前往后逐个比较path)</span>\n  <span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"*"</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">component</span><span class="token operator">:</span> NotFound\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li>\n</ol>\n<blockquote>\n<p>总结: 如果路由未命中任何规则, 给出一个兜底的404页面</p>\n</blockquote>\n<h3 id="路由-模式设置" tabindex="-1"><a class="header-anchor" href="#路由-模式设置" aria-hidden="true">#</a> 路由 - 模式设置</h3>\n<blockquote>\n<p>目标: 修改路由在地址栏的模式</p>\n</blockquote>\n<p>hash路由例如:  http://localhost:8080/#/home</p>\n<p>history路由例如: http://localhost:8080/home  (以后上线需要服务器端支持)</p>\n<p><a href="https://router.vuejs.org/zh/api/#mode" target="_blank" rel="noopener noreferrer">模式文档<ExternalLinkIcon/></a></p>\n<p>router/index.js</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token punctuation">,</span>\n  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">"history"</span> <span class="token comment">// 打包上线后需要后台支持, 模式是hash</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="vue路由-编程式导航" tabindex="-1"><a class="header-anchor" href="#vue路由-编程式导航" aria-hidden="true">#</a> vue路由 - 编程式导航</h2>\n<blockquote>\n<p>编程式导航用JS代码跳转</p>\n<p>声明式导航用a标签</p>\n</blockquote>\n<h3 id="编程式导航-基础使用" tabindex="-1"><a class="header-anchor" href="#编程式导航-基础使用" aria-hidden="true">#</a> 编程式导航 - 基础使用</h3>\n<blockquote>\n<p>目标: 用JS代码来进行跳转</p>\n</blockquote>\n<p>语法:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"路由路径"</span><span class="token punctuation">,</span> <span class="token comment">// 都去 router/index.js定义</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"路由名"</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol>\n<li>main.js - 路由数组里, 给路由起名字</li>\n</ol>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">"/find"</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">"Find"</span><span class="token punctuation">,</span>\n    component<span class="token operator">:</span> Find\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">"/my"</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">"My"</span><span class="token punctuation">,</span>\n    component<span class="token operator">:</span> My\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">"/part"</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">"Part"</span><span class="token punctuation">,</span>\n    component<span class="token operator">:</span> Part\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol start="2">\n<li>App.vue - 换成span 配合js的编程式导航跳转</li>\n</ol>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/find<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>Find<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/my<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>My<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/part<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>Part<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token comment">// 目标: 编程式导航 - js方式跳转路由</span>\n<span class="token comment">// 语法:</span>\n<span class="token comment">// this.$router.push({path: "路由路径"})</span>\n<span class="token comment">// this.$router.push({name: "路由名"})</span>\n<span class="token comment">// 注意:</span>\n<span class="token comment">// 虽然用name跳转, 但是url的hash值还是切换path路径值</span>\n<span class="token comment">// 场景:</span>\n<span class="token comment">// 方便修改: name路由名(在页面上看不见随便定义)</span>\n<span class="token comment">// path可以在url的hash值看到(尽量符合组内规范)</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">btn</span><span class="token punctuation">(</span><span class="token parameter">targetPath<span class="token punctuation">,</span> targetName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token comment">// 方式1: path跳转</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token comment">// path: targetPath,</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> targetName\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="编程式导航-跳转传参" tabindex="-1"><a class="header-anchor" href="#编程式导航-跳转传参" aria-hidden="true">#</a> 编程式导航 - 跳转传参</h3>\n<blockquote>\n<p>目标: JS跳转路由, 传参</p>\n</blockquote>\n<p>语法 query / params 任选 一个</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"路由路径"</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"路由名"</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    \t<span class="token string-property property">"参数名"</span><span class="token operator">:</span> 值\n    <span class="token punctuation">}</span>\n    <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n\t\t<span class="token string-property property">"参数名"</span><span class="token operator">:</span> 值\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 对应路由接收   $route.params.参数名   取值</span>\n<span class="token comment">// 对应路由接收   $route.query.参数名    取值</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>==格外注意: 使用path会自动忽略params==</p>\n<p>App.vue</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/find<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>Find<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/my<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>My<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>oneBtn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小传<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>twoBtn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小智<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token comment">// 目标: 编程式导航 - 跳转路由传参</span>\n<span class="token comment">// 方式1:</span>\n<span class="token comment">// params => $route.params.参数名</span>\n<span class="token comment">// 方式2:</span>\n<span class="token comment">// query => $route.query.参数名</span>\n<span class="token comment">// 重要: path会自动忽略params</span>\n<span class="token comment">// 推荐: name+query方式传参</span>\n<span class="token comment">// 注意: 如果当前url上"hash值和?参数"与你要跳转到的"hash值和?参数"一致, 爆出冗余导航的问题, 不会跳转路由</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">btn</span><span class="token punctuation">(</span><span class="token parameter">targetPath<span class="token punctuation">,</span> targetName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token comment">// 方式1: path跳转</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token comment">// path: targetPath,</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> targetName\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">oneBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'Part\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">\'小传\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">twoBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'Part\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'小智\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><h2 id="组件缓存-keep-alive" tabindex="-1"><a class="header-anchor" href="#组件缓存-keep-alive" aria-hidden="true">#</a> 组件缓存 keep-alive</h2>\n<h3 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法" aria-hidden="true">#</a> 基本语法</h3>\n<p>思考：从面经 点到 收藏，又点回 面经，面经的数据需要重新加载么？不需要，希望缓存下来！</p>\n<p>如果希望组件被缓存下来，可以在外面包一个 keep-alive 组件 ~</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220613022957478" originSrc="images/image-20220613022957478.png" data="aurora"></p>\n<p><code>src/views/Layout.vue</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>h5-wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">></span></span><span class="token plain-text">\n        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tabbar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">面经</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/collect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">收藏</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/like<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">喜欢</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我的</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="keep-alive对应的两个钩子" tabindex="-1"><a class="header-anchor" href="#keep-alive对应的两个钩子" aria-hidden="true">#</a> keep-alive对应的两个钩子</h3>\n<p>当组件被keep-alive管理时，会多出两个生命周期钩子，activated  /  deactivated</p>\n<p><code>src/views/Article.vue</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'ArticlePage\'</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">articles</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">async</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>\n      <span class="token string">\'https://mock.boxuegu.com/mock/3083/articles\'</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>articles <span class="token operator">=</span> data<span class="token punctuation">.</span>result<span class="token punctuation">.</span>rows<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>articles<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'缓存组件被激活\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'缓存组件被隐藏\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/生命周期+路由+组件缓存.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"生命周期+路由+组件缓存",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/生命周期+路由+组件缓存.md",filePathRelative:"Vue/生命周期+路由+组件缓存.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/生命周期+路由+组件缓存.html.vue",componentFilePathRelative:"pages/Vue/生命周期+路由+组件缓存.html.vue",componentFileChunkName:"v-a25da32e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/生命周期+路由+组件缓存.html.js",dataFilePathRelative:"pages/Vue/生命周期+路由+组件缓存.html.js",dataFileChunkName:"v-a25da32e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/生命周期+路由+组件缓存.html",htmlFilePathRelative:"Vue/生命周期+路由+组件缓存.html"},{data:{key:"v-1054ac98",path:"/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",title:"组件化开发",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"什么是组件化开发",slug:"什么是组件化开发",children:[]},{level:2,title:"组件的注册",slug:"组件的注册",children:[{level:3,title:"局部注册",slug:"局部注册",children:[]}]},{level:2,title:"全局注册组件",slug:"全局注册组件",children:[{level:3,title:"组件名的大小写",slug:"组件名的大小写",children:[]},{level:3,title:"通过 name 注册组件 (了解)",slug:"通过-name-注册组件-了解",children:[]}]},{level:2,title:"组件的样式冲突  scoped",slug:"组件的样式冲突-scoped",children:[]},{level:2,title:"组件通信 - 父传子 props 传值",slug:"组件通信-父传子-props-传值",children:[]},{level:2,title:"v-for 遍历展示组件练习",slug:"v-for-遍历展示组件练习",children:[]},{level:2,title:"单向数据流",slug:"单向数据流",children:[]},{level:2,title:"组件通信 - 子传父",slug:"组件通信-子传父",children:[]},{level:2,title:"props 校验",slug:"props-校验",children:[]}],git:{}},key:"v-1054ac98",path:"/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",title:"组件化开发",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"什么是组件化开发",slug:"什么是组件化开发",children:[]},{level:2,title:"组件的注册",slug:"组件的注册",children:[{level:3,title:"局部注册",slug:"局部注册",children:[]}]},{level:2,title:"全局注册组件",slug:"全局注册组件",children:[{level:3,title:"组件名的大小写",slug:"组件名的大小写",children:[]},{level:3,title:"通过 name 注册组件 (了解)",slug:"通过-name-注册组件-了解",children:[]}]},{level:2,title:"组件的样式冲突  scoped",slug:"组件的样式冲突-scoped",children:[]},{level:2,title:"组件通信 - 父传子 props 传值",slug:"组件通信-父传子-props-传值",children:[]},{level:2,title:"v-for 遍历展示组件练习",slug:"v-for-遍历展示组件练习",children:[]},{level:2,title:"单向数据流",slug:"单向数据流",children:[]},{level:2,title:"组件通信 - 子传父",slug:"组件通信-子传父",children:[]},{level:2,title:"props 校验",slug:"props-校验",children:[]}],content:"# 组件化开发\n\n## 什么是组件化开发\n\n**组件化开发** 指的是：根据封装的思想，把页面上 `可重用的部分` 封装为 `组件`，从而方便项目的 开发 和 维护。\n\n**一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为**\n\n例如：http://www.ibootstrap.cn/ 所展示的效果，就契合了组件化开发的思想。\n\n用户可以通过拖拽组件的方式，快速生成一个页面的布局结构。\n\n\n\n前端组件化开发的好处主要体现在以下两方面：\n\n- 提高了前端代码的**复用性和灵活性**  \n\n- 提升了开发效率和后期的**可维护性**\n\n\nvue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 `.vue`。\n\n## 组件的注册\n\n刚才我们创建使用的是 App.vue 根组件, 这个比较特殊, 是最大的一个根组件\n\n而App.vue根组件内, 还可以写入一些小组件, 而这些组件, 要使用, 就需要先注册!\n\n**注册组件有两种注册方式**:  分为“全局注册”和“局部注册”两种\n\n- 被全局注册的组件，可以在任意的组件模板范围中使用 通过`Vue.component()`\n- 被局部注册的组件，只能在当前注册的组件模板范围内使用 通过`components`\n\n### 局部注册\n\n+ 把独立的组件封装一个`.vue文件中`，推荐放到`components`文件夹\n\n```jsx\ncomponents\n  -- HmHeader.vue\n  -- HmContent.vue\n  -- HmFooter.vue\n```\n\n+ 通过组件的`components`配置 局部注册组件\n\n```jsx\nimport HmHeader from './components/HmHeader'\nimport HmContent from './components/HmContent'\nimport HmFooter from './components/HmFooter'\n\nexport default {\n  // data methods filters computed watch\n  components: {\n    // 组件名: 组件\n    // 组件名：注意，不能和html内置的标签重名\n    // 使用的时候：直接通过组件名去使用\n    // HmHeader  HmHeader  hm-header\n    HmHeader,\n    HmContent,\n    HmFooter\n  }\n}\n```\n\n==注意点：注册的组件的名字不能和HTML内置的标签重名==\n\n+ 可以在模板中使用组件，，，，使用组件和使用html的标签是一样的，，，可以多次使用\n\n```jsx\n<template>\n  <div>\n    \x3c!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    <hm-header></hm-header>\n    <hm-content></hm-content>\n    <hm-footer></hm-footer>\n  </div>\n</template>\n```\n\n==局部注册的组件只能在当前组件中使用==\n\n## 全局注册组件\n\n+ 在`components`文件夹中创建一些新的组件\n\n```jsx\ncomponents\n  -- HmHeader.vue\n  -- HmContent.vue\n  -- HmFooter.vue\n```\n\n+ 在`main.js`中通过`Vue.component()`全局注册组件\n\n```jsx\nimport HmHeader from './components/HmHeader'\nimport HmContent from './components/HmContent'\nimport HmFooter from './components/HmFooter'\n\n// 全局注册\n// Vue.component(名字, 组件)\nVue.component('HmHeader', HmHeader)\nVue.component('HmContent', HmContent)\nVue.component('HmFooter', HmFooter)\n```\n\n+ 使用\n\n```jsx\n<template>\n  <div>\n    \x3c!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    <hm-header></hm-header>\n    <hm-content></hm-content>\n    <hm-footer></hm-footer>\n  </div>\n</template>\n```\n\n==注意：全局注册的组件 可以在任意的组件中去使用==\n\n\n\n### 组件名的大小写\n\n在进行组件的注册时，定义组件名的方式有两种：\n\n- 注册使用短横线命名法，例如 hm-header 和 hm-main\n\n  ```js\n  Vue.component('hm-button', HmButton)\n  ```\n\n  使用时 `<hm-button> </hm-button>`\n\n- 注册使用大驼峰命名法，例如 HmHeader 和 HmMain\n\n  ```jsx\n  Vue.component('HmButton', HmButton)\n  ```\n\n  使用时 `<HmButton> </HmButton>` 和 `<hm-button> </hm-button>`  都可以\n\n推荐定义组件名时, 用大驼峰命名法, 更加方便\n\n全局注册\n\n```jsx\nVue.component('HmButton', HmButton)\n```\n\n局部注册:\n\n```jsx\ncomponents: {\n  HmHeader,\n  HmMain,\n  HmFooter\n}\n```\n\n使用时, 推荐遵循html5规范, 小写横杠隔开\n\n```jsx\n<hm-header></hm-header>\n<hm-main></hm-main>\n<hm-footer></hm-footer>\n```\n\n### 通过 name 注册组件 (了解)\n\n> 组件在开发者工具中显示的名字可以通过name进行修改\n\n在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的 name 属性作为注册后组件的名称\n\n组件内容:\n\n```jsx\n<template>\n  <button>按钮组件</button>\n</template>\n\n<script>\nexport default {\n  name: 'HmButton'\n}\n<\/script>\n\n<style lang=\"less\">\nbutton {\n  width: 80px;\n  height: 50px;\n  border-radius: 5px;\n  background-color: pink;\n}\n</style>\n```\n\n进行注册:\n\n```jsx\nimport HmButton from './components/hm-button.vue'\nVue.component(HmButton.name, HmButton)  // 等价于 app.component('HmButton', HmButton)\n```\n\n## 组件的样式冲突  `scoped`\n\n默认情况下，写在组件中的样式会`全局生效`，因此很容易造成多个组件之间的样式冲突问题。\n\n组件样式默认会作用到全局, 就会影响到整个 index.html 中的 dom 元素\n\n- `全局样式`: 默认组件中的样式会作用到全局\n\n- `局部样式`: 可以给组件加上 scoped 属性, 可以让样式只作用于当前组件\n\n```jsx\n<style lang=\"less\" scoped>\ndiv {\n  background-color: pink;\n}\n</style>\n```\n\n原理:\n\n1. 添加scoped后, 会给当前组件中所有元素, 添加上一个自定义属性\n\n2. 添加scoped后,  每个style样式, 也会加上对应的属性选择器\n\n\n最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到\n\n# 组件通信\n\n每个组件都有自己的数据, 提供在data中, 每个组件的数据是独立的, 组件数据无法互相直接访问 (合理的)\n\n但是如果需要跨组件访问数据, 就需要用到组件通信\n\n组件通信的方式有很多: 现在先关注两种,  父传子  子传父\n\n## 组件通信 - 父传子 props 传值\n\n语法:\n\n1. 父组件通过给子组件加属性传值\n\n```jsx\n<Son price=\"100\" title=\"不错\" :info=\"msg\"></Son>\n```\n\n2. 子组件中, 通过props属性接收\n\n```js\nprops: ['price', 'title', 'info']\n```\n\n**需求: 封装一个商品组件 my-product**\n\n`my-product.vue`\n\n```vue\n<template>\n  <div class=\"my-product\">\n    <h3>标题: {{ title }}</h3>\n    <p>价格: {{ price }}元</p>\n    <p>{{ info }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['title', 'price', 'info']\n}\n<\/script>\n\n<style>\n.my-product {\n  width: 400px;\n  padding: 20px;\n  border: 2px solid #000;\n  border-radius: 5px;\n  margin: 10px;\n}\n</style>\n```\n\n\n\n## v-for 遍历展示组件练习\n\n**需求: 遍历展示商品列表**\n\n假定, 发送请求回来的商品数据, \n\n```jsx\nlist: [\n  { id: 1, proname: '超级好吃的棒棒糖', proprice: 18.8 },\n  { id: 2, proname: '超级好吃的大鸡腿', proprice: 34.2 },\n  { id: 3, proname: '超级无敌的冰激凌', proprice: 14.2 }\n]\n```\n\nv-for 遍历展示\n\n```jsx\n<template>\n  <div class=\"container\">\n    <h3>我是app组件的内容</h3>\n    <my-product \n      v-for=\"item in list\" :key=\"item.id\" \n      :price=\"item.proprice\" \n      :title=\"item.proname\" \n      :info=\"msg\">\n    </my-product>\n  </div>\n</template>\n```\n\n## 单向数据流\n\n```jsx\n/* \n  在vue中需要遵循单向数据流原则\n  1. 父组件的数据发生了改变，子组件会自动跟着变\n  2. 子组件不能直接修改父组件传递过来的props  props是只读的\n*/\n```\n\n==如果父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，，，，也应该避免==\n\n## 组件通信 - 子传父\n\n**需求: 砍价**\n\n1. 子组件可以通过 `this.$emit('事件名', 参数1, 参数2, ...)` 触发事件的同时传参的\n\n   ```jsx\n   this.$emit('sayPrice', 2)\n   ```\n\n2. 父组件给子组件注册一个自定义事件\n\n   ```jsx\n   <my-product \n     ...\n     @sayPrice=\"sayPrice\">\n   </my-product>\n   ```\n\n   父组件并提供对应的函数接收参数\n\n   ```jsx\n   methods: {\n     sayPrice (num) {\n       console.log(num)\n     }\n   },\n   ```\n\n## props 校验\n\n**props 是父传子, 传递给子组件的数据, 为了提高 子组件被使用时 的稳定性, 可以进行props校验**, 验证传递的数据是否符合要求\n\n默认的数组形式, 不会进行校验, 如果希望校验, 需要提供对象形式的 props\n\n风格指南：https://cn.vuejs.org/v2/style-guide/#Prop-%E5%AE%9A%E4%B9%89%E5%BF%85%E8%A6%81\n\n```jsx\nprops: {\n\t...\n}\n```\n\nprops 提供了多种数据验证方案，例如：\n\n- 基础的类型检查  Number\n- 多个可能的类型 [String, Number]\n- 必填项校验   required: true\n- 默认值 default: 100\n- 自定义验证函数\n\n官网语法: [地址](https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81)\n\n```js\n{\n  props: {\n    // 基础的类型检查\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // -------------------------------------------------------------------------\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n}\n```\n\n\n",contentRendered:'<h1 id="组件化开发" tabindex="-1"><a class="header-anchor" href="#组件化开发" aria-hidden="true">#</a> 组件化开发</h1>\n<h2 id="什么是组件化开发" tabindex="-1"><a class="header-anchor" href="#什么是组件化开发" aria-hidden="true">#</a> 什么是组件化开发</h2>\n<p><strong>组件化开发</strong> 指的是：根据封装的思想，把页面上 <code>可重用的部分</code> 封装为 <code>组件</code>，从而方便项目的 开发 和 维护。</p>\n<p><strong>一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为</strong></p>\n<p>例如：http://www.ibootstrap.cn/ 所展示的效果，就契合了组件化开发的思想。</p>\n<p>用户可以通过拖拽组件的方式，快速生成一个页面的布局结构。</p>\n<p>前端组件化开发的好处主要体现在以下两方面：</p>\n<ul>\n<li>\n<p>提高了前端代码的<strong>复用性和灵活性</strong></p>\n</li>\n<li>\n<p>提升了开发效率和后期的<strong>可维护性</strong></p>\n</li>\n</ul>\n<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 <code>.vue</code>。</p>\n<h2 id="组件的注册" tabindex="-1"><a class="header-anchor" href="#组件的注册" aria-hidden="true">#</a> 组件的注册</h2>\n<p>刚才我们创建使用的是 App.vue 根组件, 这个比较特殊, 是最大的一个根组件</p>\n<p>而App.vue根组件内, 还可以写入一些小组件, 而这些组件, 要使用, 就需要先注册!</p>\n<p><strong>注册组件有两种注册方式</strong>:  分为“全局注册”和“局部注册”两种</p>\n<ul>\n<li>被全局注册的组件，可以在任意的组件模板范围中使用 通过<code>Vue.component()</code></li>\n<li>被局部注册的组件，只能在当前注册的组件模板范围内使用 通过<code>components</code></li>\n</ul>\n<h3 id="局部注册" tabindex="-1"><a class="header-anchor" href="#局部注册" aria-hidden="true">#</a> 局部注册</h3>\n<ul>\n<li>把独立的组件封装一个<code>.vue文件中</code>，推荐放到<code>components</code>文件夹</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>components\n  <span class="token operator">--</span> HmHeader<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmContent<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmFooter<span class="token punctuation">.</span>vue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>通过组件的<code>components</code>配置 局部注册组件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> HmHeader <span class="token keyword">from</span> <span class="token string">\'./components/HmHeader\'</span>\n<span class="token keyword">import</span> HmContent <span class="token keyword">from</span> <span class="token string">\'./components/HmContent\'</span>\n<span class="token keyword">import</span> HmFooter <span class="token keyword">from</span> <span class="token string">\'./components/HmFooter\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// data methods filters computed watch</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 组件名: 组件</span>\n    <span class="token comment">// 组件名：注意，不能和html内置的标签重名</span>\n    <span class="token comment">// 使用的时候：直接通过组件名去使用</span>\n    <span class="token comment">// HmHeader  HmHeader  hm-header</span>\n    HmHeader<span class="token punctuation">,</span>\n    HmContent<span class="token punctuation">,</span>\n    HmFooter\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>==注意点：注册的组件的名字不能和HTML内置的标签重名==</p>\n<ul>\n<li>可以在模板中使用组件，，，，使用组件和使用html的标签是一样的，，，可以多次使用</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-header</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-content</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-footer</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>==局部注册的组件只能在当前组件中使用==</p>\n<h2 id="全局注册组件" tabindex="-1"><a class="header-anchor" href="#全局注册组件" aria-hidden="true">#</a> 全局注册组件</h2>\n<ul>\n<li>在<code>components</code>文件夹中创建一些新的组件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>components\n  <span class="token operator">--</span> HmHeader<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmContent<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmFooter<span class="token punctuation">.</span>vue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>在<code>main.js</code>中通过<code>Vue.component()</code>全局注册组件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> HmHeader <span class="token keyword">from</span> <span class="token string">\'./components/HmHeader\'</span>\n<span class="token keyword">import</span> HmContent <span class="token keyword">from</span> <span class="token string">\'./components/HmContent\'</span>\n<span class="token keyword">import</span> HmFooter <span class="token keyword">from</span> <span class="token string">\'./components/HmFooter\'</span>\n\n<span class="token comment">// 全局注册</span>\n<span class="token comment">// Vue.component(名字, 组件)</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmHeader\'</span><span class="token punctuation">,</span> HmHeader<span class="token punctuation">)</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmContent\'</span><span class="token punctuation">,</span> HmContent<span class="token punctuation">)</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmFooter\'</span><span class="token punctuation">,</span> HmFooter<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul>\n<li>使用</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-header</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-content</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-footer</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>==注意：全局注册的组件 可以在任意的组件中去使用==</p>\n<h3 id="组件名的大小写" tabindex="-1"><a class="header-anchor" href="#组件名的大小写" aria-hidden="true">#</a> 组件名的大小写</h3>\n<p>在进行组件的注册时，定义组件名的方式有两种：</p>\n<ul>\n<li>\n<p>注册使用短横线命名法，例如 hm-header 和 hm-main</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'hm-button\'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>使用时 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code></p>\n</li>\n<li>\n<p>注册使用大驼峰命名法，例如 HmHeader 和 HmMain</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmButton\'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>使用时 <code>&lt;HmButton&gt; &lt;/HmButton&gt;</code> 和 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code>  都可以</p>\n</li>\n</ul>\n<p>推荐定义组件名时, 用大驼峰命名法, 更加方便</p>\n<p>全局注册</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmButton\'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>局部注册:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  HmHeader<span class="token punctuation">,</span>\n  HmMain<span class="token punctuation">,</span>\n  HmFooter\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用时, 推荐遵循html5规范, 小写横杠隔开</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-header</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-main</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-footer</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="通过-name-注册组件-了解" tabindex="-1"><a class="header-anchor" href="#通过-name-注册组件-了解" aria-hidden="true">#</a> 通过 name 注册组件 (了解)</h3>\n<blockquote>\n<p>组件在开发者工具中显示的名字可以通过name进行修改</p>\n</blockquote>\n<p>在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的 name 属性作为注册后组件的名称</p>\n<p>组件内容:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">按钮组件</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token plain-text">\nexport default {\n  name: \'HmButton\'\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>less<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\nbutton {\n  width: 80px;\n  height: 50px;\n  border-radius: 5px;\n  background-color: pink;\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>进行注册:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> HmButton <span class="token keyword">from</span> <span class="token string">\'./components/hm-button.vue\'</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>HmButton<span class="token punctuation">.</span>name<span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>  <span class="token comment">// 等价于 app.component(\'HmButton\', HmButton)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="组件的样式冲突-scoped" tabindex="-1"><a class="header-anchor" href="#组件的样式冲突-scoped" aria-hidden="true">#</a> 组件的样式冲突  <code>scoped</code></h2>\n<p>默认情况下，写在组件中的样式会<code>全局生效</code>，因此很容易造成多个组件之间的样式冲突问题。</p>\n<p>组件样式默认会作用到全局, 就会影响到整个 index.html 中的 dom 元素</p>\n<ul>\n<li>\n<p><code>全局样式</code>: 默认组件中的样式会作用到全局</p>\n</li>\n<li>\n<p><code>局部样式</code>: 可以给组件加上 scoped 属性, 可以让样式只作用于当前组件</p>\n</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>less<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token plain-text">\ndiv {\n  background-color: pink;\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>原理:</p>\n<ol>\n<li>\n<p>添加scoped后, 会给当前组件中所有元素, 添加上一个自定义属性</p>\n</li>\n<li>\n<p>添加scoped后,  每个style样式, 也会加上对应的属性选择器</p>\n</li>\n</ol>\n<p>最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到</p>\n<h1 id="组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信" aria-hidden="true">#</a> 组件通信</h1>\n<p>每个组件都有自己的数据, 提供在data中, 每个组件的数据是独立的, 组件数据无法互相直接访问 (合理的)</p>\n<p>但是如果需要跨组件访问数据, 就需要用到组件通信</p>\n<p>组件通信的方式有很多: 现在先关注两种,  父传子  子传父</p>\n<h2 id="组件通信-父传子-props-传值" tabindex="-1"><a class="header-anchor" href="#组件通信-父传子-props-传值" aria-hidden="true">#</a> 组件通信 - 父传子 props 传值</h2>\n<p>语法:</p>\n<ol>\n<li>父组件通过给子组件加属性传值</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Son</span></span> <span class="token attr-name">price</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>不错<span class="token punctuation">"</span></span> <span class="token attr-name">:info</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Son</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2">\n<li>子组件中, 通过props属性接收</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'price\'</span><span class="token punctuation">,</span> <span class="token string">\'title\'</span><span class="token punctuation">,</span> <span class="token string">\'info\'</span><span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>需求: 封装一个商品组件 my-product</strong></p>\n<p><code>my-product.vue</code></p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my-product<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>标题: {{ title }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>价格: {{ price }}元<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ info }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'title\'</span><span class="token punctuation">,</span> <span class="token string">\'price\'</span><span class="token punctuation">,</span> <span class="token string">\'info\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.my-product</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 2px solid #000<span class="token punctuation">;</span>\n  <span class="token property">border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="v-for-遍历展示组件练习" tabindex="-1"><a class="header-anchor" href="#v-for-遍历展示组件练习" aria-hidden="true">#</a> v-for 遍历展示组件练习</h2>\n<p><strong>需求: 遍历展示商品列表</strong></p>\n<p>假定, 发送请求回来的商品数据,</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">proname</span><span class="token operator">:</span> <span class="token string">\'超级好吃的棒棒糖\'</span><span class="token punctuation">,</span> <span class="token literal-property property">proprice</span><span class="token operator">:</span> <span class="token number">18.8</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">proname</span><span class="token operator">:</span> <span class="token string">\'超级好吃的大鸡腿\'</span><span class="token punctuation">,</span> <span class="token literal-property property">proprice</span><span class="token operator">:</span> <span class="token number">34.2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">proname</span><span class="token operator">:</span> <span class="token string">\'超级无敌的冰激凌\'</span><span class="token punctuation">,</span> <span class="token literal-property property">proprice</span><span class="token operator">:</span> <span class="token number">14.2</span> <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>v-for 遍历展示</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">我是app组件的内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-product</span> \n      <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item in list<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span> \n      <span class="token attr-name">:price</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.proprice<span class="token punctuation">"</span></span> \n      <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.proname<span class="token punctuation">"</span></span> \n      <span class="token attr-name">:info</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-product</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="单向数据流" tabindex="-1"><a class="header-anchor" href="#单向数据流" aria-hidden="true">#</a> 单向数据流</h2>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">/* \n  在vue中需要遵循单向数据流原则\n  1. 父组件的数据发生了改变，子组件会自动跟着变\n  2. 子组件不能直接修改父组件传递过来的props  props是只读的\n*/</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>==如果父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，，，，也应该避免==</p>\n<h2 id="组件通信-子传父" tabindex="-1"><a class="header-anchor" href="#组件通信-子传父" aria-hidden="true">#</a> 组件通信 - 子传父</h2>\n<p><strong>需求: 砍价</strong></p>\n<ol>\n<li>\n<p>子组件可以通过 <code>this.$emit(\'事件名\', 参数1, 参数2, ...)</code> 触发事件的同时传参的</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">\'sayPrice\'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n<li>\n<p>父组件给子组件注册一个自定义事件</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>my<span class="token operator">-</span>product \n  <span class="token operator">...</span>\n  @sayPrice<span class="token operator">=</span><span class="token string">"sayPrice"</span><span class="token operator">></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-product</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>父组件并提供对应的函数接收参数</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">sayPrice</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li>\n</ol>\n<h2 id="props-校验" tabindex="-1"><a class="header-anchor" href="#props-校验" aria-hidden="true">#</a> props 校验</h2>\n<p><strong>props 是父传子, 传递给子组件的数据, 为了提高 子组件被使用时 的稳定性, 可以进行props校验</strong>, 验证传递的数据是否符合要求</p>\n<p>默认的数组形式, 不会进行校验, 如果希望校验, 需要提供对象形式的 props</p>\n<p>风格指南：https://cn.vuejs.org/v2/style-guide/#Prop-%E5%AE%9A%E4%B9%89%E5%BF%85%E8%A6%81</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n\t<span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>props 提供了多种数据验证方案，例如：</p>\n<ul>\n<li>基础的类型检查  Number</li>\n<li>多个可能的类型 [String, Number]</li>\n<li>必填项校验   required: true</li>\n<li>默认值 default: 100</li>\n<li>自定义验证函数</li>\n</ul>\n<p>官网语法: <a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener noreferrer">地址<ExternalLinkIcon/></a></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 基础的类型检查</span>\n    <span class="token literal-property property">propA</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>\n    <span class="token comment">// 多个可能的类型</span>\n    <span class="token literal-property property">propB</span><span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token comment">// 必填的字符串</span>\n    <span class="token literal-property property">propC</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>\n      <span class="token literal-property property">required</span><span class="token operator">:</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// 带有默认值的数字</span>\n    <span class="token literal-property property">propD</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>\n      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">100</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// -------------------------------------------------------------------------</span>\n    <span class="token comment">// 自定义验证函数</span>\n    <span class="token literal-property property">propF</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token function-variable function">validator</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 这个值必须匹配下列字符串中的一个</span>\n        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">\'success\'</span><span class="token punctuation">,</span> <span class="token string">\'warning\'</span><span class="token punctuation">,</span> <span class="token string">\'danger\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/组件基础+组件通讯.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"组件基础+组件通讯",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/组件基础+组件通讯.md",filePathRelative:"Vue/组件基础+组件通讯.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件基础+组件通讯.html.vue",componentFilePathRelative:"pages/Vue/组件基础+组件通讯.html.vue",componentFileChunkName:"v-1054ac98",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件基础+组件通讯.html.js",dataFilePathRelative:"pages/Vue/组件基础+组件通讯.html.js",dataFileChunkName:"v-1054ac98",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/组件基础+组件通讯.html",htmlFilePathRelative:"Vue/组件基础+组件通讯.html"},{data:{key:"v-1e97db11",path:"/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.html",title:"v-model",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-model 语法糖",slug:"v-model-语法糖",children:[]},{level:2,title:"v-model给组件使用",slug:"v-model给组件使用",children:[]},{level:2,title:"动态组件的基本使用",slug:"动态组件的基本使用",children:[]},{level:2,title:"自定义指令说明",slug:"自定义指令说明",children:[]},{level:2,title:"自定义指令 - 局部注册",slug:"自定义指令-局部注册",children:[]},{level:2,title:"自定义指令 - 全局注册",slug:"自定义指令-全局注册",children:[]},{level:2,title:"自定义指令 - 指令的值",slug:"自定义指令-指令的值",children:[]},{level:2,title:"默认插槽 slot",slug:"默认插槽-slot",children:[]},{level:2,title:"后备内容 (默认值)",slug:"后备内容-默认值",children:[]},{level:2,title:"具名插槽",slug:"具名插槽",children:[{level:3,title:"插槽的分类:",slug:"插槽的分类",children:[]},{level:3,title:"具名插槽的使用步骤",slug:"具名插槽的使用步骤",children:[]},{level:3,title:"具名插槽的简写",slug:"具名插槽的简写",children:[]}]},{level:2,title:"作用域插槽",slug:"作用域插槽",children:[]}],git:{}},key:"v-1e97db11",path:"/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.html",title:"v-model",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-model 语法糖",slug:"v-model-语法糖",children:[]},{level:2,title:"v-model给组件使用",slug:"v-model给组件使用",children:[]},{level:2,title:"动态组件的基本使用",slug:"动态组件的基本使用",children:[]},{level:2,title:"自定义指令说明",slug:"自定义指令说明",children:[]},{level:2,title:"自定义指令 - 局部注册",slug:"自定义指令-局部注册",children:[]},{level:2,title:"自定义指令 - 全局注册",slug:"自定义指令-全局注册",children:[]},{level:2,title:"自定义指令 - 指令的值",slug:"自定义指令-指令的值",children:[]},{level:2,title:"默认插槽 slot",slug:"默认插槽-slot",children:[]},{level:2,title:"后备内容 (默认值)",slug:"后备内容-默认值",children:[]},{level:2,title:"具名插槽",slug:"具名插槽",children:[{level:3,title:"插槽的分类:",slug:"插槽的分类",children:[]},{level:3,title:"具名插槽的使用步骤",slug:"具名插槽的使用步骤",children:[]},{level:3,title:"具名插槽的简写",slug:"具名插槽的简写",children:[]}]},{level:2,title:"作用域插槽",slug:"作用域插槽",children:[]}],content:'# v-model\r\n\r\n## v-model 语法糖\r\n\r\n语法糖：v-model本质上是 value属性和input事件的一层包装\r\n\r\n  v-model的作用：提供数据的双向绑定\r\n\r\n- 数据发生了改变，页面会自动变  v-bind:value\r\n- 页面输入改变 ，   数据会自动变化  v-on:input\r\n\r\nv-model是语法糖， v-model等价于 给一个input框提供了 :value属性以及 @input事件\r\n\r\n很显然如果每次使用input框，都需要提供value和input事件，比较麻烦，所以使用v-model\r\n\r\n```jsx\r\n<template>\r\n  <div>\r\n    <input type="text" v-model="msg">\r\n    <input type="text" :value="msg" @input="msg = $event.target.value">\r\n\r\n    <input type="text" :value="car" @input="car = $event.target.value">\r\n    <input type="text" v-model="car">\r\n  </div>\r\n</template>\r\n```\r\n\r\n\r\n\r\n## v-model给组件使用\r\n\r\n我们经常遇到一种场景： \r\n\r\n1. 父组件提供一个数据给子组件使用（父传子）\r\n2. 子组件又需要修改父组件传过来的这个数据，所以需要子传父把值传给父组件。\r\n\r\n 这种场景可以使用v-model进行简写。\r\n\r\n+ 定义组件的时候，注意接收的值叫value， 子传父触发的事件叫 input\r\n\r\n\r\n+ 父传子给子组件传递value属性和input事件\r\n\r\n# ref 和 $refs \r\n\r\n利用 ref 和 $refs 可以用于获取 dom 元素, 或者组件实例\r\n\r\n每个 vue 的组件实例上，都包含一个$refs 对象，里面存储着对应的DOM 元素或组件的引用。\r\n\r\n1 给需要获取的 dom 元素或者组件, 添加 ref 属性\r\n\r\n```jsx\r\n<div>\r\n  <div ref="box">我是div盒子</div>\r\n  <jack ref="jack"></jack>\r\n  <button @click="fn">按钮</button>\r\n</div>\r\n```\r\n\r\n2 通过 `this.$refs.xxx` 获取, 拿到组件可以调用组件的方法\r\n\r\n```jsx\r\nimport Jack from \'./jack.vue\'\r\nexport default {\r\n  methods: {\r\n    fn () {\r\n      console.log(this.$refs.box)\r\n      console.log(this.$refs.jack)\r\n      this.$refs.jack.sayHi()\r\n    }\r\n  },\r\n  components: {\r\n    Jack\r\n  }\r\n}\r\n```\r\n\r\n# $nextTick\r\n\r\n**需求1: 点击按钮, 切换显示输入框**\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    \x3c!-- 需求: 点击按钮, 切换显示输入框 --\x3e\r\n    <input type="text" v-if="isShowInput">\r\n    <button @click="fn" v-else>点此搜索</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      isShowInput: false\r\n    }\r\n  },\r\n  methods: {\r\n    fn () {\r\n      this.isShowInput = true\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n**需求2: 显示输入框的同时, 要获取焦点**\r\n\r\n当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。\r\n\r\n直接调用会报错, 因为 vue 是 异步dom更新的 (提升渲染效率),  `this.isShowInput = true` 执行完时, 实际的 dom 还没渲染出来\r\n\r\n```jsx\r\n<input ref="inp" type="text" v-if="isShowInput">\r\n\r\nfn () {\r\n  this.isShowInput = true\r\n  this.$refs.inp.focus()\r\n}\r\n```\r\n\r\n组件的 `$nextTick(callback)` 方法，会把 callback 回调推迟到下一个 DOM 更新周期之后执行。\r\n\r\n通俗的理解是：**等组件的DOM 刷新之后，再执行 callback 回调函数**。从而能保证 callback 函数可以操作到最新的 DOM 元素。\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    \x3c!-- 需求: 点击按钮, 切换显示输入框 --\x3e\r\n    <input ref="inp" type="text" v-if="isShowInput">\r\n    <button @click="fn" v-else>点此搜索</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      isShowInput: false\r\n    }\r\n  },\r\n  methods: {\r\n    fn () {\r\n      this.isShowInput = true\r\n      this.$nextTick(() => {\r\n        this.$refs.inp.focus()\r\n      })\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n# dynamic 动态组件\r\n\r\n## 动态组件的基本使用\r\n\r\n什么是动态组件:   让多个组件使用同一个挂载点，并动态切换，这就是动态组件 \r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    <h3>动态组件的演示</h3>\r\n    \x3c!-- 动态组件 => 多个组件使用同一个挂载点, 并可以动态的切换展示 --\x3e\r\n    <button @click="comName = \'my-swiper\'">swiper</button>\r\n    <button @click="comName = \'my-nav\'">nav</button>\r\n    \r\n    \x3c!-- \r\n      <my-nav></my-nav>\r\n      <my-swiper></my-swiper> \r\n    --\x3e\r\n    <component :is="comName"></component>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport MyNav from \'./my-nav.vue\'\r\nimport MySwiper from \'./my-swiper.vue\'\r\nexport default {\r\n  data () {\r\n    return {\r\n      comName: \'my-nav\'\r\n    }\r\n  },\r\n  components: {\r\n    MyNav,\r\n    MySwiper\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n# 自定义指令\r\n\r\n## 自定义指令说明\r\n\r\nhttps://www.vue3js.cn/docs/zh/guide/custom-directive.html\r\n\r\n除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，Vue 也允许注册自定义指令。 `v-xxx`  \r\n\r\n注意，代码复用和抽象的主要形式是组件。\r\n\r\n然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。\r\n\r\n## 自定义指令 - 局部注册\r\n\r\n例如需求:  当页面加载时，让元素将获得焦点 , (autofocus 在 safari 浏览器有兼容性)\r\n\r\n```less\r\n<template>\r\n  <div>\r\n    <h3>自定义指令</h3>\r\n    <input ref="inp" type="text" v-focus>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  directives: {\r\n    // 自定义一个局部指令\r\n    focus: {\r\n      inserted (el) {\r\n        el.focus()\r\n      }\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n## 自定义指令 - 全局注册\r\n\r\n```jsx\r\n// 注册全局自定义指令\r\nVue.directive(\'focus\', {\r\n  inserted (el) {\r\n    el.focus()\r\n  }\r\n})\r\n```\r\n\r\n## 自定义指令 - 指令的值\r\n\r\n在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值\r\n\r\n需求: v-color="color" 给对应的颜色, 就能改对应的字体颜色\r\n\r\n```jsx\r\n<div v-color="color">我是内容</div>\r\n```\r\n\r\n实现:\r\n\r\n```jsx\r\ndirectives: {\r\n  // 自定义一个局部指令\r\n  color: {\r\n    // 指令所在的元素渲染的时候\r\n    inserted (el, {value}) {\r\n      el.style.color = value\r\n    },\r\n    // update指令的值改变时触发, binding.value指令的值修改触发\r\n    update (el, binding) {\r\n      el.style.color = binding.value\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n# 插槽\r\n\r\n插槽（Slot）是 vue 为组件的封装者提供的能力。\r\n\r\n允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。\r\n\r\n## 默认插槽 slot\r\n\r\n**需求: 要在页面中显示一个对话框, 封装成一个组件**\r\n\r\n通过父传子, 固然可以完成一定层面的组件的定制, 但是自定义性较差, \r\n\r\n如果希望能够自定义组件内部的一些结构 => 就需要用到插槽\r\n\r\n\r\n\r\n**插槽作用: 用于实现组件的内容分发, 通过 slot 标签, 可以接收到写在组件标签内的内容**\r\n\r\n插槽：slot  作用：占位置\r\n\r\n基本示例:\r\n\r\n```jsx\r\n<my-dialog>\r\n  <p>请输入正确的手机号码</p>\r\n</my-dialog>\r\n```\r\n\r\n`my-dialog.vue`\r\n\r\n```less\r\n<template>\r\n  <div class="my-dialog">\r\n    <div class="header">\r\n      <h3>友情提示</h3>\r\n    </div>\r\n    <div class="content">\r\n      <slot></slot>\r\n    </div>\r\n    <div class="footer">\r\n      <button>关闭</button>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n\r\n}\r\n<\/script>\r\n\r\n<style lang="less" scoped>\r\n.my-dialog {\r\n  width: 400px;\r\n  padding: 10px 20px;\r\n  border: 3px solid #000;\r\n  border-radius: 5px;\r\n  margin: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n\r\n## 后备内容 (默认值)\r\n\r\n封装组件时，可以为预留的 `<slot>` 插槽提供后备内容（默认内容）。\r\n\r\n如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。\r\n\r\n```jsx\r\n<template>\r\n  <div class="my-dialog">\r\n    <div class="header">\r\n      <h3>友情提示</h3>\r\n    </div>\r\n    <div class="content">\r\n      <slot>这是后备内容</slot>\r\n    </div>\r\n    <div class="footer">\r\n      <button>关闭</button>\r\n    </div>\r\n  </div>\r\n</template>\r\n```\r\n\r\n\r\n\r\n## 具名插槽\r\n\r\n### 插槽的分类:\r\n\r\n**1 默认插槽(匿名插槽)**\r\n\r\n`<slot></slot>` 只要没有具体分发的内容, 都会给到默认插槽\r\n\r\n`<slot name="default"></slot>` 是默认插槽完整的写法 和 `<slot></slot>` 完全等价\r\n\r\n**2 具名插槽: 具有名字的插槽 (配置了名字),  可以实现定向分发**\r\n\r\n一旦配置了名字, 只会接收对应的内容, 不是分发给他的, 就不要\r\n\r\n\r\n\r\n### 具名插槽的使用步骤\r\n\r\n(1) 给插槽起名字 \r\n\r\n```jsx\r\n<div class="header">\r\n  <slot name="header"></slot>\r\n</div>\r\n<div class="content">\r\n  <slot>这是后备内容</slot>\r\n</div>\r\n<div class="footer">\r\n  <slot name="footer"></slot>\r\n</div>\r\n```\r\n\r\n(2) 需要使用 template 标签, 将内容包裹成一个整体\r\n\r\n(3) 通过 v-slot:插槽名, 指定具体分发给谁\r\n\r\n```html\r\n<my-dialog>\r\n  <template v-slot:header>\r\n    <h3>这是大标题</h3>\r\n  </template>\r\n\r\n  <template v-slot:default>\r\n    <p>这是内容</p>\r\n  </template>\r\n\r\n  <template v-slot:footer>\r\n    <button>确认</button>\r\n    <button>取消</button>\r\n  </template>\r\n</my-dialog>\r\n```\r\n\r\n\r\n\r\n### 具名插槽的简写\r\n\r\n跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。\r\n\r\n例如 v-slot:header 可以被简写为 #header\r\n\r\n```jsx\r\n<my-dialog>\r\n  <template #header>\r\n    <h3>这是大标题</h3>\r\n  </template>\r\n\r\n  <template #default>\r\n    <p>这是内容</p>\r\n  </template>\r\n\r\n  <template #footer>\r\n    <button>确认</button>\r\n    <button>取消</button>\r\n  </template>\r\n</my-dialog>\r\n```\r\n\r\n\r\n\r\n## 作用域插槽\r\n\r\n作用域插槽: **定义 slot 插槽的同时, 是可以传值的**, 将来在分发内容时, 可以使用\r\n\r\n1. 给 slot 标签, 以 添加属性的方式传值\r\n\r\n```jsx\r\n<slot name="bottom" :yes="yes" :no="no" money="100"></slot>\r\n```\r\n\r\n2. 所有添加的属性, 都会被收集到一个对象中\r\n\r\n```js\r\n{ yes: \'确认\', no: \'取消\', money: \'100\' }\r\n```\r\n\r\n3. 在template中, 通过  `v-slot:插槽名= "obj"` 接收\r\n\r\n```jsx\r\n<template #bottom="obj">\r\n  \x3c!-- {{ obj }} --\x3e\r\n  <button>{{ obj.yes }}</button>\r\n  <button>{{ obj.no }}</button>\r\n  <button>{{ obj.money }}</button>\r\n</template>\r\n```\r\n\r\n4. 可以使用解构赋值简化数据的接收\r\n\r\n```jsx\r\n<template #bottom="{ yes, no, money }">\r\n  <button>{{ yes }}</button>\r\n  <button>{{ no }}</button>\r\n  <button>{{ money }}</button>\r\n</template>\r\n```\r\n',contentRendered:'<h1 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model" aria-hidden="true">#</a> v-model</h1>\n<h2 id="v-model-语法糖" tabindex="-1"><a class="header-anchor" href="#v-model-语法糖" aria-hidden="true">#</a> v-model 语法糖</h2>\n<p>语法糖：v-model本质上是 value属性和input事件的一层包装</p>\n<p>v-model的作用：提供数据的双向绑定</p>\n<ul>\n<li>数据发生了改变，页面会自动变  v-bind:value</li>\n<li>页面输入改变 ，   数据会自动变化  v-on:input</li>\n</ul>\n<p>v-model是语法糖， v-model等价于 给一个input框提供了 :value属性以及 @input事件</p>\n<p>很显然如果每次使用input框，都需要提供value和input事件，比较麻烦，所以使用v-model</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;input type="text" :value="msg" @input="msg = $event.target.value">\n\n    &lt;input type="text" :value="car" @input="car = $event.target.value">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="v-model给组件使用" tabindex="-1"><a class="header-anchor" href="#v-model给组件使用" aria-hidden="true">#</a> v-model给组件使用</h2>\n<p>我们经常遇到一种场景：</p>\n<ol>\n<li>父组件提供一个数据给子组件使用（父传子）</li>\n<li>子组件又需要修改父组件传过来的这个数据，所以需要子传父把值传给父组件。</li>\n</ol>\n<p>这种场景可以使用v-model进行简写。</p>\n<ul>\n<li>\n<p>定义组件的时候，注意接收的值叫value， 子传父触发的事件叫 input</p>\n</li>\n<li>\n<p>父传子给子组件传递value属性和input事件</p>\n</li>\n</ul>\n<h1 id="ref-和-refs" tabindex="-1"><a class="header-anchor" href="#ref-和-refs" aria-hidden="true">#</a> ref 和 $refs</h1>\n<p>利用 ref 和 $refs 可以用于获取 dom 元素, 或者组件实例</p>\n<p>每个 vue 的组件实例上，都包含一个$refs 对象，里面存储着对应的DOM 元素或组件的引用。</p>\n<p>1 给需要获取的 dom 元素或者组件, 添加 ref 属性</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我是div盒子</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jack</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jack</span><span class="token punctuation">></span></span><span class="token plain-text">\n  &lt;button @click="fn">按钮</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>2 通过 <code>this.$refs.xxx</code> 获取, 拿到组件可以调用组件的方法</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> Jack <span class="token keyword">from</span> <span class="token string">\'./jack.vue\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>box<span class="token punctuation">)</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>jack<span class="token punctuation">)</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>jack<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    Jack\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick" aria-hidden="true">#</a> $nextTick</h1>\n<p><strong>需求1: 点击按钮, 切换显示输入框</strong></p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 需求: 点击按钮, 切换显示输入框 --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowInput<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>点此搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">isShowInput</span><span class="token operator">:</span> <span class="token boolean">false</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>isShowInput <span class="token operator">=</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>需求2: 显示输入框的同时, 要获取焦点</strong></p>\n<p>当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。</p>\n<p>直接调用会报错, 因为 vue 是 异步dom更新的 (提升渲染效率),  <code>this.isShowInput = true</code> 执行完时, 实际的 dom 还没渲染出来</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowInput<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n\nfn () </span><span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>isShowInput <span class="token operator">=</span> <span class="token boolean">true</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token plain-text">\n</span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>组件的 <code>$nextTick(callback)</code> 方法，会把 callback 回调推迟到下一个 DOM 更新周期之后执行。</p>\n<p>通俗的理解是：<strong>等组件的DOM 刷新之后，再执行 callback 回调函数</strong>。从而能保证 callback 函数可以操作到最新的 DOM 元素。</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 需求: 点击按钮, 切换显示输入框 --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowInput<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>点此搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">isShowInput</span><span class="token operator">:</span> <span class="token boolean">false</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>isShowInput <span class="token operator">=</span> <span class="token boolean">true</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="dynamic-动态组件" tabindex="-1"><a class="header-anchor" href="#dynamic-动态组件" aria-hidden="true">#</a> dynamic 动态组件</h1>\n<h2 id="动态组件的基本使用" tabindex="-1"><a class="header-anchor" href="#动态组件的基本使用" aria-hidden="true">#</a> 动态组件的基本使用</h2>\n<p>什么是动态组件:   让多个组件使用同一个挂载点，并动态切换，这就是动态组件</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>动态组件的演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 动态组件 => 多个组件使用同一个挂载点, 并可以动态的切换展示 --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>comName = <span class="token punctuation">\'</span>my-swiper<span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>swiper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>comName = <span class="token punctuation">\'</span>my-nav<span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>nav<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n    \n    <span class="token comment">&lt;!-- \n      &lt;my-nav>&lt;/my-nav>\n      &lt;my-swiper>&lt;/my-swiper> \n    --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>comName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> MyNav <span class="token keyword">from</span> <span class="token string">\'./my-nav.vue\'</span>\n<span class="token keyword">import</span> MySwiper <span class="token keyword">from</span> <span class="token string">\'./my-swiper.vue\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">comName</span><span class="token operator">:</span> <span class="token string">\'my-nav\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    MyNav<span class="token punctuation">,</span>\n    MySwiper\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h1 id="自定义指令" tabindex="-1"><a class="header-anchor" href="#自定义指令" aria-hidden="true">#</a> 自定义指令</h1>\n<h2 id="自定义指令说明" tabindex="-1"><a class="header-anchor" href="#自定义指令说明" aria-hidden="true">#</a> 自定义指令说明</h2>\n<p>https://www.vue3js.cn/docs/zh/guide/custom-directive.html</p>\n<p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。 <code>v-xxx</code></p>\n<p>注意，代码复用和抽象的主要形式是组件。</p>\n<p>然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>\n<h2 id="自定义指令-局部注册" tabindex="-1"><a class="header-anchor" href="#自定义指令-局部注册" aria-hidden="true">#</a> 自定义指令 - 局部注册</h2>\n<p>例如需求:  当页面加载时，让元素将获得焦点 , (autofocus 在 safari 浏览器有兼容性)</p>\n<div class="language-less ext-less line-numbers-mode"><pre v-pre class="language-less"><code><span class="token selector">&lt;template>\n  &lt;div>\n    &lt;h3>自定义指令&lt;/h3>\n    &lt;input ref="inp" type="text" v-focus>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nexport default</span> <span class="token punctuation">{</span>\n  <span class="token selector">directives:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 自定义一个局部指令</span>\n    <span class="token selector">focus:</span> <span class="token punctuation">{</span>\n      <span class="token selector">inserted (el)</span> <span class="token punctuation">{</span>\n        el.<span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n&lt;<span class="token operator">/</span>script>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="自定义指令-全局注册" tabindex="-1"><a class="header-anchor" href="#自定义指令-全局注册" aria-hidden="true">#</a> 自定义指令 - 全局注册</h2>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 注册全局自定义指令</span>\nVue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">\'focus\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">inserted</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="自定义指令-指令的值" tabindex="-1"><a class="header-anchor" href="#自定义指令-指令的值" aria-hidden="true">#</a> 自定义指令 - 指令的值</h2>\n<p>在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值</p>\n<p>需求: v-color=&quot;color&quot; 给对应的颜色, 就能改对应的字体颜色</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我是内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>实现:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">directives</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 自定义一个局部指令</span>\n  <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 指令所在的元素渲染的时候</span>\n    <span class="token function">inserted</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> value\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// update指令的值改变时触发, binding.value指令的值修改触发</span>\n    <span class="token function">update</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="插槽" tabindex="-1"><a class="header-anchor" href="#插槽" aria-hidden="true">#</a> 插槽</h1>\n<p>插槽（Slot）是 vue 为组件的封装者提供的能力。</p>\n<p>允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。</p>\n<h2 id="默认插槽-slot" tabindex="-1"><a class="header-anchor" href="#默认插槽-slot" aria-hidden="true">#</a> 默认插槽 slot</h2>\n<p><strong>需求: 要在页面中显示一个对话框, 封装成一个组件</strong></p>\n<p>通过父传子, 固然可以完成一定层面的组件的定制, 但是自定义性较差,</p>\n<p>如果希望能够自定义组件内部的一些结构 =&gt; 就需要用到插槽</p>\n<p><strong>插槽作用: 用于实现组件的内容分发, 通过 slot 标签, 可以接收到写在组件标签内的内容</strong></p>\n<p>插槽：slot  作用：占位置</p>\n<p>基本示例:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-dialog</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">请输入正确的手机号码</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-dialog</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>my-dialog.vue</code></p>\n<div class="language-less ext-less line-numbers-mode"><pre v-pre class="language-less"><code><span class="token selector">&lt;template>\n  &lt;div class="my-dialog">\n    &lt;div class="header">\n      &lt;h3>友情提示&lt;/h3>\n    &lt;/div>\n    &lt;div class="content">\n      &lt;slot>&lt;/slot>\n    &lt;/div>\n    &lt;div class="footer">\n      &lt;button>关闭&lt;/button>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nexport default</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span>\n<span class="token selector">&lt;/script>\n\n&lt;style lang="less" scoped>\n.my-dialog</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px 20px<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #000<span class="token punctuation">;</span>\n  <span class="token property">border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n&lt;<span class="token operator">/</span>style>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="后备内容-默认值" tabindex="-1"><a class="header-anchor" href="#后备内容-默认值" aria-hidden="true">#</a> 后备内容 (默认值)</h2>\n<p>封装组件时，可以为预留的 <code>&lt;slot&gt;</code> 插槽提供后备内容（默认内容）。</p>\n<p>如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my-dialog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">友情提示</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">这是后备内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">关闭</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="具名插槽" tabindex="-1"><a class="header-anchor" href="#具名插槽" aria-hidden="true">#</a> 具名插槽</h2>\n<h3 id="插槽的分类" tabindex="-1"><a class="header-anchor" href="#插槽的分类" aria-hidden="true">#</a> 插槽的分类:</h3>\n<p><strong>1 默认插槽(匿名插槽)</strong></p>\n<p><code>&lt;slot&gt;&lt;/slot&gt;</code> 只要没有具体分发的内容, 都会给到默认插槽</p>\n<p><code>&lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</code> 是默认插槽完整的写法 和 <code>&lt;slot&gt;&lt;/slot&gt;</code> 完全等价</p>\n<p><strong>2 具名插槽: 具有名字的插槽 (配置了名字),  可以实现定向分发</strong></p>\n<p>一旦配置了名字, 只会接收对应的内容, 不是分发给他的, 就不要</p>\n<h3 id="具名插槽的使用步骤" tabindex="-1"><a class="header-anchor" href="#具名插槽的使用步骤" aria-hidden="true">#</a> 具名插槽的使用步骤</h3>\n<p>(1) 给插槽起名字</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">这是后备内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>(2) 需要使用 template 标签, 将内容包裹成一个整体</p>\n<p>(3) 通过 v-slot:插槽名, 指定具体分发给谁</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-dialog</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>header</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>这是大标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>footer</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>确认<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>取消<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-dialog</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="具名插槽的简写" tabindex="-1"><a class="header-anchor" href="#具名插槽的简写" aria-hidden="true">#</a> 具名插槽的简写</h3>\n<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。</p>\n<p>例如 v-slot:header 可以被简写为 #header</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-dialog</span><span class="token punctuation">></span></span><span class="token plain-text">\n  &lt;template #header>\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">这是大标题</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n  &lt;template #default>\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">这是内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n  &lt;template #footer>\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">确认</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">取消</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-dialog</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="作用域插槽" tabindex="-1"><a class="header-anchor" href="#作用域插槽" aria-hidden="true">#</a> 作用域插槽</h2>\n<p>作用域插槽: <strong>定义 slot 插槽的同时, 是可以传值的</strong>, 将来在分发内容时, 可以使用</p>\n<ol>\n<li>给 slot 标签, 以 添加属性的方式传值</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bottom<span class="token punctuation">"</span></span> <span class="token attr-name">:yes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span> <span class="token attr-name">:no</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">money</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2">\n<li>所有添加的属性, 都会被收集到一个对象中</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span> <span class="token literal-property property">yes</span><span class="token operator">:</span> <span class="token string">\'确认\'</span><span class="token punctuation">,</span> <span class="token literal-property property">no</span><span class="token operator">:</span> <span class="token string">\'取消\'</span><span class="token punctuation">,</span> <span class="token literal-property property">money</span><span class="token operator">:</span> <span class="token string">\'100\'</span> <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="3">\n<li>在template中, 通过  <code>v-slot:插槽名= &quot;obj&quot;</code> 接收</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>template #bottom<span class="token operator">=</span><span class="token string">"obj"</span><span class="token operator">></span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> obj <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>yes <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>no <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>money <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="4">\n<li>可以使用解构赋值简化数据的接收</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>template #bottom<span class="token operator">=</span><span class="token string">"{ yes, no, money }"</span><span class="token operator">></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> yes <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> no <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> money <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/组件进阶.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"组件进阶",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/组件进阶.md",filePathRelative:"Vue/组件进阶.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件进阶.html.vue",componentFilePathRelative:"pages/Vue/组件进阶.html.vue",componentFileChunkName:"v-1e97db11",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件进阶.html.js",dataFilePathRelative:"pages/Vue/组件进阶.html.js",dataFileChunkName:"v-1e97db11",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/组件进阶.html",htmlFilePathRelative:"Vue/组件进阶.html"},{data:{key:"v-0a97e47a",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.html",title:"HTML基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. HTML 文件中的 DOCTYPE 是什么作用？",slug:"_1-html-文件中的-doctype-是什么作用",children:[]},{level:2,title:"2. HTML、XML、XHTML 之间有什么区别？",slug:"_2-html、xml、xhtml-之间有什么区别",children:[]},{level:2,title:"3. 前缀为 data- 开头的元素属性是什么？",slug:"_3-前缀为-data-开头的元素属性是什么",children:[]},{level:2,title:"4. 谈谈你对 HTML 语义化的理解？",slug:"_4-谈谈你对-html-语义化的理解",children:[]},{level:2,title:"5. HTML5 对比 HTML4 有哪些不同之处？",slug:"_5-html5-对比-html4-有哪些不同之处",children:[]},{level:2,title:"6. meta 标签有哪些常用用法？",slug:"_6-meta-标签有哪些常用用法",children:[]},{level:2,title:"7. img 标签的 srcset 的作用是什么？",slug:"_7-img-标签的-srcset-的作用是什么",children:[]},{level:2,title:"8. 响应式图片处理优化: Picture 标签",slug:"_8-响应式图片处理优化-picture-标签",children:[]},{level:2,title:"9. 在 script 标签上使用 defer 和 async 的区别是什么？",slug:"_9-在-script-标签上使用-defer-和-async-的区别是什么",children:[]},{level:2,title:"10. 前端做本地数据存储的方式有哪些？",slug:"_10-前端做本地数据存储的方式有哪些",children:[]},{level:2,title:"11. 以上几种前端存储的区别是什么？",slug:"_11-以上几种前端存储的区别是什么",children:[]},{level:2,title:"1. CSS选择器的优先级是怎么样的？",slug:"_1-css选择器的优先级是怎么样的",children:[]},{level:2,title:"2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？",slug:"_2-通过-css-的哪些方式可以实现隐藏页面上的元素",children:[]},{level:2,title:"3. px、em、rem之间有什么区别？",slug:"_3-px、em、rem之间有什么区别",children:[]},{level:2,title:"4. 让元素水平居中的方法有哪些？",slug:"_4-让元素水平居中的方法有哪些",children:[]},{level:2,title:"5. 在 CSS 中有哪些定位方式？",slug:"_5-在-css-中有哪些定位方式",children:[]},{level:2,title:"6. 如何理解 z-index？",slug:"_6-如何理解-z-index",children:[]},{level:2,title:"7. 如何清除浮动 ？",slug:"_7-如何清除浮动",children:[]},{level:2,title:"8. 谈谈你对 BFC 的理解？",slug:"_8-谈谈你对-bfc-的理解",children:[]},{level:2,title:"9. 什么是CSS Sprites以及它的好处？",slug:"_9-什么是css-sprites以及它的好处",children:[]},{level:2,title:"10. 你对媒体查询的理解是什么样的？",slug:"_10-你对媒体查询的理解是什么样的",children:[]},{level:2,title:"11. 你对盒子模型的理解是什么样的？",slug:"_11-你对盒子模型的理解是什么样的",children:[]},{level:2,title:"12. 标准盒模型和怪异盒模型有哪些区别？",slug:"_12-标准盒模型和怪异盒模型有哪些区别",children:[]},{level:2,title:"13. 说说伪类和伪元素的区别？",slug:"_13-说说伪类和伪元素的区别",children:[]},{level:2,title:"14. 谈谈你对 flex 的理解？",slug:"_14-谈谈你对-flex-的理解",children:[]},{level:2,title:"1. 解释下什么是变量声明提升？",slug:"_1-解释下什么是变量声明提升",children:[]},{level:2,title:"2. JS 的参数是以什么方式进行传递的？",slug:"_2-js-的参数是以什么方式进行传递的",children:[]},{level:2,title:"3. JavaScript垃圾回收是怎么做的？",slug:"_3-javascript垃圾回收是怎么做的",children:[{level:3,title:"3.1 内存的生命周期",slug:"_3-1-内存的生命周期",children:[]},{level:3,title:"3.2 垃圾回收算法说明",slug:"_3-2-垃圾回收算法说明",children:[]},{level:3,title:"3.3 引用计数",slug:"_3-3-引用计数",children:[]},{level:3,title:"3.4 标记清除算法",slug:"_3-4-标记清除算法",children:[]}]},{level:2,title:"4. 谈谈你对 JavaScript 作用域链的理解？",slug:"_4-谈谈你对-javascript-作用域链的理解",children:[]},{level:2,title:"5. 谈谈你对闭包的理解？",slug:"_5-谈谈你对闭包的理解",children:[]},{level:2,title:"6. JavaScript中数据类型的隐式转换规则(了解)",slug:"_6-javascript中数据类型的隐式转换规则-了解",children:[]},{level:2,title:"7. 谈谈你对原型链的理解？",slug:"_7-谈谈你对原型链的理解",children:[]},{level:2,title:"6. 谈谈对于继承的理解",slug:"_6-谈谈对于继承的理解",children:[{level:3,title:"6.1 继承 - 原型继承",slug:"_6-1-继承-原型继承",children:[]},{level:3,title:"6.2 继承 - 组合继承",slug:"_6-2-继承-组合继承",children:[]},{level:3,title:"6.3 继承 - 寄生组合继承",slug:"_6-3-继承-寄生组合继承",children:[]},{level:3,title:"6.4 es6 - class 实现继承 extends",slug:"_6-4-es6-class-实现继承-extends",children:[]}]},{level:2,title:"8. 如何判断是否是数组？",slug:"_8-如何判断是否是数组",children:[]},{level:2,title:"9. 谈谈你对this的理解？",slug:"_9-谈谈你对this的理解",children:[]},{level:2,title:"10. 箭头函数中的this指向什么？",slug:"_10-箭头函数中的this指向什么",children:[]},{level:2,title:"11. Promise 的静态方法",slug:"_11-promise-的静态方法",children:[]},{level:2,title:"12. 宏任务 微任务 是什么",slug:"_12-宏任务-微任务-是什么",children:[]},{level:2,title:"13. async/await是什么？",slug:"_13-async-await是什么",children:[]},{level:2,title:"14. 相较于 Promise，async/await有何优势？",slug:"_14-相较于-promise-async-await有何优势",children:[]},{level:2,title:"15. 深拷贝 浅拷贝",slug:"_15-深拷贝-浅拷贝",children:[]},{level:2,title:"1. HTTP有哪些⽅法？",slug:"_1-http有哪些方法",children:[]},{level:2,title:"2. 各个HTTP方法的具体作用是什么？",slug:"_2-各个http方法的具体作用是什么",children:[]},{level:2,title:"3. GET方法和POST方法有何区别？",slug:"_3-get方法和post方法有何区别",children:[]},{level:2,title:"4. HTTP请求报文是什么样的？",slug:"_4-http请求报文是什么样的",children:[]},{level:2,title:"5. HTTP响应报文是什么样的？",slug:"_5-http响应报文是什么样的",children:[]},{level:2,title:"6. 你了解的HTTP状态码有哪些？",slug:"_6-你了解的http状态码有哪些",children:[]},{level:2,title:"7. HTTP的keep-alive是什么作用？",slug:"_7-http的keep-alive是什么作用",children:[]},{level:2,title:"8. 为什么需要HTTPS？",slug:"_8-为什么需要https",children:[]},{level:2,title:"9. HTTPS是如何保证安全的？",slug:"_9-https是如何保证安全的",children:[{level:3,title:"9.1 什么是对称加密？",slug:"_9-1-什么是对称加密",children:[]},{level:3,title:"9.2 什么是⾮对称加密？",slug:"_9-2-什么是非对称加密",children:[]},{level:3,title:"9.3 HTTPS 加密解决⽅案",slug:"_9-3-https-加密解决方案",children:[]},{level:3,title:"9.4 数字证书",slug:"_9-4-数字证书",children:[]},{level:3,title:"9.5 数字签名",slug:"_9-5-数字签名",children:[]}]},{level:2,title:"10. HTTP2和HTTP1.x比，有什么优势和特点？",slug:"_10-http2和http1-x比-有什么优势和特点",children:[]},{level:2,title:"11. http缓存控制",slug:"_11-http缓存控制",children:[{level:3,title:"11.1 基本认知",slug:"_11-1-基本认知",children:[]},{level:3,title:"11.2 强缓存  (食品过期时间判断)",slug:"_11-2-强缓存-食品过期时间判断",children:[]},{level:3,title:"11.3 协商缓存 (找供货商专家协商)",slug:"_11-3-协商缓存-找供货商专家协商",children:[]},{level:3,title:"11.4 整体请求缓存流程",slug:"_11-4-整体请求缓存流程",children:[]}]},{level:2,title:"TCP的特性",slug:"tcp的特性",children:[]},{level:2,title:"简述 TCP 和 UDP 的区别",slug:"简述-tcp-和-udp-的区别",children:[]},{level:2,title:"什么是 TCP 粘包，怎么处理？",slug:"什么是-tcp-粘包-怎么处理",children:[]},{level:2,title:"你知道哪些常用的端口号，以及它们对应的服务？",slug:"你知道哪些常用的端口号-以及它们对应的服务",children:[]},{level:2,title:"一次完整的HTTP服务过程是什么",slug:"一次完整的http服务过程是什么",children:[]},{level:2,title:"什么是DNS 解析",slug:"什么是dns-解析",children:[]},{level:2,title:"什么是三次握手？",slug:"什么是三次握手",children:[]},{level:2,title:"什么是四次挥手？",slug:"什么是四次挥手",children:[]},{level:2,title:"TCP 三次握手理解 (双方确认)",slug:"tcp-三次握手理解-双方确认",children:[]},{level:2,title:"关闭TCP连接四次挥手的理解 (客气挽留)",slug:"关闭tcp连接四次挥手的理解-客气挽留",children:[]},{level:2,title:"浏览器解析响应",slug:"浏览器解析响应",children:[]},{level:2,title:"DOM的事件模型是什么？",slug:"dom的事件模型是什么",children:[]},{level:2,title:"DOM的事件流是什么？",slug:"dom的事件流是什么",children:[]},{level:2,title:"说说什么是事件委托？",slug:"说说什么是事件委托",children:[]},{level:2,title:"常见的浏览器内核有哪些？",slug:"常见的浏览器内核有哪些",children:[]},{level:2,title:"浏览器是如何进行界面渲染的？",slug:"浏览器是如何进行界面渲染的",children:[]},{level:2,title:"浏览器是如何解析CSS选择器的？",slug:"浏览器是如何解析css选择器的",children:[]},{level:2,title:"DOM树是如何构建的？",slug:"dom树是如何构建的",children:[]},{level:2,title:"浏览器重绘与重排的区别是什么？",slug:"浏览器重绘与重排的区别是什么",children:[]},{level:2,title:"如何触发重排和重绘？",slug:"如何触发重排和重绘",children:[]},{level:2,title:"如何避免重排或重绘？",slug:"如何避免重排或重绘",children:[]},{level:2,title:"前端如何实现即时通讯？",slug:"前端如何实现即时通讯",children:[]},{level:2,title:"什么是浏览器的同源策略？",slug:"什么是浏览器的同源策略",children:[]},{level:2,title:"如何实现跨域？",slug:"如何实现跨域",children:[]},{level:2,title:"Babel的原理是什么？",slug:"babel的原理是什么",children:[]},{level:2,title:"如何编写一个Babel插件？",slug:"如何编写一个babel插件",children:[]},{level:2,title:"你们的Git工作流是什么样的？",slug:"你们的git工作流是什么样的",children:[]},{level:2,title:"Git的rebase和merge的区别是什么？",slug:"git的rebase和merge的区别是什么",children:[]},{level:2,title:"什么是MVVM？",slug:"什么是mvvm",children:[]},{level:2,title:"MVVM的优缺点有哪些？",slug:"mvvm的优缺点有哪些",children:[]},{level:2,title:"谈谈对Vue生命周期的理解？",slug:"谈谈对vue生命周期的理解",children:[]},{level:2,title:"在Vue中网络请求应该放在哪个生命周期中发起？",slug:"在vue中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"Vue组件之间如何进行通信？",slug:"vue组件之间如何进行通信",children:[]},{level:2,title:"computed和watch的区别是什么？",slug:"computed和watch的区别是什么",children:[]},{level:2,title:"Vue双向绑定原理？",slug:"vue双向绑定原理",children:[]},{level:2,title:"Object.defineProperty和Proxy的优缺点？",slug:"object-defineproperty和proxy的优缺点",children:[]},{level:2,title:"如何理解Vue的响应式系统？",slug:"如何理解vue的响应式系统",children:[{level:3,title:"基本原理",slug:"基本原理",children:[]},{level:3,title:"观察者模式",slug:"观察者模式",children:[]}]},{level:2,title:"Vue中的key到底有什么用？",slug:"vue中的key到底有什么用",children:[{level:3,title:"diff算法",slug:"diff算法",children:[]},{level:3,title:"key的常见应用场景",slug:"key的常见应用场景",children:[]}]},{level:2,title:"React最新的生命周期是怎么样的？",slug:"react最新的生命周期是怎么样的",children:[]},{level:2,title:"在React中网络请求应该放在哪个生命周期中发起？",slug:"在react中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"setState是同步的还是异步的？",slug:"setstate是同步的还是异步的",children:[]},{level:2,title:"React中如何实现组件间的通信？",slug:"react中如何实现组件间的通信",children:[]},{level:2,title:"React存在哪些性能优化手段？",slug:"react存在哪些性能优化手段",children:[]},{level:2,title:"React中如何进行组件和逻辑的复用？",slug:"react中如何进行组件和逻辑的复用",children:[]},{level:2,title:"Mixin、HoC、Render props、React Hooks的优缺点分别是什么？",slug:"mixin、hoc、render-props、react-hooks的优缺点分别是什么",children:[]},{level:2,title:"Redux的工作流程是怎么样的？",slug:"redux的工作流程是怎么样的",children:[]},{level:2,title:"react-redux这个库是如何工作的？",slug:"react-redux这个库是如何工作的",children:[]},{level:2,title:"Redux和Mobx的区别？",slug:"redux和mobx的区别",children:[]},{level:2,title:"在Redux中如何进行异步操作？",slug:"在redux中如何进行异步操作",children:[]}],git:{}},key:"v-0a97e47a",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.html",title:"HTML基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. HTML 文件中的 DOCTYPE 是什么作用？",slug:"_1-html-文件中的-doctype-是什么作用",children:[]},{level:2,title:"2. HTML、XML、XHTML 之间有什么区别？",slug:"_2-html、xml、xhtml-之间有什么区别",children:[]},{level:2,title:"3. 前缀为 data- 开头的元素属性是什么？",slug:"_3-前缀为-data-开头的元素属性是什么",children:[]},{level:2,title:"4. 谈谈你对 HTML 语义化的理解？",slug:"_4-谈谈你对-html-语义化的理解",children:[]},{level:2,title:"5. HTML5 对比 HTML4 有哪些不同之处？",slug:"_5-html5-对比-html4-有哪些不同之处",children:[]},{level:2,title:"6. meta 标签有哪些常用用法？",slug:"_6-meta-标签有哪些常用用法",children:[]},{level:2,title:"7. img 标签的 srcset 的作用是什么？",slug:"_7-img-标签的-srcset-的作用是什么",children:[]},{level:2,title:"8. 响应式图片处理优化: Picture 标签",slug:"_8-响应式图片处理优化-picture-标签",children:[]},{level:2,title:"9. 在 script 标签上使用 defer 和 async 的区别是什么？",slug:"_9-在-script-标签上使用-defer-和-async-的区别是什么",children:[]},{level:2,title:"10. 前端做本地数据存储的方式有哪些？",slug:"_10-前端做本地数据存储的方式有哪些",children:[]},{level:2,title:"11. 以上几种前端存储的区别是什么？",slug:"_11-以上几种前端存储的区别是什么",children:[]},{level:2,title:"1. CSS选择器的优先级是怎么样的？",slug:"_1-css选择器的优先级是怎么样的",children:[]},{level:2,title:"2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？",slug:"_2-通过-css-的哪些方式可以实现隐藏页面上的元素",children:[]},{level:2,title:"3. px、em、rem之间有什么区别？",slug:"_3-px、em、rem之间有什么区别",children:[]},{level:2,title:"4. 让元素水平居中的方法有哪些？",slug:"_4-让元素水平居中的方法有哪些",children:[]},{level:2,title:"5. 在 CSS 中有哪些定位方式？",slug:"_5-在-css-中有哪些定位方式",children:[]},{level:2,title:"6. 如何理解 z-index？",slug:"_6-如何理解-z-index",children:[]},{level:2,title:"7. 如何清除浮动 ？",slug:"_7-如何清除浮动",children:[]},{level:2,title:"8. 谈谈你对 BFC 的理解？",slug:"_8-谈谈你对-bfc-的理解",children:[]},{level:2,title:"9. 什么是CSS Sprites以及它的好处？",slug:"_9-什么是css-sprites以及它的好处",children:[]},{level:2,title:"10. 你对媒体查询的理解是什么样的？",slug:"_10-你对媒体查询的理解是什么样的",children:[]},{level:2,title:"11. 你对盒子模型的理解是什么样的？",slug:"_11-你对盒子模型的理解是什么样的",children:[]},{level:2,title:"12. 标准盒模型和怪异盒模型有哪些区别？",slug:"_12-标准盒模型和怪异盒模型有哪些区别",children:[]},{level:2,title:"13. 说说伪类和伪元素的区别？",slug:"_13-说说伪类和伪元素的区别",children:[]},{level:2,title:"14. 谈谈你对 flex 的理解？",slug:"_14-谈谈你对-flex-的理解",children:[]},{level:2,title:"1. 解释下什么是变量声明提升？",slug:"_1-解释下什么是变量声明提升",children:[]},{level:2,title:"2. JS 的参数是以什么方式进行传递的？",slug:"_2-js-的参数是以什么方式进行传递的",children:[]},{level:2,title:"3. JavaScript垃圾回收是怎么做的？",slug:"_3-javascript垃圾回收是怎么做的",children:[{level:3,title:"3.1 内存的生命周期",slug:"_3-1-内存的生命周期",children:[]},{level:3,title:"3.2 垃圾回收算法说明",slug:"_3-2-垃圾回收算法说明",children:[]},{level:3,title:"3.3 引用计数",slug:"_3-3-引用计数",children:[]},{level:3,title:"3.4 标记清除算法",slug:"_3-4-标记清除算法",children:[]}]},{level:2,title:"4. 谈谈你对 JavaScript 作用域链的理解？",slug:"_4-谈谈你对-javascript-作用域链的理解",children:[]},{level:2,title:"5. 谈谈你对闭包的理解？",slug:"_5-谈谈你对闭包的理解",children:[]},{level:2,title:"6. JavaScript中数据类型的隐式转换规则(了解)",slug:"_6-javascript中数据类型的隐式转换规则-了解",children:[]},{level:2,title:"7. 谈谈你对原型链的理解？",slug:"_7-谈谈你对原型链的理解",children:[]},{level:2,title:"6. 谈谈对于继承的理解",slug:"_6-谈谈对于继承的理解",children:[{level:3,title:"6.1 继承 - 原型继承",slug:"_6-1-继承-原型继承",children:[]},{level:3,title:"6.2 继承 - 组合继承",slug:"_6-2-继承-组合继承",children:[]},{level:3,title:"6.3 继承 - 寄生组合继承",slug:"_6-3-继承-寄生组合继承",children:[]},{level:3,title:"6.4 es6 - class 实现继承 extends",slug:"_6-4-es6-class-实现继承-extends",children:[]}]},{level:2,title:"8. 如何判断是否是数组？",slug:"_8-如何判断是否是数组",children:[]},{level:2,title:"9. 谈谈你对this的理解？",slug:"_9-谈谈你对this的理解",children:[]},{level:2,title:"10. 箭头函数中的this指向什么？",slug:"_10-箭头函数中的this指向什么",children:[]},{level:2,title:"11. Promise 的静态方法",slug:"_11-promise-的静态方法",children:[]},{level:2,title:"12. 宏任务 微任务 是什么",slug:"_12-宏任务-微任务-是什么",children:[]},{level:2,title:"13. async/await是什么？",slug:"_13-async-await是什么",children:[]},{level:2,title:"14. 相较于 Promise，async/await有何优势？",slug:"_14-相较于-promise-async-await有何优势",children:[]},{level:2,title:"15. 深拷贝 浅拷贝",slug:"_15-深拷贝-浅拷贝",children:[]},{level:2,title:"1. HTTP有哪些⽅法？",slug:"_1-http有哪些方法",children:[]},{level:2,title:"2. 各个HTTP方法的具体作用是什么？",slug:"_2-各个http方法的具体作用是什么",children:[]},{level:2,title:"3. GET方法和POST方法有何区别？",slug:"_3-get方法和post方法有何区别",children:[]},{level:2,title:"4. HTTP请求报文是什么样的？",slug:"_4-http请求报文是什么样的",children:[]},{level:2,title:"5. HTTP响应报文是什么样的？",slug:"_5-http响应报文是什么样的",children:[]},{level:2,title:"6. 你了解的HTTP状态码有哪些？",slug:"_6-你了解的http状态码有哪些",children:[]},{level:2,title:"7. HTTP的keep-alive是什么作用？",slug:"_7-http的keep-alive是什么作用",children:[]},{level:2,title:"8. 为什么需要HTTPS？",slug:"_8-为什么需要https",children:[]},{level:2,title:"9. HTTPS是如何保证安全的？",slug:"_9-https是如何保证安全的",children:[{level:3,title:"9.1 什么是对称加密？",slug:"_9-1-什么是对称加密",children:[]},{level:3,title:"9.2 什么是⾮对称加密？",slug:"_9-2-什么是非对称加密",children:[]},{level:3,title:"9.3 HTTPS 加密解决⽅案",slug:"_9-3-https-加密解决方案",children:[]},{level:3,title:"9.4 数字证书",slug:"_9-4-数字证书",children:[]},{level:3,title:"9.5 数字签名",slug:"_9-5-数字签名",children:[]}]},{level:2,title:"10. HTTP2和HTTP1.x比，有什么优势和特点？",slug:"_10-http2和http1-x比-有什么优势和特点",children:[]},{level:2,title:"11. http缓存控制",slug:"_11-http缓存控制",children:[{level:3,title:"11.1 基本认知",slug:"_11-1-基本认知",children:[]},{level:3,title:"11.2 强缓存  (食品过期时间判断)",slug:"_11-2-强缓存-食品过期时间判断",children:[]},{level:3,title:"11.3 协商缓存 (找供货商专家协商)",slug:"_11-3-协商缓存-找供货商专家协商",children:[]},{level:3,title:"11.4 整体请求缓存流程",slug:"_11-4-整体请求缓存流程",children:[]}]},{level:2,title:"TCP的特性",slug:"tcp的特性",children:[]},{level:2,title:"简述 TCP 和 UDP 的区别",slug:"简述-tcp-和-udp-的区别",children:[]},{level:2,title:"什么是 TCP 粘包，怎么处理？",slug:"什么是-tcp-粘包-怎么处理",children:[]},{level:2,title:"你知道哪些常用的端口号，以及它们对应的服务？",slug:"你知道哪些常用的端口号-以及它们对应的服务",children:[]},{level:2,title:"一次完整的HTTP服务过程是什么",slug:"一次完整的http服务过程是什么",children:[]},{level:2,title:"什么是DNS 解析",slug:"什么是dns-解析",children:[]},{level:2,title:"什么是三次握手？",slug:"什么是三次握手",children:[]},{level:2,title:"什么是四次挥手？",slug:"什么是四次挥手",children:[]},{level:2,title:"TCP 三次握手理解 (双方确认)",slug:"tcp-三次握手理解-双方确认",children:[]},{level:2,title:"关闭TCP连接四次挥手的理解 (客气挽留)",slug:"关闭tcp连接四次挥手的理解-客气挽留",children:[]},{level:2,title:"浏览器解析响应",slug:"浏览器解析响应",children:[]},{level:2,title:"DOM的事件模型是什么？",slug:"dom的事件模型是什么",children:[]},{level:2,title:"DOM的事件流是什么？",slug:"dom的事件流是什么",children:[]},{level:2,title:"说说什么是事件委托？",slug:"说说什么是事件委托",children:[]},{level:2,title:"常见的浏览器内核有哪些？",slug:"常见的浏览器内核有哪些",children:[]},{level:2,title:"浏览器是如何进行界面渲染的？",slug:"浏览器是如何进行界面渲染的",children:[]},{level:2,title:"浏览器是如何解析CSS选择器的？",slug:"浏览器是如何解析css选择器的",children:[]},{level:2,title:"DOM树是如何构建的？",slug:"dom树是如何构建的",children:[]},{level:2,title:"浏览器重绘与重排的区别是什么？",slug:"浏览器重绘与重排的区别是什么",children:[]},{level:2,title:"如何触发重排和重绘？",slug:"如何触发重排和重绘",children:[]},{level:2,title:"如何避免重排或重绘？",slug:"如何避免重排或重绘",children:[]},{level:2,title:"前端如何实现即时通讯？",slug:"前端如何实现即时通讯",children:[]},{level:2,title:"什么是浏览器的同源策略？",slug:"什么是浏览器的同源策略",children:[]},{level:2,title:"如何实现跨域？",slug:"如何实现跨域",children:[]},{level:2,title:"Babel的原理是什么？",slug:"babel的原理是什么",children:[]},{level:2,title:"如何编写一个Babel插件？",slug:"如何编写一个babel插件",children:[]},{level:2,title:"你们的Git工作流是什么样的？",slug:"你们的git工作流是什么样的",children:[]},{level:2,title:"Git的rebase和merge的区别是什么？",slug:"git的rebase和merge的区别是什么",children:[]},{level:2,title:"什么是MVVM？",slug:"什么是mvvm",children:[]},{level:2,title:"MVVM的优缺点有哪些？",slug:"mvvm的优缺点有哪些",children:[]},{level:2,title:"谈谈对Vue生命周期的理解？",slug:"谈谈对vue生命周期的理解",children:[]},{level:2,title:"在Vue中网络请求应该放在哪个生命周期中发起？",slug:"在vue中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"Vue组件之间如何进行通信？",slug:"vue组件之间如何进行通信",children:[]},{level:2,title:"computed和watch的区别是什么？",slug:"computed和watch的区别是什么",children:[]},{level:2,title:"Vue双向绑定原理？",slug:"vue双向绑定原理",children:[]},{level:2,title:"Object.defineProperty和Proxy的优缺点？",slug:"object-defineproperty和proxy的优缺点",children:[]},{level:2,title:"如何理解Vue的响应式系统？",slug:"如何理解vue的响应式系统",children:[{level:3,title:"基本原理",slug:"基本原理",children:[]},{level:3,title:"观察者模式",slug:"观察者模式",children:[]}]},{level:2,title:"Vue中的key到底有什么用？",slug:"vue中的key到底有什么用",children:[{level:3,title:"diff算法",slug:"diff算法",children:[]},{level:3,title:"key的常见应用场景",slug:"key的常见应用场景",children:[]}]},{level:2,title:"React最新的生命周期是怎么样的？",slug:"react最新的生命周期是怎么样的",children:[]},{level:2,title:"在React中网络请求应该放在哪个生命周期中发起？",slug:"在react中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"setState是同步的还是异步的？",slug:"setstate是同步的还是异步的",children:[]},{level:2,title:"React中如何实现组件间的通信？",slug:"react中如何实现组件间的通信",children:[]},{level:2,title:"React存在哪些性能优化手段？",slug:"react存在哪些性能优化手段",children:[]},{level:2,title:"React中如何进行组件和逻辑的复用？",slug:"react中如何进行组件和逻辑的复用",children:[]},{level:2,title:"Mixin、HoC、Render props、React Hooks的优缺点分别是什么？",slug:"mixin、hoc、render-props、react-hooks的优缺点分别是什么",children:[]},{level:2,title:"Redux的工作流程是怎么样的？",slug:"redux的工作流程是怎么样的",children:[]},{level:2,title:"react-redux这个库是如何工作的？",slug:"react-redux这个库是如何工作的",children:[]},{level:2,title:"Redux和Mobx的区别？",slug:"redux和mobx的区别",children:[]},{level:2,title:"在Redux中如何进行异步操作？",slug:"在redux中如何进行异步操作",children:[]}],content:'# HTML基础\r\n\r\n## 1. HTML 文件中的 DOCTYPE 是什么作用？\r\n\r\nHTML超文本标记语言: 是一个标记语言, 就有对应的语法标准\r\n\r\nDOCTYPE 即 Document Type，网页文件的文档类型标准。\r\n\r\n主要作用是告诉浏览器的解析器要使用哪种  **HTML规范** 或 **XHTML规范** 来解析页面。\r\n\r\nDOCTYPE 需要放置在 HTML 文件的 `<html>`标签之前，如：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  ...\r\n</html> (目前主流)\r\n```\r\n\r\n```html\r\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">\r\n<html>\r\n  ...\r\n</html> (早期)\r\n```\r\n\r\n\r\n\r\n## 2. HTML、XML、XHTML 之间有什么区别？\r\n\r\n它们都属于标记语言。  \r\n\r\n| 语言  | 中文名               | 说明                                                         |\r\n| ----- | -------------------- | ------------------------------------------------------------ |\r\n| HTML4 | 超文本标记语言       | 主要用于做界面呈现。HTML 是先有实现，后面才慢慢制定标准的，导致HTML⾮常混乱和松散，语法非常的不严谨。 |\r\n| XML   | 可扩展标记语言       | 主要⽤于存储数据和结构。语法严谨，可扩展性强。由于 JSON 也有类似作⽤但更轻量⾼效， XML 的市场变得越来越⼩。 |\r\n| XHTML | 可扩展超文本标记语言 | 属于加强版 HTML，为解决 HTML 的混乱问题而生，在语法方面变得和 XML 一样严格。另外，XHTML 的出现也催生了 HTML 5，让HTML向规范化严谨化过渡。 |\r\n| HTML5 | 超文本标记语言       | 在HTML的基础上进行拓展，用于页面呈现 (目前标准)              |\r\n\r\nXML的要求会比较严格:\r\n\r\n1. 有且只能有一个根元素\r\n\r\n2. 大小写敏感\r\n\r\n3. 正确嵌套\r\n\r\n4. 必须双引号\r\n\r\n5. 必须闭合标签\r\n\r\n   ...\r\n\r\n```jsx\r\n<?xml version="1.0" encoding="utf-8"?>\r\n<root>\r\n  <father id=\'box\'>\r\n    <child>小张</child>\r\n    <child>小王</child>\r\n  </father>\r\n</root>\r\n```\r\n\r\nXHTML 和 HTML5 的历史延展: https://www.cnblogs.com/my-freedom/p/5796915.html\r\n\r\n\r\n\r\n**番外:** 所以 HTML5 是HTML的新一代标准, 所谓的 H5 工程师这一词, 其实是国产词, 泛指新一代的web开发工程师, \r\n\r\n具体H5工程师, 做什么工作方向, 还是要看需求 (比如: 移动端开发, PC端网页开发, H5小游戏开发....)\r\n\r\n\r\n\r\n## 3. 前缀为 `data-` 开头的元素属性是什么？\r\n\r\n这是一种为 HTML 元素添加额外数据信息的方式，被称为 **自定义属性**。\r\n\r\n我们可以直接在元素标签上声明这样的数据属性：\r\n\r\n```html\r\n<div id="mydiv" data-message="Hello,world" data-num="123"></div>\r\n```\r\n\r\n也可以使用 JavaScript 来操作元素的数据属性：\r\n\r\n```js\r\nlet mydiv = document.getElementById(\'mydiv\')\r\n\r\n// 读取\r\nconsole.log(mydiv.dataset.message)\r\n\r\n// 写入\r\nmydiv.dataset.foo = "bar!!!"\r\n```\r\n\r\n**注意：在各种现代前端框架出现后，这种原生的自定义属性已经变得不太常用了, 以前的使用频率非常高, 所以我们知道即可。**\r\n\r\n例如: vue实现删除功能时需要 id, 可以直接传值\r\n\r\n```jsx\r\n<tr v-for="item in list" :key="item.id">\r\n  <td>张三</td>\r\n  <td>18</td>\r\n  <td>体育好</td>\r\n  <td>\r\n    <button @click="del(item.id)">删除</button>\r\n    <button>编辑</button>\r\n  </td>\r\n</tr>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 4. 谈谈你对 HTML 语义化的理解？\r\n\r\n考察核心点: 语义化的好处 (利于SEO, 可阅读性更好)\r\n\r\n**语义化之前：**\r\n\r\n在提倡语义化之前，你可能会使用各种各样的标签去实现同样的功能，比如：\r\n\r\n- 使用 span、div、p、a 等做文字, 做按钮\r\n- 使用 div 做一切\r\n\r\n从功能方面来说，这确实是不存在什么问题的，完全可以达到功能效果。但这不符合直觉，非常不友好：\r\n\r\n- 对人不友好：阅读代码的人不能一眼看出代码的功能\r\n- 对机器不友好：解析代码的程序不能很好的对这些元素进行分类处理\r\n\r\n\r\n\r\n**语义化之后：**\r\n\r\n为了解决上面说的问题，HTML5 规范提倡语义化标签，即使⽤恰当语义的 HTML 标签让⻚⾯具有良好的结构与含义，⽐如：\r\n\r\n- `<p>` 标签就代表段落\r\n- `<article>` 代表正⽂内容\r\n- `<button> `代表按钮\r\n- `<header>` 代表头部\r\n- 等等...\r\n\r\n语义化的好处：\r\n\r\n| 对开发者的好处                                               | 对机器/程序的好处                                            |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| 使⽤了语义化标签的程序，可读性明显增强，开发者可以比容易和清晰地看出⽹⻚的结构；这也更利于整个开发团队的协作开发和后续维护工作 | 带有语义的网页代码在⽂字类应用上的表现⼒丰富，利于搜索引擎爬⾍程序来爬取和提取出有效的信息；语义化标签还⽀持读屏软件，根据⽂章可以⾃动⽣成⽬录等，方便特殊人群无障碍的使用这些网页程序。 |\r\n\r\n**语义化的适用性：**\r\n\r\n语义化适合内容型的网站来使用（如简书、知乎），对其⽹站内容的传播有很⼤帮助。\r\n\r\n\r\n\r\n## 5. HTML5 对比 HTML4 有哪些不同之处？\r\n\r\n**考察点: 是否了解 html5 新增的一些新特性**\r\n\r\n| 不同点                                  | 备注说明                                                     |\r\n| --------------------------------------- | ------------------------------------------------------------ |\r\n| 只有一种 DOCTYPE ⽂件类型声明(统一标准) | `<!DOCTYPE html>`                                            |\r\n| 增加了一些新的标签元素(功能, 语义化)    | **section**, **video**, progress, **nav**, meter, time, **aside**, <br/>**canvas**, command, datalist, details, embed, figcaption, <br/>figure, **footer**, **header**, hgroup... |\r\n| input 支持了几个新的类型值              | `date, email, url` 等等                                      |\r\n| 新增了一些标签属性                      | charset（⽤于 meta 标签）；async（⽤于 script 标签）         |\r\n| 新增的全域属性                          | contenteditable, draggable... <br/>hidden...                 |\r\n| 新增API                                 | 本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket... |\r\n\r\n获取地理定位: navigator.geolocation.getCurrentPosition(successCallback, errorCallback) (为了安全, 需要在 https 网站使用)\r\n\r\n记忆角度: 更标准, 新增标签, 新增type表单属性, 新增全域属性, 新增API...\r\n\r\n\r\n\r\n\r\n\r\n## 6. meta 标签有哪些常用用法？\r\n\r\n`<meta>` 标签的具体功能一般由 name/http-equiv 和 content 两部分属性来定义。\r\n\r\n- 如果设置 name 属性，则它描述的是网页文档的信息（例如：作者、⽇期和时间、⽹⻚描述、 关键词）\r\n- 如果设置 http-equiv 属性，则它描述的相当于是 HTTP 响应头信息（例如：网页内容信息, 网页缓存等）\r\n\r\n**一些常用的功能及写法：**\r\n\r\n1. 设置网页关键词 (SEO)\r\n\r\n```html\r\n<meta name="keywords" content="电商,好货,便宜">\r\n```\r\n\r\n2. 设置网页视口（viewport）控制视⼝的⼤⼩、缩放和⽐例等 (移动端开发)\r\n\r\n```html\r\n<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">\r\n```\r\n\r\n3. 设置 http 响应头：Content-Type 网页内容类型  (字符集)\r\n\r\n```html\r\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\r\n\r\n\x3c!-- 设置字符集可简写为 --\x3e\r\n<meta charset="utf-8">\r\n```\r\n\r\n\r\n\r\n## 7. img 标签的 srcset 的作用是什么？\r\n\r\n**考察点: 处理响应式图片的方式** (css媒体查询换的是背景图片, 而不是 img 标签的 src)\r\n\r\n开发者和设计师们竞相寻求 **处理响应式图片** 的方法。这的确是一个[棘手的问题](https://css-tricks.com/responsive-images-hard/) ，因为我们对同一个网站在众多设备宽度下，\r\n\r\n使用同一图像源。你愿意在一个大显示屏上显示模糊地、马赛克状的图像？\r\n\r\n你愿意在你的手机上加载一个巨大的（虽然更漂亮的）图像？这个问题令人左右为难。 [博客链接](https://www.jiangweishan.com/article/response-srcset-sizes.html)\r\n\r\n其实通过使用 img 标签的 srcset 属性，可定义一组额外的图片集合，让浏览器根据不同的屏幕状况选取合适的图片来显示。\r\n\r\n> 也就是图片的响应式处理能力。\r\n\r\n如果你的响应式需求比较简单，只需要针对屏幕的不同 dpr （device pixel ratio，设备像素比）来决定图片的显示的话，\r\n\r\ndpr 设备像素比, 越高, 能够显示的越清晰  (dpr: 2, dpr: 3)\r\n\r\n那么就只要这么写：\r\n\r\n```html\r\n<img srcset="320.png 1x, 640.png 2x, 960.png 3x" />\r\n```\r\n\r\n对于可变宽度的图像，我们使用`srcset`搭配`w`描述符以及`sizes`属性 。\r\n\r\n- `w`描述符告诉浏览器列表中的每个图象的宽度。\r\n\r\n- `sizes`属性需要至少包含两个值，是由逗号分隔的列表。\r\n\r\n根据最新规范，如果`srcset`中任何图像使用了`w`描述符，那么必须要设置`sizes`属性。\r\n\r\n`sizes`属性有两个值：\r\n\r\n1. 第一个是媒体查询条件；\r\n\r\n2. 第二个是图片对应的尺寸值，\r\n\r\n   在特定媒体条件下，此值决定了图片的宽度。\r\n\r\n   需要注意是，源图尺寸值不能使用百分比，如果要用100%,  `vw`是唯一可用的CSS单位。\r\n\r\n```html\r\n<img alt="img元素srcset属性浅析"\r\n  srcset="\r\n    320.png 320w, \r\n    480.png 480w, \r\n    640.png 640w"\r\n  sizes="\r\n    (max-width: 320px) 100vw, \r\n    (max-width: 360px) 320px,\r\n    (max-width: 480px) 360px,\r\n    (max-width: 640px) 480px,\r\n    640px"\r\n  src="640.png"\r\n/>\r\n```\r\n\r\n为 img 定义以上属性后，浏览器的工作流程如下：\r\n\r\n1. 检查设备的实际宽度\r\n2. 检查 img 标签的 sizes 属性中定义的媒体查询条件列表，并计算哪个条件最先匹配到\r\n3. 得到图片此时的响应式宽度\r\n4. 加载 srcset 中最接近, 最适合媒体查询匹配到的宽度的图片\r\n\r\n注意: 测试时, 清除缓存测试, 因为一旦加载了高清图, 就不会也没有必要, 回过去再用小图替换了\r\n\r\n且我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。\r\n\r\n(译者注：srcset和size列表是对浏览器的一个建议(hint)，而非指令。由浏览器根据其能力、网络等因素来决定。)\r\n\r\n\r\n\r\n## 8. 响应式图片处理优化: Picture 标签\r\n\r\n**考察点: 响应式图片处理**\r\n\r\n`picture`元素就像是图像和其源的容器。浏览器仍然需要`img`元素，用来表明需要加载的图片\r\n\r\n在 `<picture>` 下可放置零个或多个`<source>`标签、以及一个`<img>`标签，为不同的屏幕设备和场景显示不同的图片。\r\n\r\n如果source匹配到了, 就会优先用匹配到的, 如果没有匹配到会往下继续找\r\n\r\n使用`picture`元素选择图像，不会有歧义。\r\n\r\n浏览器的工作流程如下：\r\n\r\n- 浏览器会先根据当前的情况，去匹配和使用`<source>`提供的图片\r\n\r\n- 如果未匹配到合适的`<source>`，就使用`<img>`标签提供的图片\r\n\r\n```html\r\n<picture>\r\n  <source srcset="640.png" media="(min-width: 640px)">\r\n  <source srcset="480.png" media="(min-width: 480px)">\r\n  <img src="320.png" alt="">\r\n</picture>\r\n```\r\n\r\n\r\n\r\n## 9. 在 script 标签上使用 defer 和 async 的区别是什么？\r\n\r\n**明确: defer 和 async 的使用, 可以用于提升网页性能**\r\n\r\nscript标签存在两个属性，defer和async，因此 script标签 的使用分为三种情况：\r\n\r\n1. `<script src="example.js"><\/script>`\r\n\r\n   没有defer或async属性，浏览器会立即加载并执行相应的脚本。\r\n\r\n   不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载\r\n\r\n2. `<script async src="example.js"><\/script>`\r\n\r\n   有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；\r\n\r\n3. `<script defer src="example.js"><\/script>`\r\n\r\n   有了defer属性，加载后续文档的过程和js脚本的加载是并行进行的(异步)，此时的js脚本仅加载不执行, js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。\r\n\r\n下图是使用了 defer、async、和未使用时的运行情况对比：\r\n\r\n<img src="\\images\\image-20210209172314832.png" alt="image-20210209172314832" />\r\n\r\n> 【上图的图例说明】\r\n>\r\n> 绿线：HTML 的解析时间\r\n>\r\n> 蓝线：JS 脚本的加载时间\r\n>\r\n> 红色：JS 脚本的执行时间\r\n\r\n从图中我们可以明确一下几点：\r\n\r\n　　1.defer和async在网络加载过程是一致的，都是异步执行的；(放在页面顶部, 也不会阻塞页面的加载, 与页面加载同时进行)\r\n\r\n　　2.两者的区别, 脚本加载完成之后, async是立刻执行, defer会等一等 (等前面的defer脚本执行, 等dom的加载)\r\n\r\n所以, js脚本加上 async 或 defer, 放在头部可以减少网页的下载加载时间, 如果不考虑兼容性, 可以用于优化页面加载的性能\r\n\r\n```jsx\r\n<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js"><\/script>\r\n<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js"><\/script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 10. 前端做本地数据存储的方式有哪些？\r\n\r\n<img src="\\images\\image-20210209174438863.png" alt="image-20210209174438863" />\r\n\r\n1. Cookies\r\n2. localStorage\r\n3. sessionStorage\r\n4. Web SQL\r\n5. IndexedDB\r\n\r\n\r\n\r\n## 11. 以上几种前端存储的区别是什么？\r\n\r\n| 方式名称       | 标准说明     | 功能说明                                                     |\r\n| -------------- | ------------ | ------------------------------------------------------------ |\r\n| Cookies        | HTML5 前加入 | 1.会为每个请求自动携带所有的Cookies数据，比较方便，但是也是缺点，浪费流量；<br>2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie) |\r\n| localStorage   | HTML5 加入   | 1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M |\r\n| sessionStorage | HTML5 加入   | 1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储 |\r\n| Web SQL        | 非标准功能   | 1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作； |\r\n| IndexedDB      | HTML5 加入   | 1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限 |\r\n\r\n---\r\n\r\n\r\n\r\n# CSS基础\r\n\r\n## 1. CSS选择器的优先级是怎么样的？\r\n\r\n**CSS选择器的优先级顺序：**\r\n\r\n`内联样式` > `ID选择器` > `类选择器` > `标签选择器`\r\n\r\n**优先级的计算：**\r\n\r\n优先级是由 A、B、C、D 四个值来决定的，具体计算规则如下\r\n\r\n- A={如果存在内联样式则为1，否则为0}\r\n- B={ID选择器出现的次数}\r\n- C={类选择器、属性选择器、伪类选择器出现的总次数}\r\n- D={标签选择器、伪元素选择器出现的总次数}\r\n\r\n**计算示例：**\r\n\r\n样式一：\r\n\r\n```css\r\n/*\r\n  A=0   不存在内联样式\r\n  B=0   不存在ID选择器\r\n  C=1   有一个类选择器\r\n  D=3   有三个标签选择器\r\n\r\n  最终计算结果：{0,0,1,3}\r\n*/\r\ndiv ul li .red { ... }\r\n```\r\n\r\n样式二：\r\n\r\n```css\r\n/*\r\n  A=0   不存在内联样式\r\n  B=1   有一个ID选择器\r\n  C=0   不存在类选择器\r\n  D=0   不存在标签选择器\r\n\r\n  最终计算结果：{0,1,0,0}\r\n*/\r\n#mydiv { ... }\r\n```\r\n\r\n计算完成后，我们通过从A到D的顺序进行值的大小比较，权重由A到D从高到低，只要比较出最大值即可。例如上面的两个样式：\r\n\r\n```md\r\n1. 样式一的A=0，样式二的A=0  【相等，继续往下比较】\r\n2. 样式一的B=0 < 样式二的B=1 【样式二的大，不继续往下比了，即认为样式二的优先级更高】\r\n```\r\n\r\n\r\n\r\n## 2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？\r\n\r\n| 方式                  | 说明                                                         |\r\n| --------------------- | ------------------------------------------------------------ |\r\n| opacity: 0            | 通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互 |\r\n| visibility: hidden    | 与透明度为0的方案非常类似，会占据空间，但不可以进行交互      |\r\n| overflow: hidden      | 只会隐藏元素溢出的部分；占据空间且不可交互                   |\r\n| display: none         | 可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局 |\r\n| z-index: -9999        | 通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果 |\r\n| transform: scale(0,0) | 通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互      |\r\n| left: -9999px         | 通过将元素定位到屏幕外面，达到看起来看不到的效果             |\r\n\r\n\r\n\r\n## 3. px、em、rem之间有什么区别？\r\n\r\n**考察点: 相对单位, 绝对单位, 以及适配问题**\r\n\r\n| 单位名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| px       | 绝对单位。代表像素数量，页面会按照给出的精确像素进行展示     |\r\n| em       | 相对单位。默认的基准点为父元素的字体大小，而如果自身定义了字体大小则按自身的来算。所以即使在同一个页面内，1em可能不是一个固定的值。 |\r\n| rem      | 相对单位。可以理解为 `root em`，即基准点为根元素`<html>`的字体大小。rem是CSS3中新增单位，Chrome/FireFox/IE9+都支持, 一般用于做移动端适配 |\r\n\r\n正常开发 px 使用率较高, 如果要做 rem 适配, 会用到 rem 单位!\r\n\r\nrem布局的原理:\r\n\r\n1. 使用 rem 为单位\r\n2. 动态的设置 html font-size (媒体查询, js设置, 插件设置都可以)\r\n\r\nwebpack有工具, 可以写 px, 自动转 rem  https://youzan.github.io/vant/#/zh-CN/advanced-usage\r\n\r\n\r\n\r\n\r\n\r\n## 4. 让元素水平居中的方法有哪些？\r\n\r\n**方法一：使用 margin**\r\n\r\n通过为元素设置左右的 margin 为 auto，实现让元素居中。\r\n\r\n```html\r\n<div class="center">本内容会居中</div>\r\n```\r\n\r\n```scss\r\n.center {\r\n   height: 500px;\r\n   width: 500px;\r\n   background-color: pink;\r\n   margin: 0 auto;\r\n}\r\n```\r\n\r\n\r\n\r\n**方式二: 转成行内块,  给父盒子设置 text-align: center**\r\n\r\n```html\r\n<div class="father">\r\n\t<div class="center">我是内容盒子</div>\r\n</div>\r\n```\r\n\r\n```css\r\n.father {\r\n  text-align: center;\r\n}\r\n.center {\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: pink;\r\n  display: inline-block;\r\n}\r\n```\r\n\r\n\r\n\r\n**方法三：使用 flex 布局**\r\n\r\n使用 flex 提供的子元素居中排列功能，对元素进行居中。\r\n\r\n```html\r\n<div class="father">\r\n\t<div class="center">我是内容盒子</div>\r\n</div>\r\n```\r\n\r\n```css\r\n.father {\r\n  display: flex;\r\n  background-color: skyblue;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.center {\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: pink;\r\n}\r\n```\r\n\r\n\r\n\r\n**方式四: 使用定位布局**\r\n\r\n```html\r\n<div class="father">\r\n  <div class="center">我是内容盒子</div>\r\n</div>\r\n```\r\n\r\n```css\r\n.father {\r\n  background-color: skyblue;\r\n  position: relative;\r\n  height: 500px;\r\n}\r\n.center {\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: pink;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n\r\n[【更多方式参考】实现水平居中垂直居中](https://www.cnblogs.com/chengxs/p/11231906.html)\r\n\r\n\r\n\r\n## 5. 在 CSS 中有哪些定位方式？\r\n\r\n也就是 position 样式的几个属性。\r\n\r\n\r\n\r\n**static 正常文档流定位**\r\n\r\n- 此时设置 top、right、bottom、left 以及 z-index 都无效\r\n\r\n- 块级元素遵循从上往下纵向排列，行级元素遵循从左到右排列\r\n\r\n\r\n\r\n**relative 相对定位**\r\n\r\n这个 **“相对”** 是指相对于正常文档流的位置。\r\n\r\n\r\n\r\n**absolute 绝对定位**\r\n\r\n当前元素相对于 **最近的非 static 定位的祖先元素 **来确定自己的偏移位置。\r\n\r\n例如，当前为 absolute 的元素的父元素、祖父元素都为 relative，则当前元素会相对于父元素进行偏移定位。\r\n\r\n\r\n\r\n**fixed 固定定位**\r\n\r\n当前元素相对于屏幕视口 viewport 来确定自己的位置。并且当屏幕滚动时，当前元素的位置也不会发生改变。\r\n\r\n\r\n\r\n**sticky 粘性定位**\r\n\r\n这个定位方式有点像 relative 和 fixed 的结合。当它的父元素在视口区域、并进入 top 值给定的范围内时，当前元素就以 fixed 的方式进行定位，否则就以 relative 的方式进行定位。\r\n\r\n```html\r\n<style>\r\n  * {\r\n    margin: 0;\r\n    padding: 0;\r\n  }\r\n  .header {\r\n    width: 100%;\r\n    height: 100px;\r\n    background-color: orange;\r\n  }\r\n  .nav {\r\n    width: 100%;\r\n    height: 200px;\r\n    background-color: pink;\r\n    position: sticky;\r\n    top: 0px;\r\n  }\r\n  .main {\r\n    width: 100%;\r\n    height: 100px;\r\n    background-color: skyblue;\r\n  }\r\n\r\n</style>\r\n\r\n<div class="header">我是头部</div>\r\n<div class="nav">我是导航</div>\r\n<div class="container">\r\n    <div class="main">我是主体部分1</div>\r\n    <div class="main">我是主体部分2</div>\r\n    <div class="main">我是主体部分3</div>\r\n    <div class="main">我是主体部分4</div>\r\n    <div class="main">我是主体部分5</div>\r\n    <div class="main">我是主体部分6</div>\r\n    <div class="main">我是主体部分7</div>\r\n    <div class="main">我是主体部分8</div>\r\n</div>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 6. 如何理解 z-index？\r\n\r\n可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。\r\n\r\n元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。\r\n\r\n\r\n\r\n<img src="\\images\\image-20210209212043708.png" alt="image-20210209212043708" style="zoom:70%;" />\r\n\r\n可以将这种关系想象成一摞书本，通过 z-index 可以改变一本书在这摞书中的上下位置。\r\n\r\nz-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级\r\n\r\n```html\r\n<style>\r\n  .father {\r\n    width: 100%;\r\n    height: 200px;\r\n    position: relative;\r\n    background-color: skyblue;\r\n    z-index: 1;\r\n  }\r\n  .son {\r\n    position: absolute;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: red;\r\n    left: 0;\r\n    top: 0;\r\n    z-index: 999;\r\n  }\r\n  .box2 {\r\n    position: absolute;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: blue;\r\n    left: 0;\r\n    top: 0;\r\n    z-index: 100;\r\n  }\r\n</style>\r\n\r\n<div class="father">\r\n  <div class="son"></div>\r\n</div>\r\n\r\n<div class="box2"></div>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 7. 如何清除浮动 ？\r\n\r\n**考察: css基本功**\r\n\r\n可以有以下几种方式：\r\n\r\n1. 定高法\r\n\r\n2. 使用一个空的div，并设置样式\r\n\r\n```html\r\n<div style="clear:both"></div>\r\n```\r\n\r\n3. 为父元素添加 `overflow: hidden`\r\n\r\n4. 定义一个 clearfix 样式类\r\n\r\n```css\r\n.clearfix:after {\r\n  content: "";  \t\t\t/*设置内容为空*/\r\n  height: 0;    \t\t\t/*高度为0*/\r\n  line-height: 0;\t\t\t/*行高为0*/\r\n  display: block;\t\t\t/*将文本转为块级元素*/\r\n  visibility: hidden;\t/*将元素隐藏*/\r\n  clear: both; \t\t\t\t/*清除浮动*/\r\n}\r\n\r\n.clearfix {\r\n  zoom: 1; \t\t\t\t/*为了兼容IE*/\r\n}\r\n```\r\n\r\n说明：当前 flex 已成为主流布局方式，适应性强, 且稳定, 所以浮动使用率目前已逐步降低。 \r\n\r\n\r\n\r\n## 8. 谈谈你对 BFC 的理解？\r\n\r\n**什么是 BFC：**\r\n\r\nBFC 的全称是 Block Formatting Context，块级格式化上下文。这是一个用于在盒模型下布局块级盒子的独立渲染区域，\r\n\r\n将处于BFC区域内和区域外的元素进行互相隔离。\r\n\r\n\r\n\r\n**何时会形成 BFC：**\r\n\r\n满足下列条件之一就可触发BFC：\r\n\r\n- HTML根元素\r\n- position 值为 `absolute` 或 `fixed`\r\n- float 值不为 `none`\r\n- overflow 值不为 `visible`\r\n- display 值为 `inline-block`、`table-cell` 或 `table-caption`\r\n\r\n\r\n\r\n**BFC 的应用场景：**\r\n\r\n1. 场景一：防止两个相邻块级元素的上下 margin 发生重叠 (**上下margin合并问题**)\r\n\r\n属于同一 BFC 的, 两个相邻块级子元素的上下 margin 会重叠，如果想让它们不重叠，可通过让这两个相邻块级子元素分属于不同的BFC。\r\n\r\n以下示例代码中的两个盒子的上下外边距会重合（即它们都设置了10px的外边距，我们期望它们之间的间距是 20px，但实际效果却只有 10px）：\r\n\r\n```html\r\n<style>\r\n  .box1 {\r\n    width: 200px;\r\n    height: 100px;\r\n    background-color: red;\r\n    margin-bottom: 10px; /* 下外边距为 10px */\r\n  }\r\n\r\n  .box2 {\r\n    width: 200px;\r\n    height: 100px;\r\n    background-color: green;\r\n    margin-top: 10px;  /* 上外边距为 10px */\r\n  }\r\n</style>\r\n\r\n<div class="box1"></div>\r\n<div class="box2"></div>\r\n```\r\n\r\n<img src="/images/image-20210217142711472.png" alt="image-20210217142711472" style="zoom:50%;" />\r\n\r\n下面我们让其中一个盒子触发BFC，从而达到间隔 20px 的期望效果：\r\n\r\n```css\r\n.box2 {\r\n  width: 200px;\r\n  height: 100px;\r\n  background-color: green;\r\n  margin-top: 10px;\r\n  display: inline-block; /* 通过设置 display 为 inline-block 可以触发 BFC */\r\n}\r\n```\r\n\r\n<img src="/images/image-20210217143506046.png" alt="image-20210217143506046" style="zoom:50%;" />\r\n\r\n\r\n\r\n\r\n\r\n2. 场景二：**清除浮动**\r\n\r\n以下示例代码中， 容器元素 box1 的高度会没有高：\r\n\r\n```html\r\n<style>\r\n  .box1 {\r\n    width: 200px;\r\n    background-color: red;\r\n  }\r\n\r\n  .box2 {\r\n    float: left;\r\n    background-color: green;\r\n  }\r\n</style>\r\n\r\n<div class="box1">\r\n  <div class="box2">Hello,world</div>\r\n  <div class="box2">Hello,world</div>\r\n  <div class="box2">Hello,world</div>\r\n</div>\r\n```\r\n\r\n而通过为 box1 添加 BFC 触发条件，可以让它的高度变回正常状态：\r\n\r\n```css\r\n.box1 {\r\n  width: 200px;\r\n  background-color: red;\r\n  overflow: hidden;\r\n}\r\n```\r\n\r\n\r\n\r\n3. 场景三：**实现自适应布局**, 防止元素被浮动元素覆盖(左边固定, 右边自适应)\r\n\r\n以下示例中，box2 会被设置了浮动的 box1 覆盖：\r\n\r\n```html\r\n<style>\r\n  .box1 {\r\n    float: left;\r\n    width: 300px;\r\n    background-color: red;\r\n    height: 400px;\r\n  }\r\n\r\n  .box2 {\r\n    background-color: blue;\r\n    height: 600px;\r\n  }\r\n</style>\r\n\r\n<div class="box1"></div>\r\n<div class="box2"></div>\r\n```\r\n\r\n<img src="/images/image-20210217145325690.png" alt="image-20210217145325690" style="zoom:30%;" />\r\n\r\n要避免这种覆盖行为，可以让 box2 触发 BFC,  实现布局效果, 左边固定右边自适应：\r\n\r\n```css\r\n.box2 {\r\n  background-color: blue;\r\n  height: 600px;\r\n  overflow: hidden; /* 将 overflow 设置为非 visible 值可触发 BFC */\r\n}\r\n```\r\n\r\n<img src="/images/image-20210217145504963.png" alt="image-20210217145504963" style="zoom:30%;" />\r\n\r\n\r\n\r\n[参考文章：深入理解BFC](https://www.cnblogs.com/xiaohuochai/p/5248536.html)\r\n\r\n\r\n\r\n## 9. 什么是CSS Sprites以及它的好处？\r\n\r\n**考察: 性能优化的方案**\r\n\r\nCSS Sprites，俗称雪碧图、精灵图。这是一种CSS图片合并技术，就是将CSS中原先引用的一些较小的图片，合并成一张稍大的图片后再引用的技术方案。它可以减少请求多张小图片带来的网络消耗（因为发起的HTTP请求数变少了），并实现提前加载资源的效果。\r\n\r\n**操作方式：**\r\n\r\n可以手工使用图片编辑软件（如Photoshop），将多张小图片合并编辑变成一张大图片，并针对这张大图片，编写CSS样式来引用这张大图片中对应位置的小图片（涉及到的样式：background-image、background-position、background-size）。然后在HTML元素中使用这些样式即可。\r\n\r\nhttps://img.alicdn.com/tfs/TB1eiXTXlTH8KJjy0FiXXcRsXXa-24-595.png\r\n\r\n**缺点：**\r\n\r\n- CSS Sprites中任意一张小图的改动，都需要重新生成大图；并且用户端需要重新下载整张大图，这就降低了浏览器缓存的优势\r\n- 随着HTTP2的逐渐普及，HTTP2的多路复用机制可以解决请求多个小图片所创建多个HTTP请求的消耗，让CSS Sprites存在的价值降低了\r\n- 图片如果放大, 是会失真\r\n\r\n目前其他主流的处理图片的方案:  iconfont 字体图标, svg矢量图...\r\n\r\n\r\n\r\n## 10. 你对媒体查询的理解是什么样的？\r\n\r\n**考察点: 响应式适配**, 根据不同的屏幕尺寸, 显示不同的效果 (设置盒子的样式)\r\n\r\n媒体查询是自 CSS3 开始加入的一个功能。它可以进行响应式适配展示。\r\n\r\n媒体查询由两部分组成：\r\n\r\n- 一个可选的媒体类型（如 screen、print 等）\r\n- 零个或多个媒体功能限定表达式（如 max-width: 500px、orientation: landscape 等）\r\n\r\n这两部分最终都会被解析为 true 或 false 值，然后整个媒体查询值为 true，则和该媒体查询关联的样式就生效，否则就不生效。\r\n\r\n**使用示例：**\r\n\r\n```css\r\n/* 在css样式表的定义中直接使用媒体查询 */ \r\n.container {\r\n  width: 600px;\r\n  height: 200px;\r\n  background-color: pink;\r\n  margin: 0 auto;\r\n}\r\n@media screen and (max-width: 767px) {\r\n  .container {\r\n    width: 100%;\r\n  }\r\n}\r\n@media screen and (min-width: 768px) and (max-width: 991px) {\r\n  .container {\r\n    width: 750px;\r\n  }\r\n}\r\n@media screen and (min-width: 992px) and (max-width: 1199px) {\r\n  .container {\r\n    width: 980px;\r\n  }\r\n}\r\n@media screen and (min-width: 1200px) {\r\n  .container {\r\n    width: 1170px;\r\n  }\r\n}\r\n@media screen and (width: 1200px) {\r\n  .container {\r\n    background-color: skyblue;\r\n  }\r\n}\r\n```\r\n\r\n[参考文章：深入理解CSS媒体查询](https://www.cnblogs.com/xiaohuochai/p/5848612.html)\r\n\r\n\r\n\r\n## 11. 你对盒子模型的理解是什么样的？\r\n\r\n浏览器的渲染引擎在对网页文档进行布局时，会按照 “CSS 基础盒模型” （CSS Basic Box Model）标准，将文档中的所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）。\r\n\r\n\r\n\r\n下图就是盒模型示意图，它由几部分组成：\r\n\r\n- 内容（content）\r\n- 内边距（padding）\r\n- 边框（border）\r\n- 外边距（margin）\r\n\r\n<img src="/images/image-20210214144941345.png" alt="image-20210214144941345" style="zoom:25%;" />\r\n\r\n\r\n\r\n\r\n\r\n## 12. 标准盒模型和怪异盒模型有哪些区别？\r\n\r\n两者的区别主要体现在元素尺寸的表示上。\r\n\r\n**盒模型的指定：**\r\n\r\n在CSS3中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：\r\n\r\n- content-box    标准盒模型\r\n- border-box     怪异盒模型\r\n\r\n**标准盒模型：**\r\n\r\nbox-sizing: content-box; (默认值)\r\n\r\n在标准盒模型下，元素的宽（width）和高（height）值即为盒模型中内容（content）的实际宽高值。\r\n\r\n<img src="/images/image-20210214150511841.png" alt="image-20210214150511841" style="zoom:25%;" />\r\n\r\n\r\n\r\n因此，计算一个元素宽度的公式如下(不考虑margin, margin是外边距,  如果是计算占用页面的空间, 就要带上margin)：\r\n\r\n> 盒子宽度 =  `border-left` + `padding-left` + `width` + `padding-right` + `border-right`\r\n>\r\n> 占据页面宽度 = `margin-left` + `border-left` + `padding-left` + `width` + `padding-right` + `border-right` + `margin-right`\r\n\r\n\r\n\r\n**怪异盒模型：**\r\n\r\nbox-sizing: border-box; (目前主流常用值)\r\n\r\n在怪异盒模型下，元素的 width 和 height 值却不是 content 的实际宽高，而是去除 margin 后剩下的元素占用区域的宽高，即：\r\n\r\n<img src="/images/image-20210214151037552.png" alt="image-20210214151037552" style="zoom:25%;" />\r\n\r\n\r\n\r\n因此，计算一个元素占用了页面总宽度的公式如下：\r\n\r\n> 盒子宽度 =  `width`\r\n>\r\n> 盒子占据页面宽度 = `margin-left` + `width` + `margin-right`\r\n\r\n[参考文章：深入理解盒模型](https://www.cnblogs.com/xiaohuochai/p/5202597.html)\r\n\r\n\r\n\r\n\r\n\r\n## 13. 说说伪类和伪元素的区别？\r\n\r\n**什么是伪类？**\r\n\r\n伪类（pseudo-class）是以冒号`:`为前缀，可被添加到⼀个选择器的末尾的关键字。\r\n\r\n它用于让样式在元素的特定状态下才被应用到实际的元素上。比如：`:checked`、`:hover`、`:disabled`、 `:first-child`等。\r\n\r\n:hover\r\n\r\n:nth-child(1)\r\n\r\n:nth-child(2)\r\n\r\n:checked\r\n\r\n注意: 伪类, 虽然是写法比较特殊, css选择器的权重, 和类一致的\r\n\r\n\r\n\r\n**什么是伪元素？**\r\n\r\n:before / :after\r\n\r\n伪元素⽤于创建⼀些并不在 DOM 树中的元素，并为其添加样式。伪元素的语法和伪类类似，可以一个冒号或两个冒号为前缀。\r\n\r\n⽐如，可以通过 `:before` 、`:after` 来在⼀个元素前、后增加⼀些额外的⽂本并为它们添加样式；\r\n\r\n并且，虽然⽤户可以看到这些⽂本，但其实它们并不在 DOM 树中。(**坑: 伪元素是无法注册事件的, 所以不要通过js控制伪元素**)\r\n\r\n\r\n\r\n**两者的区别**\r\n\r\n虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。\r\n\r\n- 伪类是用来匹配元素的特殊状态的\r\n- 伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现\r\n\r\n[参考文章：伪类与伪元素](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)\r\n\r\n\r\n\r\n## 14. 谈谈你对 flex 的理解？\r\n\r\n在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。\r\n\r\nflex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。 \r\n\r\n你能联想到的flex语法有哪些呢?\r\n\r\nflex-direction: 调整主轴方向\r\n\r\n```txt\r\nrow：主轴方向为水平向右\r\ncolumn：主轴方向为竖直向下\r\nrow-reverse:主轴方向为水平向左\r\ncolumn-reverse:主轴方向是竖直向上。\r\n```\r\n\r\njustify-content主要用来设置**主轴方向的对齐方式**\r\n\r\n```\r\nflex-start: 弹性盒子元素将向起始位置对齐\r\nflex-end: 弹性盒子元素将向结束位置对齐。\r\ncenter: 弹性盒子元素将向行中间位置对齐\r\nspace-around: 弹性盒子元素会平均地分布在行里\r\nspace-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。\r\n```\r\n\r\nalign-items用于调整**侧轴的对齐方式**\r\n\r\n```txt\r\nflex-start： 元素在侧轴的起始位置对齐。 \r\nflex-end： 元素在侧轴的结束位置对齐。\r\ncenter： 元素在侧轴上居中对齐。\r\nstretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。\r\n```\r\n\r\nflex-wrap属性控制flex容器是单行或者多行,默认不换行\r\n\r\n```txt\r\nnowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。\r\nwrap： 当宽度不够的时候，会换行。\r\n```\r\n\r\nalign-content用来设置多行的flex容器的排列方式\r\n\r\n```txt\r\nflex-start： 各行向侧轴的起始位置堆叠。 \r\nflex-end： 各行向弹性盒容器的结束位置堆叠。\r\ncenter： 各行向弹性盒容器的中间位置堆叠。\r\nspace-around： 各行在侧轴中平均分布。 \r\nspace-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 \r\nstretch：拉伸，不设置高度的情况下。\r\n```\r\n\r\n> 可参考 [flex布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\r\n\r\n---\r\n\r\n\r\n\r\n# JavaScript基础\r\n\r\n## 1. 解释下什么是变量声明提升？\r\n\r\n变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。\r\n\r\nJS引擎在运行一份代码的时候，会按照下面的步骤进行工作：\r\n\r\n1. 首先，对代码进行预解析，并获取声明的所有变量\r\n\r\n2. 然后，将这些变量的声明语句统一放到代码的最前面\r\n\r\n3. 最后，开始一行一行运行代码\r\n\r\n\r\n\r\n我们通过一段代码来解释这个运行过程：\r\n\r\n```js\r\nconsole.log(a) \r\n\r\nvar a = 1 \r\n\r\nfunction b() { \r\n  console.log(a) \r\n}\r\n\r\nb() // 1\r\n```\r\n\r\n\r\n\r\n上⾯这段代码的实际执⾏顺序为: \r\n\r\n1. JS引擎将 `var a = 1` 分解为两个部分：变量声明语句 `var a = undefined` 和变量赋值语句 `a = 1` \r\n2. JS引擎将 `var a = undefined` 放到代码的最前面，而 `a = 1` 保留在原地 \r\n\r\n\r\n\r\n也就是说经过了转换，代码就变成了:\r\n\r\n```js\r\nvar a = undefined\r\n\r\nconsole.log(a) // undefined \r\n\r\na = 1\r\n\r\nfunction b() { \r\n  console.log(a) \r\n}\r\n\r\nb() // 1\r\n```\r\n\r\n\r\n\r\n变量的这一转换过程，就被称为变量的声明提升。\r\n\r\n而这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题\r\n\r\n\r\n\r\n## 2. JS 的参数是以什么方式进行传递的？\r\n\r\n基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。\r\n\r\n**基本类型：是值传递**！\r\n\r\n基本类型的传递方式比较简单，是按照 `值传递` 进行的。\r\n\r\n```js\r\nlet a = 1\r\n\r\nfunction test(x) { \r\n  x = 10  // 并不会改变实参的值\r\n  console.log(x)\r\n}\r\n\r\ntest(a) // 10 \r\nconsole.log(a) // 1\r\n```\r\n\r\n\r\n\r\n**复杂类型: 传递的是地址! (变量中存的就是地址)**\r\n\r\n![image-20210305165413588](images/image-20210305165413588.png)\r\n\r\n来看下面的代码：\r\n\r\n```js\r\nlet a = {\r\n  count: 1 \r\n}\r\n\r\nfunction test(x) { \r\n  x.count = 10\r\n  console.log(x)\r\n}\r\n\r\ntest(a) // { count: 10 }\r\nconsole.log(a) // { count: 10 }\r\n```\r\n\r\n从运行结果来看，函数内改变了参数对象内的 `count` 后，外部的实参对象 `a` 的内容也跟着改变了，所以传递的是地址。\r\n\r\n思考题:\r\n\r\n```js\r\nlet a = {\r\n  count: 1 \r\n}; \r\n\r\nfunction test(x) { \r\n  x = { count: 20 };\r\n  console.log(x); \r\n}\r\n\r\ntest(a); // { count: 20 }\r\nconsole.log(a); // { count: 1 }\r\n```\r\n\r\n![image-20210305165848781](images/image-20210305165848781.png)\r\n\r\n我们会发现外部的实参对象 `a` 并没有因为在函数内对形参的重新赋值而被改变！\r\n\r\n因为当我们直接为这个形参变量重新赋值时，其实只是让形参变量指向了别的堆内存地址，而外部实参变量的指向还是不变的。\r\n\r\n下图展示的是复杂类型参数传递后的状态：\r\n\r\n<img src="/images/image-20210218233241397.png" alt="image-20210218233241397" style="zoom:50%;" />\r\n\r\n下图展示的是重新为形参赋值后的状态：\r\n\r\n<img src="/images/image-20210218233343016.png" alt="image-20210218233343016" style="zoom:50%;" />\r\n\r\n\r\n\r\n\r\n\r\n## 3. JavaScript垃圾回收是怎么做的？\r\n\r\nJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。\r\n\r\n正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，\r\n\r\n但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。\r\n\r\n###  3.1 内存的生命周期\r\n\r\nJS环境中分配的内存, 一般有如下生命周期：\r\n\r\n1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存\r\n\r\n2. 内存使用：即读写内存，也就是使用变量、函数等\r\n\r\n3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存\r\n\r\n   全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉\r\n\r\n内存分配:\r\n\r\n```jsx\r\n// 为变量分配内存\r\nlet i = 11\r\nlet s = "ifcode"\r\n\r\n// 为对象分配内存\r\nlet person = {\r\n    age: 22,\r\n    name: \'ifcode\'\r\n}\r\n\r\n// 为函数分配内存\r\nfunction sum(a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n### 3.2 垃圾回收算法说明\r\n\r\n所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉\r\n\r\n下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法\r\n\r\n### 3.3 引用计数\r\n\r\nIE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。\r\n\r\n如果没有任何变量指向它了，说明该对象已经不再需要了。\r\n\r\n```jsx\r\n// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1\r\nlet person = {\r\n    age: 22,\r\n    name: \'ifcode\'\r\n}\r\n\r\nlet p = person   // 两个变量指向一块内存空间, 该内存空间的引用数为 2\r\nperson = 1       // 原来的person对象被赋值为1，对象内存空间的引用数-1,\r\n                 // 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收\r\n\r\np = null         // 原person对象已经没有引用，会被回收\r\n```\r\n\r\n由上面可以看出，引用计数算法是个简单有效的算法。\r\n\r\n**但它却存在一个致命的问题：循环引用。**\r\n\r\n如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。\r\n\r\n```jsx\r\nfunction cycle() {\r\n    let o1 = {}\r\n    let o2 = {}\r\n    o1.a = o2\r\n    o2.a = o1 \r\n    return "Cycle reference!"\r\n}\r\n\r\ncycle()\r\n```\r\n\r\n![image-20210305172448582](images/image-20210305172448582.png)\r\n\r\n\r\n\r\n### 3.4 标记清除算法\r\n\r\n现代的浏览器已经不再使用引用计数算法了。\r\n\r\n现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。\r\n\r\n标记清除法:\r\n\r\n- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 \r\n\r\n- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。\r\n\r\n- 凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\r\n\r\n从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。\r\n\r\n根据这个概念，上面的例子可以正确被垃圾回收处理了。\r\n\r\n参考文章：[JavaScript内存管理](https://www.jianshu.com/p/84a8fd5fa0ee)\r\n\r\n\r\n\r\n## 4. 谈谈你对 JavaScript 作用域链的理解？\r\n\r\nJavaScript 在执⾏过程中会创建一个个的**可执⾏上下⽂**。 (每个函数执行都会创建这么一个可执行上下文)\r\n\r\n每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。\r\n\r\n这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。\r\n\r\n\r\n\r\n简而言之: 函数内部 可以访问到 函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,\r\n\r\n这样的变量作用域访问的链式结构, 被称之为作用域链\r\n\r\n```js\r\nlet num = 1\r\n\r\nfunction fn () {\r\n  let a = 100\r\n  function inner () {\r\n    console.log(a)\r\n    console.log(num)\r\n  }\r\n  inner()\r\n}\r\nfn()\r\n```\r\n\r\n\r\n\r\n下图为由多个可执行上下文组成的调用栈：\r\n\r\n- 栈最底部为`全局可执行上下文`\r\n- `全局可执行上下文` 之上有多个 `函数可执行上下文`\r\n- 每个可执行上下文中包含了指向外部其他可执行上下文的引用，直到 `全局可执行上下文` 时它指向 `null`\r\n\r\n<img src="/images/image-20210218143938843.png" alt="image-20210218143938843" style="zoom:30%;" />\r\n\r\n![image-20210306093300970](images/image-20210306093300970.png)\r\n\r\njs全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈\r\n\r\n每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用 \r\n\r\n**=> 就形成了作用域链**\r\n\r\n\r\n\r\n\r\n\r\n## 5. 谈谈你对闭包的理解？\r\n\r\n这个问题想考察的主要有两个方面：\r\n\r\n- 对闭包的基本概念的理解\r\n- 对闭包的作用的了解\r\n\r\n**什么是闭包？**\r\n\r\nMDN的官方解释：\r\n\r\n> 闭包是函数和声明该函数的词法环境的组合\r\n\r\n更通俗一点的解释是：\r\n\r\n> 内层函数, 引用外层函数上的变量, 就可以形成闭包\r\n\r\n需求: 定义一个计数器方法, 每次执行一次函数, 就调用一次进行计数\r\n\r\n```js\r\nlet count = 0\r\nfunction fn () {\r\n  count++\r\n  console.log(\'fn函数被调用了\' + count + \'次\')\r\n}\r\nfn()\r\n```\r\n\r\n这样不好! count 定义成了全局变量, 太容易被别人修改了,  我们可以利用闭包解决\r\n\r\n闭包实例:\r\n\r\n```jsx\r\nfunction fn () {\r\n  let count = 0\r\n\r\n  function add () {\r\n    count++\r\n    console.log(\'fn函数被调用了\' + count + \'次\')\r\n  }\r\n\r\n  return add\r\n}\r\nconst addFn = fn()\r\naddFn()\r\naddFn()\r\naddFn()\r\n```\r\n\r\n\r\n\r\n**闭包的主要作用是什么？**\r\n\r\n在实际开发中，闭包最大的作用就是用来 **变量私有**。\r\n\r\n下面再来看一个简单示例：\r\n\r\n```js\r\nfunction Person() {\r\n  // 以 let 声明一个局部变量，而不是 this.name\r\n  // this.name = \'zs\'     =>  p.name\r\n  let name = \'hm_programmer\' // 数据私有\r\n  \r\n  this.getName = function(){ \r\n    return name\r\n  }\r\n  \r\n  this.setName = function(value){ \r\n    name = value\r\n  }\r\n}\r\n\r\n// new:\r\n// 1. 创建一个新的对象\r\n// 2. 让构造函数的this指向这个新对象\r\n// 3. 执行构造函数\r\n// 4. 返回实例\r\nconst p = new Person()\r\nconsole.log(p.getName()) // hm_programmer\r\n\r\np.setName(\'Tom\')\r\nconsole.log(p.getName()) // Tom\r\n\r\np.name // 访问不到 name 变量：undefined\r\n```\r\n\r\n在此示例中，变量 `name` 只能通过 Person 的实例方法进行访问，外部不能直接通过实例进行访问，形成了一个私有变量。\r\n\r\n\r\n\r\n## 6. JavaScript中数据类型的隐式转换规则(了解)\r\n\r\n在if语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。\r\n\r\n下表展示了一系列原始值，通过隐式转换成数字、字符串、布尔类型后所得到的值：\r\n\r\n<img src="/images/image-20210218171603780.png" alt="image-20210218171603780" style="zoom:45%;" />\r\n\r\n坑: 判断时,  尽量不要用 `= =` , 要用 `= = =` ( 两个等号判断,  如果类型不同,  默认会进行隐式类型转换再比较)\r\n\r\n\r\n\r\n## 7. 谈谈你对原型链的理解？\r\n\r\n要讲清楚这个问题，主要着重这几个方面：\r\n\r\n- 什么是原型对象\r\n- 构造函数, 原型对象, 实例的三角关系图\r\n- 原型链如何形成\r\n\r\n![image-20210306104516852](images/image-20210306104516852.png)\r\n\r\n**原型对象**\r\n\r\n在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 `prototype` 的属性，指向原型对象，\r\n\r\n基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。\r\n\r\n例如我们的 `hasOwnProperty`, `toString` ⽅法等其实是 Obejct 原型对象的方法，它可以被任何对象当做⾃⼰的⽅法来使⽤。\r\n\r\n`hasOwnProperty` 用于判断, 某个属性, 是不是自己的  (还是原型链上的)\r\n\r\n来看一段代码：\r\n\r\n```js\r\nlet person = { \r\n  name: "Tom", \r\n  age: 18, \r\n  job: "student"\r\n}\r\n\r\nconsole.log(person.hasOwnProperty("name")) // true \r\nconsole.log(person.hasOwnProperty("hasOwnProperty")) // false \r\nconsole.log(Object.prototype.hasOwnProperty("hasOwnProperty")) // true\r\n```\r\n\r\n可以看到，`hasOwnProperty` 并不是 `person` 对象的属性，但是 `person` 却能调用它。\r\n\r\n那么 `person` 对象是如何找到 Object 原型中的 `hasOwnProperty` 的呢？这就要靠原型链的能力了。\r\n\r\n需求: 简单绘制原型三角关系图!\r\n\r\n\r\n\r\n**原型链**\r\n\r\n在 JavaScript 中，每个对象中都有一个 `__proto__` 属性，这个属性指向了当前对象的构造函数的原型。\r\n\r\n对象可以通过自身的 `__proto__`属性与它的构造函数的原型对象连接起来，\r\n\r\n而因为它的原型对象也有 `__proto__`，因此这样就串联形成一个链式结构，也就是我们称为的原型链。\r\n\r\n<img src="/images/image-20210218212449526.png" alt="image-20210218212449526" style="zoom:50%;" />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 6. 谈谈对于继承的理解\r\n\r\n**为什么要学习继承 ?**\r\n\r\n写的构造函数, 定义了一个类型 (人类), 万一项目非常大, 又有了细化的多个类型 (老师, 工人, 学生)\r\n\r\n学习继承, 可以让多个构造函数之间建立关联, 便于管理和复用\r\n\r\n**什么是继承 ?**\r\n\r\n继承: 从别人那里, 继承东西过来 (财产, 房产)\r\n\r\n代码层面的继承: 继承一些属性和方法\r\n\r\n### 6.1 继承 - 原型继承\r\n\r\n原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!\r\n\r\n分析需求:\r\n\r\n​\t人类, 属性: name, age\r\n\r\n​\t学生, 属性: name, age, className\r\n\r\n​\t工人, 属性: name, age, companyName\r\n\r\n无论学生, 还是工人, => 都是人类, 所以人类原型上有的方法, 他们都应该要有\r\n\r\n```js\r\n// 1. 定义Person构造函数\r\nfunction Person (name, age) {\r\n  this.name = name\r\n  this.age = age\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(\'人类会说话\')\r\n}\r\n\r\n// 2. 定义Student构造函数\r\nfunction Student (name, age, className) {\r\n  this.name = name\r\n  this.age = age\r\n  this.className = className\r\n}\r\n// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法\r\n// 语法: 子构造函数.prototype = new 父构造函数()\r\nStudent.prototype = new Person()\r\nStudent.prototype.study = function() {\r\n  console.log(\'学生在学习\')\r\n}\r\n\r\nlet stu = new Student(\'张三\', 18, \'80期\')\r\nstu.say()\r\nconsole.log(stu)\r\n```\r\n\r\n![image-20210306111112493](images/image-20210306111112493.png)\r\n\r\n\r\n\r\n\r\n\r\n### 6.2 继承 - 组合继承\r\n\r\n组合继承有时候也叫伪经典继承，指的是将原型链 和 借用构造函数 call 技术组合到一块，\r\n\r\n从而发挥二者之长的一种继承模式，其背后的思路: **是使用原型链实现对原型属性和方法的继承 (主要是方法)，**\r\n\r\n**而通过借用构造函数来实现对实例属性构造的继承**。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的自己的属性。\r\n\r\n```js\r\n// 1. 定义Person构造函数\r\nfunction Person (name, age) {\r\n  this.name = name\r\n  this.age = age\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(\'人类会说话\')\r\n}\r\n\r\n// 2. 定义Student构造函数\r\nfunction Student (name, age, className) {\r\n  Person.call(this, name, age) // 实现构造属性的继承\r\n  this.className = className\r\n}\r\n\r\n// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法\r\n// 语法: 子构造函数.prototype = new 父构造函数()\r\nStudent.prototype = new Person()\r\nStudent.prototype.study = function() {\r\n  console.log(\'学生在学习\')\r\n}\r\n\r\nlet stu = new Student(\'张三\', 18, \'80期\')\r\nstu.say()\r\nconsole.log(stu)\r\n\r\n// 方法通过 原型继承\r\n// 属性通过 父构造函数的.call(this, name, age)\r\n```\r\n\r\n\r\n\r\n### 6.3 继承 - 寄生组合继承\r\n\r\nstudent实例上有 name age,  而原型 `__proto__`上不需要再有这些属性, 所以利用 Object.create 改装下\r\n\r\nObject.create(参数对象),  \r\n\r\n1. Object.create 会创建一个新对象,\r\n2. 并且这个新对象的`__proto__` 会指向传入的参数对象\r\n\r\n```js\r\n// 1. 定义Person构造函数\r\nfunction Person (name, age) {\r\n  this.name = name\r\n  this.age = age\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(\'人类会说话\')\r\n}\r\n\r\n// 2. 定义Student构造函数\r\nfunction Student (name, age, className) {\r\n  Person.call(this, name, age)\r\n  this.className = className\r\n}\r\n\r\n// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法\r\n// 语法: 子构造函数.prototype = new 父构造函数()\r\nStudent.prototype = Object.create(Person.prototype)\r\nStudent.prototype.study = function() {\r\n  console.log(\'学生在学习\')\r\n}\r\n\r\nlet stu = new Student(\'张三\', 18, \'80期\')\r\nstu.say()\r\nconsole.log(stu)\r\n\r\n\r\n// 总结:\r\n// Object.create() 以参数的对象, 作为新建对象的__proto__属性的值, 返回新建的对象\r\n```\r\n\r\n![image-20210306114638139](images/image-20210306114638139.png)\r\n\r\n\r\n\r\n\r\n\r\n### 6.4 es6 - class 实现继承 extends\r\n\r\n```jsx\r\n// 继承关键字 => extends\r\nclass Person {\r\n  constructor (name, age) {\r\n    this.name = name\r\n    this.age = age\r\n  }\r\n  jump () {\r\n    console.log(\'会跳\')\r\n  }\r\n}\r\n\r\nclass Teacher extends Person {\r\n  constructor (name, age, lesson) {\r\n    super(name, age) // extends 中, 必须调用 super(), 会触发执行父类的构造函数\r\n    this.lesson = lesson\r\n    console.log(\'构造函数执行了\')\r\n  }\r\n  sayHello () {\r\n    console.log(\'会打招呼\')\r\n  }\r\n}\r\n\r\nlet teacher1 = new Teacher(\'zs\', 18, \'体育\')\r\nconsole.log(teacher1)\r\n```\r\n\r\n\r\n\r\n## 8. 如何判断是否是数组？\r\n\r\n方法一：使用 `toString` 方法\r\n\r\n```js\r\nfunction isArray(arg) {\r\n\treturn Object.prototype.toString.call(arg) === \'[object Array]\'\r\n}\r\n\r\nlet arr = [1,2,3]\r\nisArray(arr)  // true\r\n```\r\n\r\n方法二：使用 ES6 新增的 `Array.isArray` 方法\r\n\r\n```js\r\nlet arr = [1,2,3]\r\nArray.isArray(arr) // true\r\n```\r\n\r\n\r\n\r\n## 9. 谈谈你对this的理解？\r\n\r\n`this` 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。\r\n\r\n\r\n\r\n**默认绑定** (指向window的情况)  (函数调用模式 fn() )\r\n\r\n默认情况下，`this` 会被绑定到全局对象上，比如在浏览器环境中就为`window`对象，在node.js环境下为`global`对象。\r\n\r\n如下代码展示了这种绑定关系：\r\n\r\n```js\r\nmessage = "Hello"; \r\n\r\nfunction test () { \r\n  console.log(this.message); \r\n}\r\n\r\ntest() // "Hello"\r\n```\r\n\r\n\r\n\r\n**隐式绑定** (谁调用, this指向谁) (方法调用模式 obj.fn() )\r\n\r\n如果函数的调用是从对象上发起时，则该函数中的 `this` 会被自动隐式绑定为对象：\r\n\r\n```js\r\nfunction test() {\r\n\tconsole.log(this.message); \r\n}\r\n\r\nlet obj = {\r\n  message: "hello,world",\r\n  test: test\r\n}\r\n\r\nobj.test() // "hello,world"\r\n```\r\n\r\n\r\n\r\n**显式绑定** (又叫做硬绑定)  (上下文调用模式, 想让this指向谁, this就指向谁)\r\n\r\n硬绑定 => call  apply  bind\r\n\r\n可以显式的进行绑定：\r\n\r\n```js\r\nfunction test() {\r\n\tconsole.log(this.message); \r\n}\r\n\r\nlet obj1 = {\r\n  message: "你好世界123"\r\n}\r\n\r\nlet obj2 = {\r\n  message: "你好世界456"\r\n}\r\n\r\ntest.bind(obj1)() // "你好世界123"\r\ntest.bind(obj2)() // "你好世界456"\r\n```\r\n\r\n\r\n\r\n**new 绑定** (构造函数模式)\r\n\r\n另外，在使用 `new` 创建对象时也会进行 `this` 绑定\r\n\r\n当使用 `new` 调用构造函数时，会创建一个新的对象并将该对象绑定到构造函数的 `this` 上：\r\n\r\n```js\r\nfunction Greeting(message) {\r\n\tthis.message = message;\r\n}\r\n\r\nvar obj = new Greeting("hello,world")\r\nobj.message // "hello,world"\r\n```\r\n\r\n小测试:\r\n\r\n```jsx\r\nlet obj = {\r\n    a: {\r\n        fn: function () {\r\n            console.log(this)\r\n        },\r\n        b: 10\r\n    }\r\n}\r\nobj.a.fn()\r\nlet temp = obj.a.fn;\r\ntemp()\r\n\r\n// -------------------------------------------------------------\r\n\r\nfunction Person(theName, theAge){\r\n    this.name = theName\r\n    this.age = theAge\r\n}\r\nPerson.prototype.sayHello = function(){ // 定义函数\r\n    console.log(this)\r\n}\r\n\r\nlet per = new Person("小黑", 18)\r\nper.sayHello()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 10. 箭头函数中的this指向什么？\r\n\r\n箭头函数不同于传统函数，它其实没有属于⾃⼰的 `this`，\r\n\r\n它所谓的 `this` 是, 捕获其外层  上下⽂的 `this` 值作为⾃⼰的 `this` 值。\r\n\r\n并且由于箭头函数没有属于⾃⼰的 `this` ，它是不能被 `new` 调⽤的。\r\n\r\n\r\n\r\n我们可以通过 Babel 转换前后的代码来更清晰的理解箭头函数:\r\n\r\n```js\r\n// 转换前的 ES6 代码\r\nconst obj = { \r\n  test() { \r\n    return () => { \r\n      console.log(this === obj)\r\n    }\r\n  } \r\n}\r\n```\r\n\r\n```js\r\n// 转换后的 ES5 代码\r\nvar obj = { \r\n  test: function getArrow() { \r\n    var that = this\r\n    return function () { \r\n      console.log(that === obj)\r\n    }\r\n  } \r\n}\r\n```\r\n\r\n这里我们看到，箭头函数中的 `this` 就是它上层上下文函数中的 `this`。\r\n\r\n\r\n\r\n## 11. Promise 的静态方法\r\n\r\npromise的三个状态: pending(默认)   fulfilled(成功)   rejected(失败)\r\n\r\n1. resolve函数被执行时, 会将promise的状态从 pending 改成 fulfilled 成功\r\n2. reject函数被执行时, 会将promise的状态从pending 改成 rejected 失败\r\n\r\nPromise.reject()\r\n\r\n```js\r\nnew Promise((resolve, reject) => {\r\n\treject()\r\n})\r\n```\r\n\r\nPromise.resolve()\r\n\r\n```jsx\r\nnew Promise((resolve, reject) => {\r\n\tresolve()\r\n})\r\n```\r\n\r\n**Promise.all([promise1, promise2, promise3])**  等待原则, 是在所有promise都完成后执行, 可以用于处理一些`并发的任务`\r\n\r\n```jsx\r\n// 后面的.then中配置的函数, 是在前面的所有promise都完成后执行, 可以用于处理一些并发的任务\r\nPromise.all([promise1, promise2, promise3]).then((values) => {\r\n  // values 是一个数组, 会收集前面promise的结果 values[0] => promise1的成功的结果\r\n})\r\n```\r\n\r\nPromise.race([promise1, promise2, promise3]) 赛跑, 竞速原则, 只要三个promise中有一个满足条件, 就会执行.then(用的较少)\r\n\r\n![image-20210306144638905](images/image-20210306144638905.png)\r\n\r\n\r\n\r\n\r\n\r\n## 12. 宏任务 微任务 是什么\r\n\r\n小例题:\r\n\r\n```jsx\r\nconsole.log(1)\r\n\r\nsetTimeout(function() {\r\n\tconsole.log(2)\r\n}, 0)\r\n\r\nconsole.log(3)\r\n```\r\n\r\n宏任务: 主线程代码, setTimeout 等属于宏任务,  上一个宏任务执行完, 才会考虑执行下一个宏任务\r\n\r\n微任务: promise .then .catch的需要执行的内容, 属于微任务, 满足条件的微任务, 会被添加到当前宏任务的最后去执行\r\n\r\n![image-20201208040306978](images/image-20201208040306978.png)\r\n\r\n**事件循环队列 eventLoop**\r\n\r\n![image-20201208040235602](images/image-20201208040235602.png)\r\n\r\n例题1:\r\n\r\n```jsx\r\n  console.log(1)\r\n\r\n  setTimeout(function() {\r\n    console.log(2) // 宏任务\r\n  }, 0)\r\n\r\n  const p = new Promise((resolve, reject) => {\r\n    resolve(1000)\r\n  })\r\n  p.then(data => {\r\n    console.log(data)  // 微任务\r\n  })\r\n\r\n  console.log(3)\r\n```\r\n\r\n![image-20210306151137688](images/image-20210306151137688.png)\r\n\r\n\r\n\r\n例题2:\r\n\r\n```jsx\r\nasync function fn () {\r\n  console.log(111)\r\n}\r\nfn()\r\nconsole.log(222)\r\n```\r\n\r\n例题3:\r\n\r\n```jsx\r\nasync function fn () {\r\n  const res = await 2\r\n  console.log(res)\r\n}\r\nfn()\r\nconsole.log(222)\r\n```\r\n\r\n例题4:\r\n\r\n```jsx\r\nasync function fn () {\r\n  console.log(\'嘿嘿\')\r\n  const res = await fn2()\r\n  console.log(res)  // 微任务\r\n}\r\nasync function fn2 () {\r\n  console.log(\'gaga\')\r\n}\r\nfn()\r\nconsole.log(222)\r\n```\r\n\r\n![image-20210306152010989](images/image-20210306152010989.png)\r\n\r\n考察点: async 函数只有从 await 往下才是异步的开始\r\n\r\n\r\n\r\n## 13. async/await是什么？\r\n\r\nES7 标准中新增的 `async` 函数，从目前的内部实现来说其实就是 `Generator` 函数的语法糖。\r\n\r\n它基于 Promise，并与所有现存的基于Promise 的 API 兼容。 \r\n\r\n**async 关键字**\r\n\r\n1. `async` 关键字用于声明⼀个异步函数（如 `async function asyncTask1() {...}`） \r\n\r\n2. `async` 会⾃动将常规函数转换成 Promise，返回值也是⼀个 Promise 对象 \r\n\r\n4. `async` 函数内部可以使⽤ `await` \r\n\r\n**await 关键字**\r\n\r\n1. `await` 用于等待异步的功能执⾏完毕 `var result = await someAsyncCall()` \r\n\r\n2. `await` 放置在 Promise 调⽤之前，会强制async函数中其他代码等待，直到 Promise 完成并返回结果 \r\n\r\n3. `await` 只能与 Promise ⼀起使⽤\r\n\r\n4. `await` 只能在 `async` 函数内部使⽤ \r\n\r\n\r\n\r\n## 14. 相较于 Promise，async/await有何优势？\r\n\r\n1. 同步化代码的阅读体验（Promise 虽然摆脱了回调地狱，但 then 链式调⽤的阅读负担还是存在的）\r\n3. 和同步代码更一致的错误处理方式（ async/await 可以⽤成熟的 try/catch 做处理，比 Promise 的错误捕获更简洁直观） \r\n4. 调试时的阅读性, 也相对更友好\r\n\r\n\r\n\r\n## 15. 深拷贝 浅拷贝\r\n\r\n引用类型, 进行赋值时, 赋值的是地址\r\n\r\n1. 浅拷贝\r\n\r\n   ```jsx\r\n   let obj = {\r\n   \tname: \'zs\',\r\n   \tage: 18\r\n   }\r\n   let obj2 = {\r\n       ...obj\r\n   }\r\n   ```\r\n\r\n2. 深拷贝\r\n\r\n   ```jsx\r\n   let obj = {\r\n   \tname: \'zs\',\r\n   \tage: 18,\r\n       car: {\r\n           brand: \'宝马\',\r\n           price: 100\r\n       }\r\n   }\r\n   \r\n   let obj2 = JSON.parse(JSON.stringify(obj))\r\n   console.log(obj2)\r\n   ```\r\n\r\n   当然递归也能解决, 只是比较麻烦~\r\n   \r\n   ...\r\n\r\n其他方案, 可以参考一些博客\r\n\r\n---\r\n\r\n\r\n\r\n# HTTP协议\r\n\r\n## 1. HTTP有哪些⽅法？\r\n\r\nHTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD\r\n\r\nHTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT\r\n\r\n\r\n\r\n## 2. 各个HTTP方法的具体作用是什么？\r\n\r\n|  方法   | 功能                                                         |\r\n| :-----: | ------------------------------------------------------------ |\r\n|   GET   | 通常⽤于请求服务器发送某些资源                               |\r\n|  POST   | 发送数据给服务器                                             |\r\n|  HEAD   | 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源 |\r\n|   PUT   | ⽤于全量修改⽬标资源 (看接口, 也可以用于添加)                |\r\n| DELETE  | ⽤于删除指定的资源                                           |\r\n| OPTIONS | ⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全) |\r\n|  TRACE  | 该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断 |\r\n| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户) |\r\n|  PATCH  | ⽤于对资源进⾏部分修改                                       |\r\n\r\n\r\n\r\nGET POST PUT PATCH DELETE\r\n\r\nGET/DELETE  参数是在地址栏中传递的\r\n\r\nPUT/PATCH/POST 参数是在请求体传递的\r\n\r\n\r\n\r\n## 3. GET方法和POST方法有何区别？\r\n\r\n默认的http请求的内容, 在网络中传输, 明文的形式传递的  (https 对内容加密)\r\n\r\n|                  | GET方法                                                      | POST方法                                           |\r\n| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |\r\n| **数据传输⽅式** | 通过URL传输数据 (地址栏拼接参数)                             | 通过请求体传输                                     |\r\n| **数据安全**     | 数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息 | 数据因为在请求主体内，<br />所以有⼀定的安全性保证 |\r\n| **数据类型**     | 只允许 ASCII 字符                                            | ⽆限制                                             |\r\n| **GET⽆害**      | 刷新、后退等浏览器操作是⽆害的                               | 可能会引起重复提交表单                             |\r\n| **功能特性**     | 安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br />**幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）** | ⾮安全(会引起服务器端的变化)、**⾮幂等**           |\r\n\r\n\r\n\r\n## 4. HTTP请求报文是什么样的？\r\n\r\nHTTP 请求报⽂的组成：请求⾏、请求头、(空⾏)、请求体。\r\n\r\n实际请求报文实例:\r\n\r\n![image-20210305232854139](images/image-20210305232854139.png)\r\n\r\n**请求行**\r\n\r\n包含了请求⽅法、URL、HTTP 协议版本，它们之间⽤空格进行分隔。例如：\r\n\r\n```bash\r\nGET http://www.abc.com/articles HTTP/1.1\r\n```\r\n\r\n**请求头**\r\n\r\n请求头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号`:`进行分隔。例如：\r\n\r\n```\r\nContent-Type: application/json\r\nHost: www.abc.com\r\n```\r\n\r\n**请求体**\r\n\r\n请求体中放置 POST、PUT、PATCH 等请求方法所需要携带的数据。\r\n\r\n\r\n\r\n## 5. HTTP响应报文是什么样的？\r\n\r\nHTTP 响应报⽂的组成: 响应⾏、响应头、空⾏、响应体。\r\n\r\n<img src="/images/image-20210219125038371.png" alt="image-20210219125038371" style="zoom:40%;" />\r\n\r\n**响应行**\r\n\r\n响应行由协议版本、状态码、状态码的原因短语3个内容组成，中间以空格分隔。例如：\r\n\r\n```bash\r\nHTTP/1.1 200 OK\r\n```\r\n\r\n\r\n\r\n**响应头**\r\n\r\n响应头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号`:`进行分隔。例如：\r\n\r\n```\r\nContent-Length: 1024\r\nContent-Type: application/json\r\n```\r\n\r\n\r\n\r\n**响应体**\r\n\r\n服务器发送过来的数据。\r\n\r\n小结:\r\n\r\n![image-20210306161216371](images/image-20210306161216371.png)\r\n\r\n\r\n\r\n## 6. 你了解的HTTP状态码有哪些？\r\n\r\n**成功（2XX）**\r\n\r\n| 状态码 | 原因短语        | 说明                                                         |\r\n| ------ | --------------- | ------------------------------------------------------------ |\r\n| 200    | OK              | 表示从客户端发来的请求在服务器端被正确处理                   |\r\n| 201    | Created         | 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴<br />通常是在POST请求，或是某些PUT请求之后创建了内容, 进行的返回的响应 |\r\n| 202    | Accepted        | 请求服务器已接受，但是尚未处理，不保证完成请求<br />适合异步任务或者说需要处理时间比较长的请求，避免HTTP连接一直占用 |\r\n| 204    | No content      | 表示请求成功，但响应报⽂不含实体的主体部分                   |\r\n| 206    | Partial Content | 进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求<br />响应头中会包含获取的内容范围 (常用于分段下载) |\r\n\r\n\r\n\r\n**重定向（3XX）**\r\n\r\n| 状态码  | 原因短语           | 说明                                                         |\r\n| ------- | ------------------ | ------------------------------------------------------------ |\r\n| 301     | Moved Permanently  | 永久性重定向，表示资源已被分配了新的 URL<br />比如，我们访问 **http**://www.baidu.com 会跳转到 **https**://www.baidu.com |\r\n| 302     | Found              | 临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br />首页, 个人中心, 遇到了需要登录才能操作的内容, 重定向 到 登录页 |\r\n| 303     | See Other          | 对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。 |\r\n| **304** | **Not Modified**   | **自从上次请求后，请求的网页内容未修改过。<br />服务器返回此响应时，不会返回网页内容。(协商缓存)** |\r\n| 307     | Temporary Redirect | 对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。<br />不对请求做额外处理, 正常发送请求, 请求location中的url地址 |\r\n\r\n因为post请求, 是非幂等的,  从302中, 细化出了 303 和 307\r\n\r\n简而言之: \r\n\r\n- 301  302  307  都是重定向\r\n- 304 协商缓存\r\n\r\n\r\n\r\n**客户端错误（4XX）**\r\n\r\n| 状态码  | 原因短语        | 说明                                        |\r\n| ------- | --------------- | ------------------------------------------- |\r\n| **400** | **Bad Request** | **请求报⽂存在语法错误(（传参格式不正确）** |\r\n| 401     | UnAuthorized    | 权限认证未通过(没有权限)                    |\r\n| 403     | Forbidden       | 表示对请求资源的访问被服务器拒绝            |\r\n| 404     | Not Found       | 表示在服务器上没有找到请求的资源            |\r\n| 408     | Request Timeout | 客户端请求超时                              |\r\n| 409     | Confict         | 请求的资源可能引起冲突                      |\r\n\r\n\r\n\r\n**服务端错误（5XX）**\r\n\r\n| 状态码 | 原因短语                   | 说明                                                         |\r\n| ------ | -------------------------- | ------------------------------------------------------------ |\r\n| 500    | Internal Sever Error       | 表示服务器端在执⾏请求时发⽣了错误                           |\r\n| 501    | Not Implemented            | 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br />或者请求是服务器不⽀持的某个⽅法 |\r\n| 503    | Service Unavailable        | 表明服务器暂时处于超负载或正在停机维护，⽆法处理请求         |\r\n| 505    | Http Version Not Supported | 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本           |\r\n\r\n\r\n\r\n## 7. HTTP的keep-alive是什么作用？\r\n\r\n作用：使客户端到服务器端的连接**持续有效**(长连接)，当出现对服务器的后继请求时，\r\n\r\nKeep-Alive功能避免了建立或者重新建立连接。\r\n\r\n\r\n\r\n早期 HTTP/1.0 在每次请求的时候，都要创建⼀个新的连接，⽽创建连接的过程需要消耗资源和时间，\r\n\r\n为了减少资源消耗、缩短响应时间，就需要复⽤已有连接。\r\n\r\n\r\n\r\n在后来的 HTTP/1.0 以及 HTTP/1.1 中引⼊了复⽤连接的机制，也就是在请求头中加⼊Connection: keep-alive，\r\n\r\n以此告诉对⽅这个请求响应完成后不要关闭连接，下⼀次还⽤这个请求的连接进行后续交流。\r\n\r\n**协议规定，如果想要保持连接，则需要在请求头中加上 Connection: keep-alive。** \r\n\r\n\r\n\r\n**keep-alive 的优点** (复用连接)\r\n\r\n- 较少的 CPU 和内存的占⽤（因为要打开的连接数变少了, 复用了连接） \r\n- 减少了后续请求的延迟（⽆需再进⾏握⼿） \r\n- ...\r\n\r\n缺点: 因为在处理的暂停期间，本来可以释放的资源仍旧被占用。请求已经都结束了, 但是还一直连接着也不合适\r\n\r\n解决：Keep-Alive: timeout=5, max=100\r\n\r\n- timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），\r\n\r\n- max是最多一百次请求，强制断掉连接。\r\n\r\n  就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。\r\n\r\n\r\n\r\n## 8. 为什么需要HTTPS？\r\n\r\nHTTPS 是安全版的 HTTP。\r\n\r\nHTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。\r\n\r\n而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。\r\n\r\n\r\n\r\n## 9. HTTPS是如何保证安全的？\r\n\r\nHTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。\r\n\r\n那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。\r\n\r\n目前常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。\r\n\r\n\r\n\r\n### 9.1 **什么是对称加密？**\r\n\r\n对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，\r\n\r\n这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难\r\n\r\n通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。 \r\n\r\n![image-20210306005550796](images/image-20210306005550796.png)\r\n\r\n对称加密的特点是：\r\n\r\n- 优点:\r\n\r\n  计算量小、加密速度快、加密效率高。\r\n\r\n- 缺点: \r\n\r\n  在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。\r\n\r\n  如果一方的秘钥被泄露，那么加密信息也就不安全了\r\n\r\n使用场景：本地数据加密、https通信、网络传输等\r\n\r\n常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6\r\n\r\n\r\n\r\n### 9.2 **什么是⾮对称加密？**\r\n\r\n而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，\r\n\r\n这样就避免了直接传递密钥。这种新的加密模式被称为"非对称加密算法"。\r\n\r\n通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。\r\n\r\n特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容\r\n\r\n![image-20210306011528361](images/image-20210306011528361.png)\r\n\r\n非对称加密的特点是：\r\n\r\n- 优点：非对称加密与对称加密相比其安全性更好\r\n\r\n- 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。\r\n\r\n使用场景：https会话前期、CA数字证书、信息加密、登录认证等\r\n\r\n常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）\r\n\r\n\r\n\r\n### 9.3 **HTTPS 加密解决⽅案** \r\n\r\n结合了两种加密⽅式：\r\n\r\n- 将 `对称加密的密钥` ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 `对称加密密钥`\r\n\r\n- 双⽅沟通时使⽤ `对称加密密钥` 进⾏\r\n\r\n**可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。**\r\n\r\nHTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议 \r\n\r\n它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输\r\n\r\n\r\n\r\n### 9.4 数字证书\r\n\r\n为了安全性, 一般还需要签发数字证书! \r\n\r\n客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息\r\n\r\n进而进行非对称加密, 使用公钥, 加密`对称加密密钥`, 传递给服务器, 后续通信都使用对称加密!\r\n\r\n![image-20210306020401732](images/image-20210306020401732.png)\r\n\r\n**问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!**\r\n\r\n\r\n\r\n所以, 就需要有数字证书(CA证书),  一般是CA机构颁发的, 证明这个公钥是安全可靠的!\r\n\r\n**CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性**\r\n\r\n![image-20210306014409595](images/image-20210306014409595.png)\r\n\r\n\r\n\r\n当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端\r\n\r\n![image-20210306021013686](images/image-20210306021013686.png)\r\n\r\n而客户端, 接收到消息后, 就可以查看证书\r\n\r\n1. 如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!! \r\n\r\n2. 如果签发证书的机构, 不权威, 发出警告 \r\n\r\n   ![image-20210306021532010](images/image-20210306021532010.png)\r\n\r\n3. 如果证书过期了, 浏览器也会发出警告\r\n\r\n\r\n\r\n### 9.5 数字签名\r\n\r\n但这还是有问题：如果证书被篡改了怎么办?\r\n\r\n这时就需要用⼀个技术：**数字签名**。 (根据证书内容, 生成的一个唯一标识) \r\n\r\n数字签名就是先⽤ **CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要**，然后使⽤ CA 私钥进行加密，组成数字签名。\r\n\r\n当别⼈把他的证书发过来时，**接收方⽤同样的算法再次⽣成摘要**，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,\r\n\r\n就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。\r\n\r\n[博客参考](https://blog.csdn.net/u014044812/article/details/80723009)\r\n\r\n\r\n\r\n## 10. HTTP2和HTTP1.x比，有什么优势和特点？\r\n\r\n1. HTTP/2 采⽤`⼆进制格式`来传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议`解析起来更⾼效`\r\n2. HTTP/2 采用一些`头部压缩技术`，减少在请求和响应头中重复携带的数据，`降低网络负担`\r\n3. HTTP/2 采⽤`服务器推送`方式，主动向客户端推送资源，提高页面加载效率\r\n4. HTTP/2 采⽤`多路复用机制`，减少需要创建的连接数量，降低资源占用和性能消耗\r\n\r\n下面是一些与之关联的技术知识。\r\n\r\n\r\n\r\n**⼆进制格式分帧**\r\n\r\n帧：HTTP/2 数据通信的最⼩单位消息，是指 HTTP/2 中逻辑上的 HTTP 消息（例如请求、响应等）。消息由⼀个或多个帧组成 \r\n\r\n流：存在于连接中的⼀个虚拟通道，它可以承载双向消息，且每个流都有唯⼀的整数ID\r\n\r\n\r\n\r\n**头部压缩**\r\n\r\n在 HTTP/1.x 中，请求和响应中会重复携带一些不常改变、冗⻓的头数据，给⽹络带来额外负担。\r\n\r\n在 HTTP/2 中，客户端和服务端使⽤ **“⾸部表”** 来跟踪和存储之前发送过的键值对，\r\n\r\n相同的数据不再随着每次请求和响应发送。⾸部表在连接存续期间始终存在，由客户端和服务器共同渐进更新。\r\n\r\n每个新的⾸部键值对，要么被追加到当前表的末尾，要么替换表中已存在的键值对。\r\n\r\n> 可以简单的理解为：只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量\r\n\r\n\r\n\r\n下图为首部表的更新示意图：\r\n\r\n<img src="/images/image-20210219160534616.png" alt="image-20210219160534616" style="zoom:30%;" />\r\n\r\n\r\n\r\n**服务器推送**\r\n\r\n服务端可以在发送⻚⾯ HTML 内容时，再主动推送一些其它资源，⽽不⽤等到浏览器解析到相应的位置时发起请求后再作响应。\r\n\r\n例如，服务端可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 \r\n\r\n\r\n\r\n不过，服务端的主动推送行为，客户端有权利选择是否要接收。\r\n\r\n如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。\r\n\r\n\r\n\r\n**多路复用**\r\n\r\n在 HTTP 1.x 中如果想并发多个请求的话，必须使⽤多个 TCP 链接，但浏览器为了控制资源，\r\n\r\n会对单个域名有 6-8 个 TCP 链接的数量限制。而在 HTTP 2 中： \r\n\r\n- 同域名下的所有通信，都在单个连接上完成 \r\n- 单个连接可以承载任意数量的双向数据流 \r\n- 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成（多个帧可以乱序发送，因为可以根据帧⾸部的流标识来重新组装）\r\n\r\n![image-20210306023912779](images/image-20210306023912779.png)\r\n\r\n[参考文章：HTTP/2特性及其在实际应用中的表现](https://zhuanlan.zhihu.com/p/30166894)\r\n\r\n\r\n\r\n## 11. http缓存控制\r\n\r\n### 11.1 基本认知\r\n\r\n**Web 服务缓存** 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。\r\n\r\n**浏览器缓存** 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。**`这里我们只讨论 HTTP 缓存相关内容`。**\r\n\r\n**HTTP缓存**:\r\n\r\n- **强缓存**\r\n- **协商缓存**\r\n\r\n在具体了解 HTTP 缓存之前先来明确几个术语：\r\n\r\n- 缓存命中率：从缓存中得到数据的请求数  与    所有请求数的比率。理想状态是越高越好。\r\n- 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。\r\n- 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。\r\n- 失效：失效就是把内容从缓存中移除。\r\n\r\n**浏览器缓存主要是 HTTP 协议定义的缓存机制。**\r\n\r\n\r\n\r\n**浏览器缓存, HTTP缓存分类**\r\n\r\n浏览器缓存分为`强缓存 `和 `协商缓存`，浏览器加载一个页面的简单流程如下：\r\n\r\n1. 浏览器先根据这个资源的  **http头信息**  来 **判断是否命中强缓存**。\r\n\r\n   如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）\r\n\r\n2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。\r\n\r\n   服务器来判断浏览器本地缓存是否失效。\r\n\r\n   若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）\r\n\r\n3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）\r\n\r\n\r\n\r\n### 11.2 强缓存  (食品过期时间判断)\r\n\r\n**(进行判断, 是否资源过期, 如果未过期, 直接用缓存)**\r\n\r\n**强缓存**\r\n\r\n命中强缓存时，浏览器并不会将请求发送给服务器。\r\n\r\n在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。\r\n\r\n![img](images/940884-20180423141536107-329179455.png)\r\n\r\n\r\n\r\n强缓存是利用http的返回的响应头中的Expires或者Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。\r\n\r\nExpires: 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读\r\n\r\nCache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s\r\n\r\n\r\n\r\n**Expires**\r\n\r\n缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 \r\n\r\nExpires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\r\n\r\n![image-20201209080705571](D:/z_work/72期/面试加强课-day02/02-笔记/asset/image-20201209080705571.png)\r\n\r\n该字段会返回一个时间，比如Expires:  Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在xx年xx月xx日时间之前都是有效的，即命中缓存。\r\n\r\n这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当 **服务器与客户端 时间偏差很大**  以后，就会导致缓存混乱。于是发展出了Cache-Control。\r\n\r\n\r\n\r\n**Cache-Control**\r\n\r\nCache-Control是一个`相对时间`，例如Cache-Control:max-age 3600，代表着资源的有效期是3600秒。\r\n\r\n由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。\r\n\r\nCache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。\r\n\r\nCache-Control 可以由多个字段组合而成，主要有以下几个取值：\r\n\r\n1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。\r\n\r\n   例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，\r\n\r\n   第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。\r\n\r\n   ![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141638673-1917674992.png)\r\n\r\n   在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。\r\n\r\n2. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。\r\n\r\n   不是字面意思上的不缓存。 \r\n\r\n3. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。\r\n\r\n\r\n\r\n### 11.3 协商缓存 (找供货商专家协商)\r\n\r\n看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求)   强缓存\r\n\r\n食品过期时间过了,  能不能吃呢?  问问专家(服务器),  专家瞅了一眼, 没过期 (响应304, 不返回内容) , 直接吃          (协商缓存) \r\n\r\n如果问过专家(服务器), 专家瞅了一眼, 呀真过期了, 原来的不要了, 我重新给你发一个 (响应200, 并返回内容)\r\n\r\n**协商缓存**\r\n\r\n若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。\r\n\r\n服务器根据http头信息中的`Last-Modify/If-Modify-Since`或`Etag/If-None-Match`来判断是否命中协商缓存。\r\n\r\n如果命中，则http返回码为304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。\r\n\r\n\r\n\r\n**Last-Modify/If-Modify-Since**\r\n\r\n浏览器第一次请求一个资源的时候, 服务器返回的header中会加上Last-Modify，\r\n\r\nLast-modify是一个时间标识该资源的**最后修改时间**，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141852114-1757065670.png)\r\n\r\n当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，**该值为缓存之前返回的Last-Modify**。\r\n\r\n服务器收到If-Modify-Since后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。\r\n\r\n![img](images/940884-20180423141732879-1484228353.png)\r\n\r\n如果命中缓存，则返回 **http304**，并且不会返回资源内容，并且不会返回Last-Modify。\r\n\r\n由于对比的是服务端时间，所以客户端与服务端时间差距不会导致问题。\r\n\r\n**但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。**\r\n\r\n比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了,  **于是出现了ETag/If-None-Match。**\r\n\r\n\r\n\r\n**ETag/If-None-Match**\r\n\r\n与Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。\r\n\r\nETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。\r\n\r\nETag值的变更则说明资源状态已经被修改。\r\n\r\n服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141918779-1206116367.png)\r\n\r\nETag生成靠以下几种因子\r\n\r\n1. 文件的i-node编号，是Linux/Unix用来识别文件的编号。 \r\n\r\n2. 文件最后修改时间\r\n\r\n3. 文件大小\r\n\r\n   ...\r\n\r\n生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值\r\n\r\n\r\n\r\n**既生 Last-Modified 何生 Etag ？**\r\n\r\n你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？\r\n\r\nEtag的出现主要是为了解决几个Last-Modified比较难解决的问题：\r\n\r\n1. Last-Modified标注的最后修改只能精确到秒级\r\n\r\n   如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\r\n\r\n3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\r\n\r\nEtag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 **准确的控制缓存。** \r\n\r\n不会仅仅只根据最后的修改时间判断是否进行使用缓存\r\n\r\nLast-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，\r\n\r\n最后才决定是否返回304。\r\n\r\n\r\n\r\n小结:\r\n\r\n- 强缓存: 大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读 \r\n\r\n- 协商缓存: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间,  唯一标识etag), 去问服务器, 是否真的过期了\r\n\r\n  如果验证通过,  服务器会直接响应 304, 且不会返回资源\r\n\r\n\r\n\r\n### 11.4 整体请求缓存流程\r\n\r\n**浏览器第一次请求**\r\n\r\n\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141945261-83532090.png)\r\n\r\n**浏览器第二次请求**\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141951735-912699213.png)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n# TCP\r\n\r\n## TCP的特性\r\n\r\n主要有以下5点特性：\r\n\r\n1. TCP 提供⼀种⾯向连接的、可靠的字节流服务 \r\n\r\n2. 在⼀个 TCP 连接中，仅有两⽅进⾏彼此通信（⼴播和多播不能⽤于 TCP）\r\n\r\n3. TCP 使⽤校验、确认和重传机制来保证可靠传输 \r\n\r\n4. TCP 将数据分节进⾏排序，并使⽤累积来确认保证数据的顺序不变和⾮重复 \r\n\r\n5. TCP 使⽤滑动窗⼝机制来实现流量控制，通过动态改变窗⼝的⼤⼩进⾏拥塞控制 \r\n\r\n\r\n\r\n## 简述 TCP 和 UDP 的区别\r\n\r\n| 协议 | 连接性   | 双工性     | 可靠性                 | 有序性            | 有界性             | 拥塞控制 | 传输速度 | 量级 | 头部大小  |\r\n| ---- | -------- | ---------- | ---------------------- | ----------------- | ------------------ | -------- | -------- | ---- | --------- |\r\n| TCP  | ⾯向连接 | 全双工 1:1 | 可靠，有重传机制       | 有序，通过SYN排序 | 无边界，有粘包情况 | 有       | 慢       | 低   | 20~60字节 |\r\n| UDP  | 无连接   | n:m        | 不可靠，丢包后数据丢失 | 无序              | 有边界，无粘包     | 无       | 快       | 高   | 8字节     |\r\n\r\n\r\n\r\nUDP socket ⽀持 n 对 m 的连接状态。在 Node.js 官⽅⽂档中有写到在 `dgram.createSocket(options[, callback]) ` 中的 `options` 中可指定 `reuseAddr` 为 `SO_REUSEADDR` 标志，通过它可以简单的实现 n 对 m 的多播特性 (仅在⽀持多播的操作系统上才有用)。\r\n\r\n\r\n\r\n## 什么是 TCP 粘包，怎么处理？\r\n\r\nTCP 连接在默认情况下会启⽤延迟传送算法 (Nagle算法)，它在数据发送前进行缓存数据，如短时间内有多个数据发送，会缓冲后再作⼀次发送操作 (缓冲区⼤⼩可⻅ `socket.bufferSize`)，这样可以减少 IO 产生的消耗，提⾼了性能。\r\n\r\n \r\n\r\n在传输⽂件的情况下，不⽤处理粘包问题，接收到⼀个包就拼接⼀个包就行了。但是，如果是传输多条消息、或是别的⽤途的数据，那么就需要处理粘包。可参⻅⽹上流传甚⼴的⼀个例⼦：连续调⽤两次 `send` 分别发送两段数据 data1 和 data2，则在接收端会有以下⼏种常⻅情况出现: \r\n\r\n- A. 先收到 data1，然后收到 data2\r\n\r\n- B. 先收到 data1 的部分数据，然后收到 data1 余下的部分以及 data2 的全部\r\n\r\n- C. 先收到 data1 的全部数据和 data2 的部分数据，然后收到 data2 的余下的数据\r\n\r\n- D. ⼀次性收到 data1 和 data2 的全部数据\r\n\r\n\r\n\r\n以上情况中的 `B、C、D` 三种，就是常⻅的粘包情况。而处理粘包问题的常⻅⽅案有：\r\n\r\n\r\n\r\n**方案一：多次发送之前间隔⼀个等待时间** \r\n\r\n只需等待⼀段时间再做下⼀次`send` 发送操作就可以了。\r\n\r\n- 它适⽤于交互频率特别低的场景\r\n\r\n- 对于交互频繁的场景来说， 其传输效率太低。\r\n\r\n\r\n\r\n**方案二：关闭 Nagle 算法** \r\n\r\n在 Node.js 中你可以通过 `socket.setNoDelay()` ⽅法来关闭 Nagle 算法，让每次 send 都不缓冲而直接发送。 \r\n\r\n- 该⽅法适⽤于每次发送的数据都⽐较⼤ (但不是如⽂件那么⼤)， 并且频率不特别⾼的场景\r\n- 如果是每次发送的数据量⽐较⼩且频率特别⾼的话，这种方式纯属⾃废武功\r\n\r\n- 该⽅法也不适⽤于⽹络较差的情况，因为 Nagle 算法是在服务端进⾏的包合并情况，但如果短时间内客户端的⽹络 \r\n\r\n情况不好、或者应⽤层由于某些原因不能及时将 TCP 的数据 `recv`，就会造成多个包在客户端缓冲从⽽粘包的情况\r\n\r\n\r\n\r\n**方案三：进⾏封包/拆包**\r\n\r\n这是⽬前业内最常⻅的解决⽅案，即在发送每个数据包之前，将⼀些有特征的数据放在数据包前/后，然后在收到数据的时 \r\n\r\n候，根据特征数据来分割出各个数据包。\r\n\r\n\r\n\r\n## 你知道哪些常用的端口号，以及它们对应的服务？\r\n\r\n| 端口     | 用途                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| 21       | 主要⽤于FTP（File Transfer Protocol，⽂件传输协议）服务      |\r\n| 23       | 主要⽤于Telnet（远程登录）服务，是Internet上普遍采⽤的登录和仿真程序 |\r\n| 25       | 为 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务器所开放，主要⽤于发送邮件，如今绝⼤多数邮件服务器都使⽤该协议 |\r\n| 53       | 为DNS（Domain Name Server，域名服务器）服务器所开放，主要⽤于域名解析，DNS服务在NT系统中使⽤的最为⼴泛 |\r\n| 67、68   | 分别是为 Bootp 服务的 Bootstrap Protocol Server（引导程序协议服务端）和 Bootstrap Protocol Client（引导程序协议客户端）开放的端⼝ |\r\n| 69       | TFTP是Cisco公司开发的⼀个简单⽂件传输协议，类似于FTP         |\r\n| 79       | 为Finger服务开放的，主要⽤于查询远程主机在线⽤户、操作系统类型以及是否缓冲区溢出等⽤户的详细信息 |\r\n| 80       | 为HTTP（HyperText Transport Protocol，超⽂本传输协议）开放的，这是上⽹冲浪使⽤最多的协议，主要⽤于在WWW（World WideWeb，万维⽹）服务上传输信息的协议 |\r\n| 99       | ⽤于⼀个名为“Metagram Relay”（亚对策延时）的服务，该服务⽐较少⻅，⼀般是⽤不到的 |\r\n| 109、110 | 为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，110 端⼝是为 POP3（邮件协议3）服务开放的，POP2、POP3都是主要⽤于接收邮件的 |\r\n| 111      | 是SUN公司的 RPC（Remote ProcedureCall，远程过程调⽤）服务所开放的端⼝，主要⽤于分布式系统中不同计算机的内部进程通信，RPC在多种⽹络服务中都是很重要的组件 |\r\n| 113      | 主要⽤于Windows的“Authentication Service”（验证服务）        |\r\n| 119      | 是为“Network News TransferProtocol”（⽹络新闻组传输协议，简称NNTP）开放的 |\r\n| 135      | 主要⽤于使⽤RPC（Remote Procedure Call，远程过程调⽤）协议并提供DCOM（分布式组件对象模型）服务 |\r\n| 137      | 主要⽤于“NetBIOS Name Service”（NetBIOS名称服务）            |\r\n| 139      | 是为“NetBIOS Session Service”提供的，主要⽤于提供Windows⽂件和打印机共享以及Unix中的Samba服务 |\r\n| 143      | 主要是⽤于“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP） |\r\n| 161      | 是⽤于“Simple Network Management Protocol”（简单⽹络管理协议，简称SNMP） |\r\n| 443      | ⽹⻚浏览端⼝，主要是⽤于HTTPS服务，是提供加密和通过安全端⼝传输的另⼀种HTTP |\r\n| 554      | 默认情况下⽤于“Real Time Streaming Protocol”（实时流协议，简称RTSP） |\r\n| 1024     | ⼀般不固定分配给某个服务，在英⽂中的解释是“Reserved”（保留） |\r\n| 1080     | 是Socks代理服务使⽤的端⼝，⼤家平时上⽹使⽤的WWW服务使⽤的是HTTP协议的代理服务 |\r\n| 1755     | 默认情况下⽤于“Microsoft Media Server”（微软媒体服务器，简称MMS） |\r\n| 4000     | 是⽤于⼤家经常使⽤的QQ聊天⼯具的，再细说就是为QQ客户端开放的端⼝，QQ服务端使⽤的端⼝是8000 |\r\n| 5554     | ⼀种针对微软lsass服务的新蠕⾍病毒——震荡波（Worm.Sasser）利⽤TCP 5554端⼝开启⼀个FTP服务，主要被⽤于病毒的传播 |\r\n| 5632     | 5632端⼝是被⼤家所熟悉的远程控制软件pcAnywhere所开启的端⼝   |\r\n| 8080     | 8080端⼝同80端⼝，是被⽤于WWW代理服务的，可以实现⽹⻚        |\r\n\r\n\r\n\r\n## 一次完整的HTTP服务过程是什么\r\n\r\n当我们在web浏览器的地址栏中输入：`www.baidu.com`，具体发生了什么？\r\n\r\n1. 对`www.baidu.com`这个网址进行DNS域名解析，得到对应的IP地址\r\n2. 根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) ) \r\n3. 建立TCP连接后发起HTTP请求\r\n4. 服务器响应HTTP请求，浏览器得到html代码\r\n5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）\r\n6. 浏览器对页面进行渲染呈现给用户\r\n7. 服务器关闭关闭TCP连接\r\n\r\n注：\r\n\r\n1.DNS怎么找到域名的？\r\n\r\n> DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器\r\n\r\n2.为什么HTTP协议要基于TCP来实现？  \r\n\r\n> TCP是一个端到端的可靠面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）\r\n\r\n3.最后一步浏览器是如何对页面进行渲染的？  \r\n\r\n> a）解析html文件构成 DOM树\r\n> b）解析CSS文件构成渲染树\r\n> c）边解析，边渲染\r\n> d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载\r\n\r\n\r\n\r\n## 什么是DNS 解析\r\n\r\n**DNS解析（域名解析服务器）**\r\n\r\n假定请求的是 www.baidu.com\r\n\r\na）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）\r\n\r\nb）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存\r\n\r\nc）如果还没有找到，那么尝试从 hosts 文件里面去找\r\n\r\nd）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找(就近查找)，具体过程如下\r\n\r\n![dns域名解析](images/5rxqugj8dh.png)\r\n\r\nDNS优化两个方面：DNS缓存、DNS负载均衡 (准备多台dns服务器, 进行dns解析)\r\n\r\n\r\n\r\n## 什么是三次握手？\r\n\r\n三次握⼿（Three-way Handshake）是指在建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送 3 个包。\r\n\r\n \r\n\r\n三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信 \r\n\r\n息。在 socket 编程中，客户端调用执行 `connect()` 时将触发三次握⼿。\r\n\r\n\r\n\r\n下图为三次握手的示意图：\r\n\r\n![image-20210219192116213](/images/image-20210219192116213.png)\r\n\r\n**第⼀次握⼿（SYN=1, seq=x）** \r\n\r\n客户端发送⼀个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号（Sequence Number）字段⾥。\r\n\r\n发送完毕后，客户端进⼊ SYN_SEND 状态。 \r\n\r\n\r\n\r\n**第⼆次握⼿（SYN=1, ACK=1, seq=y, ACKnum=x+1）**\r\n\r\n服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域⾥，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加1，即 X + 1。 \r\n\r\n发送完毕后，服务器端进⼊ SYN_RCVD 状态。 \r\n\r\n\r\n\r\n**第三次握⼿（ACK=1，ACKnum=y+1）** \r\n\r\n客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写 ISN 的 +1。\r\n\r\n发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿结束。\r\n\r\n\r\n\r\n## 什么是四次挥手？\r\n\r\n四次挥⼿（Four-way handshake），也叫做改进的三次握⼿，TCP 连接的拆除需要发送四个包，客户端或服务器均可主动发起挥⼿动作，在 socket 编程中，任何⼀⽅执⾏ `close()` 操作即可产⽣挥⼿操作。\r\n\r\n\r\n\r\n下图为四次挥手示意图：\r\n\r\n![image-20210219192659983](/images/image-20210219192659983.png)\r\n\r\n\r\n\r\n**第⼀次挥⼿（FIN=1，seq=x）** \r\n\r\n假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为1的包，表示⾃⼰已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进⼊ FIN_WAIT_1 状态。\r\n\r\n \r\n\r\n**第⼆次挥⼿（ACK=1，ACKnum=x+1）** \r\n\r\n服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务器端关闭连接。 \r\n\r\n\r\n\r\n**第三次挥⼿（FIN=1，seq=y）** \r\n\r\n服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个ACK。 \r\n\r\n\r\n\r\n**第四次挥⼿（ACK=1，ACKnum=y+1）** \r\n\r\n客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## TCP 三次握手理解 (双方确认)\r\n\r\nTCP是一个端到端的  **可靠**  面相连接的协议，\r\n\r\nHTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）\r\n\r\n根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) ) \r\n\r\n![image-20201209160422978](images/image-20201209160422978.png)\r\n\r\n**为什么要3次握手**\r\n\r\n我们假定第一次发送的请求,  因为网络延迟很慢才到达服务端，\r\n\r\n然后客户端以为这服务器居然不叼我，然后默默的关闭的等待连接的请求，走开了（好比追女神）；\r\n\r\n但事实呢？女神（服务器）是因为各种各样的原因，很晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！\r\n\r\n但是，A早已经远走高飞，这个请求A完全不会收到（在第二次握手，服务端打开连接，等待客户端的响应），\r\n\r\n那么女生呢，以为对方收到了，就会一直等待，这样B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；\r\n\r\n而三次握手, 就不会发生，服务端同意连接了，但是A缺一直没有下一步的动作，导致资源浪费；\r\n\r\n\r\n\r\n\r\n\r\n## 关闭TCP连接四次挥手的理解 (客气挽留)\r\n\r\n关闭连接(四次挥手)\r\n\r\n![image-20201209162908979](images/image-20201209162908979.png)\r\n\r\n 这和有礼貌的好友道别一样：（a：客户端 b:服务端）\r\n1、一开始A想要回家离开，但是呢？怕B还有事情要交代，那么呢？只好先想B打招呼，我要走了，请求停止交谈（此时，a到B的连接没有断开，依旧可以进行通信）；\r\n2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看,  你等等,  等我说完你再走。\r\n3、B确实没啥要补充的了，就告知你我可以散伙了\r\n4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )\r\n\r\n\r\n\r\n\r\n\r\n## 浏览器解析响应\r\n\r\n**浏览器解析html代码，并请求html代码中的资源**\r\n\r\n**浏览器对页面进行渲染呈现给用户**\r\n\r\n最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。\r\n\r\n首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。\r\n\r\nDOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repaint。\r\n\r\n**页面在首次加载时必然会经历reflow和repaint。**\r\n\r\nreflow过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。\r\n\r\n所以我们应该尽可能少的减少 reflow (重新布局) 。  例如: transform 变换, 只会触发重绘, 不会触发重排 (效率非常高)\r\n\r\n...\r\n\r\n页面首次渲染, 必然会进行一次 reflow 和 一次 repaint\r\n\r\n1. reflow: 重排 (布局相关的)\r\n2. repaint: 重绘(绘制, 颜色, 字体, .... 跟结构无关的)\r\n\r\n\r\n\r\n**完整的一次 http 请求流程才算结束**\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n# DOM\r\n\r\n## DOM的事件模型是什么？\r\n\r\nDOM的事件模型(注册事件的方式)分为：\r\n\r\n- 脚本模型\r\n- 内联模型（同类一个，后者覆盖前者）\r\n- 动态绑定（同类可多个）\r\n\r\n**脚本模型**\r\n\r\n```html\r\n\x3c!-- 脚本模型：⾏内绑定 --\x3e\r\n<button onclick="javascrpt:alert(\'Hello\')">Hello1</button>\r\n```\r\n\r\n**内联模型**\r\n\r\n```html\r\n\x3c!-- 内联模型：同⼀个元素的同类事件只能添加⼀个，如果添加多个则后添加的会覆盖之前添加的 --\x3e\r\n<button onclick="sayHello()">Hello2</button>\r\n\r\n<script>\r\n  function sayHello() { \r\n    alert("Hello"); \r\n  }\r\n<\/script>\r\n```\r\n\r\n**动态绑定**\r\n\r\n```html\r\n\x3c!-- 动态绑定 --\x3e\r\n<button id="btn">Hello3</button>\r\n\r\n<script>\r\n  var btn = document.getElementById("btn");\r\n\r\n  /* 1. 这种方式只能给同一个元素添加一个事件 */\r\n  btn.onclick = function () { alert("Hello"); }\r\n\r\n  /* 2. 这种方式可以给同⼀个元素添加多个同类事件 */\r\n  btn.addEventListener("click", function () { alert("hello1"); });\r\n  btn.addEventListener("click", function () { alert("hello2"); })\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n## DOM的事件流是什么？\r\n\r\n**事件**\r\n\r\n事件是HTML⽂档或浏览器窗⼝中发⽣的⼀些特定的交互瞬间。\r\n\r\n**事件流**\r\n\r\n⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2级事件规定的事件流包括了3个阶段：\r\n\r\n- 事件捕获阶段（capture phase）\r\n- 处于⽬标阶段（target phase）\r\n- 事件冒泡阶段（bubbling phase）\r\n\r\n![image-20210219222213633](/images/image-20210219222213633.png)\r\n\r\n如上图所示，事件流的触发顺序是：\r\n\r\n1. 事件捕获阶段，为截获事件提供了机会 \r\n2. 实际的⽬标元素接收到事件\r\n3. 事件冒泡阶段，可在这个阶段对事件做出响应\r\n\r\n\r\n\r\n**事件冒泡（Event Bubbling）**\r\n\r\n事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。\r\n\r\n\r\n\r\n```html\r\n<html>\r\n  \r\n  <head> \r\n    <title>Document</title> \r\n  </head>\r\n  \r\n  <body> \r\n    <button>按钮</button> \r\n  </body> \r\n  \r\n</html>\r\n```\r\n\r\n如果点击了上面页面代码中的 `<button>` 按钮，那么该 `click` 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：\r\n\r\n1. button 元素\r\n2. body 元素\r\n3. html 元素\r\n4. document 对象\r\n\r\n\r\n\r\n**事件捕获（Event Capturing）**\r\n\r\n事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。\r\n\r\n事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。\r\n\r\n\r\n\r\n如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 `click` 事件，然后再沿着 DOM 树依次向下，直到 `<button>`。具体顺序如下：\r\n\r\n1. document 对象\r\n2. html 元素\r\n3. body 元素\r\n4. button 元素\r\n\r\n\r\n\r\n## 说说什么是事件委托？\r\n\r\n事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。\r\n\r\n\r\n\r\n**示例**\r\n\r\n```html\r\n<ul id="list">\r\n    <li>111</li>\r\n    <li>222</li>\r\n    <li>333</li>\r\n</ul>\r\n\r\n<script type="text/javascript">\r\n    // ⽗元素 \r\n    var list = document.getElementById(\'list\');\r\n\r\n    // 为⽗元素绑定事件，委托管理它的所有⼦元素的点击事件 \r\n    list.onclick = function (event) {\r\n        var currentTarget = event.target;\r\n        if (currentTarget.tagName.toLowerCase() === \'li\') {\r\n            alert(currentTarget.innerText)\r\n        }\r\n    }\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n> 适用场景：在绑定大量事件的时候，可以选择事件委托\r\n\r\n**优点**\r\n\r\n- 事件委托可以减少事件注册数量，节省内存占⽤!\r\n- 当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素 \r\n\r\n---\r\n\r\n\r\n\r\n# 浏览器与新技术\r\n\r\n## 常见的浏览器内核有哪些？\r\n\r\n浏览器的内核，通常指的是渲染引擎，但现在JS引擎也成为浏览器的重要部分，所以下表展示了当前一些比较流行的常规浏览器、无头浏览器、以及JS运行时所含的渲染引擎和JS引擎：\r\n\r\n|     浏览器/运行时      |           内核（即渲染引擎）            |         JS引擎          |\r\n| :--------------------: | :-------------------------------------: | :---------------------: |\r\n|         Chrome         | Webkit (Chrome 27) / Blink (Chrome 28+) |           V8            |\r\n|        FireFox         |                  Gecko                  |      SpiderMonkey       |\r\n|         Safari         |                 Webkit                  |     JavaScriptCore      |\r\n|          Edge          |                EdgeHTML                 | Chakra (for JavaScript) |\r\n|           IE           |                 Trident                 |  Chakra (for JScript)   |\r\n| PhantomJS (无头浏览器) |                 Webkit                  |     JavaScriptCore      |\r\n| Puppeteer (无头浏览器) | Webkit (Chrome 27) / Blink (Chrome 28+) |           V8            |\r\n|        Node.js         |                   无                    |           V8            |\r\n\r\n\r\n\r\n\r\n\r\n## 浏览器是如何进行界面渲染的？\r\n\r\n不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 webkit 的渲染流程来说明：\r\n\r\n<img src="/images/image-20210220214851409.png" alt="image-20210220214851409" style="zoom:45%;" />\r\n\r\n上图展示的流程是：\r\n\r\n1. 获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）\r\n\r\n2. 解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）\r\n\r\n3. 根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）\r\n\r\n4. 进行布局（Layout），即为每个节点分配⼀个在屏幕上应显示的确切坐标位置 \r\n\r\n5. 进⾏绘制（Paint），遍历渲染树节点，调⽤ GPU 将元素呈现出来 \r\n\r\n\r\n\r\n## 浏览器是如何解析CSS选择器的？\r\n\r\n在生成渲染树的过程中，渲染引擎会根据选择器提供的信息来遍历 DOM 树，找到对应的 DOM 节点后将样式规则附加到上面。\r\n\r\n\r\n\r\n来看一段样式选择器代码、以及一段要应用样式的 HTML：\r\n\r\n```css\r\n.mod-nav h3 span {\r\n\tfont-size: 16px;\r\n}\r\n```\r\n\r\n```html\r\n<div class="mod-nav">\r\n  <header>\r\n    <h3>\r\n      <span>标题</span>\r\n    </h3>\r\n  </header>\r\n  \r\n  <div>\r\n    <ul>\r\n      <li><a href="#">项目一</a></li>\r\n      <li><a href="#">项目一</a></li>\r\n      <li><a href="#">项目一</a></li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n```\r\n\r\n\r\n\r\n渲染引擎是怎么根据以上样式选择器去遍历这个 DOM 树的呢？是按照从左往右的选择器顺序去匹配，还是从右往左呢？\r\n\r\n\r\n\r\n为了更直观的观查，我们先将这棵 DOM 树先绘制成图：\r\n\r\n<img src="/images/image-20210220222103787.png" alt="image-20210220222103787" style="zoom:30%;" />\r\n\r\n然后我们来对比一下两种顺序的匹配：\r\n\r\n\r\n\r\n**从左往右：`.mod-nav > h3 > span`**\r\n\r\n1. 从 `.mod-nav` 开始遍历⼦节点 `header`、`div`\r\n2. 然后向各⾃的⼦节点遍历\r\n3. 在右侧 `div` 的分⽀中，当遍历到叶节点 `a` 后，发现不符合规则。则重新回溯到 `ul` 节点，再遍历下⼀个 `li` - `a`\r\n\r\n\r\n\r\n**从右往左：`span > h3 > .mod-nav`**\r\n\r\n1. 先找到所有的 `span` 节点 ，然后基于每⼀个 `span` 再向上查找 `h3` \r\n\r\n2. 由 `h3` 再向上查找 `.mod-nav` 的节点\r\n\r\n3. 最后触及根元素 `html` 结束该分⽀遍历\r\n\r\n\r\n\r\n可以看到，从右向左的匹配规则可以在第⼀步时就筛选掉⼤量不符合条件的叶节点；⽽从左向右的匹配规则需要消耗大量时间在失败的查找上，这在真实页面中⼀棵 DOM 树的节点成百上千的情况下，这种遍历方式的效率会非常的低，根本不适合采用。\r\n\r\n\r\n\r\n因此，浏览器遵循 “从右往左” 的规则来解析 CSS 选择器！\r\n\r\n\r\n\r\n## DOM树是如何构建的？\r\n\r\n构建的过程如下：\r\n\r\n1. 浏览器将接收到的⼆进制数据，按指定编码格式转换为 HTML 字符串 \r\n\r\n2. 开始解析，将 HTML 字符串解析成 Tokens \r\n\r\n3. 构建节点，对节点添加特定的属性，并通过指针确定节点的⽗、⼦、兄弟关系、以及所属 treeScope \r\n\r\n4. 通过已确定的节点⽗、⼦、兄弟关系，构建出 DOM 树 \r\n\r\n\r\n\r\n下图为以上描述过程的图示：\r\n\r\n<img src="/images/image-20210220230003937.png" alt="image-20210220230003937" style="zoom:50%;" />\r\n\r\n\r\n\r\n## 浏览器重绘与重排的区别是什么？\r\n\r\n**重排**\r\n\r\n重排是指部分或整个渲染树需要重新分析，并且节点的尺⼨需要重新计算。\r\n\r\n表现为重新⽣成布局，重新排列元素。\r\n\r\n\r\n\r\n**重绘**\r\n\r\n重绘是由于节点的⼏何属性发⽣改变，或由于样式发⽣改变（例如：改变元素背景⾊）。\r\n\r\n表现为某些元素的外观被改变。\r\n\r\n\r\n\r\n**两者的关系**\r\n\r\n> 重绘不⼀定会出现重排，重排必定会出现重绘。\r\n\r\n只改变元素的外观不会引发⽹⻚重排；但若浏览器进行重排后，将会重绘受此次重排影响的部分。\r\n\r\n重排和重绘的代价都很⾼昂，破坏⽤户体验、让界面显示变迟缓。\r\n\r\n但相⽐之下，重排的性能影响会更⼤，在⽆法避免的情况下，⼀般宁可选择代价较⼩的重绘。 \r\n\r\n\r\n\r\n## 如何触发重排和重绘？\r\n\r\n改变任意的⽤于构建渲染树的信息，都会引发⼀次重排或重绘。比如： \r\n\r\n- 添加、删除、更新 DOM 节点 \r\n\r\n- 通过 `display: none` 隐藏 DOM 节点（同时会触发重排和重绘）\r\n\r\n- 通过 `visibility: hidden` 隐藏 DOM节点（只会触发重绘，因为没有⼏何变化 ）\r\n\r\n- 移动 DOM 节点，或是给⻚⾯中的 DOM 节点添加动画 \r\n\r\n- 添加⼀个样式表，调整样式属性 \r\n\r\n- ⽤户⾏为，例如：调整浏览器窗⼝的⼤⼩，改变字号，或者滚动页面\r\n\r\n\r\n\r\n## 如何避免重排或重绘？\r\n\r\n主要有三大方式来避免：\r\n\r\n- 集中修改样式\r\n- 使用文档碎片（DocumentFragment）\r\n- 将元素提升为合成层\r\n\r\n\r\n\r\n**集中修改样式**\r\n\r\n通常以改 class 的⽅式，实现样式的集中修改。\r\n\r\n```js\r\nel.setAttribute(\'className\', isDark ? \'dark\' : \'light\')\r\n```\r\n\r\n\r\n\r\n**使用文档碎片**\r\n\r\n通过 `document.createDocumentFragment` 可创建⼀个游离于 DOM 树外的节点，在该节点上做批量操作后再将它插⼊ DOM 树中，只会引发⼀次重排。\r\n\r\n```js\r\n// 创建碎片节点\r\nconst fragment = document.createDocumentFragment()\r\n\r\n// 多次操作碎片节点\r\nfor (let i = 0; i< 10; i++) { \r\n  const node = document.createElement("p")\r\n  node.innerHTML = i\r\n  fragment.appendChild(node)\r\n}\r\n\r\n// 一次性添加到 DOM 树中\r\ndocument.body.appendChild(fragment)\r\n```\r\n\r\n\r\n\r\n**将元素提升为合成层**\r\n\r\n将元素提升为合成层的最好⽅式是使⽤ CSS 的 `will-change` 属性： \r\n\r\n```css\r\n#target {\r\n  will-change: transform; \r\n}\r\n```\r\n\r\n\r\n\r\n提升为合成层有下列几个优点： \r\n\r\n- 合成层的位图会由 GPU 合成，⽐由 CPU 处理更快 \r\n\r\n- 当需要重绘时只重绘本身，不影响其他层 \r\n\r\n- `transform` 和 `opacity` 不会触发重排和重绘\r\n\r\n\r\n\r\n## 前端如何实现即时通讯？\r\n\r\n基于Web的前端，存在以下几种可实现即时通讯的方式：\r\n\r\n- 短轮询\r\n- Comet\r\n- SSE\r\n- WebSocket\r\n\r\n\r\n\r\n**短轮询**\r\n\r\n短轮询就是客户端定时发送请求，获取服务器上的最新数据。不是真正的即时通讯，但一定程度上可以模拟即时通讯的效果。\r\n\r\n\r\n\r\n优缺点：\r\n\r\n- 优点：浏览器兼容性好，实现简单\r\n- 缺点：实时性不高，资源消耗高，存在较多无用请求，影响性能\r\n\r\n\r\n\r\n**Comet**\r\n\r\n有两种实现 Comet 的方式：\r\n\r\n1. 使用 Ajax 长轮询（long-polling）\r\n2. 使用 HTTP 长连接（基于 iframe 和 htmlfile 的流）\r\n\r\n\r\n\r\n优缺点：\r\n\r\n- 优点：浏览器兼容性好，即时性好，不存在⽆⽤请求 \r\n\r\n- 缺点：服务器压力较大（维护⻓连接会消耗较多服务器资源）\r\n\r\n\r\n\r\n[参考文章：Comet技术详解](http://www.52im.net/thread-334-1-1.html)\r\n\r\n\r\n\r\n**SSE**\r\n\r\n服务端推送事件（Server-Sent Event），它是⼀种允许服务端向客户端推送新数据的 HTML5 技术。 \r\n\r\n优缺点：\r\n\r\n- 优点：基于 HTTP，无需太多改造就能使⽤；相比 WebSocket 要简单方便很多\r\n\r\n- 缺点：基于⽂本传输，效率没有 WebSocket ⾼；不是严格的双向通信，客户端⽆法复⽤连接来向服务端发送请求，\r\n\r\n  而是每次都需重新创建新请求\r\n\r\n[参考文章：SSE教程](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\r\n\r\n\r\n\r\n**WebSocket**\r\n\r\n这是基于 TCP 协议的全新、独⽴的协议，作⽤是在服务器和客户端之间建⽴实时的双向通信。\r\n\r\nWebSocket 协议与 HTTP 协议保持兼容，但它不会融⼊ HTTP 协议，仅作为 HTML 5 的⼀部分。 \r\n\r\n优缺点：\r\n\r\n- 优点：真正意义上的双向实时通信，性能好、延迟低 \r\n\r\n- 缺点：由于是独⽴于 HTTP 的协议，因此要使用的话需要对项⽬作改造；使⽤复杂度较⾼，通常需要引⼊成熟的库；并且⽆法兼容低版本的浏览器\r\n\r\nHTTP 和 WebSocket 的连接通信比较图：\r\n\r\n<img src="/images/image-20210221101152845.png" alt="image-20210221101152845" style="zoom:30%;" />\r\n\r\n\r\n\r\n\r\n\r\n## 什么是浏览器的同源策略？\r\n\r\n首先，同源是指资源地址的 "协议 + 域名 + 端⼝" 三者都相同，即使两个不同域名指向了同⼀ IP 地址，也被判断为⾮同源。\r\n\r\n下面是一些地址的同源判断示例：\r\n\r\n![image-20210221103114013](/images/image-20210221103114013.png)\r\n\r\n\r\n\r\n了解了什么是同源，再来说同源策略。\r\n\r\n> 同源策略是一种⽤于隔离潜在恶意⽂件的重要安全保护机制，它用于限制从⼀个源加载的⽂档或脚本与来⾃另⼀个源的资源进⾏交互。\r\n\r\n\r\n\r\n在浏览器中，⼤部分内容都受同源策略限制，除了以下三个标签：\r\n\r\n- `<img>`\r\n- `<link>`\r\n- `script`\r\n\r\n\r\n\r\n## 如何实现跨域？\r\n\r\n历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：\r\n\r\n- JSONP\r\n- CORS\r\n- 服务器代理(webpack代理, Nginx反向代理)\r\n\r\n**JSONP** \r\n\r\n这是一种非常经典的跨域方案，它利用了`<script>` 标签不受同源策略的限制的特性，实现跨域效果。\r\n\r\n优点：\r\n\r\n- 实现简单\r\n- 兼容性好\r\n\r\n缺点：\r\n\r\n- 只支持 GET 请求 （因为 `<script>` 标签只能发送 GET 请求）\r\n- 存在被 XSS 攻击的可能，缺乏安全性保证\r\n- 需要服务端配合改造\r\n\r\n实现示例：\r\n\r\n```js\r\n// 1. JSONP 发送请求的函数封装\r\nfunction JSONP({ url, params, callbackKey, callback }) {\r\n  // 在参数中指定 callback 名字 \r\n  params = params || {} params[callbackKey] = \'jsonpCallback\'\r\n  \r\n  // 预留 callback \r\n  window.jsonpCallback = callback \r\n  \r\n  // 拼接参数字符串\r\n  const queryString = Object.keys(params).map(key => `${key}=${params[key]}`).join(\'&\')\r\n  \r\n  // 创建 script 标签\r\n  const script = document.createElement(\'script\') \r\n  script.setAttribute(\'src\', `${url}?${queryString}`) \r\n  \r\n  // 插⼊ DOM 树\r\n  document.body.appendChild(script) \r\n}\r\n\r\n// 2. 调用示例\r\nJSONP({ \r\n  url: \'http://s.weibo.com/ajax/jsonp/suggestion\', \r\n  params: {\r\n  \tkey: \'test\'\r\n\t},\r\n  callbackKey: \'_cb\',\r\n  callback(res) { \r\n    console.log(res.data) \r\n  } \r\n})\r\n```\r\n\r\n\r\n\r\n**CORS**\r\n\r\n跨域资源共享（CORS），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 HTTP 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。\r\n\r\n当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 HTTP 请求。 \r\n\r\n如果你⽤的是 Node.js 的 Express 框架，则可以这样来进行设置：\r\n\r\n```js\r\n// 创建一个 CORS 中间件 \r\nfunction allowCrossDomain(req, res, next) { \r\n  res.header(\'Access-Control-Allow-Origin\', \'http://example.com\'); \r\n  res.header(\'Access-Control-Allow-Methods\', \'GET,PUT,POST,DELETE\'); \r\n  res.header(\'Access-Control-Allow-Headers\', \'Content-Type\'); \r\n  next(); \r\n}\r\n\r\n//...\r\n\r\napp.configure(function() { \r\n  // ...\r\n  \r\n  // 为 Express 配置 CORS 中间件\r\n  app.use(allowCrossDomain); \r\n  \r\n  // ...\r\n});\r\n```\r\n\r\n在实际项目中，建议使用一些已经比较成熟的开源中间件。\r\n\r\n\r\n\r\n**Nginx反向代理**\r\n\r\n这是目前最方便，最推荐使用的跨域解决方案。Nginx 本身是⼀款极其强⼤的 Web 服务器，轻量级、启动快、⾼并发。 \r\n\r\n\r\n\r\n现在的后端服务程序，通常会使用 Nginx 进行反向代理：\r\n\r\n<img src="/images/image-20210221111025585.png" alt="image-20210221111025585" style="zoom:33%;" />\r\n\r\n反向代理的原理其实很简单：\r\n\r\n> Nginx 作为代理服务器，所有客户端的请求都必须先经过 Nginx 的处理，然后再将请求转发给其他后端程序（比如 Node.js 或Java 程序），这样就规避同源策略的影响\r\n\r\n\r\n\r\n下面是一个配置 Nginx 反向代理的示例配置文件：\r\n\r\n```nginx\r\n# 进程, 可更具 cpu 数量调整\r\nworker_processes 1; \r\n\r\nevents { \r\n  # 连接数 \r\n  worker_connections 1024; \r\n}\r\n\r\nhttp {\r\n  include mime.types; \r\n  default_type application/octet-stream;\r\n  \r\n  sendfile on;\r\n  \r\n  #连接超时时间，服务器会在这个时间过后关闭连接。 \r\n  keepalive_timeout 10;\r\n  \r\n  # 开启 Gzip 压缩\r\n  gzip on;\r\n  \r\n  # 直接请求nginx也是会报跨域错误的这⾥设置允许跨域 \r\n  # 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了) \r\n  add_header Access-Control-Allow-Origin *; \r\n  add_header Access-Control-Allow-Headers X-Requested-With; \r\n  add_header Access-Control-Allow-Methods GET,POST,OPTIONS;\r\n  \r\n  # srever模块配置是http模块中的⼀个⼦模块，⽤来定义⼀个虚拟访问主机\r\n  server { \r\n    listen 80; \r\n    server_name localhost; \r\n    \r\n    # 根路径指到index.html \r\n    location / { \r\n      root html; \r\n      index index.html index.htm; \r\n    }\r\n    \r\n    # 请求转发：\r\n    # 例如 http://localhost/api 的请求会被转发到 http://192.168.0.103:8080\r\n    location /api {\r\n      proxy_set_header Host $host; \r\n      proxy_set_header X-Real-IP $remote_addr; \r\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \r\n      proxy_pass http://192.168.0.103:8080; \r\n    }\r\n    \r\n    # 重定向错误⻚⾯到/50x.html \r\n    error_page 500 502 503 504 /50x.html; \r\n    \r\n    location = /50x.html { \r\n      root html; \r\n    } \r\n  } \r\n}\r\n```\r\n\r\n[参考文章：跨域方式实现原理](https://juejin.cn/post/6844903767226351623#heading-19)\r\n\r\n\r\n\r\n# 前端工程化\r\n\r\n## Babel的原理是什么？\r\n\r\nBabel 的主要工作是对代码进行转译。\r\n\r\n转译分为三阶段：\r\n\r\n- 解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程 \r\n\r\n- 转换（Transform），对 AST 进⾏变换方面的⼀系列操作。通过 babel-traverse，对 AST 进⾏遍历并作添加、更新、删除等操作\r\n\r\n- ⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码\r\n\r\n\r\n\r\n转译流程示意图：\r\n\r\n![image-20210221114506275](/images/image-20210221114506275.png)\r\n\r\n\r\n\r\n## 如何编写一个Babel插件？\r\n\r\nBabel 插件的主要工作阶段是在 Babel 将代码解析成 AST 之后，插件们对 AST 进行各种操作后，再由 Babel 输出最终的代码。\r\n\r\n要编写一个 Babel 插件模块，则需要为模块代码导出一个函数，且该函数返回一个对象，对象内应包含有 `visitor` 属性：\r\n\r\n```js\r\nmodule.exports = function (babel) {\r\n  return {\r\n    visitor: {}\r\n  }\r\n}\r\n```\r\n\r\n`visitor` 是针对各类 AST 节点作处理的地⽅。我们可以通过 `console.log` 打印或 [AST Explorer 工具](https://astexplorer.net/) 来查看 Babel 具体生成的 AST 节点。\r\n\r\n\r\n\r\n**示例**\r\n\r\n我们来编写一个插件，其功能是能自动将源码中的数字字面量数学运算进行预计算处理，简化代码。例如：\r\n\r\n```js\r\n// 原来的代码\r\nconst result = 1 + 2\r\n\r\n// 处理后的代码\r\nconst result = 3    // 这样优化以后，在实际运行时可以减少一次加法操作\r\n```\r\n\r\n\r\n\r\n我们可以先通过 AST Explorer 来获取 JSON 格式的 AST 结构：\r\n\r\n```json\r\n{\r\n  "type": "Program",\r\n  "start": 0,\r\n  "end": 20,\r\n  "body": [\r\n    {\r\n      "type": "VariableDeclaration",\r\n      "start": 0,\r\n      "end": 20,\r\n      "declarations": [\r\n        {\r\n          "type": "VariableDeclarator",\r\n          "start": 6,\r\n          "end": 20,\r\n          "id": {\r\n            "type": "Identifier",\r\n            "start": 6,\r\n            "end": 12,\r\n            "name": "result"\r\n          },\r\n          "init": {\r\n            "type": "BinaryExpression",\r\n            "start": 15,\r\n            "end": 20,\r\n            "left": {\r\n              "type": "Literal",\r\n              "start": 15,\r\n              "end": 16,\r\n              "value": 1,\r\n              "raw": "1"\r\n            },\r\n            "operator": "+",\r\n            "right": {\r\n              "type": "Literal",\r\n              "start": 19,\r\n              "end": 20,\r\n              "value": 2,\r\n              "raw": "2"\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      "kind": "const"\r\n    }\r\n  ],\r\n  "sourceType": "module"\r\n}\r\n```\r\n\r\n\r\n\r\n从以上 AST 结构可以知道，`1 + 2` 是一个 `BinaryExpression` 类型的节点，那么在我们编写的插件代码中的 `visitor` 里就可以这样进行处理：\r\n\r\n```js\r\nvar babel = require(\'babel-core\'); \r\nvar t = require(\'babel-types\'); \r\n\r\nvar visitor = {\r\n  BinaryExpression(path) { \r\n    const node = path.node;\r\n\r\n    let result;\r\n\r\n    // 判断表达式两边，是否都是数字 \r\n    if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) { \r\n      // 根据不同的操作符作运算 \r\n      switch (node.operator) { \r\n        case "+": \r\n          result = node.left.value + node.right.value; \r\n          break;\r\n        case "-": \r\n          result = node.left.value - node.right.value; \r\n          break; \r\n        case "*": \r\n          result = node.left.value * node.right.value; \r\n          break;\r\n        case "/": \r\n          result = node.left.value / node.right.value; \r\n          break; \r\n        case "**": \r\n          let i = node.right.value; \r\n          while (--i) { \r\n            result = result || node.left.value; \r\n            result = result * node.left.value; \r\n          }\r\n          break; \r\n        default: \r\n      } \r\n    }\r\n\r\n    // 如果上⾯的运算有结果的话 \r\n    if (result !== undefined) { \r\n      // 把表达式节点替换成number字⾯量 \r\n      path.replaceWith(t.numericLiteral(result)); \r\n    } \r\n  }\r\n};\r\n\r\nmodule.exports = function (babel) { \r\n  return { visitor };\r\n}      \r\n```\r\n\r\n\r\n\r\n这个插件的基本功能就完成了，来运行试试：\r\n\r\n```js\r\nconst babel = require("babel-core");\r\n\r\nconst result = babel.transform("const result = 1 + 2;", { \r\n  plugins: [ \r\n    require("./index") \r\n  ] \r\n});\r\n\r\nconsole.log(result.code);\t// 结果：const result = 3;\r\n```\r\n\r\n转换结果符合预期。\r\n\r\n\r\n\r\n不过这个插件还不能完全正确的工作，在转换如 `const result = 1 + 2 + 3 + 4 + 5;` 这样的代码时，结果为 `const result = 3 + 3 + 4 + 5;`，也就是只转换了代码中的第一段表达式计算。\r\n\r\n如果用 AST Explorer 查看 AST 结构的话，会发现原来这个运算由层层嵌套的 `BinaryExpression` 组成：\r\n\r\n> BinaryExpression(  BinaryExpression( BinaryExpression( BinaryExpression(1 + 2) + 3 ) + 4 ) + 5 ) \r\n\r\n\r\n\r\n因此我们得改造一下之前的代码逻辑，进行遍历操作：\r\n\r\n```js\r\n// 如果上⾯的运算有结果的话 \r\nif (result !== undefined) { \r\n  // 把表达式节点替换成number字⾯量 \r\n  path.replaceWith(t.numericLiteral(result)); \r\n  \r\n  // 向上遍历⽗级节点\r\n  let parentPath = path.parentPath; \r\n  parentPath && visitor.BinaryExpression.call(this, parentPath);\r\n} \r\n```\r\n\r\n这样就能正确工作了。\r\n\r\n[参考文档：Babel插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#builders)\r\n\r\n\r\n\r\n## 你们的Git工作流是什么样的？\r\n\r\n每个公司采用的 Git 工作流都可能会有差别，有的比较规范，有的比较随意。在这里介绍一个名为 GitFlow 的 git 标准操作流程。\r\n\r\n\r\n\r\n在 GitFlow 标准下，我们的 git 仓库需要包含以下几个关键分支：\r\n\r\n- master：主分支\r\n- develop：主开发分⽀。包含确定即将发布的代码\r\n- feature：新功能分⽀。⼀个新功能对应⼀个分⽀\r\n- release：发布分⽀。发布时⽤的分⽀，⼀般测试阶段发现的 bug 在这个分⽀进⾏修复\r\n- hotfix：热补丁分支。用于修改在线上版本中发现的严重紧急 bug\r\n\r\n\r\n\r\n**GitFlow 的主要优点**\r\n\r\n1. 支持并⾏开发\r\n\r\n因为每个新功能都会建⽴⼀个新的 feature 分⽀，从⽽和其他已经完成的功能隔离开，且当只有在新功能完成开发的情况下，其对应的 feature 分⽀才会被合并到主开发分⽀（develop 分支）。\r\n\r\n另外，如果你正在开发某个功能的同时⼜有⼀个新功能需要开始开发，那么你只需把当前 feature 的代码提交后，新建另外⼀个 feature 分⽀即可开发新功能了。\r\n\r\n你也可以随时切回之前的其他 feature 分⽀继续完成该功能的开发。 \r\n\r\n\r\n\r\n- 协作开发\r\n\r\n因为每个 feature 分⽀上改动的代码都只对该 feature 对应的功能生效，所以不同 feature 分支上的代码在开发时不会互相影响，大家可以相安无事的开发自己负责的功能。\r\n\r\n同时我们可以根据分支的名称，很容易知道每个⼈都在做什么功能。 \r\n\r\n\r\n\r\n- 发布阶段\r\n\r\n当⼀个新 feature 开发完成时，它会被合并到 develop 分⽀，这就意味着 develop 分支上包含了所有已经开发完成的功能。\r\n\r\n因此，在开发新的 feature 时，我们只需从 develop 分⽀来创建新的分⽀，即可在新的 feature 分支中包含所有已完成的最新功能。 \r\n\r\n\r\n\r\n- ⽀持紧急修复\r\n\r\nhotfix 分⽀是从某个已经发布的 Tag 上创建出来来，用于紧急修复 Bug。\r\n\r\n该紧急修复只影响这个已经发布的 Tag，⽽不会影响你正在开发的其他新 feature 。\r\n\r\n\r\n\r\n**注意点**\r\n\r\n1. feature 分⽀都是从 develop 分⽀上创建的，开发完成后再合并到 develop 分⽀上，等待发布\r\n\r\n2. 当需要发布时，我们要从 develop 分⽀上创建⼀个 release 分⽀，然后该 release 分⽀会发布到测试环境进⾏测试。如果发现问题的话，就会直接在该分⽀上进⾏修复。所有问题修复之前，会不停重复 `发布` > `测试` > `修复` > `重新发布`  > `重新测试` 流程。 发布结束，该 release 分⽀会被合并到 develop 以及 master 分⽀，从⽽保证不会有代码丢失\r\n\r\n3. master 分⽀只跟踪已经发布的代码，合并到 master 上的 commit 只能来⾃ release 分⽀和 hotfix 分⽀\r\n\r\n4. hotfix 分⽀的作⽤是紧急修复⼀些 Bug，它们都是从 master 分⽀上的某个 Tag 建⽴，修复结束后再会被合并到 develop 和 master 分⽀上\r\n\r\n\r\n\r\n[参考文章：Git工作流](https://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\r\n\r\n\r\n\r\n## Git的rebase和merge的区别是什么？\r\n\r\n`git rebase` 和 `git merge` 两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。 \r\n\r\n\r\n\r\n以一个 `feature/todo` 分⽀合并到 `master`主分⽀为例，我们来看一下分别⽤ `rebase` 和 `merge` 会有什么不同。\r\n\r\n\r\n\r\n**使用 Merge**\r\n\r\n<img src="/images/image-20210222132936016.png" alt="image-20210222132936016" style="zoom:30%;" />\r\n\r\n`merge` 会⾃动创建⼀个新的 `commit`， 如果合并时遇到冲突的话，只需要修改后重新 `commit`。 \r\n\r\n- 优点：能记录真实的 `commit` 情况，包括每个分⽀的详情 \r\n\r\n- 缺点：由于每次 `merge` 会⾃动产⽣⼀个 `merge commit`，因此在使⽤⼀些可视化的 git 工具时会看到这些自动产生的 `commit`，这些 `commit` 对于程序员来说没有什么特别的意义，反而会影响阅读\r\n\r\n\r\n\r\n**使用 Rebase**\r\n\r\n<img src="/images/image-20210222133524146.png" alt="image-20210222133524146" style="zoom:30%;" />\r\n\r\n`rebase` 会合并之前的 `commit` 历史。 \r\n\r\n- 优点：可以得到更简洁的提交历史，去掉了 `merge commit`\r\n\r\n- 缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息 \r\n\r\n\r\n\r\n**建议**\r\n\r\n- 当需要保留详细的合并信息时，建议使⽤ `git merge`，特别是需要将分⽀合并进 `master` 分⽀时\r\n\r\n- 当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的提交信息对自己来说没有必要，那么可尝试使用 `git rebase`\r\n\r\n\r\n\r\n\r\n\r\n# Vue\r\n\r\n## 什么是MVVM？\r\n\r\nModel-View-ViewModel 模式，最早在 2005 年微软推出的基于 Windows 的⽤户界⾯框架 WPF 中提出，而最早采用 MVVM 的前端框架是 2010 年发布的 Knockout。\r\n\r\n\r\n\r\n<img src="/images/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" />\r\n\r\n\r\n\r\n**Model 层**\r\n\r\n对应数据层的域模型，主要用来做域模型的同步。\r\n\r\n通过 `Ajax`、`fetch` 等 API 完成客户端和服务端业务模型的同步。\r\n\r\n在分层关系中，它主要⽤于抽象出 ViewModel 层中视图的 Model。 \r\n\r\n\r\n\r\n**View 层**\r\n\r\n作为视图模板存在，其实在 MVVM 中整个 View 就是⼀个动态模板。\r\n\r\n除了用于定义结构和布局之外，它还展示了 ViewModel 层的数据和状态。\r\n\r\nView 层并不负责状态的实际处理，它只是做：数据绑定声明、 指令声明、 事件绑定声明。\r\n\r\n\r\n\r\n**ViewModel 层**\r\n\r\n负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明进行实际的业务逻辑。\r\n\r\nViewModel 底层会做好绑定属性的监听，当 ViewModel 中的数据变化时，View 层会自动进行更新；⽽当 View 中声明了数据的双向绑定（表单元素），框架也会监听 View 层（表单元素）值的变化，⼀旦变化，则 View 层绑定的 ViewModel 中的数据也会得到⾃动更新。\r\n\r\n\r\n\r\n## MVVM的优缺点有哪些？\r\n\r\n**优点**\r\n\r\n1. 实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性\r\n\r\n> ⽐如：View 可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定于不同的 "View"，当 View 发生变化时 Model 一定会随之改变，而当 Model 变化时则 View 可以不变。我们可以把⼀些视图逻辑放在⼀个 ViewModel ⾥，以此让多个 View 重⽤这段视图逻辑。\r\n\r\n2. 提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码 \r\n\r\n3. 能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来 \r\n\r\n\r\n\r\n**缺点**\r\n\r\n1. Bug 很难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 模版中的，它们没办法打断点进行 Debug \r\n\r\n2. 在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，也能很容易的保证了数据的⼀致性，但如果⻓期持有不释放内存，就会造成更多的内存消耗 \r\n\r\n3. 对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼\r\n\r\n\r\n\r\n## 谈谈对Vue生命周期的理解？\r\n\r\n**生命周期的概念**\r\n\r\n每个 Vue 实例都有⼀个完整的⽣命周期：\r\n\r\n1. 开始创建\r\n2. 初始化数据\r\n3. 编译模版\r\n4. 挂载 DOM\r\n5. 渲染、更新数据 => 重新渲染\r\n6. 卸载\r\n\r\n这⼀系列过程我们称之为 Vue 的⽣命周期。\r\n\r\n\r\n\r\n**各个生命周期的作用**\r\n\r\n| 生命周期      | 执行时机                                                     |\r\n| ------------- | ------------------------------------------------------------ |\r\n| beforeCreate  | 在组件实例被创建之初、组件的属性⽣效之前被调用               |\r\n| created       | 在组件实例已创建完毕。此时属性也已绑定，但真实DOM还未⽣成，$el 还不可⽤ |\r\n| beforeMount   | 在组件挂载开始之前被调⽤。相关的 render 函数⾸次被调⽤       |\r\n| mounted       | 在 el 被新建的 vm.$el 替换并挂载到实例上之后被调用           |\r\n| beforeUpdate  | 在组件数据更新之前调⽤。发⽣在虚拟 DOM 打补丁之前            |\r\n| update        | 在组件数据更新之后被调用                                     |\r\n| activited     | 在组件被激活时调⽤（使用了 `<keep-alive>` 的情况下）         |\r\n| deactivated   | 在组件被销毁时调⽤（使用了 `<keep-alive>` 的情况下）         |\r\n| beforeDestory | 在组件销毁前调⽤                                             |\r\n| destoryed     | 在组件销毁后调⽤                                             |\r\n\r\n\r\n\r\n**生命周期示意图**\r\n\r\n<img src="/images/image-20210224084130350.png" alt="image-20210224084130350"  />\r\n\r\n\r\n\r\n## 在Vue中网络请求应该放在哪个生命周期中发起？\r\n\r\n可以在 `mounted` 或 `created` 这两个⽣命周期中调⽤发起网络请求。\r\n\r\n\r\n\r\n## Vue组件之间如何进行通信？\r\n\r\n**`props` 和 `$emit + v-on`**\r\n\r\n通过 `props` 将数据在组件树中进行⾃上⽽下的传递；\r\n\r\n通过 `$emit` 和 `v-on` 来作信息的向上传递。 \r\n\r\n\r\n\r\n**EventBus**\r\n\r\n可通过 EventBus 进⾏信息的发布与订阅。\r\n\r\n\r\n\r\n**Vuex**\r\n\r\n全局状态管理库。可通过它来进行全局数据流的管理。\r\n\r\n \r\n\r\n**`$attrs` 和 `$listeners`**\r\n\r\n在 Vue 2.4 版本中加⼊的 `$attrs` 和 `$listeners` 可以用来作为跨级组件之间的通信机制。\r\n\r\n\r\n\r\n**`provide` 和 `inject`**\r\n\r\n由于 `provide` 和 `inject` 可以允许⼀个祖先组件向它的所有⼦孙组件注⼊⼀个依赖（不论组件层次有多深），并在其上下游关系成⽴的时间⾥始终⽣效，因此这种机制也就成为了一种跨组件通信的手段。\r\n\r\n\r\n\r\n> 另外还有一些方式使用场景有限，在此不介绍了。\r\n>\r\n> 可以阅读参考文章：[Vue中的8种组件通信方式](https://juejin.cn/post/6844903887162310669)\r\n\r\n\r\n\r\n## computed和watch的区别是什么？\r\n\r\n**computed**\r\n\r\n1. 它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景 \r\n\r\n2. 它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存，只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算 \r\n\r\n3. 它适⽤于计算⽐较消耗性能的计算场景 \r\n\r\n\r\n\r\n**watch**\r\n\r\n1. 它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。主要⽤于观察 `props`、`$emit` 或本组件的值，当这些值发生变化时，执⾏回调 \r\n\r\n2. 它不具有缓存性。当⻚⾯重新渲染时，即使值没发生变化也会执⾏\r\n\r\n\r\n\r\n**建议**\r\n\r\n1. 当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 `computed`\r\n\r\n2. 当需要在某个数据发生变化的同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ `watch`\r\n\r\n\r\n\r\n## Vue双向绑定原理？\r\n\r\n在 Vue 2.x 中，利⽤的是 `Object.defineProperty` 去劫持对象的访问器（Getter、Setter），当对象属性值发⽣变化时可获取变化，然后根据变化来作后续响应；\r\n\r\n在 Vue 3.0 中，则是通过 `Proxy` 代理对象进⾏类似的操作。\r\n\r\n\r\n\r\n## Object.defineProperty和Proxy的优缺点？\r\n\r\n**Proxy** \r\n\r\n- 可以直接监听整个对象，⽽⾮是对象的属性 \r\n\r\n- 可以直接监听数组的变化\r\n\r\n- 拦截⽅法丰富：多达13种，不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等。比 `Object.defineProperty` 强大很多 \r\n\r\n- 返回的是⼀个新对象，可以在不影响原对象的情况下，只操作新对象来达到⽬的；⽽ `Object.defineProperty` 只能遍历原对象属性并直接修改原对象\r\n\r\n- 受到各浏览器⼚商的重点持续性能优化，能享受到作为新标准的性能红利 \r\n\r\n**Object.defineProperty**\r\n\r\n- 兼容性较好（可⽀持到 IE9）\r\n\r\n\r\n\r\n## 如何理解Vue的响应式系统？\r\n\r\n(考察MVVM)   M: model数据模型,    V:view视图模型,  VM: viewModel视图数据模型\r\n\r\n双向:\r\n\r\n1. 视图变化了, 数据自动更新   =>  监听原生的事件即可,  输入框变了,  监听输入框input事件\r\n2. 数据变化了, 视图要自动更新  =>  vue2 和 vue3\r\n\r\n### 基本原理\r\n\r\nvue2.0 数据劫持:  Object.defineProperty  (es5)\r\n\r\nvue3.0 数据劫持:  Proxy   (es6)\r\n\r\n分析 :此题考查 Vue的 MVVM 原理\r\n\r\n解答:  Vue的双向绑定原理其实就是 MVVM 的基本原理, Vuejs官网已经说明, 实际就是通过 Object.defineProperty方法 完成了对于Vue实例中数据的 **`劫持`**, 通过对于 data中数据 进行set的劫持监听, 然后通过**`观察者模式`**, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新\r\n\r\n简单概述 : 通过Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新\r\n\r\n### 观察者模式\r\n\r\n观察者模式:  当对象间存在  **一对多**  关系时，则使用观察者模式（Observer Pattern）。\r\n\r\n比如，当一个对象或者数据被修改时，则会自动通知依赖它的对象。\r\n\r\n**意图：**定义对象间的一种 `一对多的依赖关系`，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\r\n\r\n\r\n\r\n拍卖会的时候，大家相互叫价，拍卖师(Dep)会观察最高标价(Object.defineProperty)，\r\n\r\n一旦最高价变化了, 然后通知给其它竞价者(watcher观察者 - 订阅者, 订阅了价格的变化)，这就是一个观察者模式 \r\n\r\n\r\n\r\n下图为Vue框架在数据初始化中使用观察者模式的示意图： \r\n\r\n![image-20201208122803496](images/image-20201208122803496.png)\r\n\r\nDep要进行 **依赖收集**，并通过一个subs数组, 记录观察者Watcher,  \r\n\r\nWatcher 分为渲染 watcher、计算属性 watcher、侦听器 watcher三种 \r\n\r\n收集依赖: 简单点说就是谁借了我的钱，我就把那个人  **记下来**  ，以后我的钱少了 我就通知他们说我没钱了 \r\n\r\n```jsx\r\n<div>\r\n  <p>{{ msg }}</p>   // Watcher1(渲染), 依赖于msg\r\n</div>\r\n\r\n<div>\r\n  <h1>{{ car }}</h1>   // Watcher2(渲染),  依赖于car\r\n</div>\r\n\r\n<div>\r\n  <h1>{{ myMsg }}</h1>   // Watcher3(渲染), 依赖于myMsg\r\n</div>\r\n\r\ncomputed: {\r\n  myMsg () {\r\n    console.log(\'计算属性重新计算了\')\r\n    return this.msg + \'20\'  // Watcher4(计算属性中), 依赖于msg, msg变了重新计算\r\n  }\r\n}\r\n\r\nwatch: {\r\n  msg (newValue) {\r\n    console.log(\'新的msg\', newValue) // Watcher5(侦听器), 将来msg变化, 这边要执行这个函数\r\n  }\r\n}\r\n\r\n------------------------------------------------------------------\r\n\r\n// 收集依赖 (dep结构有点类似于二维数组, (Map结构))   arr.type="msgDep"\r\ndep: [\r\n  msgDep: [Watcher5(侦听器依赖), Watcher4(计算属性依赖), Watcher1(渲染)],\r\n  carDep: [Watcher2(渲染)],\r\n  myMsgDep: [Watcher3(渲染)]\r\n]\r\n\r\n\r\n// Watcher\r\n{\r\n  callback: Function, (数据变化后, 需要执行的回调)\r\n  isRenderWatcher: Boolean, (是否是render的watcher, 是否要触发视图的更新, 往后放, 最后统一虚拟dom对比, 统一更新)\r\n  ...\r\n}\r\n```\r\n\r\n比如: 假定数据 money 变了, 那么没有任何与money相关的观察者, 就不需要进行任何更新操作, 也不需要执行任何的监视函数\r\n\r\n然而: 假定数据 msg 变了, 就会通知到相关的Watcher, 且优先通知侦听器Watcher和计算属性Watcher, 后进行统一的渲染更新\r\n\r\n1. 通知侦听器Watcher,  立刻执行配置的函数,  console.log(\'新的msg\', newValue) \r\n2. 通知计算属性Watcher, 计算属性依赖的值变了, 需要重新计算\r\n   且更新后, myMsg 变化了,  需要进行进行视图的渲染  (render)     (--- 要更新, 等着---)\r\n3. 通过到watcher1, 渲染Watcher  (---要更新---)\r\n4. 最后统一进行, 新旧虚拟dom的对比, 完成视图的更新\r\n\r\n\r\n\r\n**当数据状态发生改变时，会被 Object.defineProperty 监听劫持到, 会通知到 Dep,  并根据收集的依赖关系,**  \r\n\r\n**让订阅者Watcher进行数据更新（update）操作 ,  派发更新** \r\n\r\n\r\n\r\n总结概述: vue采用的是观察者模式, 是一种一对多的关系,  一上来vue在解析渲染时, 会进行依赖收集, 会将渲染 watcher、计算属性 watcher、侦听器 watcher, 都收集到dep中,将来Object.defineProperty 监听到数据变化, 就根据依赖关系, 派发更新\r\n\r\n\r\n\r\n\r\n\r\n## Vue中的key到底有什么用？\r\n\r\n`key` 是为 Vue 中的虚拟 DOM 节点（vNode）标记唯⼀性的 id。\r\n\r\n作用:  给虚拟dom添加标识,  **(优化复用对比策略, 优化渲染性能)**\r\n\r\n主要考察: \r\n\r\n1. vue 的更新机制 (差异化更新) 对比新旧虚拟dom 进行更新视图\r\n\r\n   为什么对比虚拟dom, 而不对比真实的dom ? 真实的dom太复杂, 对比起来性能太差\r\n\r\n2. 虚拟dom: 使用 js 对象的方式, 模拟真实的 dom 结构\r\n\r\n   属性的量大大的减少了, 没有真实dom的那么多无效的属性, 对比起来性能高很多\r\n\r\n3. diff 算法: 默认的对比(diff) 机制,  同层兄弟元素, 是按照下标进行对比的, 但是加了 key,  **就相当于给虚拟dom加了个标识**\r\n\r\n   对比策略, 就是对相同key的元素进行对比了, 在列表v-for中, key的使用尤为常见, 可以用于优化渲染性能\r\n\r\n### diff算法\r\n\r\ndiff 算法的基本策略 (对比新旧虚拟dom差异的一种算法):\r\n\r\n1. 由于dom结构是一个树形结构, 就算是对比新旧虚拟dom, 一样是在对比树形结构\r\n\r\n   而树形结构, 每往下都一层, 遍历成本就越高\r\n\r\n2. 为了避免一些无效的对比, diff算法, (tree diff) 优先比较树的根节点\r\n\r\n   如果根节点元素类型(组件), 是一致的, 才考虑复用元素内部的结构\r\n\r\n   如果根节点元素类型(组件), 不一致, 直接销毁, 重新构建新的结构\r\n\r\n   ```\r\n   旧\r\n   <div>\r\n   \t<span>我是内容</span>\r\n   </div>\r\n   \r\n   \r\n   新\r\n   <li>\r\n   \t<a href="#">我是内容</a>\r\n   \t<span>我是内容</span>\r\n   </li>\r\n   ```\r\n\r\n   大大的提升了对比的效率\r\n\r\n3. 同一根节点下,   同级兄弟元素, 默认的对比策略: 按照下标对比\r\n\r\n   ```\r\n   旧\r\n   <div class="box">\r\n   \t<h1>大标题</h1>\r\n   \t<p>内容</p>\r\n   </div>\r\n   \r\n   新\r\n   <div class="message">\r\n   \t<h1>测试标题</h1>\r\n   \t<p>内容</p>\r\n   </div>\r\n   ```\r\n\r\n4. 同一根节点下,   同级兄弟元素,  如果配置 key 属性, 那么对比的策略, 就不是按照下标, 而是按照key进行 一一对比\r\n\r\n   ```\r\n   旧\r\n   <div class="box">\r\n   \t<h1 key="201">大标题</h1>\r\n   \t<p key="202">内容</p>\r\n   </div>\r\n   \r\n   新\r\n   <div class="message">\r\n   \t<h1 key="200">大标题</h1>   // 新结构\r\n   \t<p key="202">内容</p>    // 对比出来, 原来结构有key="202", 进行对比, 完成了复用\r\n   </div>\r\n   ```\r\n\r\n   如果你希望一个结构, 并不进行复用, 就是希望某个组件某个结构,  能够重新构建, 可以设置一个不同的 key\r\n\r\n\r\n\r\n### key的常见应用场景\r\n\r\nkey 的常见应用场景 => v-for,  v-for 遍历的列表中的项的顺序, 非常的容易改变\r\n\r\n1 往后面加, 默认的对比策略, 按照下标,  没有任何问题\r\n\r\n```jsx\r\n// 旧\r\n<ul>\r\n  <li>张三</li>\r\n  <li>李四</li>\r\n</ul>\r\n\r\n// 新\r\n<ul>\r\n  <li>张三</li>\r\n  <li>李四</li>\r\n  <li>王五</li>\r\n</ul>\r\n```\r\n\r\n2 往前面加, 由于下标变了, 如果按照之前的下标对比, 元素是混乱的, 策略: 加上key\r\n\r\n​    一旦加上了key, 就是按照 key 进行新旧dom的对比了\r\n\r\n```jsx\r\n// 旧 \r\n<ul>\r\n  <li key="17">张三</li>\r\n  <li key="31">李四</li>\r\n</ul>\r\n\r\n// 新  [ { id: 17, name: \'张三\' }, ... ]\r\n<ul>\r\n  <li key="52">王五</li>\r\n  <li key="17">张三</li>\r\n  <li key="31">李四</li>\r\n</ul>\r\n```\r\n\r\n**总结: key 就是给 虚拟dom 添加了一个 标识, 优化了对比策略!!!**\r\n\r\n\r\n\r\n# React\r\n\r\n## React最新的生命周期是怎么样的？\r\n\r\n在 React 16 版本中，三个之前的生命周期被标识为废弃，并在 React 17 中计划全部删除它们：\r\n\r\n- componentWillMount \r\n\r\n- componentWillReceiveProps \r\n\r\n- componentWillUpdate\r\n\r\n\r\n\r\n当它们被删除后，将会只保留三个添加了`UNSAVE_`前缀的函数版本，作为向下兼容用途。因此我们在新项目中，要尽量避免使用这几个生命周期而使用最新的生命周期函数。\r\n\r\n\r\n\r\n⽬前 React 16.8+ 的⽣命周期分为三个阶段：挂载阶段、更新阶段、卸载阶段。\r\n\r\n\r\n\r\n**挂载阶段** \r\n\r\n`constructor` ：组件的构造函数，它会最先被执⾏，我们通常在构造函数⾥初始化 `state` 状态对象、或给⾃定义⽅法绑定 `this` \r\n\r\n\r\n\r\n`getDerivedStateFromProps` ：这是个静态⽅法，当我们接收到新的属性后想要去修改 `state` 时可以使用\r\n\r\n\r\n\r\n`render`：这是个只返回需要渲染内容的纯函数，不要包含其它的业务逻辑，可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 值 和 null 值等内容 \r\n\r\n\r\n\r\n`componentDidMount` ：在组件装载后被调⽤，此时可以获取 DOM 节点并操作，对服务器的请求、订阅等操作都可以写在这个地方，但记得要在 `componentWillUnmount` 中取消订阅，即释放资源\r\n\r\n\r\n\r\n**更新阶段** \r\n\r\n`getDerivedStateFromProps` ：此⽅法在更新个挂载阶段都可能会调⽤ \r\n\r\n\r\n\r\n`shouldComponentUpdate` ：该函数有两个参数 `nextProps` 和 `nextState`，表示新的属性和变化之后的状态；它返回⼀个布尔值，`true` 表示会触发重新渲染，`false` 则表示不会触发重新渲染，默认返回 `true`。我们通常利⽤该⽣命周期来优化 React 程序的性能\r\n\r\n\r\n\r\n`render` ：更新阶段也会触发此⽣命周期 \r\n\r\n\r\n\r\n`getSnapshotBeforeUpdate` ：该⽅法在 `render` 之后、在 `componentDidUpdate` 之前被调⽤，它有两个参数 `prevProps` 和`prevState`，表示之前的属性和状态，并且该函数有⼀个返回值，返回值会作为第三个参数传给 `componentDidUpdate` ，如果不想要返回值则返回 `null` 即可。该⽣命周期必须与 `componentDidUpdate` 搭配使⽤ \r\n\r\n\r\n\r\n`componentDidUpdate` ：该⽅法在 `getSnapshotBeforeUpdate` ⽅法之后被调⽤，它有三个参数 `prevProps` 、`prevState` 、`snapshot` ，表示之前的属性、之前的状态、以及`snapshot`。第三个参数是 `getSnapshotBeforeUpdate` 所返回的，如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ `getSnapshotBeforeUpdate`，然后在 `componentDidUpdate` 中统⼀触发回调或更新状态\r\n\r\n\r\n\r\n**卸载阶段**\r\n\r\n`componentWillUnmount` ：当组件被卸载或销毁时就会被调⽤，我们可以在这个函数⾥去做一些释放资源的操作，如：清除定时器、取消⽹络请求、清理⽆效的 DOM 元素等\r\n\r\n\r\n\r\n[React生命周期图形示意工具](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)\r\n\r\n\r\n\r\n## 在React中网络请求应该放在哪个生命周期中发起？\r\n\r\n有人认为 React 中的网络异步请求，应该放在 `componentWillMount` 这个生命周期函数中发起，这样可以提前进⾏异步请求，以避免⽩屏现象。其实这个观点是有问题的。\r\n\r\n\r\n\r\n由于 JavaScript 中异步事件的性质，当进行异步 API 调⽤时，浏览器会在此期间继续执⾏其他⼯作。因此，当 React 渲染⼀个组件时，它并不会等待 `componentWillMount` 执行完成任何事情，而是继续往前执行并继续做 `render` ，没有办法 “暂停” 渲染以等待远程数据的返回。\r\n\r\n\r\n\r\n⽽且，在 `componentWillMount` 中发起请求会存在⼀系列潜在问题：\r\n\r\n- 在用 React 作为服务器渲染（SSR）时，如果在 `componentWillMount` 中进行数据的获取，则 `fetch data` 会执⾏两次：⼀次在服务端，⼀次在客户端，这就造成了多余的请求\r\n\r\n- 在 React 16 使用 React Fiber 架构重写后，`componentWillMount` 可能会在⼀次渲染中被多次调⽤。 \r\n\r\n\r\n\r\n**⽬前官⽅推荐的是在 `componentDidmount` 中进行异步请求。** \r\n\r\n\r\n\r\n如遇到特殊需求，需要提前进行数据的请求，可考虑采用在 `constructor` 中进行。\r\n\r\n另外，由于在 React 17 之后 `componentWillMount` 被废弃仅保留 `UNSAFE_componentWillMount`，所以要慎用该生命周期。\r\n\r\n\r\n\r\n## setState是同步的还是异步的？\r\n\r\n答案是：有时表现出异步，有时表现出同步！\r\n\r\n- 在合成事件和生命周期钩⼦函数中是异步的\r\n- 在原⽣事件和 `setTimeout` 中是同步的\r\n\r\n\r\n\r\n`setState` 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。\r\n\r\n\r\n\r\n当然，我们可以通过使用第⼆个参数来拿到更新后的结果，它是个回调函数：\r\n\r\n```js\r\nsetState(partialState, callback)\r\n```\r\n\r\n\r\n\r\n此外，`setState` 的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和 `setTimeout` 中不会批量更新。在异步中，如果对同⼀个值进⾏多次 `setState`，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时 `setState` 多个不同的值，则会在更新时对其进⾏合并批量更新。\r\n\r\n\r\n\r\n## React中如何实现组件间的通信？\r\n\r\n组件间通信⽅式一共有如下几种： \r\n\r\n\r\n\r\n1. ⽗组件向⼦组件通讯\r\n\r\n⽗组件可以通过向⼦组件传 `props` 的⽅式来实现父到子的通讯。\r\n\r\n\r\n\r\n2. ⼦组件向⽗组件通讯\r\n\r\n可以采用 `props + 回调` 的⽅式。\r\n\r\n当⽗组件向⼦组件传递 `props` 进⾏通讯时，可在该 `props` 中传递一个回调函数，当⼦组件调⽤该函数时，可将⼦组件中想要传递给父组件的信息作为参数传递给该函数。由于 `props` 中的函数作⽤域为⽗组件⾃身，因此可以通过该函数内的 `setState` 更新到⽗组件上。 \r\n\r\n\r\n\r\n3. 兄弟组件通信\r\n\r\n可以通过兄弟节点的共同⽗节点，再结合以上2种⽅式，由⽗节点转发信息，实现兄弟间通信。 \r\n\r\n\r\n\r\n4. 跨层级通信\r\n\r\n可以采用 React 中的 `Context` 来实现跨越多层的全局数据通信。 \r\n\r\n`Context` 设计的⽬的是为在⼀个组件树中共享 “全局” 数据，如：当前已登录的⽤户、界面主题、界面语⾔等信息。\r\n\r\n\r\n\r\n5. 发布订阅模式\r\n\r\n发布者发布事件，订阅者监听到事件后做出反应。\r\n\r\n我们可以通过引⼊ `event` 模块进⾏此种方式的通信。\r\n\r\n\r\n\r\n6. 全局状态管理⼯具\r\n\r\n可以借助 `Redux` 或 `Mobx` 等全局状态管理⼯具进⾏通信，它们会维护⼀个全局状态中⼼（Store），并可以根据不同的事件产⽣新的状态。\r\n\r\n<img src="/images/image-20210223093430679.png" alt="image-20210223093430679" style="zoom:30%;" /> \r\n\r\n\r\n\r\n## React存在哪些性能优化手段？\r\n\r\n前端项目的性能手段，其实都是相通的。我们可以参考文章：[前端性能优化](https://blog.csdn.net/weixin_33976072/article/details/93168109)\r\n\r\n\r\n\r\n## React中如何进行组件和逻辑的复用？\r\n\r\nReact 中的组件抽象的技术有以下几种: \r\n\r\n- 混合（mixin，官方已废弃）\r\n\r\n- ⾼阶组件（hoc）：属性代理、反向继承 \r\n\r\n- 渲染属性（render props）\r\n\r\n- React Hooks（配合函数式组件使用，函数拆分的复用理念）\r\n\r\n\r\n\r\n## Mixin、HoC、Render props、React Hooks的优缺点分别是什么？\r\n\r\n**Mixin** \r\n\r\n- 组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖于组件的特定⽅法，但在定义组件时并不知道这种依赖关系） \r\n\r\n- 多个 Mixin 之间可能产⽣冲突，⽐如：多个 Mixin 中定义了相同的 state 字段，在一个组件中同时引入这些 Mixin 后会产生字段冲突\r\n\r\n- Mixin 倾向于增加更多状态，这降低了应⽤的可预测性，状态越多越难管理和溯源，复杂度剧增 \r\n\r\n- 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升： \r\n\r\n  - 难以快速理解组件的⾏为，需要全盘了解所有依赖 Mixin 的扩展⾏为及其之间的相互影响 \r\n\r\n  - 33333组件⾃身的⽅法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它 \r\n\r\n  - Mixin 也难以维护，因为 Mixin 逻辑最后会被摊平合并到⼀起，很难搞清楚⼀个 Mixin 的输⼊输出\r\n\r\n\r\n\r\n**HoC**\r\n\r\n优点：\r\n\r\n相⽐ Mixin，HoC 通过外层组件传递 props 来影响内层组件的状态，⽽不是直接改变其 state，这就不存在冲突和互相⼲扰，降低了耦合度。不同于 Mixin 的打平 + 合并，HoC 天然具有层级结构（组件树结构），这⼜降低了复杂度。\r\n\r\n \r\n\r\n缺点： \r\n\r\n- 扩展性限制：HoC ⽆法从外部访问⼦组件的 state，因此⽆法通过 `shouldComponentUpdate` 滤掉不必要的更新；React 在⽀持ES6 Class 之后提供了 `React.PureComponent` 解决了这个问题 \r\n\r\n- Ref 传递问题：Ref 被隔断。后来出现了 `React.forwardRef` 来解决了这个问题 \r\n\r\n- 包装地狱（Wrapper Hell）：和回调函数类似，HoC 如果出现多层包裹组件的情况，就会和回调函数一样层层嵌套；而这种多层抽象同样也增加了复杂度和理解成本 \r\n\r\n- 命名冲突：如果⾼阶组件多次嵌套而没有使⽤命名空间，就可能会产⽣冲突，覆盖⽼的属性 \r\n\r\n- 不可⻅性：HoC 相当于在原有组件外层再包装⼀个组件，你有可能压根都不知道外层的包装是什么，对于你来说完全是⿊盒\r\n\r\n\r\n\r\n**Render Props**\r\n\r\n优点：\r\n\r\n上述所说的 HoC 缺点，使用 Render Props 都可得到解决。 \r\n\r\n\r\n\r\n缺点：\r\n\r\n- 使⽤繁琐：HoC 使⽤只需要借助装饰器语法，通常⼀⾏代码就可以进⾏复⽤，而 Render Props ⽆法做到如此简单 \r\n\r\n- 嵌套过深：Render Props 虽然摆脱了组件多层嵌套问题，但其又会走回到了回调函数的嵌套问题\r\n\r\n\r\n\r\n**React Hooks**\r\n\r\n优点：\r\n\r\n- 简洁：React Hooks 解决了 HoC 和 Render Props 的嵌套问题，代码更加简洁\r\n\r\n- 解耦：React Hooks 可以更⽅便地把 UI 和状态分离，做到更彻底的解耦\r\n\r\n- 组合：Hooks 中可以通过引⽤另外的 Hooks 以此形成新的 Hooks，变化丰富\r\n\r\n- 函数友好：React Hooks 为函数组件⽽⽣，从⽽解决了类组件的⼏⼤问题: \r\n\r\n  - this 指向容易错误 \r\n  - 分割在不同声明周期中的逻辑会使得代码难以理解和维护 \r\n\r\n  - 代码复⽤成本⾼（⾼阶组件容易使代码量剧增） \r\n\r\n\r\n\r\n缺点： \r\n\r\n- 有额外的学习成本（需要学习和区分类组件、函数组件） \r\n\r\n- 写法上有限制（不能出现在条件、循环中），并且这种写法限制会增加代码重构时的成本 \r\n\r\n- 破坏了 `PureComponent`、`React.memo` 浅⽐较的性能优化效果（为了获取最新的 props 和 state，每次 `render()` 都要重新 \r\n\r\n创建事件处理函数）\r\n\r\n- 在闭包场景中可能会引⽤到旧的 state、props 值\r\n- 内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”） \r\n- `React.memo` 并不能完全替代 `shouldComponentUpdate`（因为获取不到 state 的变化，只针对 props 的变化）\r\n\r\n\r\n\r\n## Redux的工作流程是怎么样的？\r\n\r\n**核心概念**\r\n\r\n- `Store`：一个保存数据的容器，整个应⽤只有⼀个 Store\r\n\r\n- `State`：Store 对象内包含所有数据，如想得到某一时间点的数据，就要对 Store ⽣成快照，这种时间点的数据集合，就叫 State\r\n\r\n- `Action`：State 的变化会导致 View 的变化，但⽤户是接触不到 State 的，只能接触到 View，所以 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了\r\n\r\n- `Action Creator`：View 要发送多少种消息，就需要有多少种 Action，如果都⼿写会比较麻烦，因此我们通常会定义一个用于生成 Action 的函数，该函数就被称为 Action Creator\r\n\r\n- `Reducer`：在 Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做Reducer。Reducer 是⼀个函数，它接收 Action 和当前 State 作为参数，返回值是⼀个新的 State\r\n\r\n- `dispatch`：是 View 发送 Action 的唯⼀⽅法\r\n\r\n\r\n\r\n**⼯作流程**\r\n\r\n<img src="/images/image-20210223103127034.png" alt="image-20210223103127034" style="zoom:90%;" />\r\n\r\n⼀次⽤户交互的流程如下：\r\n\r\n1. ⾸先，View（通过⽤户）发出 Action，发出⽅式就是使用 `dispatch` ⽅法 \r\n\r\n2. 然后，Store 调⽤ Reducer 并且传⼊两个参数（当前的 State 和收到的 Action），Reducer 处理后返回新的 State \r\n\r\n3. State ⼀旦有变化，则 Store 会调⽤监听函数来通知 View 进行更新\r\n\r\n\r\n\r\n注意，在整个流程中，数据都是单向流动的，我们称之为单向数据流，这种⽅式可以保证流程的清晰性。\r\n\r\n\r\n\r\n## react-redux这个库是如何工作的？\r\n\r\n**核心概念**\r\n\r\n**`Provider`**\r\n\r\nProvider 的作⽤是从最外部封装了整个应⽤，并向 `connect` 模块传递 `store` 。\r\n\r\n\r\n\r\n**`connect`**\r\n\r\n负责将 React 和 Redux 关联起来，它的作用主要如下：\r\n\r\n- 获取 `state`：`connect` 先通过 `context` 来获取存放在 `Provider` 中的 `store`，然后通过 `store.getState()` 来获取整个 `store tree` 上所存放的 `state` \r\n\r\n- 包装原组件：`connect` 将 `state` 和 `action` 通过 `props` 传⼊到原组件的内部，并调用 `wrapWithConnect` 函数来包装和返回⼀个 `Connect` 对象，`Connect` 对象重新 `render` 外部传⼊的原组件，并把 `connect` 中传⼊的 `mapStateToProps` 和 `mapDispatchToProps` 与组件原有的 `props` 合并后，通过属性的⽅式传给包装组件 \r\n\r\n- 监听 `store tree` 变化：`connect` 缓存了 `store tree` 中 `state` 的状态，通过对比当前 `state ` 和变更前 `state`，确定是否需要调⽤ `this.setState()` ⽅法，以此触发 `Connect` 及其⼦组件的重新渲染\r\n\r\n\r\n\r\n**流程图**\r\n\r\n![image-20210223104924017](/images/image-20210223104924017.png)\r\n\r\n\r\n\r\n## Redux和Mobx的区别？\r\n\r\n| 比较点     | Redux                                                        | Mobx                                                         |\r\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| 存储方式   | 保存在单⼀的 store 中                                        | 保存在分散的多个 store 中                                    |\r\n| 数据结构   | 使⽤ plain object 保存数据，需要⼿动处理变化后的操作         | 使⽤ observable 保存数据，数据变化后⾃动处理响应的操作（类似 Vuex） |\r\n| 数据可变性 | 不可变状态，只读不能直接修改，应使⽤纯函数返回⼀个新状态     | 状态是可变的，可直接进⾏修改                                 |\r\n| 难易度     | 比较复杂<br />涉及函数式编程思想，掌握起来不那么容易，同时需借助⼀些中间件处理异步和副作⽤ | 比较简单<br />使用面向对象的编程思维                         |\r\n| 调试       | 容易<br />使用纯函数，并提供了时间回溯⼯具，因此调试直观方便 | ⽐较困难<br />有更多的对象抽象和封装，调试会⽐较困难         |\r\n\r\n\r\n\r\n**使⽤场景**\r\n\r\n`Mobx`\r\n\r\n- 更适合数据不复杂的应⽤。因为 mobx 难以调试，很多状态⽆法回溯，⾯对复杂度⾼的应⽤时往往⼒不从⼼\r\n\r\n- 适合短平快的项⽬。因为 mobx上⼿简单，样板代码少，很⼤程度上提⾼了开发效率\r\n\r\n\r\n\r\n`Redux`\r\n\r\n- 适合有回溯需求的应⽤。⽐如，画板、表格等应⽤，一般有撤销、重做等操作，由于 Redux 具有不可变的特性，天然⽀持这些操作 \r\n\r\n\r\n\r\n我们也可以在一个项目中同时使用 `Mobx` 和 `Redux` ，让两者发挥各自的长处，比如：\r\n\r\n- 使用 `Redux` 作为全局状态管理\r\n- 使⽤ `Mobx `作为组件的局部状态管理器\r\n\r\n\r\n\r\n## 在Redux中如何进行异步操作？\r\n\r\n一般项目中，我们可以直接在 `componentDidMount` 中进⾏异步操作，比如发送网络请求，⽆须借助 Redux。但如果我们的项目上了一定的规模，这种方法再管理异步流的时候就比较困难。这个时候，我们会借助 Redux 的异步中间件来进⾏异步处理。 \r\n\r\nRedux 其实有多种异步中间件，但当下主流的只有两种：`redux-thunk` 和 `redux-saga`。\r\n\r\n**redux-thunk**\r\n\r\n优点：\r\n\r\n- 体积⼩：redux-thunk 的实现⽅式很简单，只有不到20⾏代码 \r\n\r\n- 使⽤简单：redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的编程范式，上⼿非常简单 \r\n\r\n\r\n\r\n缺点：\r\n\r\n- 样板代码过多：与 redux 本身⼀样，通常发送⼀个请求就需要编写⼤量代码，⽽且很多都是重复性的 \r\n\r\n- 耦合严重：异步操作与 redux 的 action 偶合在⼀起，不⽅便管理 \r\n\r\n- 功能薄弱：实际开发中常⽤的⼀些功能都需要⾃⼰封装 \r\n\r\n\r\n\r\n**redux-saga**\r\n\r\n优点：\r\n\r\n- 异步解耦：异步操作被被转移到了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中 \r\n\r\n- action 摆脱了 thunk function：dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满了 “⿊魔法” 的 thunk function \r\n- 异常处理：受益于 Generator Function 的 saga 实现，代码异常/请求失败都可直接通过 try/catch 捕获处理 \r\n\r\n- 功能强⼤：redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器，开发者⽆须自行封装、或只要简单封装即可使⽤ \r\n\r\n- 灵活：redux-saga 可将多个 Saga 进行串⾏或并⾏组合，形成⼀个⾮常实⽤的异步流程 \r\n\r\n- 易测试：提供了各种测试⽅案，包括 mock task、分⽀覆盖等\r\n\r\n\r\n\r\n缺点：\r\n\r\n- 额外的学习成本：redux-saga 不仅使⽤了难以理解的 Generator Function，⽽且存在数⼗个 API，学习成本远超 redux-thunk；最重要的是，这些额外的学习成本只能用于使用这个库的（而对于 redux-observable 来说，它虽也有学习成本，但它基于 rxjs ，这套编程思想和技术体系可以沿用到其他地方去）\r\n\r\n- 体积庞⼤：代码近 2000 ⾏（压缩后大约 25KB） \r\n\r\n- 功能过剩：其中提供的并发控制等功能，实际开发中很难会⽤到，但我们依然要引⼊这些代码 \r\n\r\n- 对 TS ⽀持不友好：yield ⽆法返回 TS 类型 \r\n\r\n\r\n\r\n**redux-observable**\r\n\r\n优点：\r\n\r\n- 功能最强：由于基于 rxjs 这个强⼤的响应式编程库，借助 rxjs 的操作符⼏乎可以做任何你能想到的异步处理 \r\n\r\n- 知识沿用：如果你已学习过 rxjs，那么 redux-observable 的学习成本并不⾼；⽽且，随着 rxjs 的升级，redux-observable 也会变得更强⼤ \r\n\r\n\r\n\r\n缺点：\r\n\r\n- 学习成本奇⾼：对于还不会 rxjs 的开发者来说，需要额外的学习两个都较为复杂的库 \r\n\r\n- 社区⼀般：redux-observable 下载量只有 redux-saga 的 1/5，社区不够活跃，而 redux-saga 仍处于领导地位 ',contentRendered:'<h1 id="html基础" tabindex="-1"><a class="header-anchor" href="#html基础" aria-hidden="true">#</a> HTML基础</h1>\n<h2 id="_1-html-文件中的-doctype-是什么作用" tabindex="-1"><a class="header-anchor" href="#_1-html-文件中的-doctype-是什么作用" aria-hidden="true">#</a> 1. HTML 文件中的 DOCTYPE 是什么作用？</h2>\n<p>HTML超文本标记语言: 是一个标记语言, 就有对应的语法标准</p>\n<p>DOCTYPE 即 Document Type，网页文件的文档类型标准。</p>\n<p>主要作用是告诉浏览器的解析器要使用哪种  <strong>HTML规范</strong> 或 <strong>XHTML规范</strong> 来解析页面。</p>\n<p>DOCTYPE 需要放置在 HTML 文件的 <code>&lt;html&gt;</code>标签之前，如：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  ...\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> (目前主流)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span> <span class="token name">PUBLIC</span> <span class="token string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/strict.dtd"</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  ...\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> (早期)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_2-html、xml、xhtml-之间有什么区别" tabindex="-1"><a class="header-anchor" href="#_2-html、xml、xhtml-之间有什么区别" aria-hidden="true">#</a> 2. HTML、XML、XHTML 之间有什么区别？</h2>\n<p>它们都属于标记语言。</p>\n<table>\n<thead>\n<tr>\n<th>语言</th>\n<th>中文名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTML4</td>\n<td>超文本标记语言</td>\n<td>主要用于做界面呈现。HTML 是先有实现，后面才慢慢制定标准的，导致HTML⾮常混乱和松散，语法非常的不严谨。</td>\n</tr>\n<tr>\n<td>XML</td>\n<td>可扩展标记语言</td>\n<td>主要⽤于存储数据和结构。语法严谨，可扩展性强。由于 JSON 也有类似作⽤但更轻量⾼效， XML 的市场变得越来越⼩。</td>\n</tr>\n<tr>\n<td>XHTML</td>\n<td>可扩展超文本标记语言</td>\n<td>属于加强版 HTML，为解决 HTML 的混乱问题而生，在语法方面变得和 XML 一样严格。另外，XHTML 的出现也催生了 HTML 5，让HTML向规范化严谨化过渡。</td>\n</tr>\n<tr>\n<td>HTML5</td>\n<td>超文本标记语言</td>\n<td>在HTML的基础上进行拓展，用于页面呈现 (目前标准)</td>\n</tr>\n</tbody>\n</table>\n<p>XML的要求会比较严格:</p>\n<ol>\n<li>\n<p>有且只能有一个根元素</p>\n</li>\n<li>\n<p>大小写敏感</p>\n</li>\n<li>\n<p>正确嵌套</p>\n</li>\n<li>\n<p>必须双引号</p>\n</li>\n<li>\n<p>必须闭合标签</p>\n<p>...</p>\n</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>father</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">\'</span>box<span class="token punctuation">\'</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">小张</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">小王</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>father</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>XHTML 和 HTML5 的历史延展: https://www.cnblogs.com/my-freedom/p/5796915.html</p>\n<p><strong>番外:</strong> 所以 HTML5 是HTML的新一代标准, 所谓的 H5 工程师这一词, 其实是国产词, 泛指新一代的web开发工程师,</p>\n<p>具体H5工程师, 做什么工作方向, 还是要看需求 (比如: 移动端开发, PC端网页开发, H5小游戏开发....)</p>\n<h2 id="_3-前缀为-data-开头的元素属性是什么" tabindex="-1"><a class="header-anchor" href="#_3-前缀为-data-开头的元素属性是什么" aria-hidden="true">#</a> 3. 前缀为 <code>data-</code> 开头的元素属性是什么？</h2>\n<p>这是一种为 HTML 元素添加额外数据信息的方式，被称为 <strong>自定义属性</strong>。</p>\n<p>我们可以直接在元素标签上声明这样的数据属性：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mydiv<span class="token punctuation">"</span></span> <span class="token attr-name">data-message</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hello,world<span class="token punctuation">"</span></span> <span class="token attr-name">data-num</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>也可以使用 JavaScript 来操作元素的数据属性：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> mydiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mydiv\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 读取</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mydiv<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>message<span class="token punctuation">)</span>\n\n<span class="token comment">// 写入</span>\nmydiv<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">"bar!!!"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>注意：在各种现代前端框架出现后，这种原生的自定义属性已经变得不太常用了, 以前的使用频率非常高, 所以我们知道即可。</strong></p>\n<p>例如: vue实现删除功能时需要 id, 可以直接传值</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item in list<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">18</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">体育好</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;button @click="del(item.id)">删除</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">编辑</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_4-谈谈你对-html-语义化的理解" tabindex="-1"><a class="header-anchor" href="#_4-谈谈你对-html-语义化的理解" aria-hidden="true">#</a> 4. 谈谈你对 HTML 语义化的理解？</h2>\n<p>考察核心点: 语义化的好处 (利于SEO, 可阅读性更好)</p>\n<p><strong>语义化之前：</strong></p>\n<p>在提倡语义化之前，你可能会使用各种各样的标签去实现同样的功能，比如：</p>\n<ul>\n<li>使用 span、div、p、a 等做文字, 做按钮</li>\n<li>使用 div 做一切</li>\n</ul>\n<p>从功能方面来说，这确实是不存在什么问题的，完全可以达到功能效果。但这不符合直觉，非常不友好：</p>\n<ul>\n<li>对人不友好：阅读代码的人不能一眼看出代码的功能</li>\n<li>对机器不友好：解析代码的程序不能很好的对这些元素进行分类处理</li>\n</ul>\n<p><strong>语义化之后：</strong></p>\n<p>为了解决上面说的问题，HTML5 规范提倡语义化标签，即使⽤恰当语义的 HTML 标签让⻚⾯具有良好的结构与含义，⽐如：</p>\n<ul>\n<li><code>&lt;p&gt;</code> 标签就代表段落</li>\n<li><code>&lt;article&gt;</code> 代表正⽂内容</li>\n<li><code>&lt;button&gt; </code>代表按钮</li>\n<li><code>&lt;header&gt;</code> 代表头部</li>\n<li>等等...</li>\n</ul>\n<p>语义化的好处：</p>\n<table>\n<thead>\n<tr>\n<th>对开发者的好处</th>\n<th>对机器/程序的好处</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>使⽤了语义化标签的程序，可读性明显增强，开发者可以比容易和清晰地看出⽹⻚的结构；这也更利于整个开发团队的协作开发和后续维护工作</td>\n<td>带有语义的网页代码在⽂字类应用上的表现⼒丰富，利于搜索引擎爬⾍程序来爬取和提取出有效的信息；语义化标签还⽀持读屏软件，根据⽂章可以⾃动⽣成⽬录等，方便特殊人群无障碍的使用这些网页程序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>语义化的适用性：</strong></p>\n<p>语义化适合内容型的网站来使用（如简书、知乎），对其⽹站内容的传播有很⼤帮助。</p>\n<h2 id="_5-html5-对比-html4-有哪些不同之处" tabindex="-1"><a class="header-anchor" href="#_5-html5-对比-html4-有哪些不同之处" aria-hidden="true">#</a> 5. HTML5 对比 HTML4 有哪些不同之处？</h2>\n<p><strong>考察点: 是否了解 html5 新增的一些新特性</strong></p>\n<table>\n<thead>\n<tr>\n<th>不同点</th>\n<th>备注说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>只有一种 DOCTYPE ⽂件类型声明(统一标准)</td>\n<td><code>&lt;!DOCTYPE html&gt;</code></td>\n</tr>\n<tr>\n<td>增加了一些新的标签元素(功能, 语义化)</td>\n<td><strong>section</strong>, <strong>video</strong>, progress, <strong>nav</strong>, meter, time, <strong>aside</strong>, <br/><strong>canvas</strong>, command, datalist, details, embed, figcaption, <br/>figure, <strong>footer</strong>, <strong>header</strong>, hgroup...</td>\n</tr>\n<tr>\n<td>input 支持了几个新的类型值</td>\n<td><code>date, email, url</code> 等等</td>\n</tr>\n<tr>\n<td>新增了一些标签属性</td>\n<td>charset（⽤于 meta 标签）；async（⽤于 script 标签）</td>\n</tr>\n<tr>\n<td>新增的全域属性</td>\n<td>contenteditable, draggable... <br/>hidden...</td>\n</tr>\n<tr>\n<td>新增API</td>\n<td>本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket...</td>\n</tr>\n</tbody>\n</table>\n<p>获取地理定位: navigator.geolocation.getCurrentPosition(successCallback, errorCallback) (为了安全, 需要在 https 网站使用)</p>\n<p>记忆角度: 更标准, 新增标签, 新增type表单属性, 新增全域属性, 新增API...</p>\n<h2 id="_6-meta-标签有哪些常用用法" tabindex="-1"><a class="header-anchor" href="#_6-meta-标签有哪些常用用法" aria-hidden="true">#</a> 6. meta 标签有哪些常用用法？</h2>\n<p><code>&lt;meta&gt;</code> 标签的具体功能一般由 name/http-equiv 和 content 两部分属性来定义。</p>\n<ul>\n<li>如果设置 name 属性，则它描述的是网页文档的信息（例如：作者、⽇期和时间、⽹⻚描述、 关键词）</li>\n<li>如果设置 http-equiv 属性，则它描述的相当于是 HTTP 响应头信息（例如：网页内容信息, 网页缓存等）</li>\n</ul>\n<p><strong>一些常用的功能及写法：</strong></p>\n<ol>\n<li>设置网页关键词 (SEO)</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>电商,好货,便宜<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2">\n<li>设置网页视口（viewport）控制视⼝的⼤⼩、缩放和⽐例等 (移动端开发)</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1, maximum-scale=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="3">\n<li>设置 http 响应头：Content-Type 网页内容类型  (字符集)</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content-type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html;charset=utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\n<span class="token comment">&lt;!-- 设置字符集可简写为 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_7-img-标签的-srcset-的作用是什么" tabindex="-1"><a class="header-anchor" href="#_7-img-标签的-srcset-的作用是什么" aria-hidden="true">#</a> 7. img 标签的 srcset 的作用是什么？</h2>\n<p><strong>考察点: 处理响应式图片的方式</strong> (css媒体查询换的是背景图片, 而不是 img 标签的 src)</p>\n<p>开发者和设计师们竞相寻求 <strong>处理响应式图片</strong> 的方法。这的确是一个<a href="https://css-tricks.com/responsive-images-hard/" target="_blank" rel="noopener noreferrer">棘手的问题<ExternalLinkIcon/></a> ，因为我们对同一个网站在众多设备宽度下，</p>\n<p>使用同一图像源。你愿意在一个大显示屏上显示模糊地、马赛克状的图像？</p>\n<p>你愿意在你的手机上加载一个巨大的（虽然更漂亮的）图像？这个问题令人左右为难。 <a href="https://www.jiangweishan.com/article/response-srcset-sizes.html" target="_blank" rel="noopener noreferrer">博客链接<ExternalLinkIcon/></a></p>\n<p>其实通过使用 img 标签的 srcset 属性，可定义一组额外的图片集合，让浏览器根据不同的屏幕状况选取合适的图片来显示。</p>\n<blockquote>\n<p>也就是图片的响应式处理能力。</p>\n</blockquote>\n<p>如果你的响应式需求比较简单，只需要针对屏幕的不同 dpr （device pixel ratio，设备像素比）来决定图片的显示的话，</p>\n<p>dpr 设备像素比, 越高, 能够显示的越清晰  (dpr: 2, dpr: 3)</p>\n<p>那么就只要这么写：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>320.png 1x, 640.png 2x, 960.png 3x<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对于可变宽度的图像，我们使用<code>srcset</code>搭配<code>w</code>描述符以及<code>sizes</code>属性 。</p>\n<ul>\n<li>\n<p><code>w</code>描述符告诉浏览器列表中的每个图象的宽度。</p>\n</li>\n<li>\n<p><code>sizes</code>属性需要至少包含两个值，是由逗号分隔的列表。</p>\n</li>\n</ul>\n<p>根据最新规范，如果<code>srcset</code>中任何图像使用了<code>w</code>描述符，那么必须要设置<code>sizes</code>属性。</p>\n<p><code>sizes</code>属性有两个值：</p>\n<ol>\n<li>\n<p>第一个是媒体查询条件；</p>\n</li>\n<li>\n<p>第二个是图片对应的尺寸值，</p>\n<p>在特定媒体条件下，此值决定了图片的宽度。</p>\n<p>需要注意是，源图尺寸值不能使用百分比，如果要用100%,  <code>vw</code>是唯一可用的CSS单位。</p>\n</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img元素srcset属性浅析<span class="token punctuation">"</span></span>\n  <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\n    320.png 320w, \n    480.png 480w, \n    640.png 640w<span class="token punctuation">"</span></span>\n  <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\n    (max-width: 320px) 100vw, \n    (max-width: 360px) 320px,\n    (max-width: 480px) 360px,\n    (max-width: 640px) 480px,\n    640px<span class="token punctuation">"</span></span>\n  <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640.png<span class="token punctuation">"</span></span>\n<span class="token punctuation">/></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>为 img 定义以上属性后，浏览器的工作流程如下：</p>\n<ol>\n<li>检查设备的实际宽度</li>\n<li>检查 img 标签的 sizes 属性中定义的媒体查询条件列表，并计算哪个条件最先匹配到</li>\n<li>得到图片此时的响应式宽度</li>\n<li>加载 srcset 中最接近, 最适合媒体查询匹配到的宽度的图片</li>\n</ol>\n<p>注意: 测试时, 清除缓存测试, 因为一旦加载了高清图, 就不会也没有必要, 回过去再用小图替换了</p>\n<p>且我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。</p>\n<p>(译者注：srcset和size列表是对浏览器的一个建议(hint)，而非指令。由浏览器根据其能力、网络等因素来决定。)</p>\n<h2 id="_8-响应式图片处理优化-picture-标签" tabindex="-1"><a class="header-anchor" href="#_8-响应式图片处理优化-picture-标签" aria-hidden="true">#</a> 8. 响应式图片处理优化: Picture 标签</h2>\n<p><strong>考察点: 响应式图片处理</strong></p>\n<p><code>picture</code>元素就像是图像和其源的容器。浏览器仍然需要<code>img</code>元素，用来表明需要加载的图片</p>\n<p>在 <code>&lt;picture&gt;</code> 下可放置零个或多个<code>&lt;source&gt;</code>标签、以及一个<code>&lt;img&gt;</code>标签，为不同的屏幕设备和场景显示不同的图片。</p>\n<p>如果source匹配到了, 就会优先用匹配到的, 如果没有匹配到会往下继续找</p>\n<p>使用<code>picture</code>元素选择图像，不会有歧义。</p>\n<p>浏览器的工作流程如下：</p>\n<ul>\n<li>\n<p>浏览器会先根据当前的情况，去匹配和使用<code>&lt;source&gt;</code>提供的图片</p>\n</li>\n<li>\n<p>如果未匹配到合适的<code>&lt;source&gt;</code>，就使用<code>&lt;img&gt;</code>标签提供的图片</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640.png<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(min-width: 640px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480.png<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(min-width: 480px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>320.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_9-在-script-标签上使用-defer-和-async-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_9-在-script-标签上使用-defer-和-async-的区别是什么" aria-hidden="true">#</a> 9. 在 script 标签上使用 defer 和 async 的区别是什么？</h2>\n<p><strong>明确: defer 和 async 的使用, 可以用于提升网页性能</strong></p>\n<p>script标签存在两个属性，defer和async，因此 script标签 的使用分为三种情况：</p>\n<ol>\n<li>\n<p><code>&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>没有defer或async属性，浏览器会立即加载并执行相应的脚本。</p>\n<p>不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载</p>\n</li>\n<li>\n<p><code>&lt;script async src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；</p>\n</li>\n<li>\n<p><code>&lt;script defer src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>有了defer属性，加载后续文档的过程和js脚本的加载是并行进行的(异步)，此时的js脚本仅加载不执行, js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。</p>\n</li>\n</ol>\n<p>下图是使用了 defer、async、和未使用时的运行情况对比：</p>\n<img src="\\images\\image-20210209172314832.png" alt="image-20210209172314832" />\n<blockquote>\n<p>【上图的图例说明】</p>\n<p>绿线：HTML 的解析时间</p>\n<p>蓝线：JS 脚本的加载时间</p>\n<p>红色：JS 脚本的执行时间</p>\n</blockquote>\n<p>从图中我们可以明确一下几点：</p>\n<p>1.defer和async在网络加载过程是一致的，都是异步执行的；(放在页面顶部, 也不会阻塞页面的加载, 与页面加载同时进行)</p>\n<p>2.两者的区别, 脚本加载完成之后, async是立刻执行, defer会等一等 (等前面的defer脚本执行, 等dom的加载)</p>\n<p>所以, js脚本加上 async 或 defer, 放在头部可以减少网页的下载加载时间, 如果不考虑兼容性, 可以用于优化页面加载的性能</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_10-前端做本地数据存储的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_10-前端做本地数据存储的方式有哪些" aria-hidden="true">#</a> 10. 前端做本地数据存储的方式有哪些？</h2>\n<img src="\\images\\image-20210209174438863.png" alt="image-20210209174438863" />\n<ol>\n<li>Cookies</li>\n<li>localStorage</li>\n<li>sessionStorage</li>\n<li>Web SQL</li>\n<li>IndexedDB</li>\n</ol>\n<h2 id="_11-以上几种前端存储的区别是什么" tabindex="-1"><a class="header-anchor" href="#_11-以上几种前端存储的区别是什么" aria-hidden="true">#</a> 11. 以上几种前端存储的区别是什么？</h2>\n<table>\n<thead>\n<tr>\n<th>方式名称</th>\n<th>标准说明</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cookies</td>\n<td>HTML5 前加入</td>\n<td>1.会为每个请求自动携带所有的Cookies数据，比较方便，但是也是缺点，浪费流量；<br>2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie)</td>\n</tr>\n<tr>\n<td>localStorage</td>\n<td>HTML5 加入</td>\n<td>1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M</td>\n</tr>\n<tr>\n<td>sessionStorage</td>\n<td>HTML5 加入</td>\n<td>1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储</td>\n</tr>\n<tr>\n<td>Web SQL</td>\n<td>非标准功能</td>\n<td>1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作；</td>\n</tr>\n<tr>\n<td>IndexedDB</td>\n<td>HTML5 加入</td>\n<td>1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h1 id="css基础" tabindex="-1"><a class="header-anchor" href="#css基础" aria-hidden="true">#</a> CSS基础</h1>\n<h2 id="_1-css选择器的优先级是怎么样的" tabindex="-1"><a class="header-anchor" href="#_1-css选择器的优先级是怎么样的" aria-hidden="true">#</a> 1. CSS选择器的优先级是怎么样的？</h2>\n<p><strong>CSS选择器的优先级顺序：</strong></p>\n<p><code>内联样式</code> &gt; <code>ID选择器</code> &gt; <code>类选择器</code> &gt; <code>标签选择器</code></p>\n<p><strong>优先级的计算：</strong></p>\n<p>优先级是由 A、B、C、D 四个值来决定的，具体计算规则如下</p>\n<ul>\n<li>A={如果存在内联样式则为1，否则为0}</li>\n<li>B={ID选择器出现的次数}</li>\n<li>C={类选择器、属性选择器、伪类选择器出现的总次数}</li>\n<li>D={标签选择器、伪元素选择器出现的总次数}</li>\n</ul>\n<p><strong>计算示例：</strong></p>\n<p>样式一：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/*\n  A=0   不存在内联样式\n  B=0   不存在ID选择器\n  C=1   有一个类选择器\n  D=3   有三个标签选择器\n\n  最终计算结果：{0,0,1,3}\n*/</span>\n<span class="token selector">div ul li .red</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>样式二：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/*\n  A=0   不存在内联样式\n  B=1   有一个ID选择器\n  C=0   不存在类选择器\n  D=0   不存在标签选择器\n\n  最终计算结果：{0,1,0,0}\n*/</span>\n<span class="token selector">#mydiv</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>计算完成后，我们通过从A到D的顺序进行值的大小比较，权重由A到D从高到低，只要比较出最大值即可。例如上面的两个样式：</p>\n<div class="language-markdown ext-md line-numbers-mode"><pre v-pre class="language-markdown"><code><span class="token list punctuation">1.</span> 样式一的A=0，样式二的A=0  【相等，继续往下比较】\n<span class="token list punctuation">2.</span> 样式一的B=0 &lt; 样式二的B=1 【样式二的大，不继续往下比了，即认为样式二的优先级更高】\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_2-通过-css-的哪些方式可以实现隐藏页面上的元素" tabindex="-1"><a class="header-anchor" href="#_2-通过-css-的哪些方式可以实现隐藏页面上的元素" aria-hidden="true">#</a> 2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？</h2>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>opacity: 0</td>\n<td>通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互</td>\n</tr>\n<tr>\n<td>visibility: hidden</td>\n<td>与透明度为0的方案非常类似，会占据空间，但不可以进行交互</td>\n</tr>\n<tr>\n<td>overflow: hidden</td>\n<td>只会隐藏元素溢出的部分；占据空间且不可交互</td>\n</tr>\n<tr>\n<td>display: none</td>\n<td>可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局</td>\n</tr>\n<tr>\n<td>z-index: -9999</td>\n<td>通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果</td>\n</tr>\n<tr>\n<td>transform: scale(0,0)</td>\n<td>通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互</td>\n</tr>\n<tr>\n<td>left: -9999px</td>\n<td>通过将元素定位到屏幕外面，达到看起来看不到的效果</td>\n</tr>\n</tbody>\n</table>\n<h2 id="_3-px、em、rem之间有什么区别" tabindex="-1"><a class="header-anchor" href="#_3-px、em、rem之间有什么区别" aria-hidden="true">#</a> 3. px、em、rem之间有什么区别？</h2>\n<p><strong>考察点: 相对单位, 绝对单位, 以及适配问题</strong></p>\n<table>\n<thead>\n<tr>\n<th>单位名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>px</td>\n<td>绝对单位。代表像素数量，页面会按照给出的精确像素进行展示</td>\n</tr>\n<tr>\n<td>em</td>\n<td>相对单位。默认的基准点为父元素的字体大小，而如果自身定义了字体大小则按自身的来算。所以即使在同一个页面内，1em可能不是一个固定的值。</td>\n</tr>\n<tr>\n<td>rem</td>\n<td>相对单位。可以理解为 <code>root em</code>，即基准点为根元素<code>&lt;html&gt;</code>的字体大小。rem是CSS3中新增单位，Chrome/FireFox/IE9+都支持, 一般用于做移动端适配</td>\n</tr>\n</tbody>\n</table>\n<p>正常开发 px 使用率较高, 如果要做 rem 适配, 会用到 rem 单位!</p>\n<p>rem布局的原理:</p>\n<ol>\n<li>使用 rem 为单位</li>\n<li>动态的设置 html font-size (媒体查询, js设置, 插件设置都可以)</li>\n</ol>\n<p>webpack有工具, 可以写 px, 自动转 rem  https://youzan.github.io/vant/#/zh-CN/advanced-usage</p>\n<h2 id="_4-让元素水平居中的方法有哪些" tabindex="-1"><a class="header-anchor" href="#_4-让元素水平居中的方法有哪些" aria-hidden="true">#</a> 4. 让元素水平居中的方法有哪些？</h2>\n<p><strong>方法一：使用 margin</strong></p>\n<p>通过为元素设置左右的 margin 为 auto，实现让元素居中。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>本内容会居中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-scss ext-scss line-numbers-mode"><pre v-pre class="language-scss"><code><span class="token selector">.center </span><span class="token punctuation">{</span>\n   <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n   <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n   <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n   <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>方式二: 转成行内块,  给父盒子设置 text-align: center</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是内容盒子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.father</span> <span class="token punctuation">{</span>\n  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.center</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>方法三：使用 flex 布局</strong></p>\n<p>使用 flex 提供的子元素居中排列功能，对元素进行居中。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是内容盒子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.father</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.center</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>方式四: 使用定位布局</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是内容盒子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.father</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.center</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>\n  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><a href="https://www.cnblogs.com/chengxs/p/11231906.html" target="_blank" rel="noopener noreferrer">【更多方式参考】实现水平居中垂直居中<ExternalLinkIcon/></a></p>\n<h2 id="_5-在-css-中有哪些定位方式" tabindex="-1"><a class="header-anchor" href="#_5-在-css-中有哪些定位方式" aria-hidden="true">#</a> 5. 在 CSS 中有哪些定位方式？</h2>\n<p>也就是 position 样式的几个属性。</p>\n<p><strong>static 正常文档流定位</strong></p>\n<ul>\n<li>\n<p>此时设置 top、right、bottom、left 以及 z-index 都无效</p>\n</li>\n<li>\n<p>块级元素遵循从上往下纵向排列，行级元素遵循从左到右排列</p>\n</li>\n</ul>\n<p><strong>relative 相对定位</strong></p>\n<p>这个 <strong>“相对”</strong> 是指相对于正常文档流的位置。</p>\n<p><strong>absolute 绝对定位</strong></p>\n<p>当前元素相对于 **最近的非 static 定位的祖先元素 **来确定自己的偏移位置。</p>\n<p>例如，当前为 absolute 的元素的父元素、祖父元素都为 relative，则当前元素会相对于父元素进行偏移定位。</p>\n<p><strong>fixed 固定定位</strong></p>\n<p>当前元素相对于屏幕视口 viewport 来确定自己的位置。并且当屏幕滚动时，当前元素的位置也不会发生改变。</p>\n<p><strong>sticky 粘性定位</strong></p>\n<p>这个定位方式有点像 relative 和 fixed 的结合。当它的父元素在视口区域、并进入 top 值给定的范围内时，当前元素就以 fixed 的方式进行定位，否则就以 relative 的方式进行定位。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">*</span> <span class="token punctuation">{</span>\n    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.header</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> orange<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.nav</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>\n    <span class="token property">top</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.main</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是头部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是导航<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h2 id="_6-如何理解-z-index" tabindex="-1"><a class="header-anchor" href="#_6-如何理解-z-index" aria-hidden="true">#</a> 6. 如何理解 z-index？</h2>\n<p>可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。</p>\n<p>元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。</p>\n<img src="\\images\\image-20210209212043708.png" alt="image-20210209212043708" style="zoom:70%;" />\n<p>可以将这种关系想象成一摞书本，通过 z-index 可以改变一本书在这摞书中的上下位置。</p>\n<p>z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.father</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n    <span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.son</span> <span class="token punctuation">{</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">z-index</span><span class="token punctuation">:</span> 999<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">z-index</span><span class="token punctuation">:</span> 100<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="_7-如何清除浮动" tabindex="-1"><a class="header-anchor" href="#_7-如何清除浮动" aria-hidden="true">#</a> 7. 如何清除浮动 ？</h2>\n<p><strong>考察: css基本功</strong></p>\n<p>可以有以下几种方式：</p>\n<ol>\n<li>\n<p>定高法</p>\n</li>\n<li>\n<p>使用一个空的div，并设置样式</p>\n</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">clear</span><span class="token punctuation">:</span>both</span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="3">\n<li>\n<p>为父元素添加 <code>overflow: hidden</code></p>\n</li>\n<li>\n<p>定义一个 clearfix 样式类</p>\n</li>\n</ol>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.clearfix:after</span> <span class="token punctuation">{</span>\n  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>  \t\t\t<span class="token comment">/*设置内容为空*/</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    \t\t\t<span class="token comment">/*高度为0*/</span>\n  <span class="token property">line-height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\t\t\t<span class="token comment">/*行高为0*/</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>\t\t\t<span class="token comment">/*将文本转为块级元素*/</span>\n  <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>\t<span class="token comment">/*将元素隐藏*/</span>\n  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span> \t\t\t\t<span class="token comment">/*清除浮动*/</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">.clearfix</span> <span class="token punctuation">{</span>\n  <span class="token property">zoom</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span> \t\t\t\t<span class="token comment">/*为了兼容IE*/</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>说明：当前 flex 已成为主流布局方式，适应性强, 且稳定, 所以浮动使用率目前已逐步降低。</p>\n<h2 id="_8-谈谈你对-bfc-的理解" tabindex="-1"><a class="header-anchor" href="#_8-谈谈你对-bfc-的理解" aria-hidden="true">#</a> 8. 谈谈你对 BFC 的理解？</h2>\n<p><strong>什么是 BFC：</strong></p>\n<p>BFC 的全称是 Block Formatting Context，块级格式化上下文。这是一个用于在盒模型下布局块级盒子的独立渲染区域，</p>\n<p>将处于BFC区域内和区域外的元素进行互相隔离。</p>\n<p><strong>何时会形成 BFC：</strong></p>\n<p>满足下列条件之一就可触发BFC：</p>\n<ul>\n<li>HTML根元素</li>\n<li>position 值为 <code>absolute</code> 或 <code>fixed</code></li>\n<li>float 值不为 <code>none</code></li>\n<li>overflow 值不为 <code>visible</code></li>\n<li>display 值为 <code>inline-block</code>、<code>table-cell</code> 或 <code>table-caption</code></li>\n</ul>\n<p><strong>BFC 的应用场景：</strong></p>\n<ol>\n<li>场景一：防止两个相邻块级元素的上下 margin 发生重叠 (<strong>上下margin合并问题</strong>)</li>\n</ol>\n<p>属于同一 BFC 的, 两个相邻块级子元素的上下 margin 会重叠，如果想让它们不重叠，可通过让这两个相邻块级子元素分属于不同的BFC。</p>\n<p>以下示例代码中的两个盒子的上下外边距会重合（即它们都设置了10px的外边距，我们期望它们之间的间距是 20px，但实际效果却只有 10px）：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.box1</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span> <span class="token comment">/* 下外边距为 10px */</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n    <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>  <span class="token comment">/* 上外边距为 10px */</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><img src="/images/image-20210217142711472.png" alt="image-20210217142711472" style="zoom:50%;" />\n<p>下面我们让其中一个盒子触发BFC，从而达到间隔 20px 的期望效果：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.box2</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n  <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token comment">/* 通过设置 display 为 inline-block 可以触发 BFC */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><img src="/images/image-20210217143506046.png" alt="image-20210217143506046" style="zoom:50%;" />\n<ol start="2">\n<li>场景二：<strong>清除浮动</strong></li>\n</ol>\n<p>以下示例代码中， 容器元素 box1 的高度会没有高：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.box1</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello,world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello,world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello,world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>而通过为 box1 添加 BFC 触发条件，可以让它的高度变回正常状态：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.box1</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3">\n<li>场景三：<strong>实现自适应布局</strong>, 防止元素被浮动元素覆盖(左边固定, 右边自适应)</li>\n</ol>\n<p>以下示例中，box2 会被设置了浮动的 box1 覆盖：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.box1</span> <span class="token punctuation">{</span>\n    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><img src="/images/image-20210217145325690.png" alt="image-20210217145325690" style="zoom:30%;" />\n<p>要避免这种覆盖行为，可以让 box2 触发 BFC,  实现布局效果, 左边固定右边自适应：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.box2</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/* 将 overflow 设置为非 visible 值可触发 BFC */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><img src="/images/image-20210217145504963.png" alt="image-20210217145504963" style="zoom:30%;" />\n<p><a href="https://www.cnblogs.com/xiaohuochai/p/5248536.html" target="_blank" rel="noopener noreferrer">参考文章：深入理解BFC<ExternalLinkIcon/></a></p>\n<h2 id="_9-什么是css-sprites以及它的好处" tabindex="-1"><a class="header-anchor" href="#_9-什么是css-sprites以及它的好处" aria-hidden="true">#</a> 9. 什么是CSS Sprites以及它的好处？</h2>\n<p><strong>考察: 性能优化的方案</strong></p>\n<p>CSS Sprites，俗称雪碧图、精灵图。这是一种CSS图片合并技术，就是将CSS中原先引用的一些较小的图片，合并成一张稍大的图片后再引用的技术方案。它可以减少请求多张小图片带来的网络消耗（因为发起的HTTP请求数变少了），并实现提前加载资源的效果。</p>\n<p><strong>操作方式：</strong></p>\n<p>可以手工使用图片编辑软件（如Photoshop），将多张小图片合并编辑变成一张大图片，并针对这张大图片，编写CSS样式来引用这张大图片中对应位置的小图片（涉及到的样式：background-image、background-position、background-size）。然后在HTML元素中使用这些样式即可。</p>\n<p>https://img.alicdn.com/tfs/TB1eiXTXlTH8KJjy0FiXXcRsXXa-24-595.png</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>CSS Sprites中任意一张小图的改动，都需要重新生成大图；并且用户端需要重新下载整张大图，这就降低了浏览器缓存的优势</li>\n<li>随着HTTP2的逐渐普及，HTTP2的多路复用机制可以解决请求多个小图片所创建多个HTTP请求的消耗，让CSS Sprites存在的价值降低了</li>\n<li>图片如果放大, 是会失真</li>\n</ul>\n<p>目前其他主流的处理图片的方案:  iconfont 字体图标, svg矢量图...</p>\n<h2 id="_10-你对媒体查询的理解是什么样的" tabindex="-1"><a class="header-anchor" href="#_10-你对媒体查询的理解是什么样的" aria-hidden="true">#</a> 10. 你对媒体查询的理解是什么样的？</h2>\n<p><strong>考察点: 响应式适配</strong>, 根据不同的屏幕尺寸, 显示不同的效果 (设置盒子的样式)</p>\n<p>媒体查询是自 CSS3 开始加入的一个功能。它可以进行响应式适配展示。</p>\n<p>媒体查询由两部分组成：</p>\n<ul>\n<li>一个可选的媒体类型（如 screen、print 等）</li>\n<li>零个或多个媒体功能限定表达式（如 max-width: 500px、orientation: landscape 等）</li>\n</ul>\n<p>这两部分最终都会被解析为 true 或 false 值，然后整个媒体查询值为 true，则和该媒体查询关联的样式就生效，否则就不生效。</p>\n<p><strong>使用示例：</strong></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/* 在css样式表的定义中直接使用媒体查询 */</span> \n<span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 767px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 768px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 991px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 750px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 992px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 1199px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 980px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 1200px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 1170px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">width</span><span class="token punctuation">:</span> 1200px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p><a href="https://www.cnblogs.com/xiaohuochai/p/5848612.html" target="_blank" rel="noopener noreferrer">参考文章：深入理解CSS媒体查询<ExternalLinkIcon/></a></p>\n<h2 id="_11-你对盒子模型的理解是什么样的" tabindex="-1"><a class="header-anchor" href="#_11-你对盒子模型的理解是什么样的" aria-hidden="true">#</a> 11. 你对盒子模型的理解是什么样的？</h2>\n<p>浏览器的渲染引擎在对网页文档进行布局时，会按照 “CSS 基础盒模型” （CSS Basic Box Model）标准，将文档中的所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）。</p>\n<p>下图就是盒模型示意图，它由几部分组成：</p>\n<ul>\n<li>内容（content）</li>\n<li>内边距（padding）</li>\n<li>边框（border）</li>\n<li>外边距（margin）</li>\n</ul>\n<img src="/images/image-20210214144941345.png" alt="image-20210214144941345" style="zoom:25%;" />\n<h2 id="_12-标准盒模型和怪异盒模型有哪些区别" tabindex="-1"><a class="header-anchor" href="#_12-标准盒模型和怪异盒模型有哪些区别" aria-hidden="true">#</a> 12. 标准盒模型和怪异盒模型有哪些区别？</h2>\n<p>两者的区别主要体现在元素尺寸的表示上。</p>\n<p><strong>盒模型的指定：</strong></p>\n<p>在CSS3中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：</p>\n<ul>\n<li>content-box    标准盒模型</li>\n<li>border-box     怪异盒模型</li>\n</ul>\n<p><strong>标准盒模型：</strong></p>\n<p>box-sizing: content-box; (默认值)</p>\n<p>在标准盒模型下，元素的宽（width）和高（height）值即为盒模型中内容（content）的实际宽高值。</p>\n<img src="/images/image-20210214150511841.png" alt="image-20210214150511841" style="zoom:25%;" />\n<p>因此，计算一个元素宽度的公式如下(不考虑margin, margin是外边距,  如果是计算占用页面的空间, 就要带上margin)：</p>\n<blockquote>\n<p>盒子宽度 =  <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code></p>\n<p>占据页面宽度 = <code>margin-left</code> + <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code> + <code>margin-right</code></p>\n</blockquote>\n<p><strong>怪异盒模型：</strong></p>\n<p>box-sizing: border-box; (目前主流常用值)</p>\n<p>在怪异盒模型下，元素的 width 和 height 值却不是 content 的实际宽高，而是去除 margin 后剩下的元素占用区域的宽高，即：</p>\n<img src="/images/image-20210214151037552.png" alt="image-20210214151037552" style="zoom:25%;" />\n<p>因此，计算一个元素占用了页面总宽度的公式如下：</p>\n<blockquote>\n<p>盒子宽度 =  <code>width</code></p>\n<p>盒子占据页面宽度 = <code>margin-left</code> + <code>width</code> + <code>margin-right</code></p>\n</blockquote>\n<p><a href="https://www.cnblogs.com/xiaohuochai/p/5202597.html" target="_blank" rel="noopener noreferrer">参考文章：深入理解盒模型<ExternalLinkIcon/></a></p>\n<h2 id="_13-说说伪类和伪元素的区别" tabindex="-1"><a class="header-anchor" href="#_13-说说伪类和伪元素的区别" aria-hidden="true">#</a> 13. 说说伪类和伪元素的区别？</h2>\n<p><strong>什么是伪类？</strong></p>\n<p>伪类（pseudo-class）是以冒号<code>:</code>为前缀，可被添加到⼀个选择器的末尾的关键字。</p>\n<p>它用于让样式在元素的特定状态下才被应用到实际的元素上。比如：<code>:checked</code>、<code>:hover</code>、<code>:disabled</code>、 <code>:first-child</code>等。</p>\n<p>:hover</p>\n<p>:nth-child(1)</p>\n<p>:nth-child(2)</p>\n<p>:checked</p>\n<p>注意: 伪类, 虽然是写法比较特殊, css选择器的权重, 和类一致的</p>\n<p><strong>什么是伪元素？</strong></p>\n<p>:before / :after</p>\n<p>伪元素⽤于创建⼀些并不在 DOM 树中的元素，并为其添加样式。伪元素的语法和伪类类似，可以一个冒号或两个冒号为前缀。</p>\n<p>⽐如，可以通过 <code>:before</code> 、<code>:after</code> 来在⼀个元素前、后增加⼀些额外的⽂本并为它们添加样式；</p>\n<p>并且，虽然⽤户可以看到这些⽂本，但其实它们并不在 DOM 树中。(<strong>坑: 伪元素是无法注册事件的, 所以不要通过js控制伪元素</strong>)</p>\n<p><strong>两者的区别</strong></p>\n<p>虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。</p>\n<ul>\n<li>伪类是用来匹配元素的特殊状态的</li>\n<li>伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现</li>\n</ul>\n<p><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener noreferrer">参考文章：伪类与伪元素<ExternalLinkIcon/></a></p>\n<h2 id="_14-谈谈你对-flex-的理解" tabindex="-1"><a class="header-anchor" href="#_14-谈谈你对-flex-的理解" aria-hidden="true">#</a> 14. 谈谈你对 flex 的理解？</h2>\n<p>在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。</p>\n<p>flex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。</p>\n<p>你能联想到的flex语法有哪些呢?</p>\n<p>flex-direction: 调整主轴方向</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>row：主轴方向为水平向右\ncolumn：主轴方向为竖直向下\nrow-reverse:主轴方向为水平向左\ncolumn-reverse:主轴方向是竖直向上。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>justify-content主要用来设置<strong>主轴方向的对齐方式</strong></p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>flex-start: 弹性盒子元素将向起始位置对齐\nflex-end: 弹性盒子元素将向结束位置对齐。\ncenter: 弹性盒子元素将向行中间位置对齐\nspace-around: 弹性盒子元素会平均地分布在行里\nspace-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>align-items用于调整<strong>侧轴的对齐方式</strong></p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>flex-start： 元素在侧轴的起始位置对齐。 \nflex-end： 元素在侧轴的结束位置对齐。\ncenter： 元素在侧轴上居中对齐。\nstretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>flex-wrap属性控制flex容器是单行或者多行,默认不换行</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。\nwrap： 当宽度不够的时候，会换行。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>align-content用来设置多行的flex容器的排列方式</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>flex-start： 各行向侧轴的起始位置堆叠。 \nflex-end： 各行向弹性盒容器的结束位置堆叠。\ncenter： 各行向弹性盒容器的中间位置堆叠。\nspace-around： 各行在侧轴中平均分布。 \nspace-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 \nstretch：拉伸，不设置高度的情况下。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote>\n<p>可参考 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener noreferrer">flex布局教程<ExternalLinkIcon/></a></p>\n</blockquote>\n<hr>\n<h1 id="javascript基础" tabindex="-1"><a class="header-anchor" href="#javascript基础" aria-hidden="true">#</a> JavaScript基础</h1>\n<h2 id="_1-解释下什么是变量声明提升" tabindex="-1"><a class="header-anchor" href="#_1-解释下什么是变量声明提升" aria-hidden="true">#</a> 1. 解释下什么是变量声明提升？</h2>\n<p>变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。</p>\n<p>JS引擎在运行一份代码的时候，会按照下面的步骤进行工作：</p>\n<ol>\n<li>\n<p>首先，对代码进行预解析，并获取声明的所有变量</p>\n</li>\n<li>\n<p>然后，将这些变量的声明语句统一放到代码的最前面</p>\n</li>\n<li>\n<p>最后，开始一行一行运行代码</p>\n</li>\n</ol>\n<p>我们通过一段代码来解释这个运行过程：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> \n\n<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上⾯这段代码的实际执⾏顺序为:</p>\n<ol>\n<li>JS引擎将 <code>var a = 1</code> 分解为两个部分：变量声明语句 <code>var a = undefined</code> 和变量赋值语句 <code>a = 1</code></li>\n<li>JS引擎将 <code>var a = undefined</code> 放到代码的最前面，而 <code>a = 1</code> 保留在原地</li>\n</ol>\n<p>也就是说经过了转换，代码就变成了:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">undefined</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined </span>\n\na <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>变量的这一转换过程，就被称为变量的声明提升。</p>\n<p>而这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题</p>\n<h2 id="_2-js-的参数是以什么方式进行传递的" tabindex="-1"><a class="header-anchor" href="#_2-js-的参数是以什么方式进行传递的" aria-hidden="true">#</a> 2. JS 的参数是以什么方式进行传递的？</h2>\n<p>基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。</p>\n<p><strong>基本类型：是值传递</strong>！</p>\n<p>基本类型的传递方式比较简单，是按照 <code>值传递</code> 进行的。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment">// 并不会改变实参的值</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10 </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>复杂类型: 传递的是地址! (变量中存的就是地址)</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305165413588" originSrc="images/image-20210305165413588.png" data="aurora"></p>\n<p>来看下面的代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">10</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// { count: 10 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// { count: 10 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从运行结果来看，函数内改变了参数对象内的 <code>count</code> 后，外部的实参对象 <code>a</code> 的内容也跟着改变了，所以传递的是地址。</p>\n<p>思考题:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span> \n<span class="token punctuation">}</span><span class="token punctuation">;</span> \n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { count: 20 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { count: 1 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305165848781" originSrc="images/image-20210305165848781.png" data="aurora"></p>\n<p>我们会发现外部的实参对象 <code>a</code> 并没有因为在函数内对形参的重新赋值而被改变！</p>\n<p>因为当我们直接为这个形参变量重新赋值时，其实只是让形参变量指向了别的堆内存地址，而外部实参变量的指向还是不变的。</p>\n<p>下图展示的是复杂类型参数传递后的状态：</p>\n<img src="/images/image-20210218233241397.png" alt="image-20210218233241397" style="zoom:50%;" />\n<p>下图展示的是重新为形参赋值后的状态：</p>\n<img src="/images/image-20210218233343016.png" alt="image-20210218233343016" style="zoom:50%;" />\n<h2 id="_3-javascript垃圾回收是怎么做的" tabindex="-1"><a class="header-anchor" href="#_3-javascript垃圾回收是怎么做的" aria-hidden="true">#</a> 3. JavaScript垃圾回收是怎么做的？</h2>\n<p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p>\n<p>正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，</p>\n<p>但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</p>\n<h3 id="_3-1-内存的生命周期" tabindex="-1"><a class="header-anchor" href="#_3-1-内存的生命周期" aria-hidden="true">#</a> 3.1 内存的生命周期</h3>\n<p>JS环境中分配的内存, 一般有如下生命周期：</p>\n<ol>\n<li>\n<p>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</p>\n</li>\n<li>\n<p>内存使用：即读写内存，也就是使用变量、函数等</p>\n</li>\n<li>\n<p>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</p>\n<p>全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉</p>\n</li>\n</ol>\n<p>内存分配:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 为变量分配内存</span>\n<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">11</span>\n<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"ifcode"</span>\n\n<span class="token comment">// 为对象分配内存</span>\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'ifcode\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 为函数分配内存</span>\n<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-2-垃圾回收算法说明" tabindex="-1"><a class="header-anchor" href="#_3-2-垃圾回收算法说明" aria-hidden="true">#</a> 3.2 垃圾回收算法说明</h3>\n<p>所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉</p>\n<p>下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法</p>\n<h3 id="_3-3-引用计数" tabindex="-1"><a class="header-anchor" href="#_3-3-引用计数" aria-hidden="true">#</a> 3.3 引用计数</h3>\n<p>IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。</p>\n<p>如果没有任何变量指向它了，说明该对象已经不再需要了。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1</span>\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'ifcode\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> p <span class="token operator">=</span> person   <span class="token comment">// 两个变量指向一块内存空间, 该内存空间的引用数为 2</span>\nperson <span class="token operator">=</span> <span class="token number">1</span>       <span class="token comment">// 原来的person对象被赋值为1，对象内存空间的引用数-1,</span>\n                 <span class="token comment">// 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收</span>\n\np <span class="token operator">=</span> <span class="token keyword">null</span>         <span class="token comment">// 原person对象已经没有引用，会被回收</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>由上面可以看出，引用计数算法是个简单有效的算法。</p>\n<p><strong>但它却存在一个致命的问题：循环引用。</strong></p>\n<p>如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    o1<span class="token punctuation">.</span>a <span class="token operator">=</span> o2\n    o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o1 \n    <span class="token keyword">return</span> <span class="token string">"Cycle reference!"</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305172448582" originSrc="images/image-20210305172448582.png" data="aurora"></p>\n<h3 id="_3-4-标记清除算法" tabindex="-1"><a class="header-anchor" href="#_3-4-标记清除算法" aria-hidden="true">#</a> 3.4 标记清除算法</h3>\n<p>现代的浏览器已经不再使用引用计数算法了。</p>\n<p>现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p>\n<p>标记清除法:</p>\n<ul>\n<li>\n<p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。</p>\n</li>\n<li>\n<p>简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。</p>\n</li>\n<li>\n<p>凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p>\n</li>\n</ul>\n<p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。</p>\n<p>根据这个概念，上面的例子可以正确被垃圾回收处理了。</p>\n<p>参考文章：<a href="https://www.jianshu.com/p/84a8fd5fa0ee" target="_blank" rel="noopener noreferrer">JavaScript内存管理<ExternalLinkIcon/></a></p>\n<h2 id="_4-谈谈你对-javascript-作用域链的理解" tabindex="-1"><a class="header-anchor" href="#_4-谈谈你对-javascript-作用域链的理解" aria-hidden="true">#</a> 4. 谈谈你对 JavaScript 作用域链的理解？</h2>\n<p>JavaScript 在执⾏过程中会创建一个个的<strong>可执⾏上下⽂</strong>。 (每个函数执行都会创建这么一个可执行上下文)</p>\n<p>每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。</p>\n<p>这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。</p>\n<p>简而言之: 函数内部 可以访问到 函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,</p>\n<p>这样的变量作用域访问的链式结构, 被称之为作用域链</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>\n  <span class="token keyword">function</span> <span class="token function">inner</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>下图为由多个可执行上下文组成的调用栈：</p>\n<ul>\n<li>栈最底部为<code>全局可执行上下文</code></li>\n<li><code>全局可执行上下文</code> 之上有多个 <code>函数可执行上下文</code></li>\n<li>每个可执行上下文中包含了指向外部其他可执行上下文的引用，直到 <code>全局可执行上下文</code> 时它指向 <code>null</code></li>\n</ul>\n<img src="/images/image-20210218143938843.png" alt="image-20210218143938843" style="zoom:30%;" />\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306093300970" originSrc="images/image-20210306093300970.png" data="aurora"></p>\n<p>js全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈</p>\n<p>每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用</p>\n<p><strong>=&gt; 就形成了作用域链</strong></p>\n<h2 id="_5-谈谈你对闭包的理解" tabindex="-1"><a class="header-anchor" href="#_5-谈谈你对闭包的理解" aria-hidden="true">#</a> 5. 谈谈你对闭包的理解？</h2>\n<p>这个问题想考察的主要有两个方面：</p>\n<ul>\n<li>对闭包的基本概念的理解</li>\n<li>对闭包的作用的了解</li>\n</ul>\n<p><strong>什么是闭包？</strong></p>\n<p>MDN的官方解释：</p>\n<blockquote>\n<p>闭包是函数和声明该函数的词法环境的组合</p>\n</blockquote>\n<p>更通俗一点的解释是：</p>\n<blockquote>\n<p>内层函数, 引用外层函数上的变量, 就可以形成闭包</p>\n</blockquote>\n<p>需求: 定义一个计数器方法, 每次执行一次函数, 就调用一次进行计数</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  count<span class="token operator">++</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'fn函数被调用了\'</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">\'次\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这样不好! count 定义成了全局变量, 太容易被别人修改了,  我们可以利用闭包解决</p>\n<p>闭包实例:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>\n\n  <span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count<span class="token operator">++</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'fn函数被调用了\'</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">\'次\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> add\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> addFn <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>闭包的主要作用是什么？</strong></p>\n<p>在实际开发中，闭包最大的作用就是用来 <strong>变量私有</strong>。</p>\n<p>下面再来看一个简单示例：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 以 let 声明一个局部变量，而不是 this.name</span>\n  <span class="token comment">// this.name = \'zs\'     =>  p.name</span>\n  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">\'hm_programmer\'</span> <span class="token comment">// 数据私有</span>\n  \n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n    <span class="token keyword">return</span> name\n  <span class="token punctuation">}</span>\n  \n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n    name <span class="token operator">=</span> value\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// new:</span>\n<span class="token comment">// 1. 创建一个新的对象</span>\n<span class="token comment">// 2. 让构造函数的this指向这个新对象</span>\n<span class="token comment">// 3. 执行构造函数</span>\n<span class="token comment">// 4. 返回实例</span>\n<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// hm_programmer</span>\n\np<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">\'Tom\'</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Tom</span>\n\np<span class="token punctuation">.</span>name <span class="token comment">// 访问不到 name 变量：undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>在此示例中，变量 <code>name</code> 只能通过 Person 的实例方法进行访问，外部不能直接通过实例进行访问，形成了一个私有变量。</p>\n<h2 id="_6-javascript中数据类型的隐式转换规则-了解" tabindex="-1"><a class="header-anchor" href="#_6-javascript中数据类型的隐式转换规则-了解" aria-hidden="true">#</a> 6. JavaScript中数据类型的隐式转换规则(了解)</h2>\n<p>在if语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。</p>\n<p>下表展示了一系列原始值，通过隐式转换成数字、字符串、布尔类型后所得到的值：</p>\n<img src="/images/image-20210218171603780.png" alt="image-20210218171603780" style="zoom:45%;" />\n<p>坑: 判断时,  尽量不要用 <code>= =</code> , 要用 <code>= = =</code> ( 两个等号判断,  如果类型不同,  默认会进行隐式类型转换再比较)</p>\n<h2 id="_7-谈谈你对原型链的理解" tabindex="-1"><a class="header-anchor" href="#_7-谈谈你对原型链的理解" aria-hidden="true">#</a> 7. 谈谈你对原型链的理解？</h2>\n<p>要讲清楚这个问题，主要着重这几个方面：</p>\n<ul>\n<li>什么是原型对象</li>\n<li>构造函数, 原型对象, 实例的三角关系图</li>\n<li>原型链如何形成</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306104516852" originSrc="images/image-20210306104516852.png" data="aurora"></p>\n<p><strong>原型对象</strong></p>\n<p>在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 <code>prototype</code> 的属性，指向原型对象，</p>\n<p>基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。</p>\n<p>例如我们的 <code>hasOwnProperty</code>, <code>toString</code> ⽅法等其实是 Obejct 原型对象的方法，它可以被任何对象当做⾃⼰的⽅法来使⽤。</p>\n<p><code>hasOwnProperty</code> 用于判断, 某个属性, 是不是自己的  (还是原型链上的)</p>\n<p>来看一段代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Tom"</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">job</span><span class="token operator">:</span> <span class="token string">"student"</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"hasOwnProperty"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"hasOwnProperty"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，<code>hasOwnProperty</code> 并不是 <code>person</code> 对象的属性，但是 <code>person</code> 却能调用它。</p>\n<p>那么 <code>person</code> 对象是如何找到 Object 原型中的 <code>hasOwnProperty</code> 的呢？这就要靠原型链的能力了。</p>\n<p>需求: 简单绘制原型三角关系图!</p>\n<p><strong>原型链</strong></p>\n<p>在 JavaScript 中，每个对象中都有一个 <code>__proto__</code> 属性，这个属性指向了当前对象的构造函数的原型。</p>\n<p>对象可以通过自身的 <code>__proto__</code>属性与它的构造函数的原型对象连接起来，</p>\n<p>而因为它的原型对象也有 <code>__proto__</code>，因此这样就串联形成一个链式结构，也就是我们称为的原型链。</p>\n<img src="/images/image-20210218212449526.png" alt="image-20210218212449526" style="zoom:50%;" />\n<h2 id="_6-谈谈对于继承的理解" tabindex="-1"><a class="header-anchor" href="#_6-谈谈对于继承的理解" aria-hidden="true">#</a> 6. 谈谈对于继承的理解</h2>\n<p><strong>为什么要学习继承 ?</strong></p>\n<p>写的构造函数, 定义了一个类型 (人类), 万一项目非常大, 又有了细化的多个类型 (老师, 工人, 学生)</p>\n<p>学习继承, 可以让多个构造函数之间建立关联, 便于管理和复用</p>\n<p><strong>什么是继承 ?</strong></p>\n<p>继承: 从别人那里, 继承东西过来 (财产, 房产)</p>\n<p>代码层面的继承: 继承一些属性和方法</p>\n<h3 id="_6-1-继承-原型继承" tabindex="-1"><a class="header-anchor" href="#_6-1-继承-原型继承" aria-hidden="true">#</a> 6.1 继承 - 原型继承</h3>\n<p>原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!</p>\n<p>分析需求:</p>\n<p>​\t人类, 属性: name, age</p>\n<p>​\t学生, 属性: name, age, className</p>\n<p>​\t工人, 属性: name, age, companyName</p>\n<p>无论学生, 还是工人, =&gt; 都是人类, 所以人类原型上有的方法, 他们都应该要有</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'人类会说话\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'学生在学习\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">\'张三\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'80期\'</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306111112493" originSrc="images/image-20210306111112493.png" data="aurora"></p>\n<h3 id="_6-2-继承-组合继承" tabindex="-1"><a class="header-anchor" href="#_6-2-继承-组合继承" aria-hidden="true">#</a> 6.2 继承 - 组合继承</h3>\n<p>组合继承有时候也叫伪经典继承，指的是将原型链 和 借用构造函数 call 技术组合到一块，</p>\n<p>从而发挥二者之长的一种继承模式，其背后的思路: <strong>是使用原型链实现对原型属性和方法的继承 (主要是方法)，</strong></p>\n<p><strong>而通过借用构造函数来实现对实例属性构造的继承</strong>。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的自己的属性。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'人类会说话\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// 实现构造属性的继承</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'学生在学习\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">\'张三\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'80期\'</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n\n<span class="token comment">// 方法通过 原型继承</span>\n<span class="token comment">// 属性通过 父构造函数的.call(this, name, age)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="_6-3-继承-寄生组合继承" tabindex="-1"><a class="header-anchor" href="#_6-3-继承-寄生组合继承" aria-hidden="true">#</a> 6.3 继承 - 寄生组合继承</h3>\n<p>student实例上有 name age,  而原型 <code>__proto__</code>上不需要再有这些属性, 所以利用 Object.create 改装下</p>\n<p>Object.create(参数对象),</p>\n<ol>\n<li>Object.create 会创建一个新对象,</li>\n<li>并且这个新对象的<code>__proto__</code> 会指向传入的参数对象</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'人类会说话\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'学生在学习\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">\'张三\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'80期\'</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n\n\n<span class="token comment">// 总结:</span>\n<span class="token comment">// Object.create() 以参数的对象, 作为新建对象的__proto__属性的值, 返回新建的对象</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306114638139" originSrc="images/image-20210306114638139.png" data="aurora"></p>\n<h3 id="_6-4-es6-class-实现继承-extends" tabindex="-1"><a class="header-anchor" href="#_6-4-es6-class-实现继承-extends" aria-hidden="true">#</a> 6.4 es6 - class 实现继承 extends</h3>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 继承关键字 => extends</span>\n<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token punctuation">}</span>\n  <span class="token function">jump</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'会跳\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> lesson</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// extends 中, 必须调用 super(), 会触发执行父类的构造函数</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>lesson <span class="token operator">=</span> lesson\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'构造函数执行了\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">sayHello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'会打招呼\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> teacher1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token string">\'zs\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'体育\'</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>teacher1<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="_8-如何判断是否是数组" tabindex="-1"><a class="header-anchor" href="#_8-如何判断是否是数组" aria-hidden="true">#</a> 8. 如何判断是否是数组？</h2>\n<p>方法一：使用 <code>toString</code> 方法</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object Array]\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>\n<span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>方法二：使用 ES6 新增的 <code>Array.isArray</code> 方法</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>\nArray<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_9-谈谈你对this的理解" tabindex="-1"><a class="header-anchor" href="#_9-谈谈你对this的理解" aria-hidden="true">#</a> 9. 谈谈你对this的理解？</h2>\n<p><code>this</code> 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。</p>\n<p><strong>默认绑定</strong> (指向window的情况)  (函数调用模式 fn() )</p>\n<p>默认情况下，<code>this</code> 会被绑定到全局对象上，比如在浏览器环境中就为<code>window</code>对象，在node.js环境下为<code>global</code>对象。</p>\n<p>如下代码展示了这种绑定关系：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>message <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> \n\n<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "Hello"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>隐式绑定</strong> (谁调用, this指向谁) (方法调用模式 obj.fn() )</p>\n<p>如果函数的调用是从对象上发起时，则该函数中的 <code>this</code> 会被自动隐式绑定为对象：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"hello,world"</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">test</span><span class="token operator">:</span> test\n<span class="token punctuation">}</span>\n\nobj<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "hello,world"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>显式绑定</strong> (又叫做硬绑定)  (上下文调用模式, 想让this指向谁, this就指向谁)</p>\n<p>硬绑定 =&gt; call  apply  bind</p>\n<p>可以显式的进行绑定：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"你好世界123"</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"你好世界456"</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "你好世界123"</span>\n<span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "你好世界456"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>new 绑定</strong> (构造函数模式)</p>\n<p>另外，在使用 <code>new</code> 创建对象时也会进行 <code>this</code> 绑定</p>\n<p>当使用 <code>new</code> 调用构造函数时，会创建一个新的对象并将该对象绑定到构造函数的 <code>this</code> 上：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token string">"hello,world"</span><span class="token punctuation">)</span>\nobj<span class="token punctuation">.</span>message <span class="token comment">// "hello,world"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>小测试:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">10</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nobj<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>\n<span class="token function">temp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// -------------------------------------------------------------</span>\n\n<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">,</span> theAge</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> theAge\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 定义函数</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"小黑"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>\nper<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="_10-箭头函数中的this指向什么" tabindex="-1"><a class="header-anchor" href="#_10-箭头函数中的this指向什么" aria-hidden="true">#</a> 10. 箭头函数中的this指向什么？</h2>\n<p>箭头函数不同于传统函数，它其实没有属于⾃⼰的 <code>this</code>，</p>\n<p>它所谓的 <code>this</code> 是, 捕获其外层  上下⽂的 <code>this</code> 值作为⾃⼰的 <code>this</code> 值。</p>\n<p>并且由于箭头函数没有属于⾃⼰的 <code>this</code> ，它是不能被 <code>new</code> 调⽤的。</p>\n<p>我们可以通过 Babel 转换前后的代码来更清晰的理解箭头函数:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 转换前的 ES6 代码</span>\n<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> \n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> obj<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 转换后的 ES5 代码</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token function-variable function">test</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that <span class="token operator">===</span> obj<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这里我们看到，箭头函数中的 <code>this</code> 就是它上层上下文函数中的 <code>this</code>。</p>\n<h2 id="_11-promise-的静态方法" tabindex="-1"><a class="header-anchor" href="#_11-promise-的静态方法" aria-hidden="true">#</a> 11. Promise 的静态方法</h2>\n<p>promise的三个状态: pending(默认)   fulfilled(成功)   rejected(失败)</p>\n<ol>\n<li>resolve函数被执行时, 会将promise的状态从 pending 改成 fulfilled 成功</li>\n<li>reject函数被执行时, 会将promise的状态从pending 改成 rejected 失败</li>\n</ol>\n<p>Promise.reject()</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t<span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Promise.resolve()</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>Promise.all([promise1, promise2, promise3])</strong>  等待原则, 是在所有promise都完成后执行, 可以用于处理一些<code>并发的任务</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 后面的.then中配置的函数, 是在前面的所有promise都完成后执行, 可以用于处理一些并发的任务</span>\nPromise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">values</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// values 是一个数组, 会收集前面promise的结果 values[0] => promise1的成功的结果</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Promise.race([promise1, promise2, promise3]) 赛跑, 竞速原则, 只要三个promise中有一个满足条件, 就会执行.then(用的较少)</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306144638905" originSrc="images/image-20210306144638905.png" data="aurora"></p>\n<h2 id="_12-宏任务-微任务-是什么" tabindex="-1"><a class="header-anchor" href="#_12-宏任务-微任务-是什么" aria-hidden="true">#</a> 12. 宏任务 微任务 是什么</h2>\n<p>小例题:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>宏任务: 主线程代码, setTimeout 等属于宏任务,  上一个宏任务执行完, 才会考虑执行下一个宏任务</p>\n<p>微任务: promise .then .catch的需要执行的内容, 属于微任务, 满足条件的微任务, 会被添加到当前宏任务的最后去执行</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201208040306978" originSrc="images/image-20201208040306978.png" data="aurora"></p>\n<p><strong>事件循环队列 eventLoop</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201208040235602" originSrc="images/image-20201208040235602.png" data="aurora"></p>\n<p>例题1:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 宏任务</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment">// 微任务</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306151137688" originSrc="images/image-20210306151137688.png" data="aurora"></p>\n<p>例题2:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>例题3:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">2</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>例题4:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'嘿嘿\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">// 微任务</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'gaga\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306152010989" originSrc="images/image-20210306152010989.png" data="aurora"></p>\n<p>考察点: async 函数只有从 await 往下才是异步的开始</p>\n<h2 id="_13-async-await是什么" tabindex="-1"><a class="header-anchor" href="#_13-async-await是什么" aria-hidden="true">#</a> 13. async/await是什么？</h2>\n<p>ES7 标准中新增的 <code>async</code> 函数，从目前的内部实现来说其实就是 <code>Generator</code> 函数的语法糖。</p>\n<p>它基于 Promise，并与所有现存的基于Promise 的 API 兼容。</p>\n<p><strong>async 关键字</strong></p>\n<ol>\n<li>\n<p><code>async</code> 关键字用于声明⼀个异步函数（如 <code>async function asyncTask1() {...}</code>）</p>\n</li>\n<li>\n<p><code>async</code> 会⾃动将常规函数转换成 Promise，返回值也是⼀个 Promise 对象</p>\n</li>\n<li>\n<p><code>async</code> 函数内部可以使⽤ <code>await</code></p>\n</li>\n</ol>\n<p><strong>await 关键字</strong></p>\n<ol>\n<li>\n<p><code>await</code> 用于等待异步的功能执⾏完毕 <code>var result = await someAsyncCall()</code></p>\n</li>\n<li>\n<p><code>await</code> 放置在 Promise 调⽤之前，会强制async函数中其他代码等待，直到 Promise 完成并返回结果</p>\n</li>\n<li>\n<p><code>await</code> 只能与 Promise ⼀起使⽤</p>\n</li>\n<li>\n<p><code>await</code> 只能在 <code>async</code> 函数内部使⽤</p>\n</li>\n</ol>\n<h2 id="_14-相较于-promise-async-await有何优势" tabindex="-1"><a class="header-anchor" href="#_14-相较于-promise-async-await有何优势" aria-hidden="true">#</a> 14. 相较于 Promise，async/await有何优势？</h2>\n<ol>\n<li>同步化代码的阅读体验（Promise 虽然摆脱了回调地狱，但 then 链式调⽤的阅读负担还是存在的）</li>\n<li>和同步代码更一致的错误处理方式（ async/await 可以⽤成熟的 try/catch 做处理，比 Promise 的错误捕获更简洁直观）</li>\n<li>调试时的阅读性, 也相对更友好</li>\n</ol>\n<h2 id="_15-深拷贝-浅拷贝" tabindex="-1"><a class="header-anchor" href="#_15-深拷贝-浅拷贝" aria-hidden="true">#</a> 15. 深拷贝 浅拷贝</h2>\n<p>引用类型, 进行赋值时, 赋值的是地址</p>\n<ol>\n<li>\n<p>浅拷贝</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n\t<span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>obj\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li>\n<li>\n<p>深拷贝</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n\t<span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">car</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token literal-property property">brand</span><span class="token operator">:</span> <span class="token string">\'宝马\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">100</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>当然递归也能解决, 只是比较麻烦~</p>\n<p>...</p>\n</li>\n</ol>\n<p>其他方案, 可以参考一些博客</p>\n<hr>\n<h1 id="http协议" tabindex="-1"><a class="header-anchor" href="#http协议" aria-hidden="true">#</a> HTTP协议</h1>\n<h2 id="_1-http有哪些方法" tabindex="-1"><a class="header-anchor" href="#_1-http有哪些方法" aria-hidden="true">#</a> 1. HTTP有哪些⽅法？</h2>\n<p>HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD</p>\n<p>HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT</p>\n<h2 id="_2-各个http方法的具体作用是什么" tabindex="-1"><a class="header-anchor" href="#_2-各个http方法的具体作用是什么" aria-hidden="true">#</a> 2. 各个HTTP方法的具体作用是什么？</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">方法</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">GET</td>\n<td>通常⽤于请求服务器发送某些资源</td>\n</tr>\n<tr>\n<td style="text-align:center">POST</td>\n<td>发送数据给服务器</td>\n</tr>\n<tr>\n<td style="text-align:center">HEAD</td>\n<td>请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</td>\n</tr>\n<tr>\n<td style="text-align:center">PUT</td>\n<td>⽤于全量修改⽬标资源 (看接口, 也可以用于添加)</td>\n</tr>\n<tr>\n<td style="text-align:center">DELETE</td>\n<td>⽤于删除指定的资源</td>\n</tr>\n<tr>\n<td style="text-align:center">OPTIONS</td>\n<td>⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全)</td>\n</tr>\n<tr>\n<td style="text-align:center">TRACE</td>\n<td>该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断</td>\n</tr>\n<tr>\n<td style="text-align:center">CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户)</td>\n</tr>\n<tr>\n<td style="text-align:center">PATCH</td>\n<td>⽤于对资源进⾏部分修改</td>\n</tr>\n</tbody>\n</table>\n<p>GET POST PUT PATCH DELETE</p>\n<p>GET/DELETE  参数是在地址栏中传递的</p>\n<p>PUT/PATCH/POST 参数是在请求体传递的</p>\n<h2 id="_3-get方法和post方法有何区别" tabindex="-1"><a class="header-anchor" href="#_3-get方法和post方法有何区别" aria-hidden="true">#</a> 3. GET方法和POST方法有何区别？</h2>\n<p>默认的http请求的内容, 在网络中传输, 明文的形式传递的  (https 对内容加密)</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>GET方法</th>\n<th>POST方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据传输⽅式</strong></td>\n<td>通过URL传输数据 (地址栏拼接参数)</td>\n<td>通过请求体传输</td>\n</tr>\n<tr>\n<td><strong>数据安全</strong></td>\n<td>数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息</td>\n<td>数据因为在请求主体内，<br />所以有⼀定的安全性保证</td>\n</tr>\n<tr>\n<td><strong>数据类型</strong></td>\n<td>只允许 ASCII 字符</td>\n<td>⽆限制</td>\n</tr>\n<tr>\n<td><strong>GET⽆害</strong></td>\n<td>刷新、后退等浏览器操作是⽆害的</td>\n<td>可能会引起重复提交表单</td>\n</tr>\n<tr>\n<td><strong>功能特性</strong></td>\n<td>安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br /><strong>幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）</strong></td>\n<td>⾮安全(会引起服务器端的变化)、<strong>⾮幂等</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id="_4-http请求报文是什么样的" tabindex="-1"><a class="header-anchor" href="#_4-http请求报文是什么样的" aria-hidden="true">#</a> 4. HTTP请求报文是什么样的？</h2>\n<p>HTTP 请求报⽂的组成：请求⾏、请求头、(空⾏)、请求体。</p>\n<p>实际请求报文实例:</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305232854139" originSrc="images/image-20210305232854139.png" data="aurora"></p>\n<p><strong>请求行</strong></p>\n<p>包含了请求⽅法、URL、HTTP 协议版本，它们之间⽤空格进行分隔。例如：</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>GET http://www.abc.com/articles HTTP/1.1\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>请求头</strong></p>\n<p>请求头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号<code>:</code>进行分隔。例如：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>Content-Type: application/json\nHost: www.abc.com\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>请求体</strong></p>\n<p>请求体中放置 POST、PUT、PATCH 等请求方法所需要携带的数据。</p>\n<h2 id="_5-http响应报文是什么样的" tabindex="-1"><a class="header-anchor" href="#_5-http响应报文是什么样的" aria-hidden="true">#</a> 5. HTTP响应报文是什么样的？</h2>\n<p>HTTP 响应报⽂的组成: 响应⾏、响应头、空⾏、响应体。</p>\n<img src="/images/image-20210219125038371.png" alt="image-20210219125038371" style="zoom:40%;" />\n<p><strong>响应行</strong></p>\n<p>响应行由协议版本、状态码、状态码的原因短语3个内容组成，中间以空格分隔。例如：</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>HTTP/1.1 <span class="token number">200</span> OK\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>响应头</strong></p>\n<p>响应头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号<code>:</code>进行分隔。例如：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>Content-Length: 1024\nContent-Type: application/json\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>响应体</strong></p>\n<p>服务器发送过来的数据。</p>\n<p>小结:</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306161216371" originSrc="images/image-20210306161216371.png" data="aurora"></p>\n<h2 id="_6-你了解的http状态码有哪些" tabindex="-1"><a class="header-anchor" href="#_6-你了解的http状态码有哪些" aria-hidden="true">#</a> 6. 你了解的HTTP状态码有哪些？</h2>\n<p><strong>成功（2XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>表示从客户端发来的请求在服务器端被正确处理</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴<br />通常是在POST请求，或是某些PUT请求之后创建了内容, 进行的返回的响应</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>请求服务器已接受，但是尚未处理，不保证完成请求<br />适合异步任务或者说需要处理时间比较长的请求，避免HTTP连接一直占用</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No content</td>\n<td>表示请求成功，但响应报⽂不含实体的主体部分</td>\n</tr>\n<tr>\n<td>206</td>\n<td>Partial Content</td>\n<td>进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求<br />响应头中会包含获取的内容范围 (常用于分段下载)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>重定向（3XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>永久性重定向，表示资源已被分配了新的 URL<br />比如，我们访问 <strong>http</strong>😕/www.baidu.com 会跳转到 <strong>https</strong>😕/www.baidu.com</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br />首页, 个人中心, 遇到了需要登录才能操作的内容, 重定向 到 登录页</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。</td>\n</tr>\n<tr>\n<td><strong>304</strong></td>\n<td><strong>Not Modified</strong></td>\n<td><strong>自从上次请求后，请求的网页内容未修改过。<br />服务器返回此响应时，不会返回网页内容。(协商缓存)</strong></td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。<br />不对请求做额外处理, 正常发送请求, 请求location中的url地址</td>\n</tr>\n</tbody>\n</table>\n<p>因为post请求, 是非幂等的,  从302中, 细化出了 303 和 307</p>\n<p>简而言之:</p>\n<ul>\n<li>301  302  307  都是重定向</li>\n<li>304 协商缓存</li>\n</ul>\n<p><strong>客户端错误（4XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>400</strong></td>\n<td><strong>Bad Request</strong></td>\n<td><strong>请求报⽂存在语法错误(（传参格式不正确）</strong></td>\n</tr>\n<tr>\n<td>401</td>\n<td>UnAuthorized</td>\n<td>权限认证未通过(没有权限)</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>表示对请求资源的访问被服务器拒绝</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>表示在服务器上没有找到请求的资源</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>客户端请求超时</td>\n</tr>\n<tr>\n<td>409</td>\n<td>Confict</td>\n<td>请求的资源可能引起冲突</td>\n</tr>\n</tbody>\n</table>\n<p><strong>服务端错误（5XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Sever Error</td>\n<td>表示服务器端在执⾏请求时发⽣了错误</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br />或者请求是服务器不⽀持的某个⽅法</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</td>\n</tr>\n<tr>\n<td>505</td>\n<td>Http Version Not Supported</td>\n<td>服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</td>\n</tr>\n</tbody>\n</table>\n<h2 id="_7-http的keep-alive是什么作用" tabindex="-1"><a class="header-anchor" href="#_7-http的keep-alive是什么作用" aria-hidden="true">#</a> 7. HTTP的keep-alive是什么作用？</h2>\n<p>作用：使客户端到服务器端的连接<strong>持续有效</strong>(长连接)，当出现对服务器的后继请求时，</p>\n<p>Keep-Alive功能避免了建立或者重新建立连接。</p>\n<p>早期 HTTP/1.0 在每次请求的时候，都要创建⼀个新的连接，⽽创建连接的过程需要消耗资源和时间，</p>\n<p>为了减少资源消耗、缩短响应时间，就需要复⽤已有连接。</p>\n<p>在后来的 HTTP/1.0 以及 HTTP/1.1 中引⼊了复⽤连接的机制，也就是在请求头中加⼊Connection: keep-alive，</p>\n<p>以此告诉对⽅这个请求响应完成后不要关闭连接，下⼀次还⽤这个请求的连接进行后续交流。</p>\n<p><strong>协议规定，如果想要保持连接，则需要在请求头中加上 Connection: keep-alive。</strong></p>\n<p><strong>keep-alive 的优点</strong> (复用连接)</p>\n<ul>\n<li>较少的 CPU 和内存的占⽤（因为要打开的连接数变少了, 复用了连接）</li>\n<li>减少了后续请求的延迟（⽆需再进⾏握⼿）</li>\n<li>...</li>\n</ul>\n<p>缺点: 因为在处理的暂停期间，本来可以释放的资源仍旧被占用。请求已经都结束了, 但是还一直连接着也不合适</p>\n<p>解决：Keep-Alive: timeout=5, max=100</p>\n<ul>\n<li>\n<p>timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），</p>\n</li>\n<li>\n<p>max是最多一百次请求，强制断掉连接。</p>\n<p>就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</p>\n</li>\n</ul>\n<h2 id="_8-为什么需要https" tabindex="-1"><a class="header-anchor" href="#_8-为什么需要https" aria-hidden="true">#</a> 8. 为什么需要HTTPS？</h2>\n<p>HTTPS 是安全版的 HTTP。</p>\n<p>HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。</p>\n<p>而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。</p>\n<h2 id="_9-https是如何保证安全的" tabindex="-1"><a class="header-anchor" href="#_9-https是如何保证安全的" aria-hidden="true">#</a> 9. HTTPS是如何保证安全的？</h2>\n<p>HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。</p>\n<p>那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。</p>\n<p>目前常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。</p>\n<h3 id="_9-1-什么是对称加密" tabindex="-1"><a class="header-anchor" href="#_9-1-什么是对称加密" aria-hidden="true">#</a> 9.1 <strong>什么是对称加密？</strong></h3>\n<p>对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，</p>\n<p>这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难</p>\n<p>通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306005550796" originSrc="images/image-20210306005550796.png" data="aurora"></p>\n<p>对称加密的特点是：</p>\n<ul>\n<li>\n<p>优点:</p>\n<p>计算量小、加密速度快、加密效率高。</p>\n</li>\n<li>\n<p>缺点:</p>\n<p>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。</p>\n<p>如果一方的秘钥被泄露，那么加密信息也就不安全了</p>\n</li>\n</ul>\n<p>使用场景：本地数据加密、https通信、网络传输等</p>\n<p>常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6</p>\n<h3 id="_9-2-什么是非对称加密" tabindex="-1"><a class="header-anchor" href="#_9-2-什么是非对称加密" aria-hidden="true">#</a> 9.2 <strong>什么是⾮对称加密？</strong></h3>\n<p>而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，</p>\n<p>这样就避免了直接传递密钥。这种新的加密模式被称为&quot;非对称加密算法&quot;。</p>\n<p>通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。</p>\n<p>特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306011528361" originSrc="images/image-20210306011528361.png" data="aurora"></p>\n<p>非对称加密的特点是：</p>\n<ul>\n<li>\n<p>优点：非对称加密与对称加密相比其安全性更好</p>\n</li>\n<li>\n<p>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>\n</li>\n</ul>\n<p>使用场景：https会话前期、CA数字证书、信息加密、登录认证等</p>\n<p>常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p>\n<h3 id="_9-3-https-加密解决方案" tabindex="-1"><a class="header-anchor" href="#_9-3-https-加密解决方案" aria-hidden="true">#</a> 9.3 <strong>HTTPS 加密解决⽅案</strong></h3>\n<p>结合了两种加密⽅式：</p>\n<ul>\n<li>\n<p>将 <code>对称加密的密钥</code> ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 <code>对称加密密钥</code></p>\n</li>\n<li>\n<p>双⽅沟通时使⽤ <code>对称加密密钥</code> 进⾏</p>\n</li>\n</ul>\n<p><strong>可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。</strong></p>\n<p>HTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议</p>\n<p>它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输</p>\n<h3 id="_9-4-数字证书" tabindex="-1"><a class="header-anchor" href="#_9-4-数字证书" aria-hidden="true">#</a> 9.4 数字证书</h3>\n<p>为了安全性, 一般还需要签发数字证书!</p>\n<p>客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息</p>\n<p>进而进行非对称加密, 使用公钥, 加密<code>对称加密密钥</code>, 传递给服务器, 后续通信都使用对称加密!</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306020401732" originSrc="images/image-20210306020401732.png" data="aurora"></p>\n<p><strong>问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!</strong></p>\n<p>所以, 就需要有数字证书(CA证书),  一般是CA机构颁发的, 证明这个公钥是安全可靠的!</p>\n<p><strong>CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306014409595" originSrc="images/image-20210306014409595.png" data="aurora"></p>\n<p>当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306021013686" originSrc="images/image-20210306021013686.png" data="aurora"></p>\n<p>而客户端, 接收到消息后, 就可以查看证书</p>\n<ol>\n<li>\n<p>如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!!</p>\n</li>\n<li>\n<p>如果签发证书的机构, 不权威, 发出警告</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306021532010" originSrc="images/image-20210306021532010.png" data="aurora"></p>\n</li>\n<li>\n<p>如果证书过期了, 浏览器也会发出警告</p>\n</li>\n</ol>\n<h3 id="_9-5-数字签名" tabindex="-1"><a class="header-anchor" href="#_9-5-数字签名" aria-hidden="true">#</a> 9.5 数字签名</h3>\n<p>但这还是有问题：如果证书被篡改了怎么办?</p>\n<p>这时就需要用⼀个技术：<strong>数字签名</strong>。 (根据证书内容, 生成的一个唯一标识)</p>\n<p>数字签名就是先⽤ <strong>CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要</strong>，然后使⽤ CA 私钥进行加密，组成数字签名。</p>\n<p>当别⼈把他的证书发过来时，<strong>接收方⽤同样的算法再次⽣成摘要</strong>，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,</p>\n<p>就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。</p>\n<p><a href="https://blog.csdn.net/u014044812/article/details/80723009" target="_blank" rel="noopener noreferrer">博客参考<ExternalLinkIcon/></a></p>\n<h2 id="_10-http2和http1-x比-有什么优势和特点" tabindex="-1"><a class="header-anchor" href="#_10-http2和http1-x比-有什么优势和特点" aria-hidden="true">#</a> 10. HTTP2和HTTP1.x比，有什么优势和特点？</h2>\n<ol>\n<li>HTTP/2 采⽤<code>⼆进制格式</code>来传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议<code>解析起来更⾼效</code></li>\n<li>HTTP/2 采用一些<code>头部压缩技术</code>，减少在请求和响应头中重复携带的数据，<code>降低网络负担</code></li>\n<li>HTTP/2 采⽤<code>服务器推送</code>方式，主动向客户端推送资源，提高页面加载效率</li>\n<li>HTTP/2 采⽤<code>多路复用机制</code>，减少需要创建的连接数量，降低资源占用和性能消耗</li>\n</ol>\n<p>下面是一些与之关联的技术知识。</p>\n<p><strong>⼆进制格式分帧</strong></p>\n<p>帧：HTTP/2 数据通信的最⼩单位消息，是指 HTTP/2 中逻辑上的 HTTP 消息（例如请求、响应等）。消息由⼀个或多个帧组成</p>\n<p>流：存在于连接中的⼀个虚拟通道，它可以承载双向消息，且每个流都有唯⼀的整数ID</p>\n<p><strong>头部压缩</strong></p>\n<p>在 HTTP/1.x 中，请求和响应中会重复携带一些不常改变、冗⻓的头数据，给⽹络带来额外负担。</p>\n<p>在 HTTP/2 中，客户端和服务端使⽤ <strong>“⾸部表”</strong> 来跟踪和存储之前发送过的键值对，</p>\n<p>相同的数据不再随着每次请求和响应发送。⾸部表在连接存续期间始终存在，由客户端和服务器共同渐进更新。</p>\n<p>每个新的⾸部键值对，要么被追加到当前表的末尾，要么替换表中已存在的键值对。</p>\n<blockquote>\n<p>可以简单的理解为：只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</p>\n</blockquote>\n<p>下图为首部表的更新示意图：</p>\n<img src="/images/image-20210219160534616.png" alt="image-20210219160534616" style="zoom:30%;" />\n<p><strong>服务器推送</strong></p>\n<p>服务端可以在发送⻚⾯ HTML 内容时，再主动推送一些其它资源，⽽不⽤等到浏览器解析到相应的位置时发起请求后再作响应。</p>\n<p>例如，服务端可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。</p>\n<p>不过，服务端的主动推送行为，客户端有权利选择是否要接收。</p>\n<p>如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。</p>\n<p><strong>多路复用</strong></p>\n<p>在 HTTP 1.x 中如果想并发多个请求的话，必须使⽤多个 TCP 链接，但浏览器为了控制资源，</p>\n<p>会对单个域名有 6-8 个 TCP 链接的数量限制。而在 HTTP 2 中：</p>\n<ul>\n<li>同域名下的所有通信，都在单个连接上完成</li>\n<li>单个连接可以承载任意数量的双向数据流</li>\n<li>数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成（多个帧可以乱序发送，因为可以根据帧⾸部的流标识来重新组装）</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306023912779" originSrc="images/image-20210306023912779.png" data="aurora"></p>\n<p><a href="https://zhuanlan.zhihu.com/p/30166894" target="_blank" rel="noopener noreferrer">参考文章：HTTP/2特性及其在实际应用中的表现<ExternalLinkIcon/></a></p>\n<h2 id="_11-http缓存控制" tabindex="-1"><a class="header-anchor" href="#_11-http缓存控制" aria-hidden="true">#</a> 11. http缓存控制</h2>\n<h3 id="_11-1-基本认知" tabindex="-1"><a class="header-anchor" href="#_11-1-基本认知" aria-hidden="true">#</a> 11.1 基本认知</h3>\n<p><strong>Web 服务缓存</strong> 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。</p>\n<p><strong>浏览器缓存</strong> 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。<strong><code>这里我们只讨论 HTTP 缓存相关内容</code>。</strong></p>\n<p><strong>HTTP缓存</strong>:</p>\n<ul>\n<li><strong>强缓存</strong></li>\n<li><strong>协商缓存</strong></li>\n</ul>\n<p>在具体了解 HTTP 缓存之前先来明确几个术语：</p>\n<ul>\n<li>缓存命中率：从缓存中得到数据的请求数  与    所有请求数的比率。理想状态是越高越好。</li>\n<li>过期内容：超过设置的有效时间，被标记为“陈旧”的内容。</li>\n<li>验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</li>\n<li>失效：失效就是把内容从缓存中移除。</li>\n</ul>\n<p><strong>浏览器缓存主要是 HTTP 协议定义的缓存机制。</strong></p>\n<p><strong>浏览器缓存, HTTP缓存分类</strong></p>\n<p>浏览器缓存分为<code>强缓存 </code>和 <code>协商缓存</code>，浏览器加载一个页面的简单流程如下：</p>\n<ol>\n<li>\n<p>浏览器先根据这个资源的  <strong>http头信息</strong>  来 <strong>判断是否命中强缓存</strong>。</p>\n<p>如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）</p>\n</li>\n<li>\n<p>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。</p>\n<p>服务器来判断浏览器本地缓存是否失效。</p>\n<p>若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</p>\n</li>\n<li>\n<p>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</p>\n</li>\n</ol>\n<h3 id="_11-2-强缓存-食品过期时间判断" tabindex="-1"><a class="header-anchor" href="#_11-2-强缓存-食品过期时间判断" aria-hidden="true">#</a> 11.2 强缓存  (食品过期时间判断)</h3>\n<p><strong>(进行判断, 是否资源过期, 如果未过期, 直接用缓存)</strong></p>\n<p><strong>强缓存</strong></p>\n<p>命中强缓存时，浏览器并不会将请求发送给服务器。</p>\n<p>在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="images/940884-20180423141536107-329179455.png" data="aurora"></p>\n<p>强缓存是利用http的返回的响应头中的Expires或者Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。</p>\n<p>Expires: 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读</p>\n<p>Cache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s</p>\n<p><strong>Expires</strong></p>\n<p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。</p>\n<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201209080705571" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/image-20201209080705571.png" data="aurora"></p>\n<p>该字段会返回一个时间，比如Expires:  Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在xx年xx月xx日时间之前都是有效的，即命中缓存。</p>\n<p>这种方式有一个明显的缺点，由于失效时间是一个<code>绝对时间</code>，所以当 <strong>服务器与客户端 时间偏差很大</strong>  以后，就会导致缓存混乱。于是发展出了Cache-Control。</p>\n<p><strong>Cache-Control</strong></p>\n<p>Cache-Control是一个<code>相对时间</code>，例如Cache-Control:max-age 3600，代表着资源的有效期是3600秒。</p>\n<p>由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。</p>\n<p>Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。</p>\n<p>Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</p>\n<ol>\n<li>\n<p><strong>max-age</strong> 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。</p>\n<p>例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，</p>\n<p>第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141638673-1917674992.png" data="aurora"></p>\n<p>在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</p>\n</li>\n<li>\n<p><strong>no-cache</strong> 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。</p>\n<p>不是字面意思上的不缓存。</p>\n</li>\n<li>\n<p><strong>no-store</strong> 禁止缓存，每次请求都要向服务器重新获取数据。</p>\n</li>\n</ol>\n<h3 id="_11-3-协商缓存-找供货商专家协商" tabindex="-1"><a class="header-anchor" href="#_11-3-协商缓存-找供货商专家协商" aria-hidden="true">#</a> 11.3 协商缓存 (找供货商专家协商)</h3>\n<p>看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求)   强缓存</p>\n<p>食品过期时间过了,  能不能吃呢?  问问专家(服务器),  专家瞅了一眼, 没过期 (响应304, 不返回内容) , 直接吃          (协商缓存)</p>\n<p>如果问过专家(服务器), 专家瞅了一眼, 呀真过期了, 原来的不要了, 我重新给你发一个 (响应200, 并返回内容)</p>\n<p><strong>协商缓存</strong></p>\n<p>若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。</p>\n<p>服务器根据http头信息中的<code>Last-Modify/If-Modify-Since</code>或<code>Etag/If-None-Match</code>来判断是否命中协商缓存。</p>\n<p>如果命中，则http返回码为304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。</p>\n<p><strong>Last-Modify/If-Modify-Since</strong></p>\n<p>浏览器第一次请求一个资源的时候, 服务器返回的header中会加上Last-Modify，</p>\n<p>Last-modify是一个时间标识该资源的<strong>最后修改时间</strong>，例如<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141852114-1757065670.png" data="aurora"></p>\n<p>当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，<strong>该值为缓存之前返回的Last-Modify</strong>。</p>\n<p>服务器收到If-Modify-Since后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="images/940884-20180423141732879-1484228353.png" data="aurora"></p>\n<p>如果命中缓存，则返回 <strong>http304</strong>，并且不会返回资源内容，并且不会返回Last-Modify。</p>\n<p>由于对比的是服务端时间，所以客户端与服务端时间差距不会导致问题。</p>\n<p><strong>但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。</strong></p>\n<p>比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了,  <strong>于是出现了ETag/If-None-Match。</strong></p>\n<p><strong>ETag/If-None-Match</strong></p>\n<p>与Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。</p>\n<p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。</p>\n<p>ETag值的变更则说明资源状态已经被修改。</p>\n<p>服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141918779-1206116367.png" data="aurora"></p>\n<p>ETag生成靠以下几种因子</p>\n<ol>\n<li>\n<p>文件的i-node编号，是Linux/Unix用来识别文件的编号。</p>\n</li>\n<li>\n<p>文件最后修改时间</p>\n</li>\n<li>\n<p>文件大小</p>\n<p>...</p>\n</li>\n</ol>\n<p>生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值</p>\n<p><strong>既生 Last-Modified 何生 Etag ？</strong></p>\n<p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？</p>\n<p>Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>\n<ol>\n<li>\n<p>Last-Modified标注的最后修改只能精确到秒级</p>\n<p>如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li>\n<p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 <strong>准确的控制缓存。</strong></p>\n<p>不会仅仅只根据最后的修改时间判断是否进行使用缓存</p>\n<p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，</p>\n<p>最后才决定是否返回304。</p>\n<p>小结:</p>\n<ul>\n<li>\n<p>强缓存: 大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读</p>\n</li>\n<li>\n<p>协商缓存: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间,  唯一标识etag), 去问服务器, 是否真的过期了</p>\n<p>如果验证通过,  服务器会直接响应 304, 且不会返回资源</p>\n</li>\n</ul>\n<h3 id="_11-4-整体请求缓存流程" tabindex="-1"><a class="header-anchor" href="#_11-4-整体请求缓存流程" aria-hidden="true">#</a> 11.4 整体请求缓存流程</h3>\n<p><strong>浏览器第一次请求</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141945261-83532090.png" data="aurora"></p>\n<p><strong>浏览器第二次请求</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141951735-912699213.png" data="aurora"></p>\n<hr>\n<h1 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h1>\n<h2 id="tcp的特性" tabindex="-1"><a class="header-anchor" href="#tcp的特性" aria-hidden="true">#</a> TCP的特性</h2>\n<p>主要有以下5点特性：</p>\n<ol>\n<li>\n<p>TCP 提供⼀种⾯向连接的、可靠的字节流服务</p>\n</li>\n<li>\n<p>在⼀个 TCP 连接中，仅有两⽅进⾏彼此通信（⼴播和多播不能⽤于 TCP）</p>\n</li>\n<li>\n<p>TCP 使⽤校验、确认和重传机制来保证可靠传输</p>\n</li>\n<li>\n<p>TCP 将数据分节进⾏排序，并使⽤累积来确认保证数据的顺序不变和⾮重复</p>\n</li>\n<li>\n<p>TCP 使⽤滑动窗⼝机制来实现流量控制，通过动态改变窗⼝的⼤⼩进⾏拥塞控制</p>\n</li>\n</ol>\n<h2 id="简述-tcp-和-udp-的区别" tabindex="-1"><a class="header-anchor" href="#简述-tcp-和-udp-的区别" aria-hidden="true">#</a> 简述 TCP 和 UDP 的区别</h2>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>连接性</th>\n<th>双工性</th>\n<th>可靠性</th>\n<th>有序性</th>\n<th>有界性</th>\n<th>拥塞控制</th>\n<th>传输速度</th>\n<th>量级</th>\n<th>头部大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TCP</td>\n<td>⾯向连接</td>\n<td>全双工 1:1</td>\n<td>可靠，有重传机制</td>\n<td>有序，通过SYN排序</td>\n<td>无边界，有粘包情况</td>\n<td>有</td>\n<td>慢</td>\n<td>低</td>\n<td>20~60字节</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>无连接</td>\n<td>n:m</td>\n<td>不可靠，丢包后数据丢失</td>\n<td>无序</td>\n<td>有边界，无粘包</td>\n<td>无</td>\n<td>快</td>\n<td>高</td>\n<td>8字节</td>\n</tr>\n</tbody>\n</table>\n<p>UDP socket ⽀持 n 对 m 的连接状态。在 Node.js 官⽅⽂档中有写到在 <code>dgram.createSocket(options[, callback]) </code> 中的 <code>options</code> 中可指定 <code>reuseAddr</code> 为 <code>SO_REUSEADDR</code> 标志，通过它可以简单的实现 n 对 m 的多播特性 (仅在⽀持多播的操作系统上才有用)。</p>\n<h2 id="什么是-tcp-粘包-怎么处理" tabindex="-1"><a class="header-anchor" href="#什么是-tcp-粘包-怎么处理" aria-hidden="true">#</a> 什么是 TCP 粘包，怎么处理？</h2>\n<p>TCP 连接在默认情况下会启⽤延迟传送算法 (Nagle算法)，它在数据发送前进行缓存数据，如短时间内有多个数据发送，会缓冲后再作⼀次发送操作 (缓冲区⼤⼩可⻅ <code>socket.bufferSize</code>)，这样可以减少 IO 产生的消耗，提⾼了性能。</p>\n<p>在传输⽂件的情况下，不⽤处理粘包问题，接收到⼀个包就拼接⼀个包就行了。但是，如果是传输多条消息、或是别的⽤途的数据，那么就需要处理粘包。可参⻅⽹上流传甚⼴的⼀个例⼦：连续调⽤两次 <code>send</code> 分别发送两段数据 data1 和 data2，则在接收端会有以下⼏种常⻅情况出现:</p>\n<ul>\n<li>\n<p>A. 先收到 data1，然后收到 data2</p>\n</li>\n<li>\n<p>B. 先收到 data1 的部分数据，然后收到 data1 余下的部分以及 data2 的全部</p>\n</li>\n<li>\n<p>C. 先收到 data1 的全部数据和 data2 的部分数据，然后收到 data2 的余下的数据</p>\n</li>\n<li>\n<p>D. ⼀次性收到 data1 和 data2 的全部数据</p>\n</li>\n</ul>\n<p>以上情况中的 <code>B、C、D</code> 三种，就是常⻅的粘包情况。而处理粘包问题的常⻅⽅案有：</p>\n<p><strong>方案一：多次发送之前间隔⼀个等待时间</strong></p>\n<p>只需等待⼀段时间再做下⼀次<code>send</code> 发送操作就可以了。</p>\n<ul>\n<li>\n<p>它适⽤于交互频率特别低的场景</p>\n</li>\n<li>\n<p>对于交互频繁的场景来说， 其传输效率太低。</p>\n</li>\n</ul>\n<p><strong>方案二：关闭 Nagle 算法</strong></p>\n<p>在 Node.js 中你可以通过 <code>socket.setNoDelay()</code> ⽅法来关闭 Nagle 算法，让每次 send 都不缓冲而直接发送。</p>\n<ul>\n<li>\n<p>该⽅法适⽤于每次发送的数据都⽐较⼤ (但不是如⽂件那么⼤)， 并且频率不特别⾼的场景</p>\n</li>\n<li>\n<p>如果是每次发送的数据量⽐较⼩且频率特别⾼的话，这种方式纯属⾃废武功</p>\n</li>\n<li>\n<p>该⽅法也不适⽤于⽹络较差的情况，因为 Nagle 算法是在服务端进⾏的包合并情况，但如果短时间内客户端的⽹络</p>\n</li>\n</ul>\n<p>情况不好、或者应⽤层由于某些原因不能及时将 TCP 的数据 <code>recv</code>，就会造成多个包在客户端缓冲从⽽粘包的情况</p>\n<p><strong>方案三：进⾏封包/拆包</strong></p>\n<p>这是⽬前业内最常⻅的解决⽅案，即在发送每个数据包之前，将⼀些有特征的数据放在数据包前/后，然后在收到数据的时</p>\n<p>候，根据特征数据来分割出各个数据包。</p>\n<h2 id="你知道哪些常用的端口号-以及它们对应的服务" tabindex="-1"><a class="header-anchor" href="#你知道哪些常用的端口号-以及它们对应的服务" aria-hidden="true">#</a> 你知道哪些常用的端口号，以及它们对应的服务？</h2>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>21</td>\n<td>主要⽤于FTP（File Transfer Protocol，⽂件传输协议）服务</td>\n</tr>\n<tr>\n<td>23</td>\n<td>主要⽤于Telnet（远程登录）服务，是Internet上普遍采⽤的登录和仿真程序</td>\n</tr>\n<tr>\n<td>25</td>\n<td>为 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务器所开放，主要⽤于发送邮件，如今绝⼤多数邮件服务器都使⽤该协议</td>\n</tr>\n<tr>\n<td>53</td>\n<td>为DNS（Domain Name Server，域名服务器）服务器所开放，主要⽤于域名解析，DNS服务在NT系统中使⽤的最为⼴泛</td>\n</tr>\n<tr>\n<td>67、68</td>\n<td>分别是为 Bootp 服务的 Bootstrap Protocol Server（引导程序协议服务端）和 Bootstrap Protocol Client（引导程序协议客户端）开放的端⼝</td>\n</tr>\n<tr>\n<td>69</td>\n<td>TFTP是Cisco公司开发的⼀个简单⽂件传输协议，类似于FTP</td>\n</tr>\n<tr>\n<td>79</td>\n<td>为Finger服务开放的，主要⽤于查询远程主机在线⽤户、操作系统类型以及是否缓冲区溢出等⽤户的详细信息</td>\n</tr>\n<tr>\n<td>80</td>\n<td>为HTTP（HyperText Transport Protocol，超⽂本传输协议）开放的，这是上⽹冲浪使⽤最多的协议，主要⽤于在WWW（World WideWeb，万维⽹）服务上传输信息的协议</td>\n</tr>\n<tr>\n<td>99</td>\n<td>⽤于⼀个名为“Metagram Relay”（亚对策延时）的服务，该服务⽐较少⻅，⼀般是⽤不到的</td>\n</tr>\n<tr>\n<td>109、110</td>\n<td>为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，110 端⼝是为 POP3（邮件协议3）服务开放的，POP2、POP3都是主要⽤于接收邮件的</td>\n</tr>\n<tr>\n<td>111</td>\n<td>是SUN公司的 RPC（Remote ProcedureCall，远程过程调⽤）服务所开放的端⼝，主要⽤于分布式系统中不同计算机的内部进程通信，RPC在多种⽹络服务中都是很重要的组件</td>\n</tr>\n<tr>\n<td>113</td>\n<td>主要⽤于Windows的“Authentication Service”（验证服务）</td>\n</tr>\n<tr>\n<td>119</td>\n<td>是为“Network News TransferProtocol”（⽹络新闻组传输协议，简称NNTP）开放的</td>\n</tr>\n<tr>\n<td>135</td>\n<td>主要⽤于使⽤RPC（Remote Procedure Call，远程过程调⽤）协议并提供DCOM（分布式组件对象模型）服务</td>\n</tr>\n<tr>\n<td>137</td>\n<td>主要⽤于“NetBIOS Name Service”（NetBIOS名称服务）</td>\n</tr>\n<tr>\n<td>139</td>\n<td>是为“NetBIOS Session Service”提供的，主要⽤于提供Windows⽂件和打印机共享以及Unix中的Samba服务</td>\n</tr>\n<tr>\n<td>143</td>\n<td>主要是⽤于“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP）</td>\n</tr>\n<tr>\n<td>161</td>\n<td>是⽤于“Simple Network Management Protocol”（简单⽹络管理协议，简称SNMP）</td>\n</tr>\n<tr>\n<td>443</td>\n<td>⽹⻚浏览端⼝，主要是⽤于HTTPS服务，是提供加密和通过安全端⼝传输的另⼀种HTTP</td>\n</tr>\n<tr>\n<td>554</td>\n<td>默认情况下⽤于“Real Time Streaming Protocol”（实时流协议，简称RTSP）</td>\n</tr>\n<tr>\n<td>1024</td>\n<td>⼀般不固定分配给某个服务，在英⽂中的解释是“Reserved”（保留）</td>\n</tr>\n<tr>\n<td>1080</td>\n<td>是Socks代理服务使⽤的端⼝，⼤家平时上⽹使⽤的WWW服务使⽤的是HTTP协议的代理服务</td>\n</tr>\n<tr>\n<td>1755</td>\n<td>默认情况下⽤于“Microsoft Media Server”（微软媒体服务器，简称MMS）</td>\n</tr>\n<tr>\n<td>4000</td>\n<td>是⽤于⼤家经常使⽤的QQ聊天⼯具的，再细说就是为QQ客户端开放的端⼝，QQ服务端使⽤的端⼝是8000</td>\n</tr>\n<tr>\n<td>5554</td>\n<td>⼀种针对微软lsass服务的新蠕⾍病毒——震荡波（Worm.Sasser）利⽤TCP 5554端⼝开启⼀个FTP服务，主要被⽤于病毒的传播</td>\n</tr>\n<tr>\n<td>5632</td>\n<td>5632端⼝是被⼤家所熟悉的远程控制软件pcAnywhere所开启的端⼝</td>\n</tr>\n<tr>\n<td>8080</td>\n<td>8080端⼝同80端⼝，是被⽤于WWW代理服务的，可以实现⽹⻚</td>\n</tr>\n</tbody>\n</table>\n<h2 id="一次完整的http服务过程是什么" tabindex="-1"><a class="header-anchor" href="#一次完整的http服务过程是什么" aria-hidden="true">#</a> 一次完整的HTTP服务过程是什么</h2>\n<p>当我们在web浏览器的地址栏中输入：<code>www.baidu.com</code>，具体发生了什么？</p>\n<ol>\n<li>对<code>www.baidu.com</code>这个网址进行DNS域名解析，得到对应的IP地址</li>\n<li>根据这个IP，找到对应的服务器，发起TCP的三次握手 (<a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener noreferrer">tcp 三次握手四次挥手<ExternalLinkIcon/></a> )</li>\n<li>建立TCP连接后发起HTTP请求</li>\n<li>服务器响应HTTP请求，浏览器得到html代码</li>\n<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）</li>\n<li>浏览器对页面进行渲染呈现给用户</li>\n<li>服务器关闭关闭TCP连接</li>\n</ol>\n<p>注：</p>\n<p>1.DNS怎么找到域名的？</p>\n<blockquote>\n<p>DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存-&gt;缓存找不到就去找根域名服务器-&gt;根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器</p>\n</blockquote>\n<p>2.为什么HTTP协议要基于TCP来实现？</p>\n<blockquote>\n<p>TCP是一个端到端的可靠面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）</p>\n</blockquote>\n<p>3.最后一步浏览器是如何对页面进行渲染的？</p>\n<blockquote>\n<p>a）解析html文件构成 DOM树\nb）解析CSS文件构成渲染树\nc）边解析，边渲染\nd）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载</p>\n</blockquote>\n<h2 id="什么是dns-解析" tabindex="-1"><a class="header-anchor" href="#什么是dns-解析" aria-hidden="true">#</a> 什么是DNS 解析</h2>\n<p><strong>DNS解析（域名解析服务器）</strong></p>\n<p>假定请求的是 www.baidu.com</p>\n<p>a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p>\n<p>b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p>\n<p>c）如果还没有找到，那么尝试从 hosts 文件里面去找</p>\n<p>d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找(就近查找)，具体过程如下</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="dns域名解析" originSrc="images/5rxqugj8dh.png" data="aurora"></p>\n<p>DNS优化两个方面：DNS缓存、DNS负载均衡 (准备多台dns服务器, 进行dns解析)</p>\n<h2 id="什么是三次握手" tabindex="-1"><a class="header-anchor" href="#什么是三次握手" aria-hidden="true">#</a> 什么是三次握手？</h2>\n<p>三次握⼿（Three-way Handshake）是指在建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p>\n<p>三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信</p>\n<p>息。在 socket 编程中，客户端调用执行 <code>connect()</code> 时将触发三次握⼿。</p>\n<p>下图为三次握手的示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210219192116213" originSrc="/images/image-20210219192116213.png" data="aurora"></p>\n<p><strong>第⼀次握⼿（SYN=1, seq=x）</strong></p>\n<p>客户端发送⼀个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号（Sequence Number）字段⾥。</p>\n<p>发送完毕后，客户端进⼊ SYN_SEND 状态。</p>\n<p><strong>第⼆次握⼿（SYN=1, ACK=1, seq=y, ACKnum=x+1）</strong></p>\n<p>服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域⾥，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加1，即 X + 1。</p>\n<p>发送完毕后，服务器端进⼊ SYN_RCVD 状态。</p>\n<p><strong>第三次握⼿（ACK=1，ACKnum=y+1）</strong></p>\n<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写 ISN 的 +1。</p>\n<p>发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿结束。</p>\n<h2 id="什么是四次挥手" tabindex="-1"><a class="header-anchor" href="#什么是四次挥手" aria-hidden="true">#</a> 什么是四次挥手？</h2>\n<p>四次挥⼿（Four-way handshake），也叫做改进的三次握⼿，TCP 连接的拆除需要发送四个包，客户端或服务器均可主动发起挥⼿动作，在 socket 编程中，任何⼀⽅执⾏ <code>close()</code> 操作即可产⽣挥⼿操作。</p>\n<p>下图为四次挥手示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210219192659983" originSrc="/images/image-20210219192659983.png" data="aurora"></p>\n<p><strong>第⼀次挥⼿（FIN=1，seq=x）</strong></p>\n<p>假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为1的包，表示⾃⼰已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进⼊ FIN_WAIT_1 状态。</p>\n<p><strong>第⼆次挥⼿（ACK=1，ACKnum=x+1）</strong></p>\n<p>服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务器端关闭连接。</p>\n<p><strong>第三次挥⼿（FIN=1，seq=y）</strong></p>\n<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个ACK。</p>\n<p><strong>第四次挥⼿（ACK=1，ACKnum=y+1）</strong></p>\n<p>客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。</p>\n<h2 id="tcp-三次握手理解-双方确认" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手理解-双方确认" aria-hidden="true">#</a> TCP 三次握手理解 (双方确认)</h2>\n<p>TCP是一个端到端的  <strong>可靠</strong>  面相连接的协议，</p>\n<p>HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）</p>\n<p>根据这个IP，找到对应的服务器，发起TCP的三次握手 (<a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener noreferrer">tcp 三次握手四次挥手<ExternalLinkIcon/></a> )</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201209160422978" originSrc="images/image-20201209160422978.png" data="aurora"></p>\n<p><strong>为什么要3次握手</strong></p>\n<p>我们假定第一次发送的请求,  因为网络延迟很慢才到达服务端，</p>\n<p>然后客户端以为这服务器居然不叼我，然后默默的关闭的等待连接的请求，走开了（好比追女神）；</p>\n<p>但事实呢？女神（服务器）是因为各种各样的原因，很晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！</p>\n<p>但是，A早已经远走高飞，这个请求A完全不会收到（在第二次握手，服务端打开连接，等待客户端的响应），</p>\n<p>那么女生呢，以为对方收到了，就会一直等待，这样B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；</p>\n<p>而三次握手, 就不会发生，服务端同意连接了，但是A缺一直没有下一步的动作，导致资源浪费；</p>\n<h2 id="关闭tcp连接四次挥手的理解-客气挽留" tabindex="-1"><a class="header-anchor" href="#关闭tcp连接四次挥手的理解-客气挽留" aria-hidden="true">#</a> 关闭TCP连接四次挥手的理解 (客气挽留)</h2>\n<p>关闭连接(四次挥手)</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201209162908979" originSrc="images/image-20201209162908979.png" data="aurora"></p>\n<p>这和有礼貌的好友道别一样：（a：客户端 b:服务端）\n1、一开始A想要回家离开，但是呢？怕B还有事情要交代，那么呢？只好先想B打招呼，我要走了，请求停止交谈（此时，a到B的连接没有断开，依旧可以进行通信）；\n2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看,  你等等,  等我说完你再走。\n3、B确实没啥要补充的了，就告知你我可以散伙了\n4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )</p>\n<h2 id="浏览器解析响应" tabindex="-1"><a class="header-anchor" href="#浏览器解析响应" aria-hidden="true">#</a> 浏览器解析响应</h2>\n<p><strong>浏览器解析html代码，并请求html代码中的资源</strong></p>\n<p><strong>浏览器对页面进行渲染呈现给用户</strong></p>\n<p>最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。</p>\n<p>首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>\n<p>DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repaint。</p>\n<p><strong>页面在首次加载时必然会经历reflow和repaint。</strong></p>\n<p>reflow过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。</p>\n<p>所以我们应该尽可能少的减少 reflow (重新布局) 。  例如: transform 变换, 只会触发重绘, 不会触发重排 (效率非常高)</p>\n<p>...</p>\n<p>页面首次渲染, 必然会进行一次 reflow 和 一次 repaint</p>\n<ol>\n<li>reflow: 重排 (布局相关的)</li>\n<li>repaint: 重绘(绘制, 颜色, 字体, .... 跟结构无关的)</li>\n</ol>\n<p><strong>完整的一次 http 请求流程才算结束</strong></p>\n<hr>\n<h1 id="dom" tabindex="-1"><a class="header-anchor" href="#dom" aria-hidden="true">#</a> DOM</h1>\n<h2 id="dom的事件模型是什么" tabindex="-1"><a class="header-anchor" href="#dom的事件模型是什么" aria-hidden="true">#</a> DOM的事件模型是什么？</h2>\n<p>DOM的事件模型(注册事件的方式)分为：</p>\n<ul>\n<li>脚本模型</li>\n<li>内联模型（同类一个，后者覆盖前者）</li>\n<li>动态绑定（同类可多个）</li>\n</ul>\n<p><strong>脚本模型</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 脚本模型：⾏内绑定 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token literal-property property">javascrpt</span><span class="token operator">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">\'Hello\'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Hello1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>内联模型</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 内联模型：同⼀个元素的同类事件只能添加⼀个，如果添加多个则后添加的会覆盖之前添加的 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Hello2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>动态绑定</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 动态绑定 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/* 1. 这种方式只能给同一个元素添加一个事件 */</span>\n  btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n\n  <span class="token comment">/* 2. 这种方式可以给同⼀个元素添加多个同类事件 */</span>\n  btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="dom的事件流是什么" tabindex="-1"><a class="header-anchor" href="#dom的事件流是什么" aria-hidden="true">#</a> DOM的事件流是什么？</h2>\n<p><strong>事件</strong></p>\n<p>事件是HTML⽂档或浏览器窗⼝中发⽣的⼀些特定的交互瞬间。</p>\n<p><strong>事件流</strong></p>\n<p>⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2级事件规定的事件流包括了3个阶段：</p>\n<ul>\n<li>事件捕获阶段（capture phase）</li>\n<li>处于⽬标阶段（target phase）</li>\n<li>事件冒泡阶段（bubbling phase）</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210219222213633" originSrc="/images/image-20210219222213633.png" data="aurora"></p>\n<p>如上图所示，事件流的触发顺序是：</p>\n<ol>\n<li>事件捕获阶段，为截获事件提供了机会</li>\n<li>实际的⽬标元素接收到事件</li>\n<li>事件冒泡阶段，可在这个阶段对事件做出响应</li>\n</ol>\n<p><strong>事件冒泡（Event Bubbling）</strong></p>\n<p>事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span> \n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span> \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span> \n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span> \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span> \n  \n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果点击了上面页面代码中的 <code>&lt;button&gt;</code> 按钮，那么该 <code>click</code> 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：</p>\n<ol>\n<li>button 元素</li>\n<li>body 元素</li>\n<li>html 元素</li>\n<li>document 对象</li>\n</ol>\n<p><strong>事件捕获（Event Capturing）</strong></p>\n<p>事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。</p>\n<p>事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。</p>\n<p>如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 <code>click</code> 事件，然后再沿着 DOM 树依次向下，直到 <code>&lt;button&gt;</code>。具体顺序如下：</p>\n<ol>\n<li>document 对象</li>\n<li>html 元素</li>\n<li>body 元素</li>\n<li>button 元素</li>\n</ol>\n<h2 id="说说什么是事件委托" tabindex="-1"><a class="header-anchor" href="#说说什么是事件委托" aria-hidden="true">#</a> 说说什么是事件委托？</h2>\n<p>事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。</p>\n<p><strong>示例</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token comment">// ⽗元素 </span>\n    <span class="token keyword">var</span> list <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'list\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 为⽗元素绑定事件，委托管理它的所有⼦元素的点击事件 </span>\n    list<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">var</span> currentTarget <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTarget<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'li\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">alert</span><span class="token punctuation">(</span>currentTarget<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote>\n<p>适用场景：在绑定大量事件的时候，可以选择事件委托</p>\n</blockquote>\n<p><strong>优点</strong></p>\n<ul>\n<li>事件委托可以减少事件注册数量，节省内存占⽤!</li>\n<li>当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素</li>\n</ul>\n<hr>\n<h1 id="浏览器与新技术" tabindex="-1"><a class="header-anchor" href="#浏览器与新技术" aria-hidden="true">#</a> 浏览器与新技术</h1>\n<h2 id="常见的浏览器内核有哪些" tabindex="-1"><a class="header-anchor" href="#常见的浏览器内核有哪些" aria-hidden="true">#</a> 常见的浏览器内核有哪些？</h2>\n<p>浏览器的内核，通常指的是渲染引擎，但现在JS引擎也成为浏览器的重要部分，所以下表展示了当前一些比较流行的常规浏览器、无头浏览器、以及JS运行时所含的渲染引擎和JS引擎：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">浏览器/运行时</th>\n<th style="text-align:center">内核（即渲染引擎）</th>\n<th style="text-align:center">JS引擎</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">Chrome</td>\n<td style="text-align:center">Webkit (Chrome 27) / Blink (Chrome 28+)</td>\n<td style="text-align:center">V8</td>\n</tr>\n<tr>\n<td style="text-align:center">FireFox</td>\n<td style="text-align:center">Gecko</td>\n<td style="text-align:center">SpiderMonkey</td>\n</tr>\n<tr>\n<td style="text-align:center">Safari</td>\n<td style="text-align:center">Webkit</td>\n<td style="text-align:center">JavaScriptCore</td>\n</tr>\n<tr>\n<td style="text-align:center">Edge</td>\n<td style="text-align:center">EdgeHTML</td>\n<td style="text-align:center">Chakra (for JavaScript)</td>\n</tr>\n<tr>\n<td style="text-align:center">IE</td>\n<td style="text-align:center">Trident</td>\n<td style="text-align:center">Chakra (for JScript)</td>\n</tr>\n<tr>\n<td style="text-align:center">PhantomJS (无头浏览器)</td>\n<td style="text-align:center">Webkit</td>\n<td style="text-align:center">JavaScriptCore</td>\n</tr>\n<tr>\n<td style="text-align:center">Puppeteer (无头浏览器)</td>\n<td style="text-align:center">Webkit (Chrome 27) / Blink (Chrome 28+)</td>\n<td style="text-align:center">V8</td>\n</tr>\n<tr>\n<td style="text-align:center">Node.js</td>\n<td style="text-align:center">无</td>\n<td style="text-align:center">V8</td>\n</tr>\n</tbody>\n</table>\n<h2 id="浏览器是如何进行界面渲染的" tabindex="-1"><a class="header-anchor" href="#浏览器是如何进行界面渲染的" aria-hidden="true">#</a> 浏览器是如何进行界面渲染的？</h2>\n<p>不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 webkit 的渲染流程来说明：</p>\n<img src="/images/image-20210220214851409.png" alt="image-20210220214851409" style="zoom:45%;" />\n<p>上图展示的流程是：</p>\n<ol>\n<li>\n<p>获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）</p>\n</li>\n<li>\n<p>解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）</p>\n</li>\n<li>\n<p>根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）</p>\n</li>\n<li>\n<p>进行布局（Layout），即为每个节点分配⼀个在屏幕上应显示的确切坐标位置</p>\n</li>\n<li>\n<p>进⾏绘制（Paint），遍历渲染树节点，调⽤ GPU 将元素呈现出来</p>\n</li>\n</ol>\n<h2 id="浏览器是如何解析css选择器的" tabindex="-1"><a class="header-anchor" href="#浏览器是如何解析css选择器的" aria-hidden="true">#</a> 浏览器是如何解析CSS选择器的？</h2>\n<p>在生成渲染树的过程中，渲染引擎会根据选择器提供的信息来遍历 DOM 树，找到对应的 DOM 节点后将样式规则附加到上面。</p>\n<p>来看一段样式选择器代码、以及一段要应用样式的 HTML：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.mod-nav h3 span</span> <span class="token punctuation">{</span>\n\t<span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mod-nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>项目一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>项目一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>项目一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>渲染引擎是怎么根据以上样式选择器去遍历这个 DOM 树的呢？是按照从左往右的选择器顺序去匹配，还是从右往左呢？</p>\n<p>为了更直观的观查，我们先将这棵 DOM 树先绘制成图：</p>\n<img src="/images/image-20210220222103787.png" alt="image-20210220222103787" style="zoom:30%;" />\n<p>然后我们来对比一下两种顺序的匹配：</p>\n<p><strong>从左往右：<code>.mod-nav &gt; h3 &gt; span</code></strong></p>\n<ol>\n<li>从 <code>.mod-nav</code> 开始遍历⼦节点 <code>header</code>、<code>div</code></li>\n<li>然后向各⾃的⼦节点遍历</li>\n<li>在右侧 <code>div</code> 的分⽀中，当遍历到叶节点 <code>a</code> 后，发现不符合规则。则重新回溯到 <code>ul</code> 节点，再遍历下⼀个 <code>li</code> - <code>a</code></li>\n</ol>\n<p><strong>从右往左：<code>span &gt; h3 &gt; .mod-nav</code></strong></p>\n<ol>\n<li>\n<p>先找到所有的 <code>span</code> 节点 ，然后基于每⼀个 <code>span</code> 再向上查找 <code>h3</code></p>\n</li>\n<li>\n<p>由 <code>h3</code> 再向上查找 <code>.mod-nav</code> 的节点</p>\n</li>\n<li>\n<p>最后触及根元素 <code>html</code> 结束该分⽀遍历</p>\n</li>\n</ol>\n<p>可以看到，从右向左的匹配规则可以在第⼀步时就筛选掉⼤量不符合条件的叶节点；⽽从左向右的匹配规则需要消耗大量时间在失败的查找上，这在真实页面中⼀棵 DOM 树的节点成百上千的情况下，这种遍历方式的效率会非常的低，根本不适合采用。</p>\n<p>因此，浏览器遵循 “从右往左” 的规则来解析 CSS 选择器！</p>\n<h2 id="dom树是如何构建的" tabindex="-1"><a class="header-anchor" href="#dom树是如何构建的" aria-hidden="true">#</a> DOM树是如何构建的？</h2>\n<p>构建的过程如下：</p>\n<ol>\n<li>\n<p>浏览器将接收到的⼆进制数据，按指定编码格式转换为 HTML 字符串</p>\n</li>\n<li>\n<p>开始解析，将 HTML 字符串解析成 Tokens</p>\n</li>\n<li>\n<p>构建节点，对节点添加特定的属性，并通过指针确定节点的⽗、⼦、兄弟关系、以及所属 treeScope</p>\n</li>\n<li>\n<p>通过已确定的节点⽗、⼦、兄弟关系，构建出 DOM 树</p>\n</li>\n</ol>\n<p>下图为以上描述过程的图示：</p>\n<img src="/images/image-20210220230003937.png" alt="image-20210220230003937" style="zoom:50%;" />\n<h2 id="浏览器重绘与重排的区别是什么" tabindex="-1"><a class="header-anchor" href="#浏览器重绘与重排的区别是什么" aria-hidden="true">#</a> 浏览器重绘与重排的区别是什么？</h2>\n<p><strong>重排</strong></p>\n<p>重排是指部分或整个渲染树需要重新分析，并且节点的尺⼨需要重新计算。</p>\n<p>表现为重新⽣成布局，重新排列元素。</p>\n<p><strong>重绘</strong></p>\n<p>重绘是由于节点的⼏何属性发⽣改变，或由于样式发⽣改变（例如：改变元素背景⾊）。</p>\n<p>表现为某些元素的外观被改变。</p>\n<p><strong>两者的关系</strong></p>\n<blockquote>\n<p>重绘不⼀定会出现重排，重排必定会出现重绘。</p>\n</blockquote>\n<p>只改变元素的外观不会引发⽹⻚重排；但若浏览器进行重排后，将会重绘受此次重排影响的部分。</p>\n<p>重排和重绘的代价都很⾼昂，破坏⽤户体验、让界面显示变迟缓。</p>\n<p>但相⽐之下，重排的性能影响会更⼤，在⽆法避免的情况下，⼀般宁可选择代价较⼩的重绘。</p>\n<h2 id="如何触发重排和重绘" tabindex="-1"><a class="header-anchor" href="#如何触发重排和重绘" aria-hidden="true">#</a> 如何触发重排和重绘？</h2>\n<p>改变任意的⽤于构建渲染树的信息，都会引发⼀次重排或重绘。比如：</p>\n<ul>\n<li>\n<p>添加、删除、更新 DOM 节点</p>\n</li>\n<li>\n<p>通过 <code>display: none</code> 隐藏 DOM 节点（同时会触发重排和重绘）</p>\n</li>\n<li>\n<p>通过 <code>visibility: hidden</code> 隐藏 DOM节点（只会触发重绘，因为没有⼏何变化 ）</p>\n</li>\n<li>\n<p>移动 DOM 节点，或是给⻚⾯中的 DOM 节点添加动画</p>\n</li>\n<li>\n<p>添加⼀个样式表，调整样式属性</p>\n</li>\n<li>\n<p>⽤户⾏为，例如：调整浏览器窗⼝的⼤⼩，改变字号，或者滚动页面</p>\n</li>\n</ul>\n<h2 id="如何避免重排或重绘" tabindex="-1"><a class="header-anchor" href="#如何避免重排或重绘" aria-hidden="true">#</a> 如何避免重排或重绘？</h2>\n<p>主要有三大方式来避免：</p>\n<ul>\n<li>集中修改样式</li>\n<li>使用文档碎片（DocumentFragment）</li>\n<li>将元素提升为合成层</li>\n</ul>\n<p><strong>集中修改样式</strong></p>\n<p>通常以改 class 的⽅式，实现样式的集中修改。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">\'className\'</span><span class="token punctuation">,</span> isDark <span class="token operator">?</span> <span class="token string">\'dark\'</span> <span class="token operator">:</span> <span class="token string">\'light\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>使用文档碎片</strong></p>\n<p>通过 <code>document.createDocumentFragment</code> 可创建⼀个游离于 DOM 树外的节点，在该节点上做批量操作后再将它插⼊ DOM 树中，只会引发⼀次重排。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 创建碎片节点</span>\n<span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 多次操作碎片节点</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token keyword">const</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span>\n  node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i\n  fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 一次性添加到 DOM 树中</span>\ndocument<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>将元素提升为合成层</strong></p>\n<p>将元素提升为合成层的最好⽅式是使⽤ CSS 的 <code>will-change</code> 属性：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">#target</span> <span class="token punctuation">{</span>\n  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>提升为合成层有下列几个优点：</p>\n<ul>\n<li>\n<p>合成层的位图会由 GPU 合成，⽐由 CPU 处理更快</p>\n</li>\n<li>\n<p>当需要重绘时只重绘本身，不影响其他层</p>\n</li>\n<li>\n<p><code>transform</code> 和 <code>opacity</code> 不会触发重排和重绘</p>\n</li>\n</ul>\n<h2 id="前端如何实现即时通讯" tabindex="-1"><a class="header-anchor" href="#前端如何实现即时通讯" aria-hidden="true">#</a> 前端如何实现即时通讯？</h2>\n<p>基于Web的前端，存在以下几种可实现即时通讯的方式：</p>\n<ul>\n<li>短轮询</li>\n<li>Comet</li>\n<li>SSE</li>\n<li>WebSocket</li>\n</ul>\n<p><strong>短轮询</strong></p>\n<p>短轮询就是客户端定时发送请求，获取服务器上的最新数据。不是真正的即时通讯，但一定程度上可以模拟即时通讯的效果。</p>\n<p>优缺点：</p>\n<ul>\n<li>优点：浏览器兼容性好，实现简单</li>\n<li>缺点：实时性不高，资源消耗高，存在较多无用请求，影响性能</li>\n</ul>\n<p><strong>Comet</strong></p>\n<p>有两种实现 Comet 的方式：</p>\n<ol>\n<li>使用 Ajax 长轮询（long-polling）</li>\n<li>使用 HTTP 长连接（基于 iframe 和 htmlfile 的流）</li>\n</ol>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：浏览器兼容性好，即时性好，不存在⽆⽤请求</p>\n</li>\n<li>\n<p>缺点：服务器压力较大（维护⻓连接会消耗较多服务器资源）</p>\n</li>\n</ul>\n<p><a href="http://www.52im.net/thread-334-1-1.html" target="_blank" rel="noopener noreferrer">参考文章：Comet技术详解<ExternalLinkIcon/></a></p>\n<p><strong>SSE</strong></p>\n<p>服务端推送事件（Server-Sent Event），它是⼀种允许服务端向客户端推送新数据的 HTML5 技术。</p>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：基于 HTTP，无需太多改造就能使⽤；相比 WebSocket 要简单方便很多</p>\n</li>\n<li>\n<p>缺点：基于⽂本传输，效率没有 WebSocket ⾼；不是严格的双向通信，客户端⽆法复⽤连接来向服务端发送请求，</p>\n<p>而是每次都需重新创建新请求</p>\n</li>\n</ul>\n<p><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener noreferrer">参考文章：SSE教程<ExternalLinkIcon/></a></p>\n<p><strong>WebSocket</strong></p>\n<p>这是基于 TCP 协议的全新、独⽴的协议，作⽤是在服务器和客户端之间建⽴实时的双向通信。</p>\n<p>WebSocket 协议与 HTTP 协议保持兼容，但它不会融⼊ HTTP 协议，仅作为 HTML 5 的⼀部分。</p>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：真正意义上的双向实时通信，性能好、延迟低</p>\n</li>\n<li>\n<p>缺点：由于是独⽴于 HTTP 的协议，因此要使用的话需要对项⽬作改造；使⽤复杂度较⾼，通常需要引⼊成熟的库；并且⽆法兼容低版本的浏览器</p>\n</li>\n</ul>\n<p>HTTP 和 WebSocket 的连接通信比较图：</p>\n<img src="/images/image-20210221101152845.png" alt="image-20210221101152845" style="zoom:30%;" />\n<h2 id="什么是浏览器的同源策略" tabindex="-1"><a class="header-anchor" href="#什么是浏览器的同源策略" aria-hidden="true">#</a> 什么是浏览器的同源策略？</h2>\n<p>首先，同源是指资源地址的 &quot;协议 + 域名 + 端⼝&quot; 三者都相同，即使两个不同域名指向了同⼀ IP 地址，也被判断为⾮同源。</p>\n<p>下面是一些地址的同源判断示例：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210221103114013" originSrc="/images/image-20210221103114013.png" data="aurora"></p>\n<p>了解了什么是同源，再来说同源策略。</p>\n<blockquote>\n<p>同源策略是一种⽤于隔离潜在恶意⽂件的重要安全保护机制，它用于限制从⼀个源加载的⽂档或脚本与来⾃另⼀个源的资源进⾏交互。</p>\n</blockquote>\n<p>在浏览器中，⼤部分内容都受同源策略限制，除了以下三个标签：</p>\n<ul>\n<li><code>&lt;img&gt;</code></li>\n<li><code>&lt;link&gt;</code></li>\n<li><code>script</code></li>\n</ul>\n<h2 id="如何实现跨域" tabindex="-1"><a class="header-anchor" href="#如何实现跨域" aria-hidden="true">#</a> 如何实现跨域？</h2>\n<p>历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：</p>\n<ul>\n<li>JSONP</li>\n<li>CORS</li>\n<li>服务器代理(webpack代理, Nginx反向代理)</li>\n</ul>\n<p><strong>JSONP</strong></p>\n<p>这是一种非常经典的跨域方案，它利用了<code>&lt;script&gt;</code> 标签不受同源策略的限制的特性，实现跨域效果。</p>\n<p>优点：</p>\n<ul>\n<li>实现简单</li>\n<li>兼容性好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>只支持 GET 请求 （因为 <code>&lt;script&gt;</code> 标签只能发送 GET 请求）</li>\n<li>存在被 XSS 攻击的可能，缺乏安全性保证</li>\n<li>需要服务端配合改造</li>\n</ul>\n<p>实现示例：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. JSONP 发送请求的函数封装</span>\n<span class="token keyword">function</span> <span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackKey<span class="token punctuation">,</span> callback <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 在参数中指定 callback 名字 </span>\n  params <span class="token operator">=</span> params <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> params<span class="token punctuation">[</span>callbackKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">\'jsonpCallback\'</span>\n  \n  <span class="token comment">// 预留 callback </span>\n  window<span class="token punctuation">.</span>jsonpCallback <span class="token operator">=</span> callback \n  \n  <span class="token comment">// 拼接参数字符串</span>\n  <span class="token keyword">const</span> queryString <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'&amp;\'</span><span class="token punctuation">)</span>\n  \n  <span class="token comment">// 创建 script 标签</span>\n  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span> \n  script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">\'src\'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>queryString<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> \n  \n  <span class="token comment">// 插⼊ DOM 树</span>\n  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 调用示例</span>\n<span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span> \n  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">\'http://s.weibo.com/ajax/jsonp/suggestion\'</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  \t<span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">\'test\'</span>\n\t<span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">callbackKey</span><span class="token operator">:</span> <span class="token string">\'_cb\'</span><span class="token punctuation">,</span>\n  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span> \n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p><strong>CORS</strong></p>\n<p>跨域资源共享（CORS），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 HTTP 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。</p>\n<p>当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 HTTP 请求。</p>\n<p>如果你⽤的是 Node.js 的 Express 框架，则可以这样来进行设置：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 创建一个 CORS 中间件 </span>\n<span class="token keyword">function</span> <span class="token function">allowCrossDomain</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">\'Access-Control-Allow-Origin\'</span><span class="token punctuation">,</span> <span class="token string">\'http://example.com\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">\'Access-Control-Allow-Methods\'</span><span class="token punctuation">,</span> <span class="token string">\'GET,PUT,POST,DELETE\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">\'Access-Control-Allow-Headers\'</span><span class="token punctuation">,</span> <span class="token string">\'Content-Type\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token comment">//...</span>\n\napp<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// ...</span>\n  \n  <span class="token comment">// 为 Express 配置 CORS 中间件</span>\n  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>allowCrossDomain<span class="token punctuation">)</span><span class="token punctuation">;</span> \n  \n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在实际项目中，建议使用一些已经比较成熟的开源中间件。</p>\n<p><strong>Nginx反向代理</strong></p>\n<p>这是目前最方便，最推荐使用的跨域解决方案。Nginx 本身是⼀款极其强⼤的 Web 服务器，轻量级、启动快、⾼并发。</p>\n<p>现在的后端服务程序，通常会使用 Nginx 进行反向代理：</p>\n<img src="/images/image-20210221111025585.png" alt="image-20210221111025585" style="zoom:33%;" />\n<p>反向代理的原理其实很简单：</p>\n<blockquote>\n<p>Nginx 作为代理服务器，所有客户端的请求都必须先经过 Nginx 的处理，然后再将请求转发给其他后端程序（比如 Node.js 或Java 程序），这样就规避同源策略的影响</p>\n</blockquote>\n<p>下面是一个配置 Nginx 反向代理的示例配置文件：</p>\n<div class="language-nginx ext-nginx line-numbers-mode"><pre v-pre class="language-nginx"><code><span class="token comment"># 进程, 可更具 cpu 数量调整</span>\n<span class="token directive"><span class="token keyword">worker_processes</span> <span class="token number">1</span></span><span class="token punctuation">;</span> \n\n<span class="token directive"><span class="token keyword">events</span></span> <span class="token punctuation">{</span> \n  <span class="token comment"># 连接数 </span>\n  <span class="token directive"><span class="token keyword">worker_connections</span> <span class="token number">1024</span></span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>\n  <span class="token directive"><span class="token keyword">include</span> mime.types</span><span class="token punctuation">;</span> \n  <span class="token directive"><span class="token keyword">default_type</span> application/octet-stream</span><span class="token punctuation">;</span>\n  \n  <span class="token directive"><span class="token keyword">sendfile</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>\n  \n  <span class="token comment">#连接超时时间，服务器会在这个时间过后关闭连接。 </span>\n  <span class="token directive"><span class="token keyword">keepalive_timeout</span> <span class="token number">10</span></span><span class="token punctuation">;</span>\n  \n  <span class="token comment"># 开启 Gzip 压缩</span>\n  <span class="token directive"><span class="token keyword">gzip</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>\n  \n  <span class="token comment"># 直接请求nginx也是会报跨域错误的这⾥设置允许跨域 </span>\n  <span class="token comment"># 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了) </span>\n  <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Origin *</span><span class="token punctuation">;</span> \n  <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Headers X-Requested-With</span><span class="token punctuation">;</span> \n  <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS</span><span class="token punctuation">;</span>\n  \n  <span class="token comment"># srever模块配置是http模块中的⼀个⼦模块，⽤来定义⼀个虚拟访问主机</span>\n  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span> \n    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span> \n    <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span> \n    \n    <span class="token comment"># 根路径指到index.html </span>\n    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span> \n      <span class="token directive"><span class="token keyword">root</span> html</span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">index</span> index.html index.htm</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span>\n    \n    <span class="token comment"># 请求转发：</span>\n    <span class="token comment"># 例如 http://localhost/api 的请求会被转发到 http://192.168.0.103:8080</span>\n    <span class="token directive"><span class="token keyword">location</span> /api</span> <span class="token punctuation">{</span>\n      <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">proxy_pass</span> http://192.168.0.103:8080</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span>\n    \n    <span class="token comment"># 重定向错误⻚⾯到/50x.html </span>\n    <span class="token directive"><span class="token keyword">error_page</span> <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span> /50x.html</span><span class="token punctuation">;</span> \n    \n    <span class="token directive"><span class="token keyword">location</span> = /50x.html</span> <span class="token punctuation">{</span> \n      <span class="token directive"><span class="token keyword">root</span> html</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span> \n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p><a href="https://juejin.cn/post/6844903767226351623#heading-19" target="_blank" rel="noopener noreferrer">参考文章：跨域方式实现原理<ExternalLinkIcon/></a></p>\n<h1 id="前端工程化" tabindex="-1"><a class="header-anchor" href="#前端工程化" aria-hidden="true">#</a> 前端工程化</h1>\n<h2 id="babel的原理是什么" tabindex="-1"><a class="header-anchor" href="#babel的原理是什么" aria-hidden="true">#</a> Babel的原理是什么？</h2>\n<p>Babel 的主要工作是对代码进行转译。</p>\n<p>转译分为三阶段：</p>\n<ul>\n<li>\n<p>解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程</p>\n</li>\n<li>\n<p>转换（Transform），对 AST 进⾏变换方面的⼀系列操作。通过 babel-traverse，对 AST 进⾏遍历并作添加、更新、删除等操作</p>\n</li>\n<li>\n<p>⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码</p>\n</li>\n</ul>\n<p>转译流程示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210221114506275" originSrc="/images/image-20210221114506275.png" data="aurora"></p>\n<h2 id="如何编写一个babel插件" tabindex="-1"><a class="header-anchor" href="#如何编写一个babel插件" aria-hidden="true">#</a> 如何编写一个Babel插件？</h2>\n<p>Babel 插件的主要工作阶段是在 Babel 将代码解析成 AST 之后，插件们对 AST 进行各种操作后，再由 Babel 输出最终的代码。</p>\n<p>要编写一个 Babel 插件模块，则需要为模块代码导出一个函数，且该函数返回一个对象，对象内应包含有 <code>visitor</code> 属性：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">babel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">visitor</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>visitor</code> 是针对各类 AST 节点作处理的地⽅。我们可以通过 <code>console.log</code> 打印或 <a href="https://astexplorer.net/" target="_blank" rel="noopener noreferrer">AST Explorer 工具<ExternalLinkIcon/></a> 来查看 Babel 具体生成的 AST 节点。</p>\n<p><strong>示例</strong></p>\n<p>我们来编写一个插件，其功能是能自动将源码中的数字字面量数学运算进行预计算处理，简化代码。例如：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 原来的代码</span>\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>\n\n<span class="token comment">// 处理后的代码</span>\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token number">3</span>    <span class="token comment">// 这样优化以后，在实际运行时可以减少一次加法操作</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们可以先通过 AST Explorer 来获取 JSON 格式的 AST 结构：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>\n  <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n  <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n  <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>\n      <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n      <span class="token property">"declarations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>\n          <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>\n          <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n          <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>\n            <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>\n            <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>\n            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"result"</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token property">"init"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"BinaryExpression"</span><span class="token punctuation">,</span>\n            <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">15</span><span class="token punctuation">,</span>\n            <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n            <span class="token property">"left"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>\n              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">15</span><span class="token punctuation">,</span>\n              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>\n              <span class="token property">"value"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n              <span class="token property">"raw"</span><span class="token operator">:</span> <span class="token string">"1"</span>\n            <span class="token punctuation">}</span><span class="token punctuation">,</span>\n            <span class="token property">"operator"</span><span class="token operator">:</span> <span class="token string">"+"</span><span class="token punctuation">,</span>\n            <span class="token property">"right"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>\n              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">,</span>\n              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n              <span class="token property">"value"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>\n              <span class="token property">"raw"</span><span class="token operator">:</span> <span class="token string">"2"</span>\n            <span class="token punctuation">}</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">]</span><span class="token punctuation">,</span>\n      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"const"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token property">"sourceType"</span><span class="token operator">:</span> <span class="token string">"module"</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>从以上 AST 结构可以知道，<code>1 + 2</code> 是一个 <code>BinaryExpression</code> 类型的节点，那么在我们编写的插件代码中的 <code>visitor</code> 里就可以这样进行处理：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> babel <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'babel-core\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'babel-types\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n\n<span class="token keyword">var</span> visitor <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">BinaryExpression</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">const</span> node <span class="token operator">=</span> path<span class="token punctuation">.</span>node<span class="token punctuation">;</span>\n\n    <span class="token keyword">let</span> result<span class="token punctuation">;</span>\n\n    <span class="token comment">// 判断表达式两边，是否都是数字 </span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isNumericLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span><span class="token function">isNumericLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token comment">// 根据不同的操作符作运算 </span>\n      <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>operator<span class="token punctuation">)</span> <span class="token punctuation">{</span> \n        <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">-</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span> \n        <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">*</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">/</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span> \n        <span class="token keyword">case</span> <span class="token string">"**"</span><span class="token operator">:</span> \n          <span class="token keyword">let</span> i <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> \n            result <span class="token operator">=</span> result <span class="token operator">||</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n            result <span class="token operator">=</span> result <span class="token operator">*</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token punctuation">}</span>\n          <span class="token keyword">break</span><span class="token punctuation">;</span> \n        <span class="token keyword">default</span><span class="token operator">:</span> \n      <span class="token punctuation">}</span> \n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 如果上⾯的运算有结果的话 </span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token comment">// 把表达式节点替换成number字⾯量 </span>\n      path<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">numericLiteral</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span> \n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">babel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token keyword">return</span> <span class="token punctuation">{</span> visitor <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>      \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>这个插件的基本功能就完成了，来运行试试：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> babel <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"babel-core"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> result <span class="token operator">=</span> babel<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token string">"const result = 1 + 2;"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> \n  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span> \n    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./index"</span><span class="token punctuation">)</span> \n  <span class="token punctuation">]</span> \n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// 结果：const result = 3;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>转换结果符合预期。</p>\n<p>不过这个插件还不能完全正确的工作，在转换如 <code>const result = 1 + 2 + 3 + 4 + 5;</code> 这样的代码时，结果为 <code>const result = 3 + 3 + 4 + 5;</code>，也就是只转换了代码中的第一段表达式计算。</p>\n<p>如果用 AST Explorer 查看 AST 结构的话，会发现原来这个运算由层层嵌套的 <code>BinaryExpression</code> 组成：</p>\n<blockquote>\n<p>BinaryExpression(  BinaryExpression( BinaryExpression( BinaryExpression(1 + 2) + 3 ) + 4 ) + 5 )</p>\n</blockquote>\n<p>因此我们得改造一下之前的代码逻辑，进行遍历操作：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 如果上⾯的运算有结果的话 </span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 把表达式节点替换成number字⾯量 </span>\n  path<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">numericLiteral</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  \n  <span class="token comment">// 向上遍历⽗级节点</span>\n  <span class="token keyword">let</span> parentPath <span class="token operator">=</span> path<span class="token punctuation">.</span>parentPath<span class="token punctuation">;</span> \n  parentPath <span class="token operator">&amp;&amp;</span> visitor<span class="token punctuation">.</span><span class="token function">BinaryExpression</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentPath<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这样就能正确工作了。</p>\n<p><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#builders" target="_blank" rel="noopener noreferrer">参考文档：Babel插件手册<ExternalLinkIcon/></a></p>\n<h2 id="你们的git工作流是什么样的" tabindex="-1"><a class="header-anchor" href="#你们的git工作流是什么样的" aria-hidden="true">#</a> 你们的Git工作流是什么样的？</h2>\n<p>每个公司采用的 Git 工作流都可能会有差别，有的比较规范，有的比较随意。在这里介绍一个名为 GitFlow 的 git 标准操作流程。</p>\n<p>在 GitFlow 标准下，我们的 git 仓库需要包含以下几个关键分支：</p>\n<ul>\n<li>master：主分支</li>\n<li>develop：主开发分⽀。包含确定即将发布的代码</li>\n<li>feature：新功能分⽀。⼀个新功能对应⼀个分⽀</li>\n<li>release：发布分⽀。发布时⽤的分⽀，⼀般测试阶段发现的 bug 在这个分⽀进⾏修复</li>\n<li>hotfix：热补丁分支。用于修改在线上版本中发现的严重紧急 bug</li>\n</ul>\n<p><strong>GitFlow 的主要优点</strong></p>\n<ol>\n<li>支持并⾏开发</li>\n</ol>\n<p>因为每个新功能都会建⽴⼀个新的 feature 分⽀，从⽽和其他已经完成的功能隔离开，且当只有在新功能完成开发的情况下，其对应的 feature 分⽀才会被合并到主开发分⽀（develop 分支）。</p>\n<p>另外，如果你正在开发某个功能的同时⼜有⼀个新功能需要开始开发，那么你只需把当前 feature 的代码提交后，新建另外⼀个 feature 分⽀即可开发新功能了。</p>\n<p>你也可以随时切回之前的其他 feature 分⽀继续完成该功能的开发。</p>\n<ul>\n<li>协作开发</li>\n</ul>\n<p>因为每个 feature 分⽀上改动的代码都只对该 feature 对应的功能生效，所以不同 feature 分支上的代码在开发时不会互相影响，大家可以相安无事的开发自己负责的功能。</p>\n<p>同时我们可以根据分支的名称，很容易知道每个⼈都在做什么功能。</p>\n<ul>\n<li>发布阶段</li>\n</ul>\n<p>当⼀个新 feature 开发完成时，它会被合并到 develop 分⽀，这就意味着 develop 分支上包含了所有已经开发完成的功能。</p>\n<p>因此，在开发新的 feature 时，我们只需从 develop 分⽀来创建新的分⽀，即可在新的 feature 分支中包含所有已完成的最新功能。</p>\n<ul>\n<li>⽀持紧急修复</li>\n</ul>\n<p>hotfix 分⽀是从某个已经发布的 Tag 上创建出来来，用于紧急修复 Bug。</p>\n<p>该紧急修复只影响这个已经发布的 Tag，⽽不会影响你正在开发的其他新 feature 。</p>\n<p><strong>注意点</strong></p>\n<ol>\n<li>\n<p>feature 分⽀都是从 develop 分⽀上创建的，开发完成后再合并到 develop 分⽀上，等待发布</p>\n</li>\n<li>\n<p>当需要发布时，我们要从 develop 分⽀上创建⼀个 release 分⽀，然后该 release 分⽀会发布到测试环境进⾏测试。如果发现问题的话，就会直接在该分⽀上进⾏修复。所有问题修复之前，会不停重复 <code>发布</code> &gt; <code>测试</code> &gt; <code>修复</code> &gt; <code>重新发布</code>  &gt; <code>重新测试</code> 流程。 发布结束，该 release 分⽀会被合并到 develop 以及 master 分⽀，从⽽保证不会有代码丢失</p>\n</li>\n<li>\n<p>master 分⽀只跟踪已经发布的代码，合并到 master 上的 commit 只能来⾃ release 分⽀和 hotfix 分⽀</p>\n</li>\n<li>\n<p>hotfix 分⽀的作⽤是紧急修复⼀些 Bug，它们都是从 master 分⽀上的某个 Tag 建⽴，修复结束后再会被合并到 develop 和 master 分⽀上</p>\n</li>\n</ol>\n<p><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener noreferrer">参考文章：Git工作流<ExternalLinkIcon/></a></p>\n<h2 id="git的rebase和merge的区别是什么" tabindex="-1"><a class="header-anchor" href="#git的rebase和merge的区别是什么" aria-hidden="true">#</a> Git的rebase和merge的区别是什么？</h2>\n<p><code>git rebase</code> 和 <code>git merge</code> 两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。</p>\n<p>以一个 <code>feature/todo</code> 分⽀合并到 <code>master</code>主分⽀为例，我们来看一下分别⽤ <code>rebase</code> 和 <code>merge</code> 会有什么不同。</p>\n<p><strong>使用 Merge</strong></p>\n<img src="/images/image-20210222132936016.png" alt="image-20210222132936016" style="zoom:30%;" />\n<p><code>merge</code> 会⾃动创建⼀个新的 <code>commit</code>， 如果合并时遇到冲突的话，只需要修改后重新 <code>commit</code>。</p>\n<ul>\n<li>\n<p>优点：能记录真实的 <code>commit</code> 情况，包括每个分⽀的详情</p>\n</li>\n<li>\n<p>缺点：由于每次 <code>merge</code> 会⾃动产⽣⼀个 <code>merge commit</code>，因此在使⽤⼀些可视化的 git 工具时会看到这些自动产生的 <code>commit</code>，这些 <code>commit</code> 对于程序员来说没有什么特别的意义，反而会影响阅读</p>\n</li>\n</ul>\n<p><strong>使用 Rebase</strong></p>\n<img src="/images/image-20210222133524146.png" alt="image-20210222133524146" style="zoom:30%;" />\n<p><code>rebase</code> 会合并之前的 <code>commit</code> 历史。</p>\n<ul>\n<li>\n<p>优点：可以得到更简洁的提交历史，去掉了 <code>merge commit</code></p>\n</li>\n<li>\n<p>缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息</p>\n</li>\n</ul>\n<p><strong>建议</strong></p>\n<ul>\n<li>\n<p>当需要保留详细的合并信息时，建议使⽤ <code>git merge</code>，特别是需要将分⽀合并进 <code>master</code> 分⽀时</p>\n</li>\n<li>\n<p>当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的提交信息对自己来说没有必要，那么可尝试使用 <code>git rebase</code></p>\n</li>\n</ul>\n<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h1>\n<h2 id="什么是mvvm" tabindex="-1"><a class="header-anchor" href="#什么是mvvm" aria-hidden="true">#</a> 什么是MVVM？</h2>\n<p>Model-View-ViewModel 模式，最早在 2005 年微软推出的基于 Windows 的⽤户界⾯框架 WPF 中提出，而最早采用 MVVM 的前端框架是 2010 年发布的 Knockout。</p>\n<img src="/images/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" />\n<p><strong>Model 层</strong></p>\n<p>对应数据层的域模型，主要用来做域模型的同步。</p>\n<p>通过 <code>Ajax</code>、<code>fetch</code> 等 API 完成客户端和服务端业务模型的同步。</p>\n<p>在分层关系中，它主要⽤于抽象出 ViewModel 层中视图的 Model。</p>\n<p><strong>View 层</strong></p>\n<p>作为视图模板存在，其实在 MVVM 中整个 View 就是⼀个动态模板。</p>\n<p>除了用于定义结构和布局之外，它还展示了 ViewModel 层的数据和状态。</p>\n<p>View 层并不负责状态的实际处理，它只是做：数据绑定声明、 指令声明、 事件绑定声明。</p>\n<p><strong>ViewModel 层</strong></p>\n<p>负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明进行实际的业务逻辑。</p>\n<p>ViewModel 底层会做好绑定属性的监听，当 ViewModel 中的数据变化时，View 层会自动进行更新；⽽当 View 中声明了数据的双向绑定（表单元素），框架也会监听 View 层（表单元素）值的变化，⼀旦变化，则 View 层绑定的 ViewModel 中的数据也会得到⾃动更新。</p>\n<h2 id="mvvm的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#mvvm的优缺点有哪些" aria-hidden="true">#</a> MVVM的优缺点有哪些？</h2>\n<p><strong>优点</strong></p>\n<ol>\n<li>实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性</li>\n</ol>\n<blockquote>\n<p>⽐如：View 可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定于不同的 &quot;View&quot;，当 View 发生变化时 Model 一定会随之改变，而当 Model 变化时则 View 可以不变。我们可以把⼀些视图逻辑放在⼀个 ViewModel ⾥，以此让多个 View 重⽤这段视图逻辑。</p>\n</blockquote>\n<ol start="2">\n<li>\n<p>提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码</p>\n</li>\n<li>\n<p>能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来</p>\n</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>\n<p>Bug 很难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 模版中的，它们没办法打断点进行 Debug</p>\n</li>\n<li>\n<p>在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，也能很容易的保证了数据的⼀致性，但如果⻓期持有不释放内存，就会造成更多的内存消耗</p>\n</li>\n<li>\n<p>对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼</p>\n</li>\n</ol>\n<h2 id="谈谈对vue生命周期的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对vue生命周期的理解" aria-hidden="true">#</a> 谈谈对Vue生命周期的理解？</h2>\n<p><strong>生命周期的概念</strong></p>\n<p>每个 Vue 实例都有⼀个完整的⽣命周期：</p>\n<ol>\n<li>开始创建</li>\n<li>初始化数据</li>\n<li>编译模版</li>\n<li>挂载 DOM</li>\n<li>渲染、更新数据 =&gt; 重新渲染</li>\n<li>卸载</li>\n</ol>\n<p>这⼀系列过程我们称之为 Vue 的⽣命周期。</p>\n<p><strong>各个生命周期的作用</strong></p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>执行时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beforeCreate</td>\n<td>在组件实例被创建之初、组件的属性⽣效之前被调用</td>\n</tr>\n<tr>\n<td>created</td>\n<td>在组件实例已创建完毕。此时属性也已绑定，但真实DOM还未⽣成，$el 还不可⽤</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>在组件挂载开始之前被调⽤。相关的 render 函数⾸次被调⽤</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>在 el 被新建的 vm.$el 替换并挂载到实例上之后被调用</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>在组件数据更新之前调⽤。发⽣在虚拟 DOM 打补丁之前</td>\n</tr>\n<tr>\n<td>update</td>\n<td>在组件数据更新之后被调用</td>\n</tr>\n<tr>\n<td>activited</td>\n<td>在组件被激活时调⽤（使用了 <code>&lt;keep-alive&gt;</code> 的情况下）</td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td>在组件被销毁时调⽤（使用了 <code>&lt;keep-alive&gt;</code> 的情况下）</td>\n</tr>\n<tr>\n<td>beforeDestory</td>\n<td>在组件销毁前调⽤</td>\n</tr>\n<tr>\n<td>destoryed</td>\n<td>在组件销毁后调⽤</td>\n</tr>\n</tbody>\n</table>\n<p><strong>生命周期示意图</strong></p>\n<img src="/images/image-20210224084130350.png" alt="image-20210224084130350"  />\n<h2 id="在vue中网络请求应该放在哪个生命周期中发起" tabindex="-1"><a class="header-anchor" href="#在vue中网络请求应该放在哪个生命周期中发起" aria-hidden="true">#</a> 在Vue中网络请求应该放在哪个生命周期中发起？</h2>\n<p>可以在 <code>mounted</code> 或 <code>created</code> 这两个⽣命周期中调⽤发起网络请求。</p>\n<h2 id="vue组件之间如何进行通信" tabindex="-1"><a class="header-anchor" href="#vue组件之间如何进行通信" aria-hidden="true">#</a> Vue组件之间如何进行通信？</h2>\n<p><strong><code>props</code> 和 <code>$emit + v-on</code></strong></p>\n<p>通过 <code>props</code> 将数据在组件树中进行⾃上⽽下的传递；</p>\n<p>通过 <code>$emit</code> 和 <code>v-on</code> 来作信息的向上传递。</p>\n<p><strong>EventBus</strong></p>\n<p>可通过 EventBus 进⾏信息的发布与订阅。</p>\n<p><strong>Vuex</strong></p>\n<p>全局状态管理库。可通过它来进行全局数据流的管理。</p>\n<p><strong><code>$attrs</code> 和 <code>$listeners</code></strong></p>\n<p>在 Vue 2.4 版本中加⼊的 <code>$attrs</code> 和 <code>$listeners</code> 可以用来作为跨级组件之间的通信机制。</p>\n<p><strong><code>provide</code> 和 <code>inject</code></strong></p>\n<p>由于 <code>provide</code> 和 <code>inject</code> 可以允许⼀个祖先组件向它的所有⼦孙组件注⼊⼀个依赖（不论组件层次有多深），并在其上下游关系成⽴的时间⾥始终⽣效，因此这种机制也就成为了一种跨组件通信的手段。</p>\n<blockquote>\n<p>另外还有一些方式使用场景有限，在此不介绍了。</p>\n<p>可以阅读参考文章：<a href="https://juejin.cn/post/6844903887162310669" target="_blank" rel="noopener noreferrer">Vue中的8种组件通信方式<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id="computed和watch的区别是什么" tabindex="-1"><a class="header-anchor" href="#computed和watch的区别是什么" aria-hidden="true">#</a> computed和watch的区别是什么？</h2>\n<p><strong>computed</strong></p>\n<ol>\n<li>\n<p>它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景</p>\n</li>\n<li>\n<p>它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存，只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算</p>\n</li>\n<li>\n<p>它适⽤于计算⽐较消耗性能的计算场景</p>\n</li>\n</ol>\n<p><strong>watch</strong></p>\n<ol>\n<li>\n<p>它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。主要⽤于观察 <code>props</code>、<code>$emit</code> 或本组件的值，当这些值发生变化时，执⾏回调</p>\n</li>\n<li>\n<p>它不具有缓存性。当⻚⾯重新渲染时，即使值没发生变化也会执⾏</p>\n</li>\n</ol>\n<p><strong>建议</strong></p>\n<ol>\n<li>\n<p>当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 <code>computed</code></p>\n</li>\n<li>\n<p>当需要在某个数据发生变化的同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ <code>watch</code></p>\n</li>\n</ol>\n<h2 id="vue双向绑定原理" tabindex="-1"><a class="header-anchor" href="#vue双向绑定原理" aria-hidden="true">#</a> Vue双向绑定原理？</h2>\n<p>在 Vue 2.x 中，利⽤的是 <code>Object.defineProperty</code> 去劫持对象的访问器（Getter、Setter），当对象属性值发⽣变化时可获取变化，然后根据变化来作后续响应；</p>\n<p>在 Vue 3.0 中，则是通过 <code>Proxy</code> 代理对象进⾏类似的操作。</p>\n<h2 id="object-defineproperty和proxy的优缺点" tabindex="-1"><a class="header-anchor" href="#object-defineproperty和proxy的优缺点" aria-hidden="true">#</a> Object.defineProperty和Proxy的优缺点？</h2>\n<p><strong>Proxy</strong></p>\n<ul>\n<li>\n<p>可以直接监听整个对象，⽽⾮是对象的属性</p>\n</li>\n<li>\n<p>可以直接监听数组的变化</p>\n</li>\n<li>\n<p>拦截⽅法丰富：多达13种，不限于 <code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code> 等。比 <code>Object.defineProperty</code> 强大很多</p>\n</li>\n<li>\n<p>返回的是⼀个新对象，可以在不影响原对象的情况下，只操作新对象来达到⽬的；⽽ <code>Object.defineProperty</code> 只能遍历原对象属性并直接修改原对象</p>\n</li>\n<li>\n<p>受到各浏览器⼚商的重点持续性能优化，能享受到作为新标准的性能红利</p>\n</li>\n</ul>\n<p><strong>Object.defineProperty</strong></p>\n<ul>\n<li>兼容性较好（可⽀持到 IE9）</li>\n</ul>\n<h2 id="如何理解vue的响应式系统" tabindex="-1"><a class="header-anchor" href="#如何理解vue的响应式系统" aria-hidden="true">#</a> 如何理解Vue的响应式系统？</h2>\n<p>(考察MVVM)   M: model数据模型,    V:view视图模型,  VM: viewModel视图数据模型</p>\n<p>双向:</p>\n<ol>\n<li>视图变化了, 数据自动更新   =&gt;  监听原生的事件即可,  输入框变了,  监听输入框input事件</li>\n<li>数据变化了, 视图要自动更新  =&gt;  vue2 和 vue3</li>\n</ol>\n<h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h3>\n<p>vue2.0 数据劫持:  Object.defineProperty  (es5)</p>\n<p>vue3.0 数据劫持:  Proxy   (es6)</p>\n<p>分析 :此题考查 Vue的 MVVM 原理</p>\n<p>解答:  Vue的双向绑定原理其实就是 MVVM 的基本原理, Vuejs官网已经说明, 实际就是通过 Object.defineProperty方法 完成了对于Vue实例中数据的 <strong><code>劫持</code></strong>, 通过对于 data中数据 进行set的劫持监听, 然后通过**<code>观察者模式</code>**, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新</p>\n<p>简单概述 : 通过Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新</p>\n<h3 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式" aria-hidden="true">#</a> 观察者模式</h3>\n<p>观察者模式:  当对象间存在  <strong>一对多</strong>  关系时，则使用观察者模式（Observer Pattern）。</p>\n<p>比如，当一个对象或者数据被修改时，则会自动通知依赖它的对象。</p>\n<p>**意图：**定义对象间的一种 <code>一对多的依赖关系</code>，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<p>拍卖会的时候，大家相互叫价，拍卖师(Dep)会观察最高标价(Object.defineProperty)，</p>\n<p>一旦最高价变化了, 然后通知给其它竞价者(watcher观察者 - 订阅者, 订阅了价格的变化)，这就是一个观察者模式</p>\n<p>下图为Vue框架在数据初始化中使用观察者模式的示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201208122803496" originSrc="images/image-20201208122803496.png" data="aurora"></p>\n<p>Dep要进行 <strong>依赖收集</strong>，并通过一个subs数组, 记录观察者Watcher,</p>\n<p>Watcher 分为渲染 watcher、计算属性 watcher、侦听器 watcher三种</p>\n<p>收集依赖: 简单点说就是谁借了我的钱，我就把那个人  <strong>记下来</strong>  ，以后我的钱少了 我就通知他们说我没钱了</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">   // Watcher1(渲染), 依赖于msg\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> car <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">   // Watcher2(渲染),  依赖于car\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> myMsg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">   // Watcher3(渲染), 依赖于myMsg\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">myMsg</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'计算属性重新计算了\'</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\'20\'</span>  <span class="token comment">// Watcher4(计算属性中), 依赖于msg, msg变了重新计算</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">msg</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'新的msg\'</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span> <span class="token comment">// Watcher5(侦听器), 将来msg变化, 这边要执行这个函数</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>\n\n<span class="token comment">// 收集依赖 (dep结构有点类似于二维数组, (Map结构))   arr.type="msgDep"</span>\n<span class="token literal-property property">dep</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n  <span class="token literal-property property">msgDep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">Watcher5</span><span class="token punctuation">(</span>侦听器依赖<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Watcher4</span><span class="token punctuation">(</span>计算属性依赖<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Watcher1</span><span class="token punctuation">(</span>渲染<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">carDep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">Watcher2</span><span class="token punctuation">(</span>渲染<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">myMsgDep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">Watcher3</span><span class="token punctuation">(</span>渲染<span class="token punctuation">)</span><span class="token punctuation">]</span>\n<span class="token punctuation">]</span>\n\n\n<span class="token comment">// Watcher</span>\n<span class="token punctuation">{</span>\n  <span class="token literal-property property">callback</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> <span class="token punctuation">(</span>数据变化后<span class="token punctuation">,</span> 需要执行的回调<span class="token punctuation">)</span>\n  <span class="token literal-property property">isRenderWatcher</span><span class="token operator">:</span> Boolean<span class="token punctuation">,</span> <span class="token punctuation">(</span>是否是render的watcher<span class="token punctuation">,</span> 是否要触发视图的更新<span class="token punctuation">,</span> 往后放<span class="token punctuation">,</span> 最后统一虚拟dom对比<span class="token punctuation">,</span> 统一更新<span class="token punctuation">)</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>比如: 假定数据 money 变了, 那么没有任何与money相关的观察者, 就不需要进行任何更新操作, 也不需要执行任何的监视函数</p>\n<p>然而: 假定数据 msg 变了, 就会通知到相关的Watcher, 且优先通知侦听器Watcher和计算属性Watcher, 后进行统一的渲染更新</p>\n<ol>\n<li>通知侦听器Watcher,  立刻执行配置的函数,  console.log(\'新的msg\', newValue)</li>\n<li>通知计算属性Watcher, 计算属性依赖的值变了, 需要重新计算\n且更新后, myMsg 变化了,  需要进行进行视图的渲染  (render)     (--- 要更新, 等着---)</li>\n<li>通过到watcher1, 渲染Watcher  (---要更新---)</li>\n<li>最后统一进行, 新旧虚拟dom的对比, 完成视图的更新</li>\n</ol>\n<p><strong>当数据状态发生改变时，会被 Object.defineProperty 监听劫持到, 会通知到 Dep,  并根据收集的依赖关系,</strong></p>\n<p><strong>让订阅者Watcher进行数据更新（update）操作 ,  派发更新</strong></p>\n<p>总结概述: vue采用的是观察者模式, 是一种一对多的关系,  一上来vue在解析渲染时, 会进行依赖收集, 会将渲染 watcher、计算属性 watcher、侦听器 watcher, 都收集到dep中,将来Object.defineProperty 监听到数据变化, 就根据依赖关系, 派发更新</p>\n<h2 id="vue中的key到底有什么用" tabindex="-1"><a class="header-anchor" href="#vue中的key到底有什么用" aria-hidden="true">#</a> Vue中的key到底有什么用？</h2>\n<p><code>key</code> 是为 Vue 中的虚拟 DOM 节点（vNode）标记唯⼀性的 id。</p>\n<p>作用:  给虚拟dom添加标识,  <strong>(优化复用对比策略, 优化渲染性能)</strong></p>\n<p>主要考察:</p>\n<ol>\n<li>\n<p>vue 的更新机制 (差异化更新) 对比新旧虚拟dom 进行更新视图</p>\n<p>为什么对比虚拟dom, 而不对比真实的dom ? 真实的dom太复杂, 对比起来性能太差</p>\n</li>\n<li>\n<p>虚拟dom: 使用 js 对象的方式, 模拟真实的 dom 结构</p>\n<p>属性的量大大的减少了, 没有真实dom的那么多无效的属性, 对比起来性能高很多</p>\n</li>\n<li>\n<p>diff 算法: 默认的对比(diff) 机制,  同层兄弟元素, 是按照下标进行对比的, 但是加了 key,  <strong>就相当于给虚拟dom加了个标识</strong></p>\n<p>对比策略, 就是对相同key的元素进行对比了, 在列表v-for中, key的使用尤为常见, 可以用于优化渲染性能</p>\n</li>\n</ol>\n<h3 id="diff算法" tabindex="-1"><a class="header-anchor" href="#diff算法" aria-hidden="true">#</a> diff算法</h3>\n<p>diff 算法的基本策略 (对比新旧虚拟dom差异的一种算法):</p>\n<ol>\n<li>\n<p>由于dom结构是一个树形结构, 就算是对比新旧虚拟dom, 一样是在对比树形结构</p>\n<p>而树形结构, 每往下都一层, 遍历成本就越高</p>\n</li>\n<li>\n<p>为了避免一些无效的对比, diff算法, (tree diff) 优先比较树的根节点</p>\n<p>如果根节点元素类型(组件), 是一致的, 才考虑复用元素内部的结构</p>\n<p>如果根节点元素类型(组件), 不一致, 直接销毁, 重新构建新的结构</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>旧\n&lt;div>\n\t&lt;span>我是内容&lt;/span>\n&lt;/div>\n\n\n新\n&lt;li>\n\t&lt;a href="#">我是内容&lt;/a>\n\t&lt;span>我是内容&lt;/span>\n&lt;/li>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>大大的提升了对比的效率</p>\n</li>\n<li>\n<p>同一根节点下,   同级兄弟元素, 默认的对比策略: 按照下标对比</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>旧\n&lt;div class="box">\n\t&lt;h1>大标题&lt;/h1>\n\t&lt;p>内容&lt;/p>\n&lt;/div>\n\n新\n&lt;div class="message">\n\t&lt;h1>测试标题&lt;/h1>\n\t&lt;p>内容&lt;/p>\n&lt;/div>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li>\n<li>\n<p>同一根节点下,   同级兄弟元素,  如果配置 key 属性, 那么对比的策略, 就不是按照下标, 而是按照key进行 一一对比</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>旧\n&lt;div class="box">\n\t&lt;h1 key="201">大标题&lt;/h1>\n\t&lt;p key="202">内容&lt;/p>\n&lt;/div>\n\n新\n&lt;div class="message">\n\t&lt;h1 key="200">大标题&lt;/h1>   // 新结构\n\t&lt;p key="202">内容&lt;/p>    // 对比出来, 原来结构有key="202", 进行对比, 完成了复用\n&lt;/div>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果你希望一个结构, 并不进行复用, 就是希望某个组件某个结构,  能够重新构建, 可以设置一个不同的 key</p>\n</li>\n</ol>\n<h3 id="key的常见应用场景" tabindex="-1"><a class="header-anchor" href="#key的常见应用场景" aria-hidden="true">#</a> key的常见应用场景</h3>\n<p>key 的常见应用场景 =&gt; v-for,  v-for 遍历的列表中的项的顺序, 非常的容易改变</p>\n<p>1 往后面加, 默认的对比策略, 按照下标,  没有任何问题</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 旧</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 新</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">王五</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>2 往前面加, 由于下标变了, 如果按照之前的下标对比, 元素是混乱的, 策略: 加上key</p>\n<p>​    一旦加上了key, 就是按照 key 进行新旧dom的对比了</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 旧 </span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>17<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>31<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 新  [ { id: 17, name: \'张三\' }, ... ]</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>52<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">王五</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>17<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>31<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>总结: key 就是给 虚拟dom 添加了一个 标识, 优化了对比策略!!!</strong></p>\n<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h1>\n<h2 id="react最新的生命周期是怎么样的" tabindex="-1"><a class="header-anchor" href="#react最新的生命周期是怎么样的" aria-hidden="true">#</a> React最新的生命周期是怎么样的？</h2>\n<p>在 React 16 版本中，三个之前的生命周期被标识为废弃，并在 React 17 中计划全部删除它们：</p>\n<ul>\n<li>\n<p>componentWillMount</p>\n</li>\n<li>\n<p>componentWillReceiveProps</p>\n</li>\n<li>\n<p>componentWillUpdate</p>\n</li>\n</ul>\n<p>当它们被删除后，将会只保留三个添加了<code>UNSAVE_</code>前缀的函数版本，作为向下兼容用途。因此我们在新项目中，要尽量避免使用这几个生命周期而使用最新的生命周期函数。</p>\n<p>⽬前 React 16.8+ 的⽣命周期分为三个阶段：挂载阶段、更新阶段、卸载阶段。</p>\n<p><strong>挂载阶段</strong></p>\n<p><code>constructor</code> ：组件的构造函数，它会最先被执⾏，我们通常在构造函数⾥初始化 <code>state</code> 状态对象、或给⾃定义⽅法绑定 <code>this</code></p>\n<p><code>getDerivedStateFromProps</code> ：这是个静态⽅法，当我们接收到新的属性后想要去修改 <code>state</code> 时可以使用</p>\n<p><code>render</code>：这是个只返回需要渲染内容的纯函数，不要包含其它的业务逻辑，可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 值 和 null 值等内容</p>\n<p><code>componentDidMount</code> ：在组件装载后被调⽤，此时可以获取 DOM 节点并操作，对服务器的请求、订阅等操作都可以写在这个地方，但记得要在 <code>componentWillUnmount</code> 中取消订阅，即释放资源</p>\n<p><strong>更新阶段</strong></p>\n<p><code>getDerivedStateFromProps</code> ：此⽅法在更新个挂载阶段都可能会调⽤</p>\n<p><code>shouldComponentUpdate</code> ：该函数有两个参数 <code>nextProps</code> 和 <code>nextState</code>，表示新的属性和变化之后的状态；它返回⼀个布尔值，<code>true</code> 表示会触发重新渲染，<code>false</code> 则表示不会触发重新渲染，默认返回 <code>true</code>。我们通常利⽤该⽣命周期来优化 React 程序的性能</p>\n<p><code>render</code> ：更新阶段也会触发此⽣命周期</p>\n<p><code>getSnapshotBeforeUpdate</code> ：该⽅法在 <code>render</code> 之后、在 <code>componentDidUpdate</code> 之前被调⽤，它有两个参数 <code>prevProps</code> 和<code>prevState</code>，表示之前的属性和状态，并且该函数有⼀个返回值，返回值会作为第三个参数传给 <code>componentDidUpdate</code> ，如果不想要返回值则返回 <code>null</code> 即可。该⽣命周期必须与 <code>componentDidUpdate</code> 搭配使⽤</p>\n<p><code>componentDidUpdate</code> ：该⽅法在 <code>getSnapshotBeforeUpdate</code> ⽅法之后被调⽤，它有三个参数 <code>prevProps</code> 、<code>prevState</code> 、<code>snapshot</code> ，表示之前的属性、之前的状态、以及<code>snapshot</code>。第三个参数是 <code>getSnapshotBeforeUpdate</code> 所返回的，如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ <code>getSnapshotBeforeUpdate</code>，然后在 <code>componentDidUpdate</code> 中统⼀触发回调或更新状态</p>\n<p><strong>卸载阶段</strong></p>\n<p><code>componentWillUnmount</code> ：当组件被卸载或销毁时就会被调⽤，我们可以在这个函数⾥去做一些释放资源的操作，如：清除定时器、取消⽹络请求、清理⽆效的 DOM 元素等</p>\n<p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">React生命周期图形示意工具<ExternalLinkIcon/></a></p>\n<h2 id="在react中网络请求应该放在哪个生命周期中发起" tabindex="-1"><a class="header-anchor" href="#在react中网络请求应该放在哪个生命周期中发起" aria-hidden="true">#</a> 在React中网络请求应该放在哪个生命周期中发起？</h2>\n<p>有人认为 React 中的网络异步请求，应该放在 <code>componentWillMount</code> 这个生命周期函数中发起，这样可以提前进⾏异步请求，以避免⽩屏现象。其实这个观点是有问题的。</p>\n<p>由于 JavaScript 中异步事件的性质，当进行异步 API 调⽤时，浏览器会在此期间继续执⾏其他⼯作。因此，当 React 渲染⼀个组件时，它并不会等待 <code>componentWillMount</code> 执行完成任何事情，而是继续往前执行并继续做 <code>render</code> ，没有办法 “暂停” 渲染以等待远程数据的返回。</p>\n<p>⽽且，在 <code>componentWillMount</code> 中发起请求会存在⼀系列潜在问题：</p>\n<ul>\n<li>\n<p>在用 React 作为服务器渲染（SSR）时，如果在 <code>componentWillMount</code> 中进行数据的获取，则 <code>fetch data</code> 会执⾏两次：⼀次在服务端，⼀次在客户端，这就造成了多余的请求</p>\n</li>\n<li>\n<p>在 React 16 使用 React Fiber 架构重写后，<code>componentWillMount</code> 可能会在⼀次渲染中被多次调⽤。</p>\n</li>\n</ul>\n<p><strong>⽬前官⽅推荐的是在 <code>componentDidmount</code> 中进行异步请求。</strong></p>\n<p>如遇到特殊需求，需要提前进行数据的请求，可考虑采用在 <code>constructor</code> 中进行。</p>\n<p>另外，由于在 React 17 之后 <code>componentWillMount</code> 被废弃仅保留 <code>UNSAFE_componentWillMount</code>，所以要慎用该生命周期。</p>\n<h2 id="setstate是同步的还是异步的" tabindex="-1"><a class="header-anchor" href="#setstate是同步的还是异步的" aria-hidden="true">#</a> setState是同步的还是异步的？</h2>\n<p>答案是：有时表现出异步，有时表现出同步！</p>\n<ul>\n<li>在合成事件和生命周期钩⼦函数中是异步的</li>\n<li>在原⽣事件和 <code>setTimeout</code> 中是同步的</li>\n</ul>\n<p><code>setState</code> 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。</p>\n<p>当然，我们可以通过使用第⼆个参数来拿到更新后的结果，它是个回调函数：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">setState</span><span class="token punctuation">(</span>partialState<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>此外，<code>setState</code> 的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和 <code>setTimeout</code> 中不会批量更新。在异步中，如果对同⼀个值进⾏多次 <code>setState</code>，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时 <code>setState</code> 多个不同的值，则会在更新时对其进⾏合并批量更新。</p>\n<h2 id="react中如何实现组件间的通信" tabindex="-1"><a class="header-anchor" href="#react中如何实现组件间的通信" aria-hidden="true">#</a> React中如何实现组件间的通信？</h2>\n<p>组件间通信⽅式一共有如下几种：</p>\n<ol>\n<li>⽗组件向⼦组件通讯</li>\n</ol>\n<p>⽗组件可以通过向⼦组件传 <code>props</code> 的⽅式来实现父到子的通讯。</p>\n<ol start="2">\n<li>⼦组件向⽗组件通讯</li>\n</ol>\n<p>可以采用 <code>props + 回调</code> 的⽅式。</p>\n<p>当⽗组件向⼦组件传递 <code>props</code> 进⾏通讯时，可在该 <code>props</code> 中传递一个回调函数，当⼦组件调⽤该函数时，可将⼦组件中想要传递给父组件的信息作为参数传递给该函数。由于 <code>props</code> 中的函数作⽤域为⽗组件⾃身，因此可以通过该函数内的 <code>setState</code> 更新到⽗组件上。</p>\n<ol start="3">\n<li>兄弟组件通信</li>\n</ol>\n<p>可以通过兄弟节点的共同⽗节点，再结合以上2种⽅式，由⽗节点转发信息，实现兄弟间通信。</p>\n<ol start="4">\n<li>跨层级通信</li>\n</ol>\n<p>可以采用 React 中的 <code>Context</code> 来实现跨越多层的全局数据通信。</p>\n<p><code>Context</code> 设计的⽬的是为在⼀个组件树中共享 “全局” 数据，如：当前已登录的⽤户、界面主题、界面语⾔等信息。</p>\n<ol start="5">\n<li>发布订阅模式</li>\n</ol>\n<p>发布者发布事件，订阅者监听到事件后做出反应。</p>\n<p>我们可以通过引⼊ <code>event</code> 模块进⾏此种方式的通信。</p>\n<ol start="6">\n<li>全局状态管理⼯具</li>\n</ol>\n<p>可以借助 <code>Redux</code> 或 <code>Mobx</code> 等全局状态管理⼯具进⾏通信，它们会维护⼀个全局状态中⼼（Store），并可以根据不同的事件产⽣新的状态。</p>\n<img src="/images/image-20210223093430679.png" alt="image-20210223093430679" style="zoom:30%;" /> \n<h2 id="react存在哪些性能优化手段" tabindex="-1"><a class="header-anchor" href="#react存在哪些性能优化手段" aria-hidden="true">#</a> React存在哪些性能优化手段？</h2>\n<p>前端项目的性能手段，其实都是相通的。我们可以参考文章：<a href="https://blog.csdn.net/weixin_33976072/article/details/93168109" target="_blank" rel="noopener noreferrer">前端性能优化<ExternalLinkIcon/></a></p>\n<h2 id="react中如何进行组件和逻辑的复用" tabindex="-1"><a class="header-anchor" href="#react中如何进行组件和逻辑的复用" aria-hidden="true">#</a> React中如何进行组件和逻辑的复用？</h2>\n<p>React 中的组件抽象的技术有以下几种:</p>\n<ul>\n<li>\n<p>混合（mixin，官方已废弃）</p>\n</li>\n<li>\n<p>⾼阶组件（hoc）：属性代理、反向继承</p>\n</li>\n<li>\n<p>渲染属性（render props）</p>\n</li>\n<li>\n<p>React Hooks（配合函数式组件使用，函数拆分的复用理念）</p>\n</li>\n</ul>\n<h2 id="mixin、hoc、render-props、react-hooks的优缺点分别是什么" tabindex="-1"><a class="header-anchor" href="#mixin、hoc、render-props、react-hooks的优缺点分别是什么" aria-hidden="true">#</a> Mixin、HoC、Render props、React Hooks的优缺点分别是什么？</h2>\n<p><strong>Mixin</strong></p>\n<ul>\n<li>\n<p>组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖于组件的特定⽅法，但在定义组件时并不知道这种依赖关系）</p>\n</li>\n<li>\n<p>多个 Mixin 之间可能产⽣冲突，⽐如：多个 Mixin 中定义了相同的 state 字段，在一个组件中同时引入这些 Mixin 后会产生字段冲突</p>\n</li>\n<li>\n<p>Mixin 倾向于增加更多状态，这降低了应⽤的可预测性，状态越多越难管理和溯源，复杂度剧增</p>\n</li>\n<li>\n<p>隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：</p>\n<ul>\n<li>\n<p>难以快速理解组件的⾏为，需要全盘了解所有依赖 Mixin 的扩展⾏为及其之间的相互影响</p>\n</li>\n<li>\n<p>33333组件⾃身的⽅法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它</p>\n</li>\n<li>\n<p>Mixin 也难以维护，因为 Mixin 逻辑最后会被摊平合并到⼀起，很难搞清楚⼀个 Mixin 的输⼊输出</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>HoC</strong></p>\n<p>优点：</p>\n<p>相⽐ Mixin，HoC 通过外层组件传递 props 来影响内层组件的状态，⽽不是直接改变其 state，这就不存在冲突和互相⼲扰，降低了耦合度。不同于 Mixin 的打平 + 合并，HoC 天然具有层级结构（组件树结构），这⼜降低了复杂度。</p>\n<p>缺点：</p>\n<ul>\n<li>\n<p>扩展性限制：HoC ⽆法从外部访问⼦组件的 state，因此⽆法通过 <code>shouldComponentUpdate</code> 滤掉不必要的更新；React 在⽀持ES6 Class 之后提供了 <code>React.PureComponent</code> 解决了这个问题</p>\n</li>\n<li>\n<p>Ref 传递问题：Ref 被隔断。后来出现了 <code>React.forwardRef</code> 来解决了这个问题</p>\n</li>\n<li>\n<p>包装地狱（Wrapper Hell）：和回调函数类似，HoC 如果出现多层包裹组件的情况，就会和回调函数一样层层嵌套；而这种多层抽象同样也增加了复杂度和理解成本</p>\n</li>\n<li>\n<p>命名冲突：如果⾼阶组件多次嵌套而没有使⽤命名空间，就可能会产⽣冲突，覆盖⽼的属性</p>\n</li>\n<li>\n<p>不可⻅性：HoC 相当于在原有组件外层再包装⼀个组件，你有可能压根都不知道外层的包装是什么，对于你来说完全是⿊盒</p>\n</li>\n</ul>\n<p><strong>Render Props</strong></p>\n<p>优点：</p>\n<p>上述所说的 HoC 缺点，使用 Render Props 都可得到解决。</p>\n<p>缺点：</p>\n<ul>\n<li>\n<p>使⽤繁琐：HoC 使⽤只需要借助装饰器语法，通常⼀⾏代码就可以进⾏复⽤，而 Render Props ⽆法做到如此简单</p>\n</li>\n<li>\n<p>嵌套过深：Render Props 虽然摆脱了组件多层嵌套问题，但其又会走回到了回调函数的嵌套问题</p>\n</li>\n</ul>\n<p><strong>React Hooks</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>简洁：React Hooks 解决了 HoC 和 Render Props 的嵌套问题，代码更加简洁</p>\n</li>\n<li>\n<p>解耦：React Hooks 可以更⽅便地把 UI 和状态分离，做到更彻底的解耦</p>\n</li>\n<li>\n<p>组合：Hooks 中可以通过引⽤另外的 Hooks 以此形成新的 Hooks，变化丰富</p>\n</li>\n<li>\n<p>函数友好：React Hooks 为函数组件⽽⽣，从⽽解决了类组件的⼏⼤问题:</p>\n<ul>\n<li>\n<p>this 指向容易错误</p>\n</li>\n<li>\n<p>分割在不同声明周期中的逻辑会使得代码难以理解和维护</p>\n</li>\n<li>\n<p>代码复⽤成本⾼（⾼阶组件容易使代码量剧增）</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>有额外的学习成本（需要学习和区分类组件、函数组件）</p>\n</li>\n<li>\n<p>写法上有限制（不能出现在条件、循环中），并且这种写法限制会增加代码重构时的成本</p>\n</li>\n<li>\n<p>破坏了 <code>PureComponent</code>、<code>React.memo</code> 浅⽐较的性能优化效果（为了获取最新的 props 和 state，每次 <code>render()</code> 都要重新</p>\n</li>\n</ul>\n<p>创建事件处理函数）</p>\n<ul>\n<li>在闭包场景中可能会引⽤到旧的 state、props 值</li>\n<li>内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”）</li>\n<li><code>React.memo</code> 并不能完全替代 <code>shouldComponentUpdate</code>（因为获取不到 state 的变化，只针对 props 的变化）</li>\n</ul>\n<h2 id="redux的工作流程是怎么样的" tabindex="-1"><a class="header-anchor" href="#redux的工作流程是怎么样的" aria-hidden="true">#</a> Redux的工作流程是怎么样的？</h2>\n<p><strong>核心概念</strong></p>\n<ul>\n<li>\n<p><code>Store</code>：一个保存数据的容器，整个应⽤只有⼀个 Store</p>\n</li>\n<li>\n<p><code>State</code>：Store 对象内包含所有数据，如想得到某一时间点的数据，就要对 Store ⽣成快照，这种时间点的数据集合，就叫 State</p>\n</li>\n<li>\n<p><code>Action</code>：State 的变化会导致 View 的变化，但⽤户是接触不到 State 的，只能接触到 View，所以 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了</p>\n</li>\n<li>\n<p><code>Action Creator</code>：View 要发送多少种消息，就需要有多少种 Action，如果都⼿写会比较麻烦，因此我们通常会定义一个用于生成 Action 的函数，该函数就被称为 Action Creator</p>\n</li>\n<li>\n<p><code>Reducer</code>：在 Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做Reducer。Reducer 是⼀个函数，它接收 Action 和当前 State 作为参数，返回值是⼀个新的 State</p>\n</li>\n<li>\n<p><code>dispatch</code>：是 View 发送 Action 的唯⼀⽅法</p>\n</li>\n</ul>\n<p><strong>⼯作流程</strong></p>\n<img src="/images/image-20210223103127034.png" alt="image-20210223103127034" style="zoom:90%;" />\n<p>⼀次⽤户交互的流程如下：</p>\n<ol>\n<li>\n<p>⾸先，View（通过⽤户）发出 Action，发出⽅式就是使用 <code>dispatch</code> ⽅法</p>\n</li>\n<li>\n<p>然后，Store 调⽤ Reducer 并且传⼊两个参数（当前的 State 和收到的 Action），Reducer 处理后返回新的 State</p>\n</li>\n<li>\n<p>State ⼀旦有变化，则 Store 会调⽤监听函数来通知 View 进行更新</p>\n</li>\n</ol>\n<p>注意，在整个流程中，数据都是单向流动的，我们称之为单向数据流，这种⽅式可以保证流程的清晰性。</p>\n<h2 id="react-redux这个库是如何工作的" tabindex="-1"><a class="header-anchor" href="#react-redux这个库是如何工作的" aria-hidden="true">#</a> react-redux这个库是如何工作的？</h2>\n<p><strong>核心概念</strong></p>\n<p><strong><code>Provider</code></strong></p>\n<p>Provider 的作⽤是从最外部封装了整个应⽤，并向 <code>connect</code> 模块传递 <code>store</code> 。</p>\n<p><strong><code>connect</code></strong></p>\n<p>负责将 React 和 Redux 关联起来，它的作用主要如下：</p>\n<ul>\n<li>\n<p>获取 <code>state</code>：<code>connect</code> 先通过 <code>context</code> 来获取存放在 <code>Provider</code> 中的 <code>store</code>，然后通过 <code>store.getState()</code> 来获取整个 <code>store tree</code> 上所存放的 <code>state</code></p>\n</li>\n<li>\n<p>包装原组件：<code>connect</code> 将 <code>state</code> 和 <code>action</code> 通过 <code>props</code> 传⼊到原组件的内部，并调用 <code>wrapWithConnect</code> 函数来包装和返回⼀个 <code>Connect</code> 对象，<code>Connect</code> 对象重新 <code>render</code> 外部传⼊的原组件，并把 <code>connect</code> 中传⼊的 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 与组件原有的 <code>props</code> 合并后，通过属性的⽅式传给包装组件</p>\n</li>\n<li>\n<p>监听 <code>store tree</code> 变化：<code>connect</code> 缓存了 <code>store tree</code> 中 <code>state</code> 的状态，通过对比当前 <code>state </code> 和变更前 <code>state</code>，确定是否需要调⽤ <code>this.setState()</code> ⽅法，以此触发 <code>Connect</code> 及其⼦组件的重新渲染</p>\n</li>\n</ul>\n<p><strong>流程图</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210223104924017" originSrc="/images/image-20210223104924017.png" data="aurora"></p>\n<h2 id="redux和mobx的区别" tabindex="-1"><a class="header-anchor" href="#redux和mobx的区别" aria-hidden="true">#</a> Redux和Mobx的区别？</h2>\n<table>\n<thead>\n<tr>\n<th>比较点</th>\n<th>Redux</th>\n<th>Mobx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储方式</td>\n<td>保存在单⼀的 store 中</td>\n<td>保存在分散的多个 store 中</td>\n</tr>\n<tr>\n<td>数据结构</td>\n<td>使⽤ plain object 保存数据，需要⼿动处理变化后的操作</td>\n<td>使⽤ observable 保存数据，数据变化后⾃动处理响应的操作（类似 Vuex）</td>\n</tr>\n<tr>\n<td>数据可变性</td>\n<td>不可变状态，只读不能直接修改，应使⽤纯函数返回⼀个新状态</td>\n<td>状态是可变的，可直接进⾏修改</td>\n</tr>\n<tr>\n<td>难易度</td>\n<td>比较复杂<br />涉及函数式编程思想，掌握起来不那么容易，同时需借助⼀些中间件处理异步和副作⽤</td>\n<td>比较简单<br />使用面向对象的编程思维</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>容易<br />使用纯函数，并提供了时间回溯⼯具，因此调试直观方便</td>\n<td>⽐较困难<br />有更多的对象抽象和封装，调试会⽐较困难</td>\n</tr>\n</tbody>\n</table>\n<p><strong>使⽤场景</strong></p>\n<p><code>Mobx</code></p>\n<ul>\n<li>\n<p>更适合数据不复杂的应⽤。因为 mobx 难以调试，很多状态⽆法回溯，⾯对复杂度⾼的应⽤时往往⼒不从⼼</p>\n</li>\n<li>\n<p>适合短平快的项⽬。因为 mobx上⼿简单，样板代码少，很⼤程度上提⾼了开发效率</p>\n</li>\n</ul>\n<p><code>Redux</code></p>\n<ul>\n<li>适合有回溯需求的应⽤。⽐如，画板、表格等应⽤，一般有撤销、重做等操作，由于 Redux 具有不可变的特性，天然⽀持这些操作</li>\n</ul>\n<p>我们也可以在一个项目中同时使用 <code>Mobx</code> 和 <code>Redux</code> ，让两者发挥各自的长处，比如：</p>\n<ul>\n<li>使用 <code>Redux</code> 作为全局状态管理</li>\n<li>使⽤ <code>Mobx </code>作为组件的局部状态管理器</li>\n</ul>\n<h2 id="在redux中如何进行异步操作" tabindex="-1"><a class="header-anchor" href="#在redux中如何进行异步操作" aria-hidden="true">#</a> 在Redux中如何进行异步操作？</h2>\n<p>一般项目中，我们可以直接在 <code>componentDidMount</code> 中进⾏异步操作，比如发送网络请求，⽆须借助 Redux。但如果我们的项目上了一定的规模，这种方法再管理异步流的时候就比较困难。这个时候，我们会借助 Redux 的异步中间件来进⾏异步处理。</p>\n<p>Redux 其实有多种异步中间件，但当下主流的只有两种：<code>redux-thunk</code> 和 <code>redux-saga</code>。</p>\n<p><strong>redux-thunk</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>体积⼩：redux-thunk 的实现⽅式很简单，只有不到20⾏代码</p>\n</li>\n<li>\n<p>使⽤简单：redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的编程范式，上⼿非常简单</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>样板代码过多：与 redux 本身⼀样，通常发送⼀个请求就需要编写⼤量代码，⽽且很多都是重复性的</p>\n</li>\n<li>\n<p>耦合严重：异步操作与 redux 的 action 偶合在⼀起，不⽅便管理</p>\n</li>\n<li>\n<p>功能薄弱：实际开发中常⽤的⼀些功能都需要⾃⼰封装</p>\n</li>\n</ul>\n<p><strong>redux-saga</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>异步解耦：异步操作被被转移到了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中</p>\n</li>\n<li>\n<p>action 摆脱了 thunk function：dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满了 “⿊魔法” 的 thunk function</p>\n</li>\n<li>\n<p>异常处理：受益于 Generator Function 的 saga 实现，代码异常/请求失败都可直接通过 try/catch 捕获处理</p>\n</li>\n<li>\n<p>功能强⼤：redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器，开发者⽆须自行封装、或只要简单封装即可使⽤</p>\n</li>\n<li>\n<p>灵活：redux-saga 可将多个 Saga 进行串⾏或并⾏组合，形成⼀个⾮常实⽤的异步流程</p>\n</li>\n<li>\n<p>易测试：提供了各种测试⽅案，包括 mock task、分⽀覆盖等</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>额外的学习成本：redux-saga 不仅使⽤了难以理解的 Generator Function，⽽且存在数⼗个 API，学习成本远超 redux-thunk；最重要的是，这些额外的学习成本只能用于使用这个库的（而对于 redux-observable 来说，它虽也有学习成本，但它基于 rxjs ，这套编程思想和技术体系可以沿用到其他地方去）</p>\n</li>\n<li>\n<p>体积庞⼤：代码近 2000 ⾏（压缩后大约 25KB）</p>\n</li>\n<li>\n<p>功能过剩：其中提供的并发控制等功能，实际开发中很难会⽤到，但我们依然要引⼊这些代码</p>\n</li>\n<li>\n<p>对 TS ⽀持不友好：yield ⽆法返回 TS 类型</p>\n</li>\n</ul>\n<p><strong>redux-observable</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>功能最强：由于基于 rxjs 这个强⼤的响应式编程库，借助 rxjs 的操作符⼏乎可以做任何你能想到的异步处理</p>\n</li>\n<li>\n<p>知识沿用：如果你已学习过 rxjs，那么 redux-observable 的学习成本并不⾼；⽽且，随着 rxjs 的升级，redux-observable 也会变得更强⼤</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>学习成本奇⾼：对于还不会 rxjs 的开发者来说，需要额外的学习两个都较为复杂的库</p>\n</li>\n<li>\n<p>社区⼀般：redux-observable 下载量只有 redux-saga 的 1/5，社区不够活跃，而 redux-saga 仍处于领导地位</p>\n</li>\n</ul>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/前端面试手册/前端面试手册.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"前端面试手册",filePath:"D:/桌面文件/Blog/blog-demo/docs/前端面试手册/前端面试手册.md",filePathRelative:"前端面试手册/前端面试手册.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/前端面试手册/前端面试手册.html.vue",componentFilePathRelative:"pages/前端面试手册/前端面试手册.html.vue",componentFileChunkName:"v-0a97e47a",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/前端面试手册/前端面试手册.html.js",dataFilePathRelative:"pages/前端面试手册/前端面试手册.html.js",dataFileChunkName:"v-0a97e47a",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/前端面试手册/前端面试手册.html",htmlFilePathRelative:"前端面试手册/前端面试手册.html"},{data:{key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],git:{}},key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/404.html.vue",componentFilePathRelative:"pages/404.html.vue",componentFileChunkName:"v-3706649a",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/404.html.js",dataFilePathRelative:"pages/404.html.js",dataFileChunkName:"v-3706649a",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/404.html",htmlFilePathRelative:"404.html"},{data:{key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],git:{}},key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/index.html.vue",componentFilePathRelative:"pages/index.html.vue",componentFileChunkName:"v-8daa1a0e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/index.html.js",dataFilePathRelative:"pages/index.html.js",dataFileChunkName:"v-8daa1a0e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/index.html",htmlFilePathRelative:"index.html"},{data:{key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],git:{}},key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/about/index.html.vue",componentFilePathRelative:"pages/about/index.html.vue",componentFileChunkName:"v-74bc627b",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/about/index.html.js",dataFilePathRelative:"pages/about/index.html.js",dataFileChunkName:"v-74bc627b",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/about/index.html",htmlFilePathRelative:"about/index.html"},{data:{key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],git:{}},key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/mood/index.html.vue",componentFilePathRelative:"pages/mood/index.html.vue",componentFileChunkName:"v-14f724bf",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/mood/index.html.js",dataFilePathRelative:"pages/mood/index.html.js",dataFileChunkName:"v-14f724bf",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/mood/index.html",htmlFilePathRelative:"mood/index.html"},{data:{key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],git:{}},key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/link/index.html.vue",componentFilePathRelative:"pages/link/index.html.vue",componentFileChunkName:"v-14e6501c",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/link/index.html.js",dataFilePathRelative:"pages/link/index.html.js",dataFileChunkName:"v-14e6501c",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/link/index.html",htmlFilePathRelative:"link/index.html"},{data:{key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],git:{}},key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/tag/index.html.vue",componentFilePathRelative:"pages/tag/index.html.vue",componentFileChunkName:"v-744d024e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/tag/index.html.js",dataFilePathRelative:"pages/tag/index.html.js",dataFileChunkName:"v-744d024e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/tag/index.html",htmlFilePathRelative:"tag/index.html"},{data:{key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],git:{}},key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/archive/index.html.vue",componentFilePathRelative:"pages/archive/index.html.vue",componentFileChunkName:"v-705c21a6",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/archive/index.html.js",dataFilePathRelative:"pages/archive/index.html.js",dataFileChunkName:"v-705c21a6",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/archive/index.html",htmlFilePathRelative:"archive/index.html"},{data:{key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],git:{}},key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/aurora-archive/index.html.vue",componentFilePathRelative:"pages/aurora-archive/index.html.vue",componentFileChunkName:"v-3279cf61",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/aurora-archive/index.html.js",dataFilePathRelative:"pages/aurora-archive/index.html.js",dataFileChunkName:"v-3279cf61",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/aurora-archive/index.html",htmlFilePathRelative:"aurora-archive/index.html"}]},7039:(n,s,a)=>{a.d(s,{Z:()=>t});const t=[{data:{key:"v-ef444906",path:"/Git/git.html",title:"Git",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git基础入门",slug:"git基础入门",children:[{level:3,title:"git的安装",slug:"git的安装",children:[]},{level:3,title:"git三个区",slug:"git三个区",children:[]},{level:3,title:"git基本命令",slug:"git基本命令",children:[]},{level:3,title:"git重置",slug:"git重置",children:[]},{level:3,title:"git忽视文件",slug:"git忽视文件",children:[]}]},{level:2,title:"git分支操作",slug:"git分支操作",children:[{level:3,title:"为什么要有分支？",slug:"为什么要有分支",children:[]},{level:3,title:"git分支命令",slug:"git分支命令",children:[]},{level:3,title:"git合并冲突",slug:"git合并冲突",children:[]}]},{level:2,title:"git远程仓库",slug:"git远程仓库",children:[{level:3,title:"github、gitee、gitlab",slug:"github、gitee、gitlab",children:[]},{level:3,title:"码云创建远程仓库",slug:"码云创建远程仓库",children:[]},{level:3,title:"SSH免密码登陆",slug:"ssh免密码登陆",children:[]},{level:3,title:"SSH免密码登录配置",slug:"ssh免密码登录配置",children:[]},{level:3,title:"git push",slug:"git-push",children:[]},{level:3,title:"git remote",slug:"git-remote",children:[]},{level:3,title:"git clone",slug:"git-clone",children:[]},{level:3,title:"git pull",slug:"git-pull",children:[]},{level:3,title:"下载远端分支本地",slug:"下载远端分支本地",children:[]}]}],git:{}},key:"v-ef444906",path:"/Git/git.html",title:"Git",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"git基础入门",slug:"git基础入门",children:[{level:3,title:"git的安装",slug:"git的安装",children:[]},{level:3,title:"git三个区",slug:"git三个区",children:[]},{level:3,title:"git基本命令",slug:"git基本命令",children:[]},{level:3,title:"git重置",slug:"git重置",children:[]},{level:3,title:"git忽视文件",slug:"git忽视文件",children:[]}]},{level:2,title:"git分支操作",slug:"git分支操作",children:[{level:3,title:"为什么要有分支？",slug:"为什么要有分支",children:[]},{level:3,title:"git分支命令",slug:"git分支命令",children:[]},{level:3,title:"git合并冲突",slug:"git合并冲突",children:[]}]},{level:2,title:"git远程仓库",slug:"git远程仓库",children:[{level:3,title:"github、gitee、gitlab",slug:"github、gitee、gitlab",children:[]},{level:3,title:"码云创建远程仓库",slug:"码云创建远程仓库",children:[]},{level:3,title:"SSH免密码登陆",slug:"ssh免密码登陆",children:[]},{level:3,title:"SSH免密码登录配置",slug:"ssh免密码登录配置",children:[]},{level:3,title:"git push",slug:"git-push",children:[]},{level:3,title:"git remote",slug:"git-remote",children:[]},{level:3,title:"git clone",slug:"git-clone",children:[]},{level:3,title:"git pull",slug:"git-pull",children:[]},{level:3,title:"下载远端分支本地",slug:"下载远端分支本地",children:[]}]}],content:"# Git\r\n\r\n## git基础入门\r\n\r\n> Git是一款免费、开源的**分布式** **版本控制系统** ，用于敏捷高效地处理任何或小或大的项目。\r\n\r\n> Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\r\n\r\n### git的安装\r\n\r\n[下载地址](https://git-scm.com/download/win)\r\n\r\n注意：\r\n\r\n1. 不要安装在中文目录\r\n2. 不要使用桌面管理软件\r\n\r\n安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。\r\n\r\n\r\n### git三个区\r\n\r\n要对某个项目使用git进行管理，需要使用`git init`命令初始化git仓库\r\n`git init`会在当前目录生成一个隐藏文件夹 .git  不要去修改这个文件夹下的任意东西。\r\n\r\ngit仓库会分成三个区\r\n\r\n工作区：我们书写代码的地方，工作的目录就叫工作区。\r\n\r\n暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。\r\n\r\n本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。\r\n\r\n### git基本命令\r\n\r\n#### git init\r\n\r\n+ 作用：初始化git仓库，想要使用git对某个项目进行管理，需要`git init`进行初始化\r\n\r\n```bash\r\n# 初始化仓库， 在当前目录下生成一个隐藏文件夹.git\r\ngit init\r\n```\r\n\r\n#### git add\r\n\r\n- 作用：将文件由 `工作区` 添加到 `暂存区`，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。\r\n- 命令：`git add 文件名/目录名`\r\n\r\n```bash\r\n# 将index.html添加到暂存区\r\ngit add index.html\r\n\r\n# 将css目录下所有的文件添加到暂存区\r\ngit add css\r\n\r\n# 将当前目录下所有的js文件添加到暂存区\r\ngit add *.js\r\n\r\n# 添加当前目录下所有的文件\r\ngit add .\r\ngit add -A\r\ngit add --all\r\n```\r\n\r\n#### git commit\r\n\r\n作用：将文件由 暂存区 添加到 仓库区，生成版本号\r\n\r\n```bash\r\n# 将文件从暂存区提交到仓库\r\ngit commit -m \"提交说明\"\r\n\r\n# 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。\r\ngit commit -a -m '提交说明'\r\n\r\n# 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令\r\ngit commit --amend -m \"提交说明\"\r\n```\r\n\r\n#### git config配置\r\n\r\n如果是第一次提交，需要配置提交者信息，推荐和公司邮箱一致（可以用QQ邮箱）\r\n\r\n```Bash\r\n# git config  user.name 你的目标用户名\r\n# git config  user.email 你的目标邮箱名\r\n\r\n# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可\r\ngit config  --global user.name jepson\r\ngit config  --global user.email jepsonpp@qq.com\r\n\r\n# 查看配置信息\r\ngit config --list\r\n\r\n# 取消配置\r\ngit config --unset --global user.name\r\ngit config --unset --global user.email \r\n```\r\n\r\n#### git status\r\n\r\n- 作用：查看文件的状态\r\n\r\n\r\n- 命令：`git status` \r\n  - 红色表示工作区中的文件需要提交\r\n  - 绿色表示暂存区中的文件需要提交\r\n- 命令：`git stauts -s` 简化日志输出格式\r\n\r\n#### git log\r\n\r\n- 作用：查看提交日志\r\n- `git log` 查看提交的日志\r\n- `git log --oneline` 简洁的日志信息\r\n\r\n![](./assets/git01.png)\r\n\r\n\r\n\r\n### git重置\r\n\r\n#### git reset\r\n\r\n- 作用：版本回退，将代码恢复到已经提交的某一个版本中。\r\n- `git reset --hard 版本号` 将代码回退到某个指定的版本(版本号只要有前几位即可)\r\n- `git reset --hard head~1`将版本回退到上一次提交\r\n  - ~1:上一次提交\r\n  - ~2:上上次提交\r\n  - ~0:当前提交\r\n\r\n\r\n- 当使用了`git reset`命令后，版本会回退，使用`git log`只能看到当前版本之前的信息。使用`git reflog`可以查看所有的版本信息\r\n\r\n###  git忽视文件\r\n\r\n> 在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。\r\n\r\n- 在仓库的根目录创建一个`.gitignore`的文件，文件名是固定的。\r\n- 将不需要被git管理的文件路径添加到`.gitignore`中\r\n\r\n```bash\r\n# 忽视idea.txt文件\r\nidea.txt\r\n\r\n# 忽视css下的index.js文件\r\ncss/index.js\r\n\r\n# 忽视css下的所有的js文件\r\ncss/*.js\r\n\r\n# 忽视css文件夹\r\ncss\r\n```\r\n\r\n## git分支操作\r\n\r\n分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。\r\n\r\n如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！\r\n\r\n![](./assets/fenzhi.png)\r\n\r\n### 为什么要有分支？\r\n\r\n- 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。\r\n- 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。\r\n\r\n\r\n### git分支命令\r\n\r\n> 在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支\r\n\r\n#### 创建分支\r\n\r\n- `git branch 分支名称`创建分支，分支中的代码，在创建时与当前分支的内容完全相同。\r\n- git在第一次提交时，就有了一个叫`master`的主分支。\r\n- `git branch dev`，创建了一个叫做dev的分支\r\n\r\n#### 查看分支\r\n\r\n- `git branch`可以查看所有的分支，\r\n- 在当前分支的前面会有一个`*`\r\n- 在git中，有一个特殊指针`HEAD`,永远会指向当前分支\r\n\r\n#### 切换分支\r\n\r\n- `git checkout 分支名称`切换分支  HEAD指针指向了另一个分支\r\n- 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。\r\n- 提交代码时，会生产版本号，当前分支会指向最新的版本号。\r\n\r\n#### 创建并切换分支\r\n\r\n- `git checkout -b 分支名称` 创建并切换分支\r\n- 切换分支会做两件事情\r\n  - 创建一个新分支\r\n  - 把head指针指向当前的分支\r\n\r\n#### 删除分支\r\n\r\n- `git branch -d 分支名称` 可以删除分支\r\n- 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。\r\n- 注意：`master`分支是可以删除的，但是不推荐那么做。\r\n\r\n#### 合并分支\r\n\r\n- `git merge 分支名称` 将其他分支的内容合并到当前分支。\r\n- 在`master`分支中执行`git merge dev` 将`dev`分支中的代码合并到`master`分支\r\n- [分支合并](https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)\r\n\r\n### git合并冲突\r\n\r\n- 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。\r\n- 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。\r\n\r\n\r\n> \r\n\r\n```jsx\r\ndocument.querySelector('#btn-login').addEventListener('click', async function() {\r\n  const data = serialize(document.querySelector('form'), { hash: true })\r\n  // 非空校验\r\n  if (!data.username) return tip('请输入用户名')\r\n  if (!data.password) return tip('请输入密码')\r\n  if (data.password.length < 6) return tip('密码的长度不能小于6位')\r\n\r\n  try {\r\n    const res = await axios.post('/login', data)\r\n    localStorage.setItem('user-token', res.data.data.token)\r\n    localStorage.setItem('user-name', res.data.data.username)\r\n    tip('登录成功')\r\n    location.href = './index.html'\r\n  }\r\n  catch (e) {\r\n    tip('用户名或者密码错误')\r\n  }\r\n})\r\n```\r\n\r\n## git远程仓库\r\n\r\n### github、gitee、gitlab\r\n\r\n- git是一个版本控制工具。\r\n- github是一个代码托管平台，开源社区，是git的一个远程代码仓库平台。\r\n\r\n```javascript\r\n//1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。\r\n//2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。\r\n//3. 创建git项目时，不能有中文。\r\n```\r\n\r\n[github官网](https://github.com/)： 国外开源 git 代码托管平台\r\n\r\n[开源中国-git](https://git.oschina.net/):  国内开源 git 代码托管平台\r\n\r\n[gitlab](https://about.gitlab.com/)：企业级 git 代码托管平台\r\n\r\n\r\n\r\n### 码云创建远程仓库\r\n\r\n1. 新建右上角仓库\r\n\r\n   ![image-20220514184557788](assets/image-20220514184557788.png)\r\n\r\n\r\n2. 输入仓库名  **不勾初始化！！！**\r\n\r\n   ![image-20220514184702951](assets/image-20220514184702951.png)\r\n\r\n\r\n\r\n3. 点击创建\r\n\r\n![image-20220514184807839](assets/image-20220514184807839.png)\r\n\r\n\r\n\r\n\r\n\r\n### SSH免密码登陆\r\n\r\ngit支持多种数据传输协议：\r\n\r\n- https协议：`https://gitee.com/jepsonpp/test.git`  需要输入用户名和密码\r\n- ssh协议：`git@gitee.com:jepsonpp/test.git`   可以配置免密码登录\r\n\r\n每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。\r\n\r\n- github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push\r\n- 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码\r\n\r\n\r\n\r\n### SSH免密码登录配置\r\n\r\n- 1 创建SSH Key：`ssh-keygen -t rsa`    （注意：这些命令需要在bash中敲）\r\n- 2 在文件路径 `C:\\用户\\当前用户名\\` 找到 `.ssh` 文件夹\r\n- 3 文件夹中有两个文件：\r\n  - 私钥：`id_rsa`\r\n  - 公钥：`id_rsa.pub`\r\n- 4 在 `码云-> 设置 -> SSH公钥`页面中\r\n- 5 粘贴 公钥 `id_rsa.pub` 内容到对应文本框中， 添加公钥\r\n\r\n\r\n\r\n### git push\r\n\r\n- 作用：将本地仓库中代码提交到远程仓库\r\n- `git push 仓库地址 分支名`   将代码提交到远程仓库对应分支\r\n- 例子：`git push git@gitee.com:jepsonpp/test.git master` \r\n\r\n```\r\ngit push <远程主机名> <本地分支名>:<远程分支名>\r\n如果本地分支名与远程分支名相同，则可以省略冒号\r\n```\r\n\r\n\r\n\r\n### git remote\r\n\r\n每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名\r\n\r\n```bash\r\n# 给远程仓库设置一个别名\r\ngit remote add 仓库别名 仓库地址\r\ngit remote add origin git@gitee.com:jepsonpp/test.git\r\n\r\n# 删除origin这个别名\r\ngit remote remove origin\r\n```\r\n\r\n演示命令：`git push -u 仓库别名 分支名`\r\n\r\n\r\n\r\n### git clone\r\n\r\n- 作用：克隆远程仓库的代码到本地\r\n- git clone [远程仓库地址]\r\n- `git clone git@gitee.com:jepsonpp/test.git`会在本地新建一个`test`文件夹\r\n- 在test中包含了一个`.git`目录，用于保存所有的版本记录，同时test文件中还有最新的代码，可以进行后续的开发。\r\n- git克隆默认会使用远程仓库的项目名字，也可以自己指定。命令：`git clone [远程仓库地址] [本地项目名]`\r\n\r\ntips: `git branch -a`  查看分支\r\n\r\n\r\n\r\n### git pull\r\n\r\n- 作用：拉取更新，将远程的代码下载合并到本地的分支\r\n\r\n\r\n- 通常在push前，需要先pull一次。\r\n\r\n```bash\r\n# 获取远程仓库的更新，并且与本地的分支进行合并\r\ngit pull\r\ngit pull <远程主机名> <分支名>\r\ngit pull origin login  # 获取远程分支的更新，并更新合并到login分支\r\n```\r\n\r\n### 下载远端分支本地\r\n\r\n`checkout` 的 `-t `(或) `--track `)选项仅在创建新的(本地)分支时使用\r\n\r\n先在本地建立一个分支，并切换到该分支，然后从远程分支上同步代码到该分支上，并建立关联\r\n\r\n```git\r\ngit checkout -t origin/develop     #远端分支名和本地新建分支名同名\r\n```\r\n\r\n**后续拉取该分支的更新，就是切换到该分支，git  pull  origin 分支名**\r\n\r\n1. 将数据可视化项目上传到码云仓库,  主分支与开发分支均要上传\r\n\r\n```git\r\ngit push origin master\r\n\r\ngit push origin develop\r\n```\r\n\r\n2. 删除本地项目，通过克隆把远端仓库项目拉取下来，切换到develop分支\r\n\r\n```git\r\ngit clone 仓库地址\r\n\r\ngit checkout -t origin/develop\r\n```\r\n",contentRendered:'<h1 id="git" tabindex="-1"><a class="header-anchor" href="#git" aria-hidden="true">#</a> Git</h1>\n<h2 id="git基础入门" tabindex="-1"><a class="header-anchor" href="#git基础入门" aria-hidden="true">#</a> git基础入门</h2>\n<blockquote>\n<p>Git是一款免费、开源的<strong>分布式</strong> <strong>版本控制系统</strong> ，用于敏捷高效地处理任何或小或大的项目。</p>\n</blockquote>\n<blockquote>\n<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>\n</blockquote>\n<h3 id="git的安装" tabindex="-1"><a class="header-anchor" href="#git的安装" aria-hidden="true">#</a> git的安装</h3>\n<p><a href="https://git-scm.com/download/win" target="_blank" rel="noopener noreferrer">下载地址<ExternalLinkIcon/></a></p>\n<p>注意：</p>\n<ol>\n<li>不要安装在中文目录</li>\n<li>不要使用桌面管理软件</li>\n</ol>\n<p>安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。</p>\n<h3 id="git三个区" tabindex="-1"><a class="header-anchor" href="#git三个区" aria-hidden="true">#</a> git三个区</h3>\n<p>要对某个项目使用git进行管理，需要使用<code>git init</code>命令初始化git仓库\n<code>git init</code>会在当前目录生成一个隐藏文件夹 .git  不要去修改这个文件夹下的任意东西。</p>\n<p>git仓库会分成三个区</p>\n<p>工作区：我们书写代码的地方，工作的目录就叫工作区。</p>\n<p>暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。</p>\n<p>本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。</p>\n<h3 id="git基本命令" tabindex="-1"><a class="header-anchor" href="#git基本命令" aria-hidden="true">#</a> git基本命令</h3>\n<h4 id="git-init" tabindex="-1"><a class="header-anchor" href="#git-init" aria-hidden="true">#</a> git init</h4>\n<ul>\n<li>作用：初始化git仓库，想要使用git对某个项目进行管理，需要<code>git init</code>进行初始化</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 初始化仓库， 在当前目录下生成一个隐藏文件夹.git</span>\n<span class="token function">git</span> init\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="git-add" tabindex="-1"><a class="header-anchor" href="#git-add" aria-hidden="true">#</a> git add</h4>\n<ul>\n<li>作用：将文件由 <code>工作区</code> 添加到 <code>暂存区</code>，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。</li>\n<li>命令：<code>git add 文件名/目录名</code></li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 将index.html添加到暂存区</span>\n<span class="token function">git</span> <span class="token function">add</span> index.html\n\n<span class="token comment"># 将css目录下所有的文件添加到暂存区</span>\n<span class="token function">git</span> <span class="token function">add</span> css\n\n<span class="token comment"># 将当前目录下所有的js文件添加到暂存区</span>\n<span class="token function">git</span> <span class="token function">add</span> *.js\n\n<span class="token comment"># 添加当前目录下所有的文件</span>\n<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>\n<span class="token function">git</span> <span class="token function">add</span> -A\n<span class="token function">git</span> <span class="token function">add</span> --all\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="git-commit" tabindex="-1"><a class="header-anchor" href="#git-commit" aria-hidden="true">#</a> git commit</h4>\n<p>作用：将文件由 暂存区 添加到 仓库区，生成版本号</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 将文件从暂存区提交到仓库</span>\n<span class="token function">git</span> commit -m <span class="token string">"提交说明"</span>\n\n<span class="token comment"># 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。</span>\n<span class="token function">git</span> commit -a -m <span class="token string">\'提交说明\'</span>\n\n<span class="token comment"># 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令</span>\n<span class="token function">git</span> commit --amend -m <span class="token string">"提交说明"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="git-config配置" tabindex="-1"><a class="header-anchor" href="#git-config配置" aria-hidden="true">#</a> git config配置</h4>\n<p>如果是第一次提交，需要配置提交者信息，推荐和公司邮箱一致（可以用QQ邮箱）</p>\n<div class="language-Bash ext-Bash line-numbers-mode"><pre v-pre class="language-Bash"><code># git config  user.name 你的目标用户名\n# git config  user.email 你的目标邮箱名\n\n# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可\ngit config  --global user.name jepson\ngit config  --global user.email jepsonpp@qq.com\n\n# 查看配置信息\ngit config --list\n\n# 取消配置\ngit config --unset --global user.name\ngit config --unset --global user.email \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="git-status" tabindex="-1"><a class="header-anchor" href="#git-status" aria-hidden="true">#</a> git status</h4>\n<ul>\n<li>\n<p>作用：查看文件的状态</p>\n</li>\n<li>\n<p>命令：<code>git status</code></p>\n<ul>\n<li>红色表示工作区中的文件需要提交</li>\n<li>绿色表示暂存区中的文件需要提交</li>\n</ul>\n</li>\n<li>\n<p>命令：<code>git stauts -s</code> 简化日志输出格式</p>\n</li>\n</ul>\n<h4 id="git-log" tabindex="-1"><a class="header-anchor" href="#git-log" aria-hidden="true">#</a> git log</h4>\n<ul>\n<li>作用：查看提交日志</li>\n<li><code>git log</code> 查看提交的日志</li>\n<li><code>git log --oneline</code> 简洁的日志信息</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="" originSrc="./assets/git01.png" data="aurora"></p>\n<h3 id="git重置" tabindex="-1"><a class="header-anchor" href="#git重置" aria-hidden="true">#</a> git重置</h3>\n<h4 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h4>\n<ul>\n<li>\n<p>作用：版本回退，将代码恢复到已经提交的某一个版本中。</p>\n</li>\n<li>\n<p><code>git reset --hard 版本号</code> 将代码回退到某个指定的版本(版本号只要有前几位即可)</p>\n</li>\n<li>\n<p><code>git reset --hard head~1</code>将版本回退到上一次提交</p>\n<ul>\n<li>~1:上一次提交</li>\n<li>~2:上上次提交</li>\n<li>~0:当前提交</li>\n</ul>\n</li>\n<li>\n<p>当使用了<code>git reset</code>命令后，版本会回退，使用<code>git log</code>只能看到当前版本之前的信息。使用<code>git reflog</code>可以查看所有的版本信息</p>\n</li>\n</ul>\n<h3 id="git忽视文件" tabindex="-1"><a class="header-anchor" href="#git忽视文件" aria-hidden="true">#</a> git忽视文件</h3>\n<blockquote>\n<p>在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。</p>\n</blockquote>\n<ul>\n<li>在仓库的根目录创建一个<code>.gitignore</code>的文件，文件名是固定的。</li>\n<li>将不需要被git管理的文件路径添加到<code>.gitignore</code>中</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 忽视idea.txt文件</span>\nidea.txt\n\n<span class="token comment"># 忽视css下的index.js文件</span>\ncss/index.js\n\n<span class="token comment"># 忽视css下的所有的js文件</span>\ncss/*.js\n\n<span class="token comment"># 忽视css文件夹</span>\ncss\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="git分支操作" tabindex="-1"><a class="header-anchor" href="#git分支操作" aria-hidden="true">#</a> git分支操作</h2>\n<p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p>\n<p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="" originSrc="./assets/fenzhi.png" data="aurora"></p>\n<h3 id="为什么要有分支" tabindex="-1"><a class="header-anchor" href="#为什么要有分支" aria-hidden="true">#</a> 为什么要有分支？</h3>\n<ul>\n<li>如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。</li>\n<li>有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。</li>\n</ul>\n<h3 id="git分支命令" tabindex="-1"><a class="header-anchor" href="#git分支命令" aria-hidden="true">#</a> git分支命令</h3>\n<blockquote>\n<p>在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支</p>\n</blockquote>\n<h4 id="创建分支" tabindex="-1"><a class="header-anchor" href="#创建分支" aria-hidden="true">#</a> 创建分支</h4>\n<ul>\n<li><code>git branch 分支名称</code>创建分支，分支中的代码，在创建时与当前分支的内容完全相同。</li>\n<li>git在第一次提交时，就有了一个叫<code>master</code>的主分支。</li>\n<li><code>git branch dev</code>，创建了一个叫做dev的分支</li>\n</ul>\n<h4 id="查看分支" tabindex="-1"><a class="header-anchor" href="#查看分支" aria-hidden="true">#</a> 查看分支</h4>\n<ul>\n<li><code>git branch</code>可以查看所有的分支，</li>\n<li>在当前分支的前面会有一个<code>*</code></li>\n<li>在git中，有一个特殊指针<code>HEAD</code>,永远会指向当前分支</li>\n</ul>\n<h4 id="切换分支" tabindex="-1"><a class="header-anchor" href="#切换分支" aria-hidden="true">#</a> 切换分支</h4>\n<ul>\n<li><code>git checkout 分支名称</code>切换分支  HEAD指针指向了另一个分支</li>\n<li>在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。</li>\n<li>提交代码时，会生产版本号，当前分支会指向最新的版本号。</li>\n</ul>\n<h4 id="创建并切换分支" tabindex="-1"><a class="header-anchor" href="#创建并切换分支" aria-hidden="true">#</a> 创建并切换分支</h4>\n<ul>\n<li><code>git checkout -b 分支名称</code> 创建并切换分支</li>\n<li>切换分支会做两件事情\n<ul>\n<li>创建一个新分支</li>\n<li>把head指针指向当前的分支</li>\n</ul>\n</li>\n</ul>\n<h4 id="删除分支" tabindex="-1"><a class="header-anchor" href="#删除分支" aria-hidden="true">#</a> 删除分支</h4>\n<ul>\n<li><code>git branch -d 分支名称</code> 可以删除分支</li>\n<li>注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。</li>\n<li>注意：<code>master</code>分支是可以删除的，但是不推荐那么做。</li>\n</ul>\n<h4 id="合并分支" tabindex="-1"><a class="header-anchor" href="#合并分支" aria-hidden="true">#</a> 合并分支</h4>\n<ul>\n<li><code>git merge 分支名称</code> 将其他分支的内容合并到当前分支。</li>\n<li>在<code>master</code>分支中执行<code>git merge dev</code> 将<code>dev</code>分支中的代码合并到<code>master</code>分支</li>\n<li><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="noopener noreferrer">分支合并<ExternalLinkIcon/></a></li>\n</ul>\n<h3 id="git合并冲突" tabindex="-1"><a class="header-anchor" href="#git合并冲突" aria-hidden="true">#</a> git合并冲突</h3>\n<ul>\n<li>对于同一个文件，如果有多个分支需要合并时，容易出现冲突。</li>\n<li>合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。</li>\n</ul>\n<blockquote></blockquote>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'#btn-login\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'click\'</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'form\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">hash</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token comment">// 非空校验</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span>username<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'请输入用户名\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">.</span>password<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'请输入密码\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>password<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'密码的长度不能小于6位\'</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">try</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">\'/login\'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>\n    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'user-token\'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>token<span class="token punctuation">)</span>\n    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'user-name\'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>username<span class="token punctuation">)</span>\n    <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'登录成功\'</span><span class="token punctuation">)</span>\n    location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">\'./index.html\'</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">tip</span><span class="token punctuation">(</span><span class="token string">\'用户名或者密码错误\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="git远程仓库" tabindex="-1"><a class="header-anchor" href="#git远程仓库" aria-hidden="true">#</a> git远程仓库</h2>\n<h3 id="github、gitee、gitlab" tabindex="-1"><a class="header-anchor" href="#github、gitee、gitlab" aria-hidden="true">#</a> github、gitee、gitlab</h3>\n<ul>\n<li>git是一个版本控制工具。</li>\n<li>github是一个代码托管平台，开源社区，是git的一个远程代码仓库平台。</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">//1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。</span>\n<span class="token comment">//2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。</span>\n<span class="token comment">//3. 创建git项目时，不能有中文。</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><a href="https://github.com/" target="_blank" rel="noopener noreferrer">github官网<ExternalLinkIcon/></a>： 国外开源 git 代码托管平台</p>\n<p><a href="https://git.oschina.net/" target="_blank" rel="noopener noreferrer">开源中国-git<ExternalLinkIcon/></a>:  国内开源 git 代码托管平台</p>\n<p><a href="https://about.gitlab.com/" target="_blank" rel="noopener noreferrer">gitlab<ExternalLinkIcon/></a>：企业级 git 代码托管平台</p>\n<h3 id="码云创建远程仓库" tabindex="-1"><a class="header-anchor" href="#码云创建远程仓库" aria-hidden="true">#</a> 码云创建远程仓库</h3>\n<ol>\n<li>\n<p>新建右上角仓库</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220514184557788" originSrc="assets/image-20220514184557788.png" data="aurora"></p>\n</li>\n<li>\n<p>输入仓库名  <strong>不勾初始化！！！</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220514184702951" originSrc="assets/image-20220514184702951.png" data="aurora"></p>\n</li>\n<li>\n<p>点击创建</p>\n</li>\n</ol>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220514184807839" originSrc="assets/image-20220514184807839.png" data="aurora"></p>\n<h3 id="ssh免密码登陆" tabindex="-1"><a class="header-anchor" href="#ssh免密码登陆" aria-hidden="true">#</a> SSH免密码登陆</h3>\n<p>git支持多种数据传输协议：</p>\n<ul>\n<li>https协议：<code>https://gitee.com/jepsonpp/test.git</code>  需要输入用户名和密码</li>\n<li>ssh协议：<code>git@gitee.com:jepsonpp/test.git</code>   可以配置免密码登录</li>\n</ul>\n<p>每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。</p>\n<ul>\n<li>github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push</li>\n<li>使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码</li>\n</ul>\n<h3 id="ssh免密码登录配置" tabindex="-1"><a class="header-anchor" href="#ssh免密码登录配置" aria-hidden="true">#</a> SSH免密码登录配置</h3>\n<ul>\n<li>1 创建SSH Key：<code>ssh-keygen -t rsa</code>    （注意：这些命令需要在bash中敲）</li>\n<li>2 在文件路径 <code>C:\\用户\\当前用户名\\</code> 找到 <code>.ssh</code> 文件夹</li>\n<li>3 文件夹中有两个文件：\n<ul>\n<li>私钥：<code>id_rsa</code></li>\n<li>公钥：<code>id_rsa.pub</code></li>\n</ul>\n</li>\n<li>4 在 <code>码云-&gt; 设置 -&gt; SSH公钥</code>页面中</li>\n<li>5 粘贴 公钥 <code>id_rsa.pub</code> 内容到对应文本框中， 添加公钥</li>\n</ul>\n<h3 id="git-push" tabindex="-1"><a class="header-anchor" href="#git-push" aria-hidden="true">#</a> git push</h3>\n<ul>\n<li>作用：将本地仓库中代码提交到远程仓库</li>\n<li><code>git push 仓库地址 分支名</code>   将代码提交到远程仓库对应分支</li>\n<li>例子：<code>git push git@gitee.com:jepsonpp/test.git master</code></li>\n</ul>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>git push &lt;远程主机名> &lt;本地分支名>:&lt;远程分支名>\n如果本地分支名与远程分支名相同，则可以省略冒号\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="git-remote" tabindex="-1"><a class="header-anchor" href="#git-remote" aria-hidden="true">#</a> git remote</h3>\n<p>每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 给远程仓库设置一个别名</span>\n<span class="token function">git</span> remote <span class="token function">add</span> 仓库别名 仓库地址\n<span class="token function">git</span> remote <span class="token function">add</span> origin git@gitee.com:jepsonpp/test.git\n\n<span class="token comment"># 删除origin这个别名</span>\n<span class="token function">git</span> remote remove origin\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>演示命令：<code>git push -u 仓库别名 分支名</code></p>\n<h3 id="git-clone" tabindex="-1"><a class="header-anchor" href="#git-clone" aria-hidden="true">#</a> git clone</h3>\n<ul>\n<li>作用：克隆远程仓库的代码到本地</li>\n<li>git clone [远程仓库地址]</li>\n<li><code>git clone git@gitee.com:jepsonpp/test.git</code>会在本地新建一个<code>test</code>文件夹</li>\n<li>在test中包含了一个<code>.git</code>目录，用于保存所有的版本记录，同时test文件中还有最新的代码，可以进行后续的开发。</li>\n<li>git克隆默认会使用远程仓库的项目名字，也可以自己指定。命令：<code>git clone [远程仓库地址] [本地项目名]</code></li>\n</ul>\n<p>tips: <code>git branch -a</code>  查看分支</p>\n<h3 id="git-pull" tabindex="-1"><a class="header-anchor" href="#git-pull" aria-hidden="true">#</a> git pull</h3>\n<ul>\n<li>\n<p>作用：拉取更新，将远程的代码下载合并到本地的分支</p>\n</li>\n<li>\n<p>通常在push前，需要先pull一次。</p>\n</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token comment"># 获取远程仓库的更新，并且与本地的分支进行合并</span>\n<span class="token function">git</span> pull\n<span class="token function">git</span> pull <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span>\n<span class="token function">git</span> pull origin login  <span class="token comment"># 获取远程分支的更新，并更新合并到login分支</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="下载远端分支本地" tabindex="-1"><a class="header-anchor" href="#下载远端分支本地" aria-hidden="true">#</a> 下载远端分支本地</h3>\n<p><code>checkout</code> 的 <code>-t </code>(或) <code>--track </code>)选项仅在创建新的(本地)分支时使用</p>\n<p>先在本地建立一个分支，并切换到该分支，然后从远程分支上同步代码到该分支上，并建立关联</p>\n<div class="language-git ext-git line-numbers-mode"><pre v-pre class="language-git"><code>git checkout -t origin/develop     #远端分支名和本地新建分支名同名\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>后续拉取该分支的更新，就是切换到该分支，git  pull  origin 分支名</strong></p>\n<ol>\n<li>将数据可视化项目上传到码云仓库,  主分支与开发分支均要上传</li>\n</ol>\n<div class="language-git ext-git line-numbers-mode"><pre v-pre class="language-git"><code>git push origin master\n\ngit push origin develop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2">\n<li>删除本地项目，通过克隆把远端仓库项目拉取下来，切换到develop分支</li>\n</ol>\n<div class="language-git ext-git line-numbers-mode"><pre v-pre class="language-git"><code>git clone 仓库地址\n\ngit checkout -t origin/develop\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Git/git.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"git",filePath:"D:/桌面文件/Blog/blog-demo/docs/Git/git.md",filePathRelative:"Git/git.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Git/git.html.vue",componentFilePathRelative:"pages/Git/git.html.vue",componentFileChunkName:"v-ef444906",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Git/git.html.js",dataFilePathRelative:"pages/Git/git.html.js",dataFileChunkName:"v-ef444906",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Git/git.html",htmlFilePathRelative:"Git/git.html"},{data:{key:"v-3d2f7822",path:"/JAVA/1Java%E5%9F%BA%E7%A1%80.html",title:"Java基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Java语言的发展",slug:"_1-6-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",children:[]}]}],git:{}},key:"v-3d2f7822",path:"/JAVA/1Java%E5%9F%BA%E7%A1%80.html",title:"Java基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 人机交互",slug:"_1-人机交互",children:[{level:3,title:"1.1 什么是cmd？",slug:"_1-1-什么是cmd",children:[]},{level:3,title:"1.2 如何打开CMD窗口？",slug:"_1-2-如何打开cmd窗口",children:[]},{level:3,title:"1.3 常用CMD命令",slug:"_1-3-常用cmd命令",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量",children:[]}]},{level:2,title:"2. Java概述",slug:"_2-java概述",children:[{level:3,title:"1.1 Java是什么？",slug:"_1-1-java是什么",children:[]},{level:3,title:"1.2下载和安装",slug:"_1-2下载和安装",children:[]},{level:3,title:"1.4 HelloWorld案例常见问题",slug:"_1-4-helloworld案例常见问题",children:[]},{level:3,title:"1.5 环境变量",slug:"_1-5-环境变量-1",children:[]},{level:3,title:"1.6 Java语言的发展",slug:"_1-6-java语言的发展",children:[]},{level:3,title:"1.8 Java的三大平台",slug:"_1-8-java的三大平台",children:[]},{level:3,title:"1.9 Java的主要特性",slug:"_1-9-java的主要特性",children:[]},{level:3,title:"1.10 JRE和JDK",slug:"_1-10-jre和jdk",children:[]}]}],content:'\r\n\r\n# Java基础\r\n\r\n## 1. 人机交互\r\n\r\n### 1.1 什么是cmd？\r\n\r\n就是在windows操作系统中，利用命令行的方式去操作计算机。\r\n\r\n我们可以利用cmd命令去操作计算机，比如：打开文件，打开文件夹，创建文件夹等。\r\n\r\n### 1.2 如何打开CMD窗口？\r\n\r\n1. 按下快捷键：win + R。\r\n\r\n\t\t此时会出现运行窗口。\r\n\r\n2. 在运行窗口中输出cmd\r\n3. 输出回车。\r\n\r\n解惑：\r\n\r\n​\tcmd默认操作C盘下的users文件夹下的XXX文件夹。（XXX就是计算机名）\r\n\r\n### 1.3 常用CMD命令\r\n\r\n 扩展一个小点：\r\n\r\n​\t在很多资料中都说成是DOS命令，其实是不对的。真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。\r\n\r\n​\t而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做CMD命令会更准确一些。\r\n\r\n常见的CMD命令如下：\r\n\r\n| 操作               | 说明                              |\r\n| ------------------ | --------------------------------- |\r\n| 盘符名称:          | 盘符切换。E:回车，表示切换到E盘。 |\r\n| dir                | 查看当前路径下的内容。            |\r\n| cd 目录            | 进入单级目录。cd itheima          |\r\n| cd ..              | 回退到上一级目录。                |\r\n| cd 目录1\\目录2\\... | 进入多级目录。cd itheima\\JavaSE   |\r\n| cd \\               | 回退到盘符目录。                  |\r\n| cls                | 清屏。                            |\r\n| exit               | 退出命令提示符窗口。              |\r\n\r\n### 1.5 环境变量\r\n\r\n作用：\r\n\r\n​\t如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。\r\n\r\n​\t在启动软件的时候，操作系统会先在当前路径下找，如果在当前录课没有再到环境变量的路径中去找。如果都找不到就提示无法启动。\r\n\r\n步骤：\r\n\r\n- 右键我的电脑，选择属性。\r\n- 点击左侧的高级系统设置\r\n- 选择高级，再点击下面的环境变量。\r\n- 找系统变量里面的PATH\r\n- 把软件的完整路径，配置到PATH当中就可以了。\r\n- （可做可不做）就是把自己配置的路径，移动到最上面。\r\n\r\n图解示例如下：\r\n\r\n第一步：右键点击我的电脑并选择属性。\r\n\r\n（如果无法出现第二步界面，可以打开我的电脑之后右键点击空白处）\r\n\r\n第二步：点击高级系统设置。\r\n\r\n第三步：选择高级，再点击下面的环境变量。\r\n\r\n第四步：找系统变量里面的path\r\n\r\n第五步：点击新建，把软件的完整路径，配置到PATH当中，再点击确定即可。\r\n\r\n第六步：（可做可不做）点击上移，把当前配置的路径移动到最上面。\r\n\r\n移动的好处：在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上面查找的速度比较快。\r\n\r\n## 2. Java概述\r\n\r\n### 1.1 Java是什么？\r\n\r\n语言：人与人交流沟通的表达方式\r\n\r\n计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言\r\n\r\nJava是一门非常火的计算机语言。（也叫做编程语言）\r\n\r\n我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了\r\n\r\n### 1.2下载和安装\r\n\r\n#### 1.2.1 下载\r\n\r\n通过官方网站获取JDK\r\n\r\n[http://www.oracle.com](http://www.oracle.com/)\r\n\r\n**注意1**：针对不同的操作系统，需要下载对应版本的JDK。\r\n\r\n**注意2**：\r\n\r\n​\t如果你的电脑是windows32位的，建议重装系统，重装成64位的操作系统。\r\n\r\n​\t因为Java从9版本开始，就已经不提供32位版本的安装包了。\r\n\r\n​\t如果自己不愿意下载，到今天day01资料文件中，也有对应的安装包。\r\n\r\n#### 1.2.2 安装\r\n\r\n​\t傻瓜式安装，下一步即可。默认的安装路径是在C:\\Program Files下。\r\n\r\n建议：\r\n\r\n- 安装路径不要有中文，不要有空格等一些特殊的符号。\r\n- 以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。\r\n\r\n#### 1.2.3 JDK的安装目录介绍\r\n\r\n| 目录名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| bin      | 该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。 |\r\n| conf     | 该路径下存放了JDK的相关配置文件。                            |\r\n| include  | 该路径下存放了一些平台特定的头文件。                         |\r\n| jmods    | 该路径下存放了JDK的各种模块。                                |\r\n| legal    | 该路径下存放了JDK各模块的授权文档。                          |\r\n| lib      | 该路径下存放了JDK工具的一些补充JAR包。                       |\r\n\r\n#### 2.3.1 Java程序开发运行流程\r\n\r\n开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。\r\n\r\n#### 2.3.2 HelloWorld案例的编写\r\n\r\n1. 新建文本文档文件，修改名称为HelloWorld.java。\r\n\r\n**注意**：后缀名为java的才是java文件。\r\n\r\n2. 用记事本打开HelloWorld.java文件，输写程序内容。\r\n\r\n**注意**：代码要跟我编写的完全保持一致。\r\n\r\n```java\r\npublic class HelloWorld {\r\n\tpublic static void main(String[] args) {\r\n\t\tSystem.out.println("HelloWorld");\r\n\t}\r\n}\r\n```\r\n\r\n3. 保存\r\n\r\n**注意**：未保存的文件在左上角会有*符号标记\r\n\r\n4. 编译文件。编译后会产生一个class文件。\r\n\r\n   java文件：程序员自己编写的代码。\r\n\r\n   class文件：交给计算机执行的文件。\r\n\r\n5. 运行代码\r\n\r\n   **注意**：运行的是编译之后的class文件。\r\n\r\n> 用到两个命令：\r\n>\r\n> ​\tjavac + 文件名 + 后缀名 （就是编译java文件）\r\n>\r\n> ​\tjava + 文件名（运行编译之后的class文件）\r\n\r\n### 1.4 HelloWorld案例常见问题\r\n\r\n#### 1.4.1 BUG\r\n\r\n​\t在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。\r\n\r\n#### 1.4.2 BUG的解决\r\n\r\n1. 具备识别BUG的能力：多看\r\n2. 具备分析BUG的能力：多思考，多查资料\r\n3. 具备解决BUG的能力：多尝试，多总结\r\n\r\n#### 1.4.3 HelloWorld常见问题\r\n\r\n1、非法字符问题。Java中的符号都是英文格式的。\r\n\r\n2、大小写问题。Java语言对大小写敏感（区分大小写）。\r\n\r\n3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。\r\n\r\n4、编译命令后的java文件名需要带文件后缀.java\r\n\r\n5、运行命令后的class文件名（类名）不带文件后缀.class\r\n\r\n...\r\n\r\n#### 常见错误代码1：\r\n\r\n```java\r\npublicclass HelloWorld{\r\n    public static void main(String[] args){\r\n        System.out.println("HelloWorld");\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\tpublic和class之间缺少一个空格。\r\n\r\n技巧：一般来讲在单词之间的空格是不能省略的。\r\n\r\n​\t如果是单词和符号之间的空格是可以省略的。\r\n\r\n#### 常见错误代码2：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    public static void main(String[] args){\r\n        system.out.println("HelloWorld");\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\tsystem首字母必须大写。\r\n\r\n技巧：\r\n\r\n​\tJava代码中，是严格区分大小写的。\r\n\r\n​\t所以该大写的地方一定要大写，该小写的地方一定要小写。多多练习。\r\n\r\n#### 常见错误代码3：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    public static void main(String[] args){\r\n        System.out.println(HelloWorld);\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\t第三行代码中的HelloWorld必须用双引号引起来，否则就会出现问题。\r\n\r\n#### 常见错误代码4：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    public static void main(String[] args){\r\n        System.out.println("HelloWorld")；\r\n    }\r\n}\r\n```\r\n\r\n问题：\r\n\r\n​\t在以后代码当中，所有的标点符号必须是英文状态下的。\r\n\r\n技巧：\r\n\r\n​\t可以在输入法中进行对应的设置。\r\n\r\n### 1.5 环境变量\r\n\r\n#### 1.5.1 为什么配置环境变量\r\n\r\n​\t开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。\r\n\r\n注意：现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。\r\n\r\n#### 1.5.2配置方式\r\n\r\n以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。\r\n\r\n①**JAVA_HOME**：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过这个找JDK）\r\n\r\n②**Path**：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置\r\n\r\n### 1.6 Java语言的发展\r\n\r\n三个版本：\r\n\r\n* Java5.0：这是Java的第一个大版本更新。\r\n* Java8.0：这个是目前绝大数公司正在使用的版本。因为这个版本最为稳定。\r\n* Java15.0：这个是我们课程中学习的版本。\r\n\r\n解惑：\r\n\r\n​\t我们学的跟工作中使用的版本不太一样啊。会不会影响以后工作呢？\r\n\r\n向下兼容。新的版本只是在原有的基础上添加了一些新的功能而已。\r\n\r\n举例：\r\n\r\n用8版本开发的代码，用11版本能运行吗？必须可以的。\r\n\r\n用11版本开发的代码，用8版本能运行吗？不一定。\r\n\r\n如果11版本开发的代码，没有用到9~11的新特性，那么用8是可以运行的。\r\n\r\n如果11版本开发的代码，用到了9~11的新特性，那么用8就无法运行了。\r\n\r\n### 1.8 Java的三大平台\r\n\r\n​\tJavaSE、JavaME、JavaEE\r\n\r\n#### 1.8.1 JavaSE\r\n\r\n​\t是其他两个版本的基础。\r\n\r\n#### 1.8.2 JavaME\r\n\r\n​\tJava语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。\r\n\r\n​\t其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。\r\n\r\n​\t但是，安卓也是可以用Java来开发的。\r\n\r\n#### 1.8.3 JavaEE\r\n\r\n​\t用于Web方向的网站开发。（主要从事后台服务器的开发）\r\n\r\n​\t在服务器领域，Java是当之无愧的龙头老大。\r\n\r\n### 1.9 Java的主要特性\r\n\r\n- 面向对象\r\n- 安全性\r\n- 多线程\r\n- 简单易用\r\n- 开源\r\n- 跨平台\r\n\r\n#### 1.9.1 Java语言跨平台的原理\r\n\r\n- 操作系统本身其实是不认识Java语言的。\r\n- 但是针对于不同的操作系统，Java提供了不同的虚拟机。\r\n\r\n虚拟机会把Java语言翻译成操作系统能看得懂的语言。\r\n\r\n### 1.10 JRE和JDK\r\n\r\nJVM（Java Virtual Machine），Java虚拟机\r\n\r\nJRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\r\n\r\nJDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\r\n\r\n总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。\r\n',contentRendered:'<h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础" aria-hidden="true">#</a> Java基础</h1>\n<h2 id="_1-人机交互" tabindex="-1"><a class="header-anchor" href="#_1-人机交互" aria-hidden="true">#</a> 1. 人机交互</h2>\n<h3 id="_1-1-什么是cmd" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是cmd" aria-hidden="true">#</a> 1.1 什么是cmd？</h3>\n<p>就是在windows操作系统中，利用命令行的方式去操作计算机。</p>\n<p>我们可以利用cmd命令去操作计算机，比如：打开文件，打开文件夹，创建文件夹等。</p>\n<h3 id="_1-2-如何打开cmd窗口" tabindex="-1"><a class="header-anchor" href="#_1-2-如何打开cmd窗口" aria-hidden="true">#</a> 1.2 如何打开CMD窗口？</h3>\n<ol>\n<li>\n<p>按下快捷键：win + R。</p>\n<pre><code> 此时会出现运行窗口。\n</code></pre>\n</li>\n<li>\n<p>在运行窗口中输出cmd</p>\n</li>\n<li>\n<p>输出回车。</p>\n</li>\n</ol>\n<p>解惑：</p>\n<p>​\tcmd默认操作C盘下的users文件夹下的XXX文件夹。（XXX就是计算机名）</p>\n<h3 id="_1-3-常用cmd命令" tabindex="-1"><a class="header-anchor" href="#_1-3-常用cmd命令" aria-hidden="true">#</a> 1.3 常用CMD命令</h3>\n<p>扩展一个小点：</p>\n<p>​\t在很多资料中都说成是DOS命令，其实是不对的。真正的DOS命令是1981年微软和IBM出品的MS-DOS操作系统中的命令才叫做DOS命令。</p>\n<p>​\t而在Windows中，win98之前的操作系统是以非图形化的DOS为基础的，可以叫做DOS命令。到了2000年以后，windows逐渐的以图形化界面为主了，这个时候就不能叫DOS命令了，他只是模拟了DOS环境而已，很多的原本的DOS命令已经无法使用了，所以这个时候叫做CMD命令会更准确一些。</p>\n<p>常见的CMD命令如下：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>盘符名称:</td>\n<td>盘符切换。E:回车，表示切换到E盘。</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>查看当前路径下的内容。</td>\n</tr>\n<tr>\n<td>cd 目录</td>\n<td>进入单级目录。cd itheima</td>\n</tr>\n<tr>\n<td>cd ..</td>\n<td>回退到上一级目录。</td>\n</tr>\n<tr>\n<td>cd 目录1\\目录2...</td>\n<td>进入多级目录。cd itheima\\JavaSE</td>\n</tr>\n<tr>\n<td>cd \\</td>\n<td>回退到盘符目录。</td>\n</tr>\n<tr>\n<td>cls</td>\n<td>清屏。</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>退出命令提示符窗口。</td>\n</tr>\n</tbody>\n</table>\n<h3 id="_1-5-环境变量" tabindex="-1"><a class="header-anchor" href="#_1-5-环境变量" aria-hidden="true">#</a> 1.5 环境变量</h3>\n<p>作用：</p>\n<p>​\t如果我想要在CMD的任意目录下，都可以启动某一个软件，那么就可以把这个软件的路径配置到环境变量中的PATH里面。</p>\n<p>​\t在启动软件的时候，操作系统会先在当前路径下找，如果在当前录课没有再到环境变量的路径中去找。如果都找不到就提示无法启动。</p>\n<p>步骤：</p>\n<ul>\n<li>右键我的电脑，选择属性。</li>\n<li>点击左侧的高级系统设置</li>\n<li>选择高级，再点击下面的环境变量。</li>\n<li>找系统变量里面的PATH</li>\n<li>把软件的完整路径，配置到PATH当中就可以了。</li>\n<li>（可做可不做）就是把自己配置的路径，移动到最上面。</li>\n</ul>\n<p>图解示例如下：</p>\n<p>第一步：右键点击我的电脑并选择属性。</p>\n<p>（如果无法出现第二步界面，可以打开我的电脑之后右键点击空白处）</p>\n<p>第二步：点击高级系统设置。</p>\n<p>第三步：选择高级，再点击下面的环境变量。</p>\n<p>第四步：找系统变量里面的path</p>\n<p>第五步：点击新建，把软件的完整路径，配置到PATH当中，再点击确定即可。</p>\n<p>第六步：（可做可不做）点击上移，把当前配置的路径移动到最上面。</p>\n<p>移动的好处：在CMD中打开软件时，会先找当前路径，再找环境变量，在环境变量中是从上往下依次查找的，如果路径放在最上面查找的速度比较快。</p>\n<h2 id="_2-java概述" tabindex="-1"><a class="header-anchor" href="#_2-java概述" aria-hidden="true">#</a> 2. Java概述</h2>\n<h3 id="_1-1-java是什么" tabindex="-1"><a class="header-anchor" href="#_1-1-java是什么" aria-hidden="true">#</a> 1.1 Java是什么？</h3>\n<p>语言：人与人交流沟通的表达方式</p>\n<p>计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言</p>\n<p>Java是一门非常火的计算机语言。（也叫做编程语言）</p>\n<p>我们想要让计算机做一些事情，那么就可以通过Java语言告诉计算机就可以了</p>\n<h3 id="_1-2下载和安装" tabindex="-1"><a class="header-anchor" href="#_1-2下载和安装" aria-hidden="true">#</a> 1.2下载和安装</h3>\n<h4 id="_1-2-1-下载" tabindex="-1"><a class="header-anchor" href="#_1-2-1-下载" aria-hidden="true">#</a> 1.2.1 下载</h4>\n<p>通过官方网站获取JDK</p>\n<p><a href="http://www.oracle.com/" target="_blank" rel="noopener noreferrer">http://www.oracle.com<ExternalLinkIcon/></a></p>\n<p><strong>注意1</strong>：针对不同的操作系统，需要下载对应版本的JDK。</p>\n<p><strong>注意2</strong>：</p>\n<p>​\t如果你的电脑是windows32位的，建议重装系统，重装成64位的操作系统。</p>\n<p>​\t因为Java从9版本开始，就已经不提供32位版本的安装包了。</p>\n<p>​\t如果自己不愿意下载，到今天day01资料文件中，也有对应的安装包。</p>\n<h4 id="_1-2-2-安装" tabindex="-1"><a class="header-anchor" href="#_1-2-2-安装" aria-hidden="true">#</a> 1.2.2 安装</h4>\n<p>​\t傻瓜式安装，下一步即可。默认的安装路径是在C:\\Program Files下。</p>\n<p>建议：</p>\n<ul>\n<li>安装路径不要有中文，不要有空格等一些特殊的符号。</li>\n<li>以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。</li>\n</ul>\n<h4 id="_1-2-3-jdk的安装目录介绍" tabindex="-1"><a class="header-anchor" href="#_1-2-3-jdk的安装目录介绍" aria-hidden="true">#</a> 1.2.3 JDK的安装目录介绍</h4>\n<table>\n<thead>\n<tr>\n<th>目录名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bin</td>\n<td>该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。</td>\n</tr>\n<tr>\n<td>conf</td>\n<td>该路径下存放了JDK的相关配置文件。</td>\n</tr>\n<tr>\n<td>include</td>\n<td>该路径下存放了一些平台特定的头文件。</td>\n</tr>\n<tr>\n<td>jmods</td>\n<td>该路径下存放了JDK的各种模块。</td>\n</tr>\n<tr>\n<td>legal</td>\n<td>该路径下存放了JDK各模块的授权文档。</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>该路径下存放了JDK工具的一些补充JAR包。</td>\n</tr>\n</tbody>\n</table>\n<h4 id="_2-3-1-java程序开发运行流程" tabindex="-1"><a class="header-anchor" href="#_2-3-1-java程序开发运行流程" aria-hidden="true">#</a> 2.3.1 Java程序开发运行流程</h4>\n<p>开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。</p>\n<h4 id="_2-3-2-helloworld案例的编写" tabindex="-1"><a class="header-anchor" href="#_2-3-2-helloworld案例的编写" aria-hidden="true">#</a> 2.3.2 HelloWorld案例的编写</h4>\n<ol>\n<li>新建文本文档文件，修改名称为HelloWorld.java。</li>\n</ol>\n<p><strong>注意</strong>：后缀名为java的才是java文件。</p>\n<ol start="2">\n<li>用记事本打开HelloWorld.java文件，输写程序内容。</li>\n</ol>\n<p><strong>注意</strong>：代码要跟我编写的完全保持一致。</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3">\n<li>保存</li>\n</ol>\n<p><strong>注意</strong>：未保存的文件在左上角会有*符号标记</p>\n<ol start="4">\n<li>\n<p>编译文件。编译后会产生一个class文件。</p>\n<p>java文件：程序员自己编写的代码。</p>\n<p>class文件：交给计算机执行的文件。</p>\n</li>\n<li>\n<p>运行代码</p>\n<p><strong>注意</strong>：运行的是编译之后的class文件。</p>\n</li>\n</ol>\n<blockquote>\n<p>用到两个命令：</p>\n<p>​\tjavac + 文件名 + 后缀名 （就是编译java文件）</p>\n<p>​\tjava + 文件名（运行编译之后的class文件）</p>\n</blockquote>\n<h3 id="_1-4-helloworld案例常见问题" tabindex="-1"><a class="header-anchor" href="#_1-4-helloworld案例常见问题" aria-hidden="true">#</a> 1.4 HelloWorld案例常见问题</h3>\n<h4 id="_1-4-1-bug" tabindex="-1"><a class="header-anchor" href="#_1-4-1-bug" aria-hidden="true">#</a> 1.4.1 BUG</h4>\n<p>​\t在电脑系统或程序中，隐藏着的一些未被发现的缺陷或问题统称为bug（漏洞）。</p>\n<h4 id="_1-4-2-bug的解决" tabindex="-1"><a class="header-anchor" href="#_1-4-2-bug的解决" aria-hidden="true">#</a> 1.4.2 BUG的解决</h4>\n<ol>\n<li>具备识别BUG的能力：多看</li>\n<li>具备分析BUG的能力：多思考，多查资料</li>\n<li>具备解决BUG的能力：多尝试，多总结</li>\n</ol>\n<h4 id="_1-4-3-helloworld常见问题" tabindex="-1"><a class="header-anchor" href="#_1-4-3-helloworld常见问题" aria-hidden="true">#</a> 1.4.3 HelloWorld常见问题</h4>\n<p>1、非法字符问题。Java中的符号都是英文格式的。</p>\n<p>2、大小写问题。Java语言对大小写敏感（区分大小写）。</p>\n<p>3、在系统中显示文件的扩展名，避免出现HelloWorld.java.txt文件。</p>\n<p>4、编译命令后的java文件名需要带文件后缀.java</p>\n<p>5、运行命令后的class文件名（类名）不带文件后缀.class</p>\n<p>...</p>\n<h4 id="常见错误代码1" tabindex="-1"><a class="header-anchor" href="#常见错误代码1" aria-hidden="true">#</a> 常见错误代码1：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code>publicclass <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\tpublic和class之间缺少一个空格。</p>\n<p>技巧：一般来讲在单词之间的空格是不能省略的。</p>\n<p>​\t如果是单词和符号之间的空格是可以省略的。</p>\n<h4 id="常见错误代码2" tabindex="-1"><a class="header-anchor" href="#常见错误代码2" aria-hidden="true">#</a> 常见错误代码2：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\tsystem首字母必须大写。</p>\n<p>技巧：</p>\n<p>​\tJava代码中，是严格区分大小写的。</p>\n<p>​\t所以该大写的地方一定要大写，该小写的地方一定要小写。多多练习。</p>\n<h4 id="常见错误代码3" tabindex="-1"><a class="header-anchor" href="#常见错误代码3" aria-hidden="true">#</a> 常见错误代码3：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">HelloWorld</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\t第三行代码中的HelloWorld必须用双引号引起来，否则就会出现问题。</p>\n<h4 id="常见错误代码4" tabindex="-1"><a class="header-anchor" href="#常见错误代码4" aria-hidden="true">#</a> 常见错误代码4：</h4>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span>；\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>问题：</p>\n<p>​\t在以后代码当中，所有的标点符号必须是英文状态下的。</p>\n<p>技巧：</p>\n<p>​\t可以在输入法中进行对应的设置。</p>\n<h3 id="_1-5-环境变量-1" tabindex="-1"><a class="header-anchor" href="#_1-5-环境变量-1" aria-hidden="true">#</a> 1.5 环境变量</h3>\n<h4 id="_1-5-1-为什么配置环境变量" tabindex="-1"><a class="header-anchor" href="#_1-5-1-为什么配置环境变量" aria-hidden="true">#</a> 1.5.1 为什么配置环境变量</h4>\n<p>​\t开发Java程序，需要使用JDK提供的开发工具（比如javac.exe、java.exe等命令），而这些工具在JDK的安装目录的bin目录下，如果不配置环境变量，那么这些命令只可以在bin目录下使用，而我们想要在任意目录下都能使用，所以就要配置环境变量。</p>\n<p>注意：现在最新从官网上下载的JDK安装时会自动配置javac、java命令的路径到Path环境变量中去 ，所以javac、java可以直接使用。</p>\n<h4 id="_1-5-2配置方式" tabindex="-1"><a class="header-anchor" href="#_1-5-2配置方式" aria-hidden="true">#</a> 1.5.2配置方式</h4>\n<p>以前下载的老版本的JDK是没有自动配置的，而且自动配置的也只包含了4个工具而已，所以我们需要删掉已经配置完毕的，再次重新配置Path环境变量。</p>\n<p>①<strong>JAVA_HOME</strong>：告诉操作系统JDK安装在了哪个位置（未来其他技术要通过这个找JDK）</p>\n<p>②<strong>Path</strong>：告诉操作系统JDK提供的javac(编译)、java(执行)命令安装到了哪个位置</p>\n<h3 id="_1-6-java语言的发展" tabindex="-1"><a class="header-anchor" href="#_1-6-java语言的发展" aria-hidden="true">#</a> 1.6 Java语言的发展</h3>\n<p>三个版本：</p>\n<ul>\n<li>Java5.0：这是Java的第一个大版本更新。</li>\n<li>Java8.0：这个是目前绝大数公司正在使用的版本。因为这个版本最为稳定。</li>\n<li>Java15.0：这个是我们课程中学习的版本。</li>\n</ul>\n<p>解惑：</p>\n<p>​\t我们学的跟工作中使用的版本不太一样啊。会不会影响以后工作呢？</p>\n<p>向下兼容。新的版本只是在原有的基础上添加了一些新的功能而已。</p>\n<p>举例：</p>\n<p>用8版本开发的代码，用11版本能运行吗？必须可以的。</p>\n<p>用11版本开发的代码，用8版本能运行吗？不一定。</p>\n<p>如果11版本开发的代码，没有用到9~11的新特性，那么用8是可以运行的。</p>\n<p>如果11版本开发的代码，用到了9~11的新特性，那么用8就无法运行了。</p>\n<h3 id="_1-8-java的三大平台" tabindex="-1"><a class="header-anchor" href="#_1-8-java的三大平台" aria-hidden="true">#</a> 1.8 Java的三大平台</h3>\n<p>​\tJavaSE、JavaME、JavaEE</p>\n<h4 id="_1-8-1-javase" tabindex="-1"><a class="header-anchor" href="#_1-8-1-javase" aria-hidden="true">#</a> 1.8.1 JavaSE</h4>\n<p>​\t是其他两个版本的基础。</p>\n<h4 id="_1-8-2-javame" tabindex="-1"><a class="header-anchor" href="#_1-8-2-javame" aria-hidden="true">#</a> 1.8.2 JavaME</h4>\n<p>​\tJava语言的小型版，用于嵌入式消费类电子设备或者小型移动设备的开发。</p>\n<p>​\t其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和IOS给替代了。</p>\n<p>​\t但是，安卓也是可以用Java来开发的。</p>\n<h4 id="_1-8-3-javaee" tabindex="-1"><a class="header-anchor" href="#_1-8-3-javaee" aria-hidden="true">#</a> 1.8.3 JavaEE</h4>\n<p>​\t用于Web方向的网站开发。（主要从事后台服务器的开发）</p>\n<p>​\t在服务器领域，Java是当之无愧的龙头老大。</p>\n<h3 id="_1-9-java的主要特性" tabindex="-1"><a class="header-anchor" href="#_1-9-java的主要特性" aria-hidden="true">#</a> 1.9 Java的主要特性</h3>\n<ul>\n<li>面向对象</li>\n<li>安全性</li>\n<li>多线程</li>\n<li>简单易用</li>\n<li>开源</li>\n<li>跨平台</li>\n</ul>\n<h4 id="_1-9-1-java语言跨平台的原理" tabindex="-1"><a class="header-anchor" href="#_1-9-1-java语言跨平台的原理" aria-hidden="true">#</a> 1.9.1 Java语言跨平台的原理</h4>\n<ul>\n<li>操作系统本身其实是不认识Java语言的。</li>\n<li>但是针对于不同的操作系统，Java提供了不同的虚拟机。</li>\n</ul>\n<p>虚拟机会把Java语言翻译成操作系统能看得懂的语言。</p>\n<h3 id="_1-10-jre和jdk" tabindex="-1"><a class="header-anchor" href="#_1-10-jre和jdk" aria-hidden="true">#</a> 1.10 JRE和JDK</h3>\n<p>JVM（Java Virtual Machine），Java虚拟机</p>\n<p>JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）</p>\n<p>JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具</p>\n<p>总结：我们只需安装JDK即可，它包含了java的运行环境和虚拟机。</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/JAVA/1Java基础.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"1Java基础",filePath:"D:/桌面文件/Blog/blog-demo/docs/JAVA/1Java基础.md",filePathRelative:"JAVA/1Java基础.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/1Java基础.html.vue",componentFilePathRelative:"pages/JAVA/1Java基础.html.vue",componentFileChunkName:"v-3d2f7822",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/1Java基础.html.js",dataFilePathRelative:"pages/JAVA/1Java基础.html.js",dataFileChunkName:"v-3d2f7822",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/JAVA/1Java基础.html",htmlFilePathRelative:"JAVA/1Java基础.html"},{data:{key:"v-7e88feb6",path:"/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",title:"day02 - Java基础语法",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 注释",slug:"_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",children:[]}]}],git:{}},key:"v-7e88feb6",path:"/JAVA/2Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",title:"day02 - Java基础语法",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. 注释",slug:"_1-注释",children:[{level:3,title:"使用的技巧",slug:"使用的技巧",children:[]},{level:3,title:"注意点",slug:"注意点",children:[]}]},{level:2,title:"2. 关键字",slug:"_2-关键字",children:[{level:3,title:"2.1 概念",slug:"_2-1-概念",children:[]},{level:3,title:"2.2 第一个关键字class",slug:"_2-2-第一个关键字class",children:[]}]},{level:2,title:"3. 字面量",slug:"_3-字面量",children:[{level:3,title:"区分技巧",slug:"区分技巧",children:[]}]},{level:2,title:"4. 变量",slug:"_4-变量",children:[{level:3,title:"4.1 什么是变量？",slug:"_4-1-什么是变量",children:[]},{level:3,title:"4.2 变量的定义格式",slug:"_4-2-变量的定义格式",children:[]}]},{level:2,title:"5. 数据类型",slug:"_5-数据类型",children:[{level:3,title:"5.1 Java语言数据类型的分类",slug:"_5-1-java语言数据类型的分类",children:[]},{level:3,title:"5.2 基本数据类型的四类八种",slug:"_5-2-基本数据类型的四类八种",children:[]},{level:3,title:"5.3 定义8种基本数据类型变量",slug:"_5-3-定义8种基本数据类型变量",children:[]}]},{level:2,title:"6. 标识符",slug:"_6-标识符",children:[{level:3,title:"6.1 硬性要求：",slug:"_6-1-硬性要求",children:[]},{level:3,title:"6.2 软件建议：",slug:"_6-2-软件建议",children:[]},{level:3,title:"6.2.1 小驼峰命名法",slug:"_6-2-1-小驼峰命名法",children:[]},{level:3,title:"6.2.2 大驼峰命名法",slug:"_6-2-2-大驼峰命名法",children:[]},{level:3,title:"阿里巴巴命名规范细节：",slug:"阿里巴巴命名规范细节",children:[]}]},{level:2,title:"7. 键盘录入",slug:"_7-键盘录入",children:[]},{level:2,title:"8. IDEA",slug:"_8-idea",children:[{level:3,title:"8.1 IDEA概述",slug:"_8-1-idea概述",children:[]},{level:3,title:"8.2 IDEA的下载和安装",slug:"_8-2-idea的下载和安装",children:[]}]}],content:"# day02 - Java基础语法\r\n\r\n## 1. 注释\r\n\r\n​\t注释是对代码的解释和说明文字。\r\n\r\nJava中的注释分为三种：\r\n\r\n* 单行注释：\r\n\r\n~~~java\r\n// 这是单行注释文字\r\n~~~\r\n\r\n* 多行注释：\r\n\r\n~~~java\r\n/*\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n注意：多行注释不能嵌套使用。\r\n~~~\r\n\r\n* 文档注释（暂时用不到）：\r\n\r\n```java\r\n/**\r\n这是多行注释文字\r\n这是多行注释文字\r\n这是多行注释文字\r\n*/\r\n```\r\n\r\n### 使用的技巧\r\n\r\n​\t如果我们要对代码进行解释，那么就可以使用注释。\r\n\r\n​\t当注释的内容比较少，一行就写完了，可以用单行注释。\r\n\r\n​\t如果注释的内容比较多，需要写在多行，那么可以使用多行注释。\r\n\r\n### 注意点\r\n\r\n​\t注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。\r\n\r\n​\t所以，不管在注释当中写什么内容，都不会影响代码运行的结果。\r\n\r\n## 2. 关键字\r\n\r\n### 2.1 概念\r\n\r\n​\t被Java赋予了特定含义的英文单词。\r\n\r\n​\t当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。\r\n\r\n注意：关键字很多，不用刻意去记。\r\n\r\n| **abstract**   | **assert**       | **boolean**   | **break**      | **byte**   |\r\n| -------------- | ---------------- | ------------- | -------------- | ---------- |\r\n| **case**       | **catch**        | **char**      | **class**      | **const**  |\r\n| **continue**   | **default**      | **do**        | **double**     | **else**   |\r\n| **enum**       | **extends**      | **final**     | **finally**    | **float**  |\r\n| **for**        | **goto**         | **if**        | **implements** | **import** |\r\n| **instanceof** | **int**          | **interface** | **long**       | **native** |\r\n| **new**        | **package**      | **private**   | **protected**  | **public** |\r\n| **return**     | **strictfp**     | **short**     | **static**     | **super**  |\r\n| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |\r\n| **transient**  | **try**          | **void**      | **volatile**   | **while**  |\r\n\r\n### 2.2 第一个关键字class\r\n\r\n​\t表示定义一个类。创建一个类。\r\n\r\n类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。\r\n\r\nclass后面跟随的就是这个类的名字，简称：类名。\r\n\r\n在类名后面会有一对大括号，表示这个类的内容。\r\n\r\n举例：\r\n\r\n```java\r\npublic class HelloWorld{\r\n    \r\n   \r\n}\r\n```\r\n\r\n解释：class表示定义类。\r\n\r\n​\t类名：HelloWorld\r\n\r\n​\tHelloWorld后面的大括号表示这个类的范围。\r\n\r\n## 3. 字面量\r\n\r\n作用：告诉程序员，数据在程序中的书写格式。\r\n\r\n| **字面量类型** | **说明**                                  | **程序中的写法**           |\r\n| -------------- | ----------------------------------------- | -------------------------- |\r\n| 整数           | 不带小数的数字                            | 666，-88                   |\r\n| 小数           | 带小数的数字                              | 13.14，-5.21               |\r\n| 字符           | 必须使用单引号，有且仅能一个字符          | ‘A’，‘0’，   ‘我’          |\r\n| 字符串         | 必须使用双引号，内容可有可无              | “HelloWorld”，“黑马程序员” |\r\n| 布尔值         | 布尔值，表示真假，只有两个值：true，false | true 、false               |\r\n| 空值           | 一个特殊的值，空值                        | 值是：null                 |\r\n\r\n~~~java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        System.out.println(10); // 输出一个整数\r\n        System.out.println(5.5); // 输出一个小数\r\n        System.out.println('a'); // 输出一个字符\r\n        System.out.println(true); // 输出boolean值true\r\n        System.out.println(\"欢迎来到黑马程序员\"); // 输出字符串\r\n    }\r\n}\r\n~~~\r\n\r\n### 区分技巧\r\n\r\n1. 不带小数点的数字都是整数类型的字面量。\r\n2. 只要带了小数点，那么就是小数类型的字面量。\r\n3. 只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。\r\n4. 字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。\r\n5. 字符类型的字面量只有两个值，true、false。\r\n6. 空类型的字面量只有一个值，null。\r\n\r\n## 4. 变量\r\n\r\n### 4.1 什么是变量？\r\n\r\n​\t变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。\r\n\r\n### 4.2 变量的定义格式\r\n\r\n​\t数据类型 变量名 = 数据值；\r\n\r\n#### 4.2.1 格式详解\r\n\r\n​\t数据类型：限定了变量当中能存储什么类型的数据。\r\n\r\n​\t\t\t   如果要存10，那么数据类型就需要写整数类型。\r\n\r\n​\t\t\t   如果要存10.0，那么数据类型就需要写小数类型。\r\n\r\n​\t变量名：其实就是这个容器的名字。\r\n\r\n​\t\t\t当以后想要使用变量里面的数据时，直接使用变量名就可以了。\r\n\r\n​\t数据值：真正存储在容器中的数据。\r\n\r\n​\t分号：表示语句的结束，就跟以前写作文时候的句号是一样的。\r\n\r\n#### 4.2.2 常用的数据类型\r\n\r\n​\t整数：int\r\n\r\n​\t小数：（浮点数）double\r\n\r\n​\t其他数据类型稍后讲解\r\n\r\n举例：\r\n\r\n```java\r\npublic class VariableDemo{\r\n\tpublic static void main(String[] args){\r\n\t\t//定义一个整数类型的变量\r\n\t\t//数据类型 变量名 = 数据值;\r\n\t\tint a = 16;\r\n\t\tSystem.out.println(a);//16\r\n\t\t\r\n\t\t//定义一个小数类型的变量\r\n\t\tdouble b = 10.1;\r\n\t\tSystem.out.println(b);//10.1\r\n\t}\r\n}\r\n```\r\n\r\n#### 4.2.3 变量的注意事项\r\n\r\n- 变量名不能重复\r\n- 在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。\r\n- 变量在使用之前必须要赋值。\r\n\r\n案例：\r\n\r\n```java\r\npublic class VariableDemo2{\r\n\tpublic static void main(String[] args){\r\n\t\t//1.变量名不允许重复\r\n\t\t//int a = 10;\r\n\t\t//int a = 20;\r\n\t\t//System.out.println(a);\r\n\t\t\r\n\t\t//2.一条语句可以定义多个变量\r\n\t\t//了解。\r\n\t\t//int a = 10, b = 20, c = 20,d = 20;\r\n\t\t//System.out.println(a);//?\r\n\t\t//System.out.println(b);//?\r\n\t\t\r\n\t\t\r\n\t\t//3.变量在使用之前必须要赋值\r\n\t\tint a = 30;\r\n\t\tSystem.out.println(a);\r\n\t}\r\n}\r\n```\r\n\r\n## 5. 数据类型\r\n\r\n### 5.1 Java语言数据类型的分类\r\n\r\n- 基本数据类型\r\n- 引用数据类型（面向对象的时候再深入学习）\r\n\r\n### 5.2 基本数据类型的四类八种\r\n\r\n| 数据类型 | 关键字  | 内存占用 |                 取值范围                  |\r\n| :------: | :-----: | :------: | :---------------------------------------: |\r\n|   整数   |  byte   |    1     |    负的2的7次方 ~ 2的7次方-1(-128~127)    |\r\n|          |  short  |    2     | 负的2的15次方 ~ 2的15次方-1(-32768~32767) |\r\n|          |   int   |    4     |        负的2的31次方 ~ 2的31次方-1        |\r\n|          |  long   |    8     |        负的2的63次方 ~ 2的63次方-1        |\r\n|  浮点数  |  float  |    4     |        1.401298e-45 ~ 3.402823e+38        |\r\n|          | double  |    8     |      4.9000000e-324 ~ 1.797693e+308       |\r\n|   字符   |  char   |    2     |                  0-65535                  |\r\n|   布尔   | boolean |    1     |                true，false                |\r\n\r\n#### 说明\r\n\r\n​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。\r\n\r\n​\t在java中整数默认是int类型，浮点数默认是double类型。\r\n\r\n#### 需要记忆以下几点\r\n\r\nbyte类型的取值范围：\r\n\r\n​\t-128 ~ 127\r\n\r\nint类型的大概取值范围：\r\n\r\n​\t-21亿多  ~ 21亿多\r\n\r\n整数类型和小数类型的取值范围大小关系：\r\n\r\n​\tdouble > float > long > int > short > byte\r\n\r\n最为常用的数据类型选择：\r\n\r\n- 在定义变量的时候，要根据实际的情况来选择不同类型的变量。\r\n\r\n  比如：人的年龄，可以选择byte类型。\r\n\r\n  比如：地球的年龄，可以选择long类型。\r\n\r\n- 如果整数类型中，不太确定范围，那么默认使用int类型。\r\n\r\n- 如果小数类型中，不太确定范围，那么默认使用double类型。\r\n\r\n- 如果要定义字符类型的变量，那么使用char\r\n\r\n- 如果要定义布尔类型的变量，那么使用boolean\r\n\r\n### 5.3 定义8种基本数据类型变量\r\n\r\n```java\r\npublic class VariableDemo3{\r\n    public static void main(String[] args){\r\n        //1.定义byte类型的变量\r\n        //数据类型 变量名 = 数据值;\r\n        byte a = 10;\r\n        System.out.println(a);\r\n\r\n        //2.定义short类型的变量\r\n        short b = 20;\r\n        System.out.println(b);\r\n\r\n        //3.定义int类型的变量\r\n        int c = 30;\r\n        System.out.println(c);\r\n\r\n        //4.定义long类型的变量\r\n        long d = 123456789123456789L;\r\n        System.out.println(d);\r\n\r\n        //5.定义float类型的变量\r\n        float e = 10.1F;\r\n        System.out.println(e);\r\n\r\n        //6.定义double类型的变量\r\n        double f = 20.3;\r\n        System.out.println(f);\r\n\r\n        //7.定义char类型的变量\r\n        char g = 'a';\r\n        System.out.println(g);\r\n\r\n        //8.定义boolean类型的变量\r\n        boolean h = true;\r\n        System.out.println(h);\r\n\r\n    }\r\n}\r\n```\r\n\r\n#### **注意点**\r\n\r\n- 如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。\r\n- 如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。\r\n- 如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）\r\n- 如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）\r\n\r\n## 6. 标识符\r\n\r\n### 6.1 硬性要求：\r\n\r\n​\t必须要这么做，否则代码会报错。\r\n\r\n- 必须由数字、字母、下划线_、美元符号$组成。\r\n- 数字不能开头\r\n- 不能是关键字\r\n- 区分大小写的。\r\n\r\n### 6.2 软件建议：\r\n\r\n​\t如果不这么做，代码不会报错，但是会让代码显得比较low。\r\n\r\n### 6.2.1 小驼峰命名法\r\n\r\n适用于变量名和方法名\r\n\r\n* 如果是一个单词，那么全部小写，比如：name\r\n\r\n* 如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge\r\n\r\n### 6.2.2 大驼峰命名法\r\n\r\n适用于类名\r\n\r\n* 如果是一个单词，那么首字母大写。比如：Demo、Test。\r\n\r\n* 如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld\r\n\r\n不管起什么名字，都要做到见名知意。\r\n\r\n### 阿里巴巴命名规范细节：\r\n\r\n1. 尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。\r\n\r\n   正确：alibaba、hangzhou、nanjing\r\n\r\n   错误：jiage、dazhe\r\n\r\n2. 平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。\r\n\r\n   错误：_name\r\n\r\n   正确：name\r\n\r\n## 7. 键盘录入\r\n\r\n​\t键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。\r\n\r\n使用步骤：\r\n\r\n第一步：\r\n\r\n​\t导包：其实就是表示先找到Scanner这个类在哪。\r\n\r\n第二步：\r\n\r\n​\t创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。\r\n\r\n第三步：\r\n\r\n​\t接收数据：也是真正干活的代码。\r\n\r\n代码示例：\r\n\r\n```java\r\n//导包，其实就是先找到Scanner这个类在哪\r\nimport java.util.Scanner;\r\npublic class ScannerDemo1{\r\n\tpublic static void main(String[] args){\r\n\t\t//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。\r\n\t\tScanner sc = new Scanner(System.in);\r\n\t\t//3.接收数据\r\n\t\t//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了\r\n\t\tSystem.out.println(\"请输入一个数字\");\r\n\t\tint i = sc.nextInt();\r\n\t\tSystem.out.println(i);\r\n\t}\r\n}\r\n```\r\n\r\n## 8. IDEA\r\n\r\n### 8.1 IDEA概述\r\n\r\n​\tIDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。\r\n\r\n**集成环境：**\r\n\r\n​\t把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。\r\n\r\n### 8.2 IDEA的下载和安装\r\n\r\n#### 8.2.1 下载\r\n\r\n​\t可以到官方网站自行下载，网址为：https://www.jetbrains.com/idea\r\n\r\n​\t今天的资料中，对应的安装包也提高给大家了。\r\n",contentRendered:'<h1 id="day02-java基础语法" tabindex="-1"><a class="header-anchor" href="#day02-java基础语法" aria-hidden="true">#</a> day02 - Java基础语法</h1>\n<h2 id="_1-注释" tabindex="-1"><a class="header-anchor" href="#_1-注释" aria-hidden="true">#</a> 1. 注释</h2>\n<p>​\t注释是对代码的解释和说明文字。</p>\n<p>Java中的注释分为三种：</p>\n<ul>\n<li>单行注释：</li>\n</ul>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token comment">// 这是单行注释文字</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>多行注释：</li>\n</ul>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token comment">/*\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/</span>\n注意：多行注释不能嵌套使用。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul>\n<li>文档注释（暂时用不到）：</li>\n</ul>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token doc-comment comment">/**\n这是多行注释文字\n这是多行注释文字\n这是多行注释文字\n*/</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="使用的技巧" tabindex="-1"><a class="header-anchor" href="#使用的技巧" aria-hidden="true">#</a> 使用的技巧</h3>\n<p>​\t如果我们要对代码进行解释，那么就可以使用注释。</p>\n<p>​\t当注释的内容比较少，一行就写完了，可以用单行注释。</p>\n<p>​\t如果注释的内容比较多，需要写在多行，那么可以使用多行注释。</p>\n<h3 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点" aria-hidden="true">#</a> 注意点</h3>\n<p>​\t注释的内容不会参与编译和运行的，仅仅是对代码的解释说明而已。</p>\n<p>​\t所以，不管在注释当中写什么内容，都不会影响代码运行的结果。</p>\n<h2 id="_2-关键字" tabindex="-1"><a class="header-anchor" href="#_2-关键字" aria-hidden="true">#</a> 2. 关键字</h2>\n<h3 id="_2-1-概念" tabindex="-1"><a class="header-anchor" href="#_2-1-概念" aria-hidden="true">#</a> 2.1 概念</h3>\n<p>​\t被Java赋予了特定含义的英文单词。</p>\n<p>​\t当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。</p>\n<p>注意：关键字很多，不用刻意去记。</p>\n<table>\n<thead>\n<tr>\n<th><strong>abstract</strong></th>\n<th><strong>assert</strong></th>\n<th><strong>boolean</strong></th>\n<th><strong>break</strong></th>\n<th><strong>byte</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>case</strong></td>\n<td><strong>catch</strong></td>\n<td><strong>char</strong></td>\n<td><strong>class</strong></td>\n<td><strong>const</strong></td>\n</tr>\n<tr>\n<td><strong>continue</strong></td>\n<td><strong>default</strong></td>\n<td><strong>do</strong></td>\n<td><strong>double</strong></td>\n<td><strong>else</strong></td>\n</tr>\n<tr>\n<td><strong>enum</strong></td>\n<td><strong>extends</strong></td>\n<td><strong>final</strong></td>\n<td><strong>finally</strong></td>\n<td><strong>float</strong></td>\n</tr>\n<tr>\n<td><strong>for</strong></td>\n<td><strong>goto</strong></td>\n<td><strong>if</strong></td>\n<td><strong>implements</strong></td>\n<td><strong>import</strong></td>\n</tr>\n<tr>\n<td><strong>instanceof</strong></td>\n<td><strong>int</strong></td>\n<td><strong>interface</strong></td>\n<td><strong>long</strong></td>\n<td><strong>native</strong></td>\n</tr>\n<tr>\n<td><strong>new</strong></td>\n<td><strong>package</strong></td>\n<td><strong>private</strong></td>\n<td><strong>protected</strong></td>\n<td><strong>public</strong></td>\n</tr>\n<tr>\n<td><strong>return</strong></td>\n<td><strong>strictfp</strong></td>\n<td><strong>short</strong></td>\n<td><strong>static</strong></td>\n<td><strong>super</strong></td>\n</tr>\n<tr>\n<td><strong>switch</strong></td>\n<td><strong>synchronized</strong></td>\n<td><strong>this</strong></td>\n<td><strong>throw</strong></td>\n<td><strong>throws</strong></td>\n</tr>\n<tr>\n<td><strong>transient</strong></td>\n<td><strong>try</strong></td>\n<td><strong>void</strong></td>\n<td><strong>volatile</strong></td>\n<td><strong>while</strong></td>\n</tr>\n</tbody>\n</table>\n<h3 id="_2-2-第一个关键字class" tabindex="-1"><a class="header-anchor" href="#_2-2-第一个关键字class" aria-hidden="true">#</a> 2.2 第一个关键字class</h3>\n<p>​\t表示定义一个类。创建一个类。</p>\n<p>类：Java项目最基本的组成单元，一个完整的Java项目有可能会有成千上万个类来组成的。</p>\n<p>class后面跟随的就是这个类的名字，简称：类名。</p>\n<p>在类名后面会有一对大括号，表示这个类的内容。</p>\n<p>举例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>\n    \n   \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>解释：class表示定义类。</p>\n<p>​\t类名：HelloWorld</p>\n<p>​\tHelloWorld后面的大括号表示这个类的范围。</p>\n<h2 id="_3-字面量" tabindex="-1"><a class="header-anchor" href="#_3-字面量" aria-hidden="true">#</a> 3. 字面量</h2>\n<p>作用：告诉程序员，数据在程序中的书写格式。</p>\n<table>\n<thead>\n<tr>\n<th><strong>字面量类型</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>程序中的写法</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>整数</td>\n<td>不带小数的数字</td>\n<td>666，-88</td>\n</tr>\n<tr>\n<td>小数</td>\n<td>带小数的数字</td>\n<td>13.14，-5.21</td>\n</tr>\n<tr>\n<td>字符</td>\n<td>必须使用单引号，有且仅能一个字符</td>\n<td>‘A’，‘0’，   ‘我’</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>必须使用双引号，内容可有可无</td>\n<td>“HelloWorld”，“黑马程序员”</td>\n</tr>\n<tr>\n<td>布尔值</td>\n<td>布尔值，表示真假，只有两个值：true，false</td>\n<td>true 、false</td>\n</tr>\n<tr>\n<td>空值</td>\n<td>一个特殊的值，空值</td>\n<td>值是：null</td>\n</tr>\n</tbody>\n</table>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出一个整数</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">5.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出一个小数</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token char">\'a\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出一个字符</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出boolean值true</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"欢迎来到黑马程序员"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出字符串</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="区分技巧" tabindex="-1"><a class="header-anchor" href="#区分技巧" aria-hidden="true">#</a> 区分技巧</h3>\n<ol>\n<li>不带小数点的数字都是整数类型的字面量。</li>\n<li>只要带了小数点，那么就是小数类型的字面量。</li>\n<li>只要用双引号引起来的，不管里面的内容是什么，不管里面有没有内容，都是字符串类型的字面量。</li>\n<li>字符类型的字面量必须用单引号引起来，不管内容是什么，但是个数有且只能有一个。</li>\n<li>字符类型的字面量只有两个值，true、false。</li>\n<li>空类型的字面量只有一个值，null。</li>\n</ol>\n<h2 id="_4-变量" tabindex="-1"><a class="header-anchor" href="#_4-变量" aria-hidden="true">#</a> 4. 变量</h2>\n<h3 id="_4-1-什么是变量" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是变量" aria-hidden="true">#</a> 4.1 什么是变量？</h3>\n<p>​\t变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。</p>\n<h3 id="_4-2-变量的定义格式" tabindex="-1"><a class="header-anchor" href="#_4-2-变量的定义格式" aria-hidden="true">#</a> 4.2 变量的定义格式</h3>\n<p>​\t数据类型 变量名 = 数据值；</p>\n<h4 id="_4-2-1-格式详解" tabindex="-1"><a class="header-anchor" href="#_4-2-1-格式详解" aria-hidden="true">#</a> 4.2.1 格式详解</h4>\n<p>​\t数据类型：限定了变量当中能存储什么类型的数据。</p>\n<p>​\t\t\t   如果要存10，那么数据类型就需要写整数类型。</p>\n<p>​\t\t\t   如果要存10.0，那么数据类型就需要写小数类型。</p>\n<p>​\t变量名：其实就是这个容器的名字。</p>\n<p>​\t\t\t当以后想要使用变量里面的数据时，直接使用变量名就可以了。</p>\n<p>​\t数据值：真正存储在容器中的数据。</p>\n<p>​\t分号：表示语句的结束，就跟以前写作文时候的句号是一样的。</p>\n<h4 id="_4-2-2-常用的数据类型" tabindex="-1"><a class="header-anchor" href="#_4-2-2-常用的数据类型" aria-hidden="true">#</a> 4.2.2 常用的数据类型</h4>\n<p>​\t整数：int</p>\n<p>​\t小数：（浮点数）double</p>\n<p>​\t其他数据类型稍后讲解</p>\n<p>举例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableDemo</span><span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token comment">//定义一个整数类型的变量</span>\n\t\t<span class="token comment">//数据类型 变量名 = 数据值;</span>\n\t\t<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//16</span>\n\t\t\n\t\t<span class="token comment">//定义一个小数类型的变量</span>\n\t\t<span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">10.1</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10.1</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_4-2-3-变量的注意事项" tabindex="-1"><a class="header-anchor" href="#_4-2-3-变量的注意事项" aria-hidden="true">#</a> 4.2.3 变量的注意事项</h4>\n<ul>\n<li>变量名不能重复</li>\n<li>在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。</li>\n<li>变量在使用之前必须要赋值。</li>\n</ul>\n<p>案例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableDemo2</span><span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token comment">//1.变量名不允许重复</span>\n\t\t<span class="token comment">//int a = 10;</span>\n\t\t<span class="token comment">//int a = 20;</span>\n\t\t<span class="token comment">//System.out.println(a);</span>\n\t\t\n\t\t<span class="token comment">//2.一条语句可以定义多个变量</span>\n\t\t<span class="token comment">//了解。</span>\n\t\t<span class="token comment">//int a = 10, b = 20, c = 20,d = 20;</span>\n\t\t<span class="token comment">//System.out.println(a);//?</span>\n\t\t<span class="token comment">//System.out.println(b);//?</span>\n\t\t\n\t\t\n\t\t<span class="token comment">//3.变量在使用之前必须要赋值</span>\n\t\t<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_5-数据类型" tabindex="-1"><a class="header-anchor" href="#_5-数据类型" aria-hidden="true">#</a> 5. 数据类型</h2>\n<h3 id="_5-1-java语言数据类型的分类" tabindex="-1"><a class="header-anchor" href="#_5-1-java语言数据类型的分类" aria-hidden="true">#</a> 5.1 Java语言数据类型的分类</h3>\n<ul>\n<li>基本数据类型</li>\n<li>引用数据类型（面向对象的时候再深入学习）</li>\n</ul>\n<h3 id="_5-2-基本数据类型的四类八种" tabindex="-1"><a class="header-anchor" href="#_5-2-基本数据类型的四类八种" aria-hidden="true">#</a> 5.2 基本数据类型的四类八种</h3>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">数据类型</th>\n<th style="text-align:center">关键字</th>\n<th style="text-align:center">内存占用</th>\n<th style="text-align:center">取值范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">整数</td>\n<td style="text-align:center">byte</td>\n<td style="text-align:center">1</td>\n<td style="text-align:center">负的2的7次方 ~ 2的7次方-1(-128~127)</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">short</td>\n<td style="text-align:center">2</td>\n<td style="text-align:center">负的2的15次方 ~ 2的15次方-1(-32768~32767)</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">int</td>\n<td style="text-align:center">4</td>\n<td style="text-align:center">负的2的31次方 ~ 2的31次方-1</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">long</td>\n<td style="text-align:center">8</td>\n<td style="text-align:center">负的2的63次方 ~ 2的63次方-1</td>\n</tr>\n<tr>\n<td style="text-align:center">浮点数</td>\n<td style="text-align:center">float</td>\n<td style="text-align:center">4</td>\n<td style="text-align:center">1.401298e-45 ~ 3.402823e+38</td>\n</tr>\n<tr>\n<td style="text-align:center"></td>\n<td style="text-align:center">double</td>\n<td style="text-align:center">8</td>\n<td style="text-align:center">4.9000000e-324 ~ 1.797693e+308</td>\n</tr>\n<tr>\n<td style="text-align:center">字符</td>\n<td style="text-align:center">char</td>\n<td style="text-align:center">2</td>\n<td style="text-align:center">0-65535</td>\n</tr>\n<tr>\n<td style="text-align:center">布尔</td>\n<td style="text-align:center">boolean</td>\n<td style="text-align:center">1</td>\n<td style="text-align:center">true，false</td>\n</tr>\n</tbody>\n</table>\n<h4 id="说明" tabindex="-1"><a class="header-anchor" href="#说明" aria-hidden="true">#</a> 说明</h4>\n<p>​\te+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方。</p>\n<p>​\t在java中整数默认是int类型，浮点数默认是double类型。</p>\n<h4 id="需要记忆以下几点" tabindex="-1"><a class="header-anchor" href="#需要记忆以下几点" aria-hidden="true">#</a> 需要记忆以下几点</h4>\n<p>byte类型的取值范围：</p>\n<p>​\t-128 ~ 127</p>\n<p>int类型的大概取值范围：</p>\n<p>​\t-21亿多  ~ 21亿多</p>\n<p>整数类型和小数类型的取值范围大小关系：</p>\n<p>​\tdouble &gt; float &gt; long &gt; int &gt; short &gt; byte</p>\n<p>最为常用的数据类型选择：</p>\n<ul>\n<li>\n<p>在定义变量的时候，要根据实际的情况来选择不同类型的变量。</p>\n<p>比如：人的年龄，可以选择byte类型。</p>\n<p>比如：地球的年龄，可以选择long类型。</p>\n</li>\n<li>\n<p>如果整数类型中，不太确定范围，那么默认使用int类型。</p>\n</li>\n<li>\n<p>如果小数类型中，不太确定范围，那么默认使用double类型。</p>\n</li>\n<li>\n<p>如果要定义字符类型的变量，那么使用char</p>\n</li>\n<li>\n<p>如果要定义布尔类型的变量，那么使用boolean</p>\n</li>\n</ul>\n<h3 id="_5-3-定义8种基本数据类型变量" tabindex="-1"><a class="header-anchor" href="#_5-3-定义8种基本数据类型变量" aria-hidden="true">#</a> 5.3 定义8种基本数据类型变量</h3>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableDemo3</span><span class="token punctuation">{</span>\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token comment">//1.定义byte类型的变量</span>\n        <span class="token comment">//数据类型 变量名 = 数据值;</span>\n        <span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//2.定义short类型的变量</span>\n        <span class="token keyword">short</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//3.定义int类型的变量</span>\n        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//4.定义long类型的变量</span>\n        <span class="token keyword">long</span> d <span class="token operator">=</span> <span class="token number">123456789123456789L</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//5.定义float类型的变量</span>\n        <span class="token keyword">float</span> e <span class="token operator">=</span> <span class="token number">10.1F</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//6.定义double类型的变量</span>\n        <span class="token keyword">double</span> f <span class="token operator">=</span> <span class="token number">20.3</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//7.定义char类型的变量</span>\n        <span class="token keyword">char</span> g <span class="token operator">=</span> <span class="token char">\'a\'</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token comment">//8.定义boolean类型的变量</span>\n        <span class="token keyword">boolean</span> h <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h4 id="注意点-1" tabindex="-1"><a class="header-anchor" href="#注意点-1" aria-hidden="true">#</a> <strong>注意点</strong></h4>\n<ul>\n<li>如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用int。</li>\n<li>如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用double。</li>\n<li>如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（大小写都可以，建议大写。）</li>\n<li>如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。（大小写都可以）</li>\n</ul>\n<h2 id="_6-标识符" tabindex="-1"><a class="header-anchor" href="#_6-标识符" aria-hidden="true">#</a> 6. 标识符</h2>\n<h3 id="_6-1-硬性要求" tabindex="-1"><a class="header-anchor" href="#_6-1-硬性要求" aria-hidden="true">#</a> 6.1 硬性要求：</h3>\n<p>​\t必须要这么做，否则代码会报错。</p>\n<ul>\n<li>必须由数字、字母、下划线_、美元符号$组成。</li>\n<li>数字不能开头</li>\n<li>不能是关键字</li>\n<li>区分大小写的。</li>\n</ul>\n<h3 id="_6-2-软件建议" tabindex="-1"><a class="header-anchor" href="#_6-2-软件建议" aria-hidden="true">#</a> 6.2 软件建议：</h3>\n<p>​\t如果不这么做，代码不会报错，但是会让代码显得比较low。</p>\n<h3 id="_6-2-1-小驼峰命名法" tabindex="-1"><a class="header-anchor" href="#_6-2-1-小驼峰命名法" aria-hidden="true">#</a> 6.2.1 小驼峰命名法</h3>\n<p>适用于变量名和方法名</p>\n<ul>\n<li>\n<p>如果是一个单词，那么全部小写，比如：name</p>\n</li>\n<li>\n<p>如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge</p>\n</li>\n</ul>\n<h3 id="_6-2-2-大驼峰命名法" tabindex="-1"><a class="header-anchor" href="#_6-2-2-大驼峰命名法" aria-hidden="true">#</a> 6.2.2 大驼峰命名法</h3>\n<p>适用于类名</p>\n<ul>\n<li>\n<p>如果是一个单词，那么首字母大写。比如：Demo、Test。</p>\n</li>\n<li>\n<p>如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld</p>\n</li>\n</ul>\n<p>不管起什么名字，都要做到见名知意。</p>\n<h3 id="阿里巴巴命名规范细节" tabindex="-1"><a class="header-anchor" href="#阿里巴巴命名规范细节" aria-hidden="true">#</a> 阿里巴巴命名规范细节：</h3>\n<ol>\n<li>\n<p>尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。</p>\n<p>正确：alibaba、hangzhou、nanjing</p>\n<p>错误：jiage、dazhe</p>\n</li>\n<li>\n<p>平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。</p>\n<p>错误：_name</p>\n<p>正确：name</p>\n</li>\n</ol>\n<h2 id="_7-键盘录入" tabindex="-1"><a class="header-anchor" href="#_7-键盘录入" aria-hidden="true">#</a> 7. 键盘录入</h2>\n<p>​\t键盘录入的实际功能Java已经帮我们写好了，不需要我们自己再实现了，而Java写好的功能都放在了Scanner这个类中，所以，我们只要直接使用Scanner这个类就可以了。</p>\n<p>使用步骤：</p>\n<p>第一步：</p>\n<p>​\t导包：其实就是表示先找到Scanner这个类在哪。</p>\n<p>第二步：</p>\n<p>​\t创建对象：其实就表示申明一下，我准备开始用Scanner这个类了。</p>\n<p>第三步：</p>\n<p>​\t接收数据：也是真正干活的代码。</p>\n<p>代码示例：</p>\n<div class="language-java ext-java line-numbers-mode"><pre v-pre class="language-java"><code><span class="token comment">//导包，其实就是先找到Scanner这个类在哪</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Scanner</span><span class="token punctuation">;</span>\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScannerDemo1</span><span class="token punctuation">{</span>\n\t<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>\n\t\t<span class="token comment">//2.创建对象，其实就是申明一下，我准备开始用Scanner这个类了。</span>\n\t\t<span class="token class-name">Scanner</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token comment">//3.接收数据</span>\n\t\t<span class="token comment">//当程序运行之后，我们在键盘输入的数据就会被变量i给接收了</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请输入一个数字"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token keyword">int</span> i <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t\t<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_8-idea" tabindex="-1"><a class="header-anchor" href="#_8-idea" aria-hidden="true">#</a> 8. IDEA</h2>\n<h3 id="_8-1-idea概述" tabindex="-1"><a class="header-anchor" href="#_8-1-idea概述" aria-hidden="true">#</a> 8.1 IDEA概述</h3>\n<p>​\tIDEA全称IntelliJ IDEA，是用于Java语言开发的集成环境，它是业界公认的目前用于Java程序开发最好的工具。</p>\n<p><strong>集成环境：</strong></p>\n<p>​\t把代码编写，编译，执行，调试等多种功能综合到一起的开发工具。</p>\n<h3 id="_8-2-idea的下载和安装" tabindex="-1"><a class="header-anchor" href="#_8-2-idea的下载和安装" aria-hidden="true">#</a> 8.2 IDEA的下载和安装</h3>\n<h4 id="_8-2-1-下载" tabindex="-1"><a class="header-anchor" href="#_8-2-1-下载" aria-hidden="true">#</a> 8.2.1 下载</h4>\n<p>​\t可以到官方网站自行下载，网址为：https://www.jetbrains.com/idea</p>\n<p>​\t今天的资料中，对应的安装包也提高给大家了。</p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/JAVA/2Java基础语法.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"2Java基础语法",filePath:"D:/桌面文件/Blog/blog-demo/docs/JAVA/2Java基础语法.md",filePathRelative:"JAVA/2Java基础语法.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/2Java基础语法.html.vue",componentFilePathRelative:"pages/JAVA/2Java基础语法.html.vue",componentFileChunkName:"v-7e88feb6",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/JAVA/2Java基础语法.html.js",dataFilePathRelative:"pages/JAVA/2Java基础语法.html.js",dataFileChunkName:"v-7e88feb6",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/JAVA/2Java基础语法.html",htmlFilePathRelative:"JAVA/2Java基础语法.html"},{data:{key:"v-c11452c2",path:"/Vue/vuex%E5%85%A5%E9%97%A8.html",title:"vuex 概述",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"回顾-组件之间共享状态 (组件通信方案)",slug:"回顾-组件之间共享状态-组件通信方案",children:[]},{level:2,title:"vuex基本概念",slug:"vuex基本概念",children:[]},{level:2,title:"vuex的优点: 方便的解决多组件的共享状态",slug:"vuex的优点-方便的解决多组件的共享状态",children:[]},{level:2,title:"什么数据适合存到vuex中",slug:"什么数据适合存到vuex中",children:[]},{level:2,title:"概述小结:",slug:"概述小结",children:[]},{level:2,title:"需求: 多组件共享数据",slug:"需求-多组件共享数据",children:[]},{level:2,title:"vuex 的使用 - 创建仓库",slug:"vuex-的使用-创建仓库",children:[]},{level:2,title:"核心概念 - state 状态",slug:"核心概念-state-状态",children:[]},{level:2,title:"核心概念 - mutations",slug:"核心概念-mutations",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"带参数的 mutation",slug:"带参数的-mutation",children:[]},{level:3,title:"辅助函数 - mapMutations",slug:"辅助函数-mapmutations",children:[]}]},{level:2,title:"核心概念-actions",slug:"核心概念-actions",children:[]},{level:2,title:"核心概念-getters",slug:"核心概念-getters",children:[]},{level:2,title:"核心概念 - 模块 module (进阶拓展)",slug:"核心概念-模块-module-进阶拓展",children:[{level:3,title:"模块定义 - 准备 state",slug:"模块定义-准备-state",children:[]},{level:3,title:"命名空间 namespaced",slug:"命名空间-namespaced",children:[]}]}],git:{}},key:"v-c11452c2",path:"/Vue/vuex%E5%85%A5%E9%97%A8.html",title:"vuex 概述",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"回顾-组件之间共享状态 (组件通信方案)",slug:"回顾-组件之间共享状态-组件通信方案",children:[]},{level:2,title:"vuex基本概念",slug:"vuex基本概念",children:[]},{level:2,title:"vuex的优点: 方便的解决多组件的共享状态",slug:"vuex的优点-方便的解决多组件的共享状态",children:[]},{level:2,title:"什么数据适合存到vuex中",slug:"什么数据适合存到vuex中",children:[]},{level:2,title:"概述小结:",slug:"概述小结",children:[]},{level:2,title:"需求: 多组件共享数据",slug:"需求-多组件共享数据",children:[]},{level:2,title:"vuex 的使用 - 创建仓库",slug:"vuex-的使用-创建仓库",children:[]},{level:2,title:"核心概念 - state 状态",slug:"核心概念-state-状态",children:[]},{level:2,title:"核心概念 - mutations",slug:"核心概念-mutations",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"带参数的 mutation",slug:"带参数的-mutation",children:[]},{level:3,title:"辅助函数 - mapMutations",slug:"辅助函数-mapmutations",children:[]}]},{level:2,title:"核心概念-actions",slug:"核心概念-actions",children:[]},{level:2,title:"核心概念-getters",slug:"核心概念-getters",children:[]},{level:2,title:"核心概念 - 模块 module (进阶拓展)",slug:"核心概念-模块-module-进阶拓展",children:[{level:3,title:"模块定义 - 准备 state",slug:"模块定义-准备-state",children:[]},{level:3,title:"命名空间 namespaced",slug:"命名空间-namespaced",children:[]}]}],content:"# vuex 概述 \r\n\r\n目标：\r\n\r\n- 了解vuex的应用场景  (在哪用)\r\n- 掌握vuex的基本使用  (怎么用)\r\n\r\n**vuex 是一个 vue 的状态管理工具,  状态就是数据**\r\n\r\n\r\n\r\nvuex是一个插件工具，可以帮我们vue管理通用的数据\r\n\r\n之前如果要进行跨组件的数据通信  =>  父传子，子传父  =>  一旦组件关系复杂，数据非常难以维护\r\n\r\n\r\n\r\n## 回顾-组件之间共享状态 (组件通信方案)\r\n\r\n默认组件的数据, 是独立的, 每个组件有着自己的状态(数据)\r\n\r\n>  状态 === 数据\r\n\r\n组件之间共享状态的两种典型方式：\r\n\r\n- 父子之间 : props + $emit\r\n\r\n  父传子：props属性绑定\r\n\r\n  ```\r\n  <son1 msg=\"msg\"></son1>\r\n  ```\r\n\r\n  子传父：$emit事件绑定\r\n\r\n  ```\r\n  <div>\r\n  \t<button @click=\"$emit('event-name')\">通知父组件</button>\r\n  </div>\r\n  ```\r\n\r\n如果某个状态需要在很多个组件来使用，或者要实现多个组件共同维护一份数据又应该怎么做呢 ？\r\n\r\n这里就要引入Vuex了。\r\n\r\n\r\n\r\n## vuex基本概念\r\n\r\n[中文文档](https://vuex.vuejs.org/zh/guide/)\r\n\r\nvuex是vue的状态管理工具，**状态即数据**。 状态管理就是集中管理vue中 **通用的** 一些数据\r\n\r\n注意（官方原文）：\r\n\r\n- 不是所有的场景都适用于vuex，只有在必要的时候才使用vuex\r\n- 使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）\r\n\r\nVuex就像《近视眼镜》, 你自然会知道什么时候需要用它~\r\n\r\n\r\n\r\n## vuex的优点: 方便的解决多组件的共享状态\r\n\r\n vuex的作用是解决《多组件状态共享》的问题。\r\n\r\n- 它是独立于组件而单独存在的，所有的组件都可以把它当作  **一座桥梁** 来进行通讯。\r\n\r\n- 特点：\r\n\r\n  - **响应式**： 只要仓库一变化，其他所有地方都更新 （太爽了！！！）\r\n  - 操作更简洁\r\n\r\n  代码量非常少, 但是需要熟悉\r\n\r\n## 什么数据适合存到vuex中\r\n\r\n一般情况下，只有  **多个组件均需要共享的数据** ，才有必要存储在vuex中，\r\n\r\n对于某个组件中的私有数据，依旧存储在组件自身的data中。\r\n\r\n例如：\r\n\r\n- 对于所有组件而言，当前登陆的   **用户信息**  是需要在全体组件之间共享的，则它可以放在vuex中\r\n- 对于文章详情页组件来说，当前的用户浏览的文章列表数据则应该属于这个组件的私有数据，应该要放在这个组件data中。\r\n\r\n\r\n\r\n## 概述小结:\r\n\r\n1. vuex解决什么问题?   vuex 能解决  **多组件共享数据**  的问题,  非常方便便捷\r\n2. 什么样的数据, 适合存放到vuex?   多组件的  **通用**  的共用数据, 适合存到 vuex\r\n\r\nvuex 两大优势:\r\n\r\n1. 响应式变化\r\n2. 操作简洁  (vuex提供了一些简化语法的辅助函数, 这些辅助函数, 需要熟练掌握)\r\n\r\n\r\n\r\n# vuex入门\r\n\r\n## 需求: 多组件共享数据\r\n\r\n对于如下三个组件（一个父组件，两个子组件）\r\n\r\n效果是三个组件共享一份数据:\r\n\r\n- 任意一个组件都可以修改数据\r\n- 三个组件的数据是同步的\r\n\r\n1 创建项目\r\n\r\n```\r\nvue create vuex-demo\r\n```\r\n\r\n2 创建三个组件, 目录如下\r\n\r\n```\r\n|-components\r\n|--add-item.vue\r\n|--sub-item.vue\r\n|-App.vue\r\n```\r\n\r\n3 源代码如下\r\n\r\n`App.vue`在入口组件中引入add-item和sub-item这两个子组件\r\n\r\n```html\r\n<template>\r\n  <div id=\"app\">\r\n    <h1>根组件</h1>\r\n    <input type=\"text\">\r\n    <add-item></add-item>\r\n    <hr>\r\n    <sub-item></sub-item>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport AddItem from './components/add-item.vue'\r\nimport SubItem from './components/sub-item.vue'\r\n\r\nexport default {\r\n  name: 'app',\r\n  data: function () {\r\n    return {\r\n      \r\n    }\r\n  },\r\n  components: {\r\n    AddItem,\r\n    SubItem\r\n  }\r\n}\r\n<\/script>\r\n\r\n<style>\r\n#app {\r\n  width: 600px;\r\n  margin: 20px auto;\r\n  border: 3px solid #ccc;\r\n  border-radius: 3px;\r\n  padding: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n`main.js`\r\n\r\n```js\r\nimport Vue from 'vue'\r\nimport App from './App.vue'\r\n\r\nVue.config.productionTip = false\r\n\r\nnew Vue({\r\n  render: h => h(App)\r\n}).$mount('#app')\r\n```\r\n\r\n`sub-item.vue`\r\n\r\n```html\r\n<template>\r\n  <div class=\"box\">\r\n    <h2>子组件 sub</h2>\r\n    从vuex中获取的值: <label></label>\r\n    <br>\r\n    <button>值-1</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'SubItem'\r\n}\r\n<\/script>\r\n\r\n<style lang=\"css\" scoped>\r\n.box{\r\n  border: 3px solid #ccc;\r\n  width: 400px;\r\n  padding: 10px;\r\n  margin: 20px;\r\n}\r\nh2 {\r\n  margin-top: 10px;\r\n}\r\n</style>\r\n\r\n```\r\n\r\n`add-item.vue`\r\n\r\n```html\r\n<template>\r\n  <div class=\"box\">\r\n    <h2>子组件 add</h2>\r\n    从vuex中获取的值:<label></label>\r\n    <br />\r\n    <button>值+1</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'AddItem'\r\n}\r\n<\/script>\r\n\r\n<style lang=\"css\" scoped>\r\n.box {\r\n  border: 3px solid #ccc;\r\n  width: 400px;\r\n  padding: 10px;\r\n  margin: 20px;\r\n}\r\nh2 {\r\n  margin-top: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n\r\n## vuex 的使用 - 创建仓库\r\n\r\n1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。\r\n\r\n```\r\nyarn add vuex@3.4.0\r\n```\r\n\r\n2 新建 `store/index.js` 专门存放 vuex\r\n\r\n​\t为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 `router/index.js` 类似)\r\n\r\n​\t![image-20201029064100611](images/image-20201029064100611.png)\r\n\r\n3 创建仓库 `store/index.js` \r\n\r\n```jsx\r\n// 导入 vue\r\nimport Vue from 'vue'\r\n// 导入 vuex\r\nimport Vuex from 'vuex'\r\n// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化\r\nVue.use(Vuex)\r\n\r\n// 创建仓库 store\r\nconst store = new Vuex.Store()\r\n\r\n// 导出仓库\r\nexport default store\r\n```\r\n\r\n4 在 main.js 中导入挂载到 Vue 实例上\r\n\r\n```js\r\nimport Vue from 'vue'\r\nimport App from './App.vue'\r\nimport store from './store'\r\n\r\nVue.config.productionTip = false\r\n\r\nnew Vue({\r\n  render: h => h(App),\r\n  store\r\n}).$mount('#app')\r\n```\r\n\r\n此刻起, 就成功创建了一个 **空仓库!!**\r\n\r\n\r\n\r\n## 核心概念 - state 状态\r\n\r\nState提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。\r\n\r\n打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。\r\n\r\n```jsx\r\n// 创建仓库 store\r\nconst store = new Vuex.Store({\r\n  // state 状态, 即数据, 类似于vue组件中的data,\r\n  // 区别在于 data 是组件自己的数据, 而 state 中的数据整个vue项目的组件都能访问到\r\n  state: {\r\n    count: 101\r\n  }\r\n})\r\n```\r\n\r\n问题: 如何在组件中获取count?\r\n\r\n1. 插值表达式 =》  {{  $store.state.count  }}\r\n2. mapState 映射计算属性 =》  {{ count  }}\r\n\r\n\r\n\r\n**1 原始形式- 插值表达式**\r\n\r\n**`App.vue`**\r\n\r\n组件中可以使用  **this.$store** 获取到vuex中的store对象实例，可通过**state**属性属性获取**count**， 如下\r\n\r\n```vue\r\n<h1>state的数据 - {{ $store.state.count }}</h1>\r\n```\r\n\r\n**计算属性** - 将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html\r\n\r\n```js\r\n// 把state中数据，定义在组件内的计算属性中\r\n  computed: {\r\n    count () {\r\n      return this.$store.state.count\r\n    }\r\n  }\r\n```\r\n\r\n```vue\r\n<h1>state的数据 - {{ count }}</h1>\r\n```\r\n\r\n但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法\r\n\r\n\r\n\r\n**2 辅助函数  - mapState**\r\n\r\n>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法\r\n\r\n用法 ： \r\n\r\n第一步：导入mapState (mapState是vuex中的一个函数)\r\n\r\n```js\r\nimport { mapState } from 'vuex'\r\n```\r\n\r\n第二步：采用数组形式引入state属性\r\n\r\n```js\r\nmapState(['count']) \r\n```\r\n\r\n> 上面代码的最终得到的是 **类似于**\r\n\r\n```js\r\ncount () {\r\n    return this.$store.state.count\r\n}\r\n```\r\n\r\n第三步：利用**展开运算符**将导出的状态映射给计算属性\r\n\r\n```js\r\n  computed: {\r\n    ...mapState(['count'])\r\n  }\r\n```\r\n\r\n```vue\r\n <div> state的数据：{{ count }}</div>\r\n```\r\n\r\n\r\n\r\n## 核心概念 - mutations\r\n\r\n### 基本使用\r\n\r\n通过 `strict: true` 可以开启严格模式\r\n\r\n> **state数据的修改只能通过mutations，并且mutations必须是同步的**\r\n\r\n**定义mutations**\r\n\r\n```js\r\nconst store  = new Vuex.Store({\r\n  state: {\r\n    count: 0\r\n  },\r\n  // 定义mutations\r\n  mutations: {\r\n     \r\n  }\r\n})\r\n```\r\n\r\n**格式说明**\r\n\r\nmutations是一个对象，对象中存放修改state的方法\r\n\r\n```js\r\nmutations: {\r\n    // 方法里参数 第一个参数是当前store的state属性\r\n    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷\r\n    addCount (state) {\r\n      state.count += 1\r\n    }\r\n  },\r\n```\r\n\r\n组件中提交 mutations\r\n\r\n```jsx\r\nthis.$store.commit('addCount')\r\n```\r\n\r\n**解决问题: 两个子组件, 添加操作 add,  addN 实现**\r\n\r\n\r\n\r\n### 带参数的 mutation\r\n\r\n需求: 父组件也希望能改到数据\r\n\r\n提交 mutation 是可以传递参数的  `this.$store.commit('xxx',  参数)`\r\n\r\n1 提供mutation函数\r\n\r\n```js\r\nmutations: {\r\n  ...\r\n  inputCount (state, count) {\r\n    state.count = count\r\n  }\r\n},\r\n```\r\n\r\n2 注册事件\r\n\r\n```jsx\r\n<input type=\"text\" :value=\"count\" @input=\"handleInput\">\r\n```\r\n\r\n3 提交mutation\r\n\r\n```jsx\r\nhandleInput (e) {\r\n  this.$store.commit('inputCount', +e.target.value)\r\n}\r\n```\r\n\r\n**小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象**\r\n\r\n```jsx\r\nthis.$store.commit('inputCount', {\r\n  count: e.target.value\r\n})\r\n```\r\n\r\n**解决问题:  addN 的实现**\r\n\r\n\r\n\r\n### **辅助函数** - mapMutations\r\n\r\n> mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入\r\n\r\n```js\r\nimport  { mapMutations } from 'vuex'\r\nmethods: {\r\n    ...mapMutations(['addCount'])\r\n}\r\n```\r\n\r\n> 上面代码的含义是将mutations的方法导入了methods中，等价于\r\n\r\n```js\r\nmethods: {\r\n      // commit(方法名, 载荷参数)\r\n      addCount () {\r\n          this.$store.commit('addCount')\r\n      }\r\n }\r\n```\r\n\r\n此时，就可以直接通过this.addCount调用了\r\n\r\n```jsx\r\n<button @click=\"addCount\">值+1</button>\r\n```\r\n\r\n但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中\r\n\r\n\r\n\r\n## 核心概念-actions\r\n\r\n> state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，\r\n>\r\n> actions则负责进行异步操作\r\n\r\n**需求: 一秒钟之后, 要给一个数 去修改state**\r\n\r\n**定义actions**\r\n\r\n```js\r\nactions: {\r\n  setAsyncCount (context, num) {\r\n    // 一秒后, 给一个数, 去修改 num\r\n    setTimeout(() => {\r\n      context.commit('inputCount', num)\r\n    }, 1000)\r\n  }\r\n},\r\n```\r\n\r\n**原始调用** - $store (支持传参)\r\n\r\n```js\r\nsetAsyncCount () {\r\n  this.$store.dispatch('setAsyncCount', 200)\r\n}\r\n```\r\n\r\n\r\n\r\n**辅助函数** -mapActions\r\n\r\n> actions也有辅助函数，可以将action导入到组件中\r\n\r\n```js\r\nimport { mapActions } from 'vuex'\r\nmethods: {\r\n    ...mapActions(['setAsyncCount'])\r\n}\r\n```\r\n\r\n直接通过 this.方法 就可以调用\r\n\r\n```vue\r\n<button @click=\"setAsyncCount(200)\">+异步</button>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 核心概念-getters\r\n\r\n> 除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters\r\n\r\n例如，state中定义了list，为1-10的数组，\r\n\r\n```js\r\nstate: {\r\n    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n}\r\n```\r\n\r\n组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它\r\n\r\n**定义getters**\r\n\r\n```js\r\n  getters: {\r\n    // getters函数的第一个参数是 state\r\n    // 必须要有返回值\r\n     filterList:  state =>  state.list.filter(item => item > 5)\r\n  }\r\n```\r\n\r\n使用getters\r\n\r\n**原始方式** -$store\r\n\r\n```vue\r\n<div>{{ $store.getters.filterList }}</div>\r\n```\r\n\r\n**辅助函数** - mapGetters\r\n\r\n```js\r\ncomputed: {\r\n    ...mapGetters(['filterList'])\r\n}\r\n```\r\n\r\n```vue\r\n <div>{{ filterList }}</div>\r\n```\r\n\r\n\r\n\r\n## 核心概念 - 模块 module (**进阶拓展**)\r\n\r\n> **由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。**\r\n\r\n这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护\r\n\r\n由此，又有了Vuex的模块化\r\n\r\n\r\n\r\n### **模块定义** - 准备 state\r\n\r\n定义两个模块   **user** 和  **setting**\r\n\r\nuser中管理用户的信息状态  userInfo  `modules/user.js`\r\n\r\n```jsx\r\nconst state = {\r\n  userInfo: {\r\n    name: 'zs',\r\n    age: 18\r\n  }\r\n}\r\n\r\nconst mutations = {}\r\n\r\nconst actions = {}\r\n\r\nconst getters = {}\r\n\r\nexport default {\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters\r\n}\r\n\r\n```\r\n\r\nsetting中管理项目应用的名称 title, desc  `modules/setting.js`\r\n\r\n```jsx\r\nconst state = {\r\n  title: '这是大标题',\r\n  desc: '描述真呀真不错'\r\n}\r\n\r\nconst mutations = {}\r\n\r\nconst actions = {}\r\n\r\nconst getters = {}\r\n\r\nexport default {\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters\r\n}\r\n```\r\n\r\n使用模块中的数据,  可以直接通过模块名访问 `$store.state.模块名.xxx`  =>  `$store.state.setting.title`\r\n\r\n也可以通过 mapState 映射\r\n\r\n### 命名空间 namespaced\r\n\r\n默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的\r\n\r\n这句话的意思是 刚才的 user模块 还是 setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用,\r\n\r\n但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置\r\n\r\n`modules/user.js`\r\n\r\n```jsx\r\nconst state = {\r\n  userInfo: {\r\n    name: 'zs',\r\n    age: 18\r\n  },\r\n  myMsg: '我的数据'\r\n}\r\n\r\nconst mutations = {\r\n  updateMsg (state, msg) {\r\n    state.myMsg = msg\r\n  }\r\n}\r\n\r\nconst actions = {}\r\n\r\nconst getters = {}\r\n\r\nexport default {\r\n  namespaced: true,\r\n  state,\r\n  mutations,\r\n  actions,\r\n  getters\r\n}\r\n```\r\n\r\n提交模块中的mutation\r\n\r\n```jsx\r\n全局的:   this.$store.commit('mutation函数名', 参数)\r\n\r\n模块中的: this.$store.commit('模块名/mutation函数名', 参数)\r\n```\r\n\r\nnamespaced: true 后, 要添加映射, 可以加上模块名, 找对应模块的 state/mutations/actions/getters\r\n\r\n```jsx\r\ncomputed: {\r\n  // 全局的\r\n  ...mapState(['count']),\r\n  // 模块中的\r\n  ...mapState('user', ['myMsg']),\r\n},\r\nmethods: {\r\n  // 全局的\r\n  ...mapMutations(['addCount'])\r\n  // 模块中的\r\n  ...mapMutations('user', ['updateMsg'])\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",contentRendered:'<h1 id="vuex-概述" tabindex="-1"><a class="header-anchor" href="#vuex-概述" aria-hidden="true">#</a> vuex 概述</h1>\n<p>目标：</p>\n<ul>\n<li>了解vuex的应用场景  (在哪用)</li>\n<li>掌握vuex的基本使用  (怎么用)</li>\n</ul>\n<p><strong>vuex 是一个 vue 的状态管理工具,  状态就是数据</strong></p>\n<p>vuex是一个插件工具，可以帮我们vue管理通用的数据</p>\n<p>之前如果要进行跨组件的数据通信  =&gt;  父传子，子传父  =&gt;  一旦组件关系复杂，数据非常难以维护</p>\n<h2 id="回顾-组件之间共享状态-组件通信方案" tabindex="-1"><a class="header-anchor" href="#回顾-组件之间共享状态-组件通信方案" aria-hidden="true">#</a> 回顾-组件之间共享状态 (组件通信方案)</h2>\n<p>默认组件的数据, 是独立的, 每个组件有着自己的状态(数据)</p>\n<blockquote>\n<p>状态 === 数据</p>\n</blockquote>\n<p>组件之间共享状态的两种典型方式：</p>\n<ul>\n<li>\n<p>父子之间 : props + $emit</p>\n<p>父传子：props属性绑定</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>&lt;son1 msg="msg">&lt;/son1>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>子传父：$emit事件绑定</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>&lt;div>\n\t&lt;button @click="$emit(\'event-name\')">通知父组件&lt;/button>\n&lt;/div>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li>\n</ul>\n<p>如果某个状态需要在很多个组件来使用，或者要实现多个组件共同维护一份数据又应该怎么做呢 ？</p>\n<p>这里就要引入Vuex了。</p>\n<h2 id="vuex基本概念" tabindex="-1"><a class="header-anchor" href="#vuex基本概念" aria-hidden="true">#</a> vuex基本概念</h2>\n<p><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">中文文档<ExternalLinkIcon/></a></p>\n<p>vuex是vue的状态管理工具，<strong>状态即数据</strong>。 状态管理就是集中管理vue中 <strong>通用的</strong> 一些数据</p>\n<p>注意（官方原文）：</p>\n<ul>\n<li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li>\n<li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度  （数据的操作更便捷，数据的流动更清晰）</li>\n</ul>\n<p>Vuex就像《近视眼镜》, 你自然会知道什么时候需要用它~</p>\n<h2 id="vuex的优点-方便的解决多组件的共享状态" tabindex="-1"><a class="header-anchor" href="#vuex的优点-方便的解决多组件的共享状态" aria-hidden="true">#</a> vuex的优点: 方便的解决多组件的共享状态</h2>\n<p>vuex的作用是解决《多组件状态共享》的问题。</p>\n<ul>\n<li>\n<p>它是独立于组件而单独存在的，所有的组件都可以把它当作  <strong>一座桥梁</strong> 来进行通讯。</p>\n</li>\n<li>\n<p>特点：</p>\n<ul>\n<li><strong>响应式</strong>： 只要仓库一变化，其他所有地方都更新 （太爽了！！！）</li>\n<li>操作更简洁</li>\n</ul>\n<p>代码量非常少, 但是需要熟悉</p>\n</li>\n</ul>\n<h2 id="什么数据适合存到vuex中" tabindex="-1"><a class="header-anchor" href="#什么数据适合存到vuex中" aria-hidden="true">#</a> 什么数据适合存到vuex中</h2>\n<p>一般情况下，只有  <strong>多个组件均需要共享的数据</strong> ，才有必要存储在vuex中，</p>\n<p>对于某个组件中的私有数据，依旧存储在组件自身的data中。</p>\n<p>例如：</p>\n<ul>\n<li>对于所有组件而言，当前登陆的   <strong>用户信息</strong>  是需要在全体组件之间共享的，则它可以放在vuex中</li>\n<li>对于文章详情页组件来说，当前的用户浏览的文章列表数据则应该属于这个组件的私有数据，应该要放在这个组件data中。</li>\n</ul>\n<h2 id="概述小结" tabindex="-1"><a class="header-anchor" href="#概述小结" aria-hidden="true">#</a> 概述小结:</h2>\n<ol>\n<li>vuex解决什么问题?   vuex 能解决  <strong>多组件共享数据</strong>  的问题,  非常方便便捷</li>\n<li>什么样的数据, 适合存放到vuex?   多组件的  <strong>通用</strong>  的共用数据, 适合存到 vuex</li>\n</ol>\n<p>vuex 两大优势:</p>\n<ol>\n<li>响应式变化</li>\n<li>操作简洁  (vuex提供了一些简化语法的辅助函数, 这些辅助函数, 需要熟练掌握)</li>\n</ol>\n<h1 id="vuex入门" tabindex="-1"><a class="header-anchor" href="#vuex入门" aria-hidden="true">#</a> vuex入门</h1>\n<h2 id="需求-多组件共享数据" tabindex="-1"><a class="header-anchor" href="#需求-多组件共享数据" aria-hidden="true">#</a> 需求: 多组件共享数据</h2>\n<p>对于如下三个组件（一个父组件，两个子组件）</p>\n<p>效果是三个组件共享一份数据:</p>\n<ul>\n<li>任意一个组件都可以修改数据</li>\n<li>三个组件的数据是同步的</li>\n</ul>\n<p>1 创建项目</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>vue create vuex-demo\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2 创建三个组件, 目录如下</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>|-components\n|--add-item.vue\n|--sub-item.vue\n|-App.vue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>3 源代码如下</p>\n<p><code>App.vue</code>在入口组件中引入add-item和sub-item这两个子组件</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>根组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>add-item</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>add-item</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub-item</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub-item</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> AddItem <span class="token keyword">from</span> <span class="token string">\'./components/add-item.vue\'</span>\n<span class="token keyword">import</span> SubItem <span class="token keyword">from</span> <span class="token string">\'./components/sub-item.vue\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'app\'</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      \n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    AddItem<span class="token punctuation">,</span>\n    SubItem\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">#app</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 20px auto<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #ccc<span class="token punctuation">;</span>\n  <span class="token property">border-radius</span><span class="token punctuation">:</span> 3px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p><code>main.js</code></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">\'./App.vue\'</span>\n\nVue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>sub-item.vue</code></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>子组件 sub<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>\n    从vuex中获取的值: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>值-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'SubItem\'</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.box</span><span class="token punctuation">{</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #ccc<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">h2</span> <span class="token punctuation">{</span>\n  <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>add-item.vue</code></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>子组件 add<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span>\n    从vuex中获取的值:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>值+1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'AddItem\'</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.box</span> <span class="token punctuation">{</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #ccc<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">h2</span> <span class="token punctuation">{</span>\n  <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h2 id="vuex-的使用-创建仓库" tabindex="-1"><a class="header-anchor" href="#vuex-的使用-创建仓库" aria-hidden="true">#</a> vuex 的使用 - 创建仓库</h2>\n<p>1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>yarn add vuex@3.4.0\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>2 新建 <code>store/index.js</code> 专门存放 vuex</p>\n<p>​\t为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p>\n<p>​\t<img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201029064100611" originSrc="images/image-20201029064100611.png" data="aurora"></p>\n<p>3 创建仓库 <code>store/index.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 导入 vue</span>\n<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token comment">// 导入 vuex</span>\n<span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token comment">// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>\n\n<span class="token comment">// 创建仓库 store</span>\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 导出仓库</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> store\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>4 在 main.js 中导入挂载到 Vue 实例上</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">\'./App.vue\'</span>\n<span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">\'./store\'</span>\n\nVue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>productionTip <span class="token operator">=</span> <span class="token boolean">false</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token parameter">h</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  store\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>此刻起, 就成功创建了一个 <strong>空仓库!!</strong></p>\n<h2 id="核心概念-state-状态" tabindex="-1"><a class="header-anchor" href="#核心概念-state-状态" aria-hidden="true">#</a> 核心概念 - state 状态</h2>\n<p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p>\n<p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 创建仓库 store</span>\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// state 状态, 即数据, 类似于vue组件中的data,</span>\n  <span class="token comment">// 区别在于 data 是组件自己的数据, 而 state 中的数据整个vue项目的组件都能访问到</span>\n  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">101</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>问题: 如何在组件中获取count?</p>\n<ol>\n<li>插值表达式 =》  {{  $store.state.count  }}</li>\n<li>mapState 映射计算属性 =》  {{ count  }}</li>\n</ol>\n<p><strong>1 原始形式- 插值表达式</strong></p>\n<p><strong><code>App.vue</code></strong></p>\n<p>组件中可以使用  <strong>this.$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>state的数据 - {{ $store.state.count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>计算属性</strong> - 将state属性定义在计算属性中 https://vuex.vuejs.org/zh/guide/state.html</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 把state中数据，定义在组件内的计算属性中</span>\n  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>state的数据 - {{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法</p>\n<p><strong>2 辅助函数  - mapState</strong></p>\n<blockquote>\n<p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p>\n</blockquote>\n<p>用法 ：</p>\n<p>第一步：导入mapState (mapState是vuex中的一个函数)</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>第二步：采用数组形式引入state属性</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'count\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><blockquote>\n<p>上面代码的最终得到的是 <strong>类似于</strong></p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'count\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span> state的数据：{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="核心概念-mutations" tabindex="-1"><a class="header-anchor" href="#核心概念-mutations" aria-hidden="true">#</a> 核心概念 - mutations</h2>\n<h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h3>\n<p>通过 <code>strict: true</code> 可以开启严格模式</p>\n<blockquote>\n<p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p>\n</blockquote>\n<p><strong>定义mutations</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> store  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 定义mutations</span>\n  <span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n     \n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>格式说明</strong></p>\n<p>mutations是一个对象，对象中存放修改state的方法</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 方法里参数 第一个参数是当前store的state属性</span>\n    <span class="token comment">// payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷</span>\n    <span class="token function">addCount</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>组件中提交 mutations</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'addCount\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>解决问题: 两个子组件, 添加操作 add,  addN 实现</strong></p>\n<h3 id="带参数的-mutation" tabindex="-1"><a class="header-anchor" href="#带参数的-mutation" aria-hidden="true">#</a> 带参数的 mutation</h3>\n<p>需求: 父组件也希望能改到数据</p>\n<p>提交 mutation 是可以传递参数的  <code>this.$store.commit(\'xxx\',  参数)</code></p>\n<p>1 提供mutation函数</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">mutations</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token operator">...</span>\n  <span class="token function">inputCount</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> count</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span>count <span class="token operator">=</span> count\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>2 注册事件</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"count"</span> @input<span class="token operator">=</span><span class="token string">"handleInput"</span><span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>3 提交mutation</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token function">handleInput</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'inputCount\'</span><span class="token punctuation">,</span> <span class="token operator">+</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'inputCount\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">count</span><span class="token operator">:</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解决问题:  addN 的实现</strong></p>\n<h3 id="辅助函数-mapmutations" tabindex="-1"><a class="header-anchor" href="#辅助函数-mapmutations" aria-hidden="true">#</a> <strong>辅助函数</strong> - mapMutations</h3>\n<blockquote>\n<p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span>  <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'addCount\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote>\n<p>上面代码的含义是将mutations的方法导入了methods中，等价于</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// commit(方法名, 载荷参数)</span>\n      <span class="token function">addCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'addCount\'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>此时，就可以直接通过this.addCount调用了</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"addCount"</span><span class="token operator">></span>值<span class="token operator">+</span><span class="token number">1</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p>\n<h2 id="核心概念-actions" tabindex="-1"><a class="header-anchor" href="#核心概念-actions" aria-hidden="true">#</a> 核心概念-actions</h2>\n<blockquote>\n<p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p>\n<p>actions则负责进行异步操作</p>\n</blockquote>\n<p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p>\n<p><strong>定义actions</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">actions</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">setAsyncCount</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 一秒后, 给一个数, 去修改 num</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'inputCount\'</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>原始调用</strong> - $store (支持传参)</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">setAsyncCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'setAsyncCount\'</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>辅助函数</strong> -mapActions</p>\n<blockquote>\n<p>actions也有辅助函数，可以将action导入到组件中</p>\n</blockquote>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'setAsyncCount\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>直接通过 this.方法 就可以调用</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>setAsyncCount(200)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+异步<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="核心概念-getters" tabindex="-1"><a class="header-anchor" href="#核心概念-getters" aria-hidden="true">#</a> 核心概念-getters</h2>\n<blockquote>\n<p>除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters</p>\n</blockquote>\n<p>例如，state中定义了list，为1-10的数组，</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p>\n<p><strong>定义getters</strong></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>  <span class="token literal-property property">getters</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// getters函数的第一个参数是 state</span>\n    <span class="token comment">// 必须要有返回值</span>\n     <span class="token function-variable function">filterList</span><span class="token operator">:</span>  <span class="token parameter">state</span> <span class="token operator">=></span>  state<span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item <span class="token operator">></span> <span class="token number">5</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用getters</p>\n<p><strong>原始方式</strong> -$store</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ $store.getters.filterList }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>辅助函数</strong> - mapGetters</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'filterList\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{ filterList }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="核心概念-模块-module-进阶拓展" tabindex="-1"><a class="header-anchor" href="#核心概念-模块-module-进阶拓展" aria-hidden="true">#</a> 核心概念 - 模块 module (<strong>进阶拓展</strong>)</h2>\n<blockquote>\n<p><strong>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</strong></p>\n</blockquote>\n<p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p>\n<p>由此，又有了Vuex的模块化</p>\n<h3 id="模块定义-准备-state" tabindex="-1"><a class="header-anchor" href="#模块定义-准备-state" aria-hidden="true">#</a> <strong>模块定义</strong> - 准备 state</h3>\n<p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p>\n<p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">,</span>\n  mutations<span class="token punctuation">,</span>\n  actions<span class="token punctuation">,</span>\n  getters\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>setting中管理项目应用的名称 title, desc  <code>modules/setting.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">\'这是大标题\'</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">\'描述真呀真不错\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">,</span>\n  mutations<span class="token punctuation">,</span>\n  actions<span class="token punctuation">,</span>\n  getters\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  =&gt;  <code>$store.state.setting.title</code></p>\n<p>也可以通过 mapState 映射</p>\n<h3 id="命名空间-namespaced" tabindex="-1"><a class="header-anchor" href="#命名空间-namespaced" aria-hidden="true">#</a> 命名空间 namespaced</h3>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的</p>\n<p>这句话的意思是 刚才的 user模块 还是 setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用,</p>\n<p>但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置</p>\n<p><code>modules/user.js</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">myMsg</span><span class="token operator">:</span> <span class="token string">\'我的数据\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">updateMsg</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span>myMsg <span class="token operator">=</span> msg\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">namespaced</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  state<span class="token punctuation">,</span>\n  mutations<span class="token punctuation">,</span>\n  actions<span class="token punctuation">,</span>\n  getters\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>提交模块中的mutation</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">全局的</span><span class="token operator">:</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'mutation函数名\'</span><span class="token punctuation">,</span> 参数<span class="token punctuation">)</span>\n\n<span class="token literal-property property">模块中的</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'模块名/mutation函数名\'</span><span class="token punctuation">,</span> 参数<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>namespaced: true 后, 要添加映射, 可以加上模块名, 找对应模块的 state/mutations/actions/getters</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 全局的</span>\n  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'count\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token comment">// 模块中的</span>\n  <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token string">\'user\'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'myMsg\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 全局的</span>\n  <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'addCount\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token comment">// 模块中的</span>\n  <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">\'user\'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">\'updateMsg\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/vuex入门.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"vuex入门",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/vuex入门.md",filePathRelative:"Vue/vuex入门.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/vuex入门.html.vue",componentFilePathRelative:"pages/Vue/vuex入门.html.vue",componentFileChunkName:"v-c11452c2",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/vuex入门.html.js",dataFilePathRelative:"pages/Vue/vuex入门.html.js",dataFileChunkName:"v-c11452c2",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/vuex入门.html",htmlFilePathRelative:"Vue/vuex入门.html"},{data:{key:"v-41c2a7b8",path:"/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.html",title:"vue基本概念",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"vue介绍",slug:"vue介绍",children:[{level:3,title:"渐进式的概念",slug:"渐进式的概念",children:[]},{level:3,title:"框架的概念",slug:"框架的概念",children:[]},{level:3,title:"vue是 MVVM 的框架",slug:"vue是-mvvm-的框架",children:[]}]},{level:2,title:"开发vue的方式",slug:"开发vue的方式",children:[]},{level:2,title:"基本使用",slug:"基本使用",children:[]},{level:2,title:"如何覆盖webpack配置",slug:"如何覆盖webpack配置",children:[]},{level:2,title:"目录分析与清理",slug:"目录分析与清理",children:[]},{level:2,title:"vue单文件组件的说明",slug:"vue单文件组件的说明",children:[]},{level:2,title:"vue通过data提供数据",slug:"vue通过data提供数据",children:[]},{level:2,title:"通过插值表达式显示数据",slug:"通过插值表达式显示数据",children:[]},{level:2,title:"安装vue开发者工具",slug:"安装vue开发者工具",children:[]},{level:2,title:"v-bind指令",slug:"v-bind指令",children:[]},{level:2,title:"v-on指令",slug:"v-on指令",children:[{level:3,title:"基本使用",slug:"基本使用-1",children:[]},{level:3,title:"vue中获取事件对象(了解)",slug:"vue中获取事件对象-了解",children:[]},{level:3,title:"v-on 事件修饰符",slug:"v-on-事件修饰符",children:[]},{level:3,title:"按键修饰符",slug:"按键修饰符",children:[]}]},{level:2,title:"v-if 和 v-show",slug:"v-if-和-v-show",children:[{level:3,title:"基本使用",slug:"基本使用-2",children:[]},{level:3,title:"v-else 和 v-else-if",slug:"v-else-和-v-else-if",children:[]}]},{level:2,title:"v-model",slug:"v-model",children:[{level:3,title:"基本使用",slug:"基本使用-3",children:[]},{level:3,title:"v-model 处理其他表单元素",slug:"v-model-处理其他表单元素",children:[]},{level:3,title:"v-model 修饰符",slug:"v-model-修饰符",children:[]}]},{level:2,title:"v-text 和 v-html",slug:"v-text-和-v-html",children:[{level:3,title:"v-text指令",slug:"v-text指令",children:[]},{level:3,title:"v-html指令",slug:"v-html指令",children:[]}]}],git:{}},key:"v-41c2a7b8",path:"/Vue/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5+vuecli+%E6%8C%87%E4%BB%A4%E4%B8%8A.html",title:"vue基本概念",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"vue介绍",slug:"vue介绍",children:[{level:3,title:"渐进式的概念",slug:"渐进式的概念",children:[]},{level:3,title:"框架的概念",slug:"框架的概念",children:[]},{level:3,title:"vue是 MVVM 的框架",slug:"vue是-mvvm-的框架",children:[]}]},{level:2,title:"开发vue的方式",slug:"开发vue的方式",children:[]},{level:2,title:"基本使用",slug:"基本使用",children:[]},{level:2,title:"如何覆盖webpack配置",slug:"如何覆盖webpack配置",children:[]},{level:2,title:"目录分析与清理",slug:"目录分析与清理",children:[]},{level:2,title:"vue单文件组件的说明",slug:"vue单文件组件的说明",children:[]},{level:2,title:"vue通过data提供数据",slug:"vue通过data提供数据",children:[]},{level:2,title:"通过插值表达式显示数据",slug:"通过插值表达式显示数据",children:[]},{level:2,title:"安装vue开发者工具",slug:"安装vue开发者工具",children:[]},{level:2,title:"v-bind指令",slug:"v-bind指令",children:[]},{level:2,title:"v-on指令",slug:"v-on指令",children:[{level:3,title:"基本使用",slug:"基本使用-1",children:[]},{level:3,title:"vue中获取事件对象(了解)",slug:"vue中获取事件对象-了解",children:[]},{level:3,title:"v-on 事件修饰符",slug:"v-on-事件修饰符",children:[]},{level:3,title:"按键修饰符",slug:"按键修饰符",children:[]}]},{level:2,title:"v-if 和 v-show",slug:"v-if-和-v-show",children:[{level:3,title:"基本使用",slug:"基本使用-2",children:[]},{level:3,title:"v-else 和 v-else-if",slug:"v-else-和-v-else-if",children:[]}]},{level:2,title:"v-model",slug:"v-model",children:[{level:3,title:"基本使用",slug:"基本使用-3",children:[]},{level:3,title:"v-model 处理其他表单元素",slug:"v-model-处理其他表单元素",children:[]},{level:3,title:"v-model 修饰符",slug:"v-model-修饰符",children:[]}]},{level:2,title:"v-text 和 v-html",slug:"v-text-和-v-html",children:[{level:3,title:"v-text指令",slug:"v-text指令",children:[]},{level:3,title:"v-html指令",slug:"v-html指令",children:[]}]}],content:'# vue基本概念 \r\n\r\n## vue介绍\r\n\r\n- [vue 中文网](https://cn.vuejs.org/)  尤雨溪 \r\n- [Vue.js 是什么](https://cn.vuejs.org/v2/guide/index.html#Vue-js-%E6%98%AF%E4%BB%80%E4%B9%88)\r\n- Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式javascript框架**。  \r\n\r\n### 渐进式的概念\r\n\r\n渐进式：逐渐增强，可以在项目中使用vue的一部分功能，也可以使用vue的全家桶来管理整个项目。\r\n\r\nangular: 全家桶 \r\n\r\n![](images/渐进式.png)\r\n\r\n### 框架的概念\r\n\r\n- [我们所说的前端框架与库的区别？](https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120)\r\n\r\n**Library**\r\n\r\n+ 代表：moment  axios\r\n\r\n+ 库，本质上是一些函数的集合。每次调用函数，实现一个特定的功能   工具箱\r\n\r\n- 使用库的时候，把库当成工具使用，需要自己控制代码的执行逻辑。\r\n\r\n**Framework**\r\n\r\n+ 代表：vue、angular、react、bootstrap\r\n\r\n+ 框架，是一套完整的解决方案\r\n\r\n- 使用框架的时候，框架实现了大部分的功能，我们只需要按照框架的规则写代码\r\n\r\n**库和框架的区别**\r\n\r\n+ 使用库的时候，很自由，只要调用库提供的各种各样的方法就行，也可以不用其他的一些方法\r\n+ 使用框架的时候，需要按照框架的规则写代码，限制会非常多，但同时框架的功能也很强大，可以极大的提升开发的效率。\r\n\r\n\r\n\r\n### vue是 MVVM 的框架\r\n\r\n+ MVVM思想：一种软件架构模式，决定了写代码的方式。\r\n  + M：model数据模型(ajax获取到的数据)\t\r\n  + V：view视图（页面）\r\n  + VM：ViewModel 视图模型\r\n\r\n- MVVM通过`数据双向绑定`让数据自动地双向同步  **不在需要操作DOM**\r\n  - V（修改视图） -> M（数据自动同步）\r\n  - M（修改数据） -> V（视图自动同步）\r\n\r\n**1. 在vue中，不推荐直接手动操作DOM！！！**     \r\n\r\n**2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！**\r\n\r\n## 开发vue的方式\r\n\r\n开发vue有两种方式   \r\n\r\n+ 传统开发模式：基于html/css/js文件开发vue \r\n+ 工程化开发方式：在webpack环境中开发vue，这是最推荐的方式。\r\n+ 现代化的项目也都是在webpack环境下进行开发的。\r\n\r\n\r\n\r\n# vue-cli的使用\r\n\r\n> `vue-cli`也叫vue脚手架,`vue-cli`是vue官方提供的一个全局命令工具，这个命令可以帮助我们快速的创建一个vue项目的基础架子。\r\n\r\n+ 开箱即用\r\n+ 零配置\r\n+ webpack、babel\r\n\r\n## 基本使用\r\n\r\n+ 全局安装命令 \r\n\r\n```bash\r\nnpm install -g @vue/cli\r\n# OR\r\nyarn global add @vue/cli\r\n```\r\n\r\n+ 查看版本`vue`\r\n\r\n```js\r\nvue --version\r\n```\r\n\r\n+ 初始化一个vue项目\r\n\r\n```js\r\nvue create 项目名(不能用中文)\r\n```\r\n\r\n+ 启动项目\r\n\r\n```\r\nyarn serve\r\nyarn build\r\n```\r\n\r\n\r\n\r\n## 如何覆盖webpack配置\r\n\r\n> 注意：我们在项目无法找到webpack.config.js文件，因为vue把它隐藏。\r\n\r\n如果需要覆盖webpack的配置，可以修改vue.config.js文件，覆盖webpack配置文件\r\n\r\n```jsx\r\nconst { defineConfig } = require(\'@vue/cli-service\')\r\nmodule.exports = defineConfig({\r\n  transpileDependencies: true,\r\n  // 配置端口号\r\n  devServer: {\r\n    port: 3000\r\n  }\r\n})\r\n```\r\n\r\n\r\n\r\n## 目录分析与清理\r\n\r\n+ public/index.html不用动，提供一个最基础的页面\r\n+ src/main.js不用动，  渲染了App.vue组件\r\n+ src/App.vue默认有很多的内容，可以全部删除\r\n\r\n```jsx\r\n<template>\r\n  <div>123</div>\r\n</template>\r\n```\r\n\r\n+ assets文件夹与components直接删除\r\n\r\n## vue单文件组件的说明\r\n\r\n一个`.vue`文件就是一个组件,后续开发vue，所有的功能都是基于组件实现。\r\n\r\n安装插件\r\n\r\n一个单文件组件由三部分构成\r\n\r\n+ template(必须)  影响组件渲染的结构  html\r\n  + 只能有一个根元素\r\n+ script                     逻辑   js\r\n+ style                       样式   css less scss\r\n  + style用于提供组件的样式，默认只能用css\r\n  + 可以通过`lang="less"`开启less的功能，需要安装依赖包\r\n\r\n```\r\nyarn add less-loader@7.2.1 less -D\r\n```\r\n\r\n\r\n\r\n# vue的插值表达式\r\n\r\n## vue通过data提供数据\r\n\r\n> vue中通过template可以提供模板，但是这样的数据是写死的。\r\n\r\nvue可以通过data提供数据，注意：`data必须是一个函数，并且返回一个对象`\r\n\r\n```jsx\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      money: 100,\r\n      msg: \'hello\'\r\n    }\r\n  }    \r\n}\r\n<\/script>\r\n```\r\n\r\n## 通过插值表达式显示数据\r\n\r\n插值表达式, 小胡子语法  mustach语法` {{  }}`\r\n\r\n1. 作用:  使用 data 中的数据渲染视图（模板）\r\n\r\n2. 基本语法, 支持三元运算符\r\n\r\n   ```jsx\r\n   {{ msg }}\r\n   {{ obj.name }}\r\n   {{ msg.toUpperCase() }}\r\n   {{ obj.age > 18 ? \'成年\' : \'未成年\' }}\r\n   ```\r\n\r\n3. vue中插值表达式的注意点\r\n\r\n   (1)  使用的数据在 data 中要存在\r\n\r\n   ```jsx\r\n   <h1>{{ gaga }}</h1>\r\n   ```\r\n\r\n   (2)  能使用表达式, 但是不能使用 if  for\r\n\r\n   ```jsx\r\n   <h1>{{ if (obj.age > 18 ) { }   }}</h1>\r\n   ```\r\n\r\n   (3)  不能在标签属性中使用\r\n\r\n   ```jsx\r\n   <h1 id="box" class="box" title="{{ msg }}"></h1>\r\n   ```\r\n\r\n## 安装vue开发者工具\r\n\r\n+ 直接通过谷歌应用商店安装  需要梯子\r\n+ 通过极简插件下载插件，本地安装。 https://chrome.zzzmh.cn/index\r\n\r\n# vue指令\r\n\r\n**vue指令, 实质上就是特殊的 html 标签属性, 特点:  v- 开头**\r\n\r\n每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能\r\n\r\n## v-bind指令\r\n\r\n- 描述：插值表达式不能用在html的属性上，如果想要动态的设置html元素的属性，需要使用v-bind指令\r\n- 作用：动态的设置html的属性\r\n- 语法：`v-bind:title="msg"`\r\n- 简写：`:title="msg"`\r\n\r\n```html\r\n\x3c!-- 完整语法 --\x3e\r\n<a v-bind:href="url"></a>\r\n\x3c!-- 缩写 --\x3e\r\n<a :href="url"></a>\r\n```\r\n\r\n## v-on指令\r\n\r\n### 基本使用\r\n\r\n语法：\r\n       1. v-on:事件名=“要执行的少量代码"\r\n       2. v-on:事件名=“methods中的函数名"\r\n       3. v-on:事件名=“methods中的函数名(实参)" \r\n\r\n+ 最基本的语法\r\n\r\n  + `<button v-on:事件名="事件函数">按钮</button>`，需要在methods中提供事件处理函数\r\n\r\n  ```jsx\r\n  <button v-on:click="fn">搬砖</button>\r\n  <button v-on:click="fn1">卖房</button>\r\n  \r\n    // 提供方法\r\n    methods: {\r\n      fn () {\r\n        console.log(\'你好啊\')\r\n        // console.log(this)\r\n        this.money++\r\n      },\r\n      fn1 () {\r\n        this.money += 10000\r\n      },\r\n    }\r\n  ```\r\n\r\n+ 需要传递参数\r\n\r\n  + `<button v-on:事件名="事件函数(参数)">按钮</button>`，需要在methods中提供事件函数，接受参数\r\n\r\n  ```jsx\r\n  <button v-on:click="addMoney(1)">搬砖</button>\r\n  <button v-on:click="addMoney(10000)">卖房</button>\r\n  \r\n  methods: {\r\n    addMoney (money) {\r\n      this.money += money\r\n    }\r\n  }\r\n  ```\r\n\r\n+ 如果事件的逻辑足够简单，可以不提供函数\r\n\r\n```jsx\r\n<button v-on:click="money++">搬砖</button>\r\n<button v-on:click="money += 10000">卖房</button>\r\n```\r\n\r\n### vue中获取事件对象(了解)\r\n\r\n需求: 默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()\r\n\r\nvue中获取事件对象\r\n\r\n(1) 没有传参, 通过形参接收 e\r\n\r\n(2) 传参了, 通过$event指代事件对象 e\r\n\r\n```jsx\r\n<template>\r\n  <div id="app">\r\n    <a @click="fn" href="http://www.baidu.com">去百度</a>\r\n    <a @click="fn2(100, $event)" href="http://www.baidu.com">去百度2</a>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  methods: {\r\n    fn(e) {\r\n      e.preventDefault()\r\n    },\r\n    fn2(num, e) {\r\n      e.preventDefault()\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n### v-on 事件修饰符\r\n\r\n- vue中提供的事件修饰符\r\n\r\n  .prevent 阻止默认行为\r\n\r\n  .stop 阻止冒泡\r\n\r\n```html\r\n<div id="app">\r\n  <a @click.prevent="fn" href="http://www.baidu.com">去百度</a>\r\n</div>\r\n```\r\n\r\n### 按键修饰符\r\n\r\n需求: 用户输入内容, 回车, 打印输入的内容\r\n\r\n在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符\r\n\r\n- @keyup.enter  回车\r\n\r\n- @keyup.esc  返回\r\n\r\n```html\r\n<div id="app">\r\n  <input type="text" @keyup="fn"> <hr>\r\n  <input type="text" @keyup.enter="fn2">\r\n</div>\r\n\r\n```\r\n\r\n## v-if 和 v-show\r\n\r\n### 基本使用\r\n\r\nv-show 和 v-if 功能: 控制盒子的显示隐藏\r\n\r\n1. v-show\r\n\r\n   语法:  v-show="布尔值"    (true显示, false隐藏)\r\n\r\n   原理:  实质是在控制元素的 css 样式,  `display: none;`\r\n\r\n2. v-if   \r\n\r\n   语法: v-if="布尔值"   (true显示, false隐藏)\r\n\r\n   原理:  实质是在动态的创建 或者 删除元素节点\r\n\r\n应用场景: \r\n\r\n- 如果是频繁的切换显示隐藏, 用 v-show\r\n\r\n  v-if, 频繁切换会大量的创建和删除元素, 消耗性能\r\n\r\n- 如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if\r\n\r\n  v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销\r\n\r\n```html\r\n<template>\r\n  <div id="app">\r\n    <h1 v-show="isShow">v-show盒子-{{ msg }}</h1>\r\n    <h1 v-if="isShow">v-if盒子-{{ msg }}</h1>\r\n  </div>\r\n</template>\r\n```\r\n\r\n### v-else 和 v-else-if\r\n\r\n```html\r\n<div id="app">\r\n  <h1 v-if="isLogin">尊敬的超级vip, 你好</h1>\r\n  <h1 v-else>你谁呀, 赶紧登陆~</h1>\r\n\r\n  <hr>\r\n  \r\n  <h1 v-if="age >= 60">60岁以上, 广场舞</h1>\r\n  <h1 v-else-if="age >= 30">30岁以上, 搓麻将</h1>\r\n  <h1 v-else-if="age >= 20">20岁以上, 蹦迪</h1>\r\n  <h1 v-else>20岁以下, 唱跳rap篮球</h1>\r\n</div>\r\n\r\n```\r\n\r\n## v-model\r\n\r\n### 基本使用\r\n\r\n**作用: 给表单元素使用, 双向数据绑定 ** \r\n\r\n1. 数据变化了, 视图会跟着变\r\n\r\n2. 视图变化了, 数据要跟着变\r\n\r\n   输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变\r\n\r\n语法: v-model=\'值\'\r\n\r\n```jsx\r\n<input type="text" v-model="msg">\r\n```\r\n\r\n\r\n\r\n### v-model 处理其他表单元素\r\n\r\n**v-model 会忽略掉表单元素原本的value, checked等初始值**\r\n\r\ntextarea, select, checkbox\r\n\r\n### v-model 修饰符\r\n\r\n- number\r\n\r\n  如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 `v-model` 添加 `number` 修饰符：\r\n\r\n  ```html\r\n  <input v-model.number="age" type="number">\r\n  ```\r\n\r\n  如果这个值如果这个值无法转数字，则会返回原始的值。\r\n\r\n- trim\r\n\r\n  如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\r\n\r\n  ```html\r\n  <input v-model.trim="msg">\r\n  ```\r\n\r\n- lazy\r\n\r\n  在`change`时而非`input`时更新，可以给 `v-model` 添加 `lazy` 修饰符：\r\n\r\n  ```html\r\n  <input v-model.lazy="msg">\r\n  ```\r\n\r\n\r\n\r\n## v-text 和 v-html\r\n\r\n### v-text指令\r\n\r\n- 解释：更新元素的 `textContent/innerText`。如果要更新部分的 `textContent` ，需要使用 `{{ Mustache }}` 插值。 \r\n\r\n```html\r\n<h1 v-text="msg"></h1>\r\n```\r\n\r\n### v-html指令\r\n\r\n- 解释：更新DOM对象的` innerHTML`,html标签会生效\r\n\r\n```html\r\n<h1 v-html="msg"></h1>\r\n```\r\n\r\n**在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。** \r\n\r\n**只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。** \r\n',contentRendered:'<h1 id="vue基本概念" tabindex="-1"><a class="header-anchor" href="#vue基本概念" aria-hidden="true">#</a> vue基本概念</h1>\n<h2 id="vue介绍" tabindex="-1"><a class="header-anchor" href="#vue介绍" aria-hidden="true">#</a> vue介绍</h2>\n<ul>\n<li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener noreferrer">vue 中文网<ExternalLinkIcon/></a>  尤雨溪</li>\n<li><a href="https://cn.vuejs.org/v2/guide/index.html#Vue-js-%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">Vue.js 是什么<ExternalLinkIcon/></a></li>\n<li>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的<strong>渐进式javascript框架</strong>。</li>\n</ul>\n<h3 id="渐进式的概念" tabindex="-1"><a class="header-anchor" href="#渐进式的概念" aria-hidden="true">#</a> 渐进式的概念</h3>\n<p>渐进式：逐渐增强，可以在项目中使用vue的一部分功能，也可以使用vue的全家桶来管理整个项目。</p>\n<p>angular: 全家桶</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="" originSrc="images/%E6%B8%90%E8%BF%9B%E5%BC%8F.png" data="aurora"></p>\n<h3 id="框架的概念" tabindex="-1"><a class="header-anchor" href="#框架的概念" aria-hidden="true">#</a> 框架的概念</h3>\n<ul>\n<li><a href="https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120" target="_blank" rel="noopener noreferrer">我们所说的前端框架与库的区别？<ExternalLinkIcon/></a></li>\n</ul>\n<p><strong>Library</strong></p>\n<ul>\n<li>\n<p>代表：moment  axios</p>\n</li>\n<li>\n<p>库，本质上是一些函数的集合。每次调用函数，实现一个特定的功能   工具箱</p>\n</li>\n</ul>\n<ul>\n<li>使用库的时候，把库当成工具使用，需要自己控制代码的执行逻辑。</li>\n</ul>\n<p><strong>Framework</strong></p>\n<ul>\n<li>\n<p>代表：vue、angular、react、bootstrap</p>\n</li>\n<li>\n<p>框架，是一套完整的解决方案</p>\n</li>\n</ul>\n<ul>\n<li>使用框架的时候，框架实现了大部分的功能，我们只需要按照框架的规则写代码</li>\n</ul>\n<p><strong>库和框架的区别</strong></p>\n<ul>\n<li>使用库的时候，很自由，只要调用库提供的各种各样的方法就行，也可以不用其他的一些方法</li>\n<li>使用框架的时候，需要按照框架的规则写代码，限制会非常多，但同时框架的功能也很强大，可以极大的提升开发的效率。</li>\n</ul>\n<h3 id="vue是-mvvm-的框架" tabindex="-1"><a class="header-anchor" href="#vue是-mvvm-的框架" aria-hidden="true">#</a> vue是 MVVM 的框架</h3>\n<ul>\n<li>MVVM思想：一种软件架构模式，决定了写代码的方式。\n<ul>\n<li>M：model数据模型(ajax获取到的数据)</li>\n<li>V：view视图（页面）</li>\n<li>VM：ViewModel 视图模型</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>MVVM通过<code>数据双向绑定</code>让数据自动地双向同步  <strong>不在需要操作DOM</strong>\n<ul>\n<li>V（修改视图） -&gt; M（数据自动同步）</li>\n<li>M（修改数据） -&gt; V（视图自动同步）</li>\n</ul>\n</li>\n</ul>\n<p><strong>1. 在vue中，不推荐直接手动操作DOM！！！</strong></p>\n<p><strong>2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！</strong></p>\n<h2 id="开发vue的方式" tabindex="-1"><a class="header-anchor" href="#开发vue的方式" aria-hidden="true">#</a> 开发vue的方式</h2>\n<p>开发vue有两种方式</p>\n<ul>\n<li>传统开发模式：基于html/css/js文件开发vue</li>\n<li>工程化开发方式：在webpack环境中开发vue，这是最推荐的方式。</li>\n<li>现代化的项目也都是在webpack环境下进行开发的。</li>\n</ul>\n<h1 id="vue-cli的使用" tabindex="-1"><a class="header-anchor" href="#vue-cli的使用" aria-hidden="true">#</a> vue-cli的使用</h1>\n<blockquote>\n<p><code>vue-cli</code>也叫vue脚手架,<code>vue-cli</code>是vue官方提供的一个全局命令工具，这个命令可以帮助我们快速的创建一个vue项目的基础架子。</p>\n</blockquote>\n<ul>\n<li>开箱即用</li>\n<li>零配置</li>\n<li>webpack、babel</li>\n</ul>\n<h2 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h2>\n<ul>\n<li>全局安装命令</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> -g @vue/cli\n<span class="token comment"># OR</span>\n<span class="token function">yarn</span> global <span class="token function">add</span> @vue/cli\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>查看版本<code>vue</code></li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>vue <span class="token operator">--</span>version\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>初始化一个vue项目</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>vue create <span class="token function">项目名</span><span class="token punctuation">(</span>不能用中文<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>启动项目</li>\n</ul>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>yarn serve\nyarn build\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="如何覆盖webpack配置" tabindex="-1"><a class="header-anchor" href="#如何覆盖webpack配置" aria-hidden="true">#</a> 如何覆盖webpack配置</h2>\n<blockquote>\n<p>注意：我们在项目无法找到webpack.config.js文件，因为vue把它隐藏。</p>\n</blockquote>\n<p>如果需要覆盖webpack的配置，可以修改vue.config.js文件，覆盖webpack配置文件</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'@vue/cli-service\'</span><span class="token punctuation">)</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">transpileDependencies</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token comment">// 配置端口号</span>\n  <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">3000</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="目录分析与清理" tabindex="-1"><a class="header-anchor" href="#目录分析与清理" aria-hidden="true">#</a> 目录分析与清理</h2>\n<ul>\n<li>public/index.html不用动，提供一个最基础的页面</li>\n<li>src/main.js不用动，  渲染了App.vue组件</li>\n<li>src/App.vue默认有很多的内容，可以全部删除</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul>\n<li>assets文件夹与components直接删除</li>\n</ul>\n<h2 id="vue单文件组件的说明" tabindex="-1"><a class="header-anchor" href="#vue单文件组件的说明" aria-hidden="true">#</a> vue单文件组件的说明</h2>\n<p>一个<code>.vue</code>文件就是一个组件,后续开发vue，所有的功能都是基于组件实现。</p>\n<p>安装插件</p>\n<p>一个单文件组件由三部分构成</p>\n<ul>\n<li>template(必须)  影响组件渲染的结构  html\n<ul>\n<li>只能有一个根元素</li>\n</ul>\n</li>\n<li>script                     逻辑   js</li>\n<li>style                       样式   css less scss\n<ul>\n<li>style用于提供组件的样式，默认只能用css</li>\n<li>可以通过<code>lang=&quot;less&quot;</code>开启less的功能，需要安装依赖包</li>\n</ul>\n</li>\n</ul>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>yarn add less-loader@7.2.1 less -D\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h1 id="vue的插值表达式" tabindex="-1"><a class="header-anchor" href="#vue的插值表达式" aria-hidden="true">#</a> vue的插值表达式</h1>\n<h2 id="vue通过data提供数据" tabindex="-1"><a class="header-anchor" href="#vue通过data提供数据" aria-hidden="true">#</a> vue通过data提供数据</h2>\n<blockquote>\n<p>vue中通过template可以提供模板，但是这样的数据是写死的。</p>\n</blockquote>\n<p>vue可以通过data提供数据，注意：<code>data必须是一个函数，并且返回一个对象</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token plain-text">\nexport default {\n  data () {\n    return {\n      money: 100,\n      msg: \'hello\'\n    }\n  }    \n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="通过插值表达式显示数据" tabindex="-1"><a class="header-anchor" href="#通过插值表达式显示数据" aria-hidden="true">#</a> 通过插值表达式显示数据</h2>\n<p>插值表达式, 小胡子语法  mustach语法<code> {{  }}</code></p>\n<ol>\n<li>\n<p>作用:  使用 data 中的数据渲染视图（模板）</p>\n</li>\n<li>\n<p>基本语法, 支持三元运算符</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span><span class="token punctuation">{</span> msg<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>\n<span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>age <span class="token operator">></span> <span class="token number">18</span> <span class="token operator">?</span> <span class="token string">\'成年\'</span> <span class="token operator">:</span> <span class="token string">\'未成年\'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li>\n<li>\n<p>vue中插值表达式的注意点</p>\n<p>(1)  使用的数据在 data 中要存在</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> gaga <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>(2)  能使用表达式, 但是不能使用 if  for</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>age <span class="token operator">></span> <span class="token number">18</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>(3)  不能在标签属性中使用</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{{ msg }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n</ol>\n<h2 id="安装vue开发者工具" tabindex="-1"><a class="header-anchor" href="#安装vue开发者工具" aria-hidden="true">#</a> 安装vue开发者工具</h2>\n<ul>\n<li>直接通过谷歌应用商店安装  需要梯子</li>\n<li>通过极简插件下载插件，本地安装。 https://chrome.zzzmh.cn/index</li>\n</ul>\n<h1 id="vue指令" tabindex="-1"><a class="header-anchor" href="#vue指令" aria-hidden="true">#</a> vue指令</h1>\n<p><strong>vue指令, 实质上就是特殊的 html 标签属性, 特点:  v- 开头</strong></p>\n<p>每个 v- 开头的指令, 都有着自己独立的功能, 将来vue解析时, 会根据不同的指令提供不同的功能</p>\n<h2 id="v-bind指令" tabindex="-1"><a class="header-anchor" href="#v-bind指令" aria-hidden="true">#</a> v-bind指令</h2>\n<ul>\n<li>描述：插值表达式不能用在html的属性上，如果想要动态的设置html元素的属性，需要使用v-bind指令</li>\n<li>作用：动态的设置html的属性</li>\n<li>语法：<code>v-bind:title=&quot;msg&quot;</code></li>\n<li>简写：<code>:title=&quot;msg&quot;</code></li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 完整语法 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token comment">&lt;!-- 缩写 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="v-on指令" tabindex="-1"><a class="header-anchor" href="#v-on指令" aria-hidden="true">#</a> v-on指令</h2>\n<h3 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1" aria-hidden="true">#</a> 基本使用</h3>\n<p>语法：\n1. v-on:事件名=“要执行的少量代码&quot;\n2. v-on:事件名=“methods中的函数名&quot;\n3. v-on:事件名=“methods中的函数名(实参)&quot;</p>\n<ul>\n<li>\n<p>最基本的语法</p>\n<ul>\n<li><code>&lt;button v-on:事件名=&quot;事件函数&quot;&gt;按钮&lt;/button&gt;</code>，需要在methods中提供事件处理函数</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">搬砖</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">卖房</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n  <span class="token comment">// 提供方法</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'你好啊\'</span><span class="token punctuation">)</span>\n      <span class="token comment">// console.log(this)</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>money<span class="token operator">++</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">fn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">+=</span> <span class="token number">10000</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li>\n<li>\n<p>需要传递参数</p>\n<ul>\n<li><code>&lt;button v-on:事件名=&quot;事件函数(参数)&quot;&gt;按钮&lt;/button&gt;</code>，需要在methods中提供事件函数，接受参数</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addMoney(1)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">搬砖</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>addMoney(10000)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">卖房</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">addMoney</span> <span class="token punctuation">(</span><span class="token parameter">money</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">+=</span> money\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li>\n<li>\n<p>如果事件的逻辑足够简单，可以不提供函数</p>\n</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>money++<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">搬砖</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>money += 10000<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">卖房</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="vue中获取事件对象-了解" tabindex="-1"><a class="header-anchor" href="#vue中获取事件对象-了解" aria-hidden="true">#</a> vue中获取事件对象(了解)</h3>\n<p>需求: 默认a标签点击会跳走,  希望阻止默认的跳转, 阻止默认行为  e.preventDefault()</p>\n<p>vue中获取事件对象</p>\n<p>(1) 没有传参, 通过形参接收 e</p>\n<p>(2) 传参了, 通过$event指代事件对象 e</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;a @click="fn" href="http://www.baidu.com">去百度</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;a @click="fn2(100, $event)" href="http://www.baidu.com">去百度2</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token plain-text">\nexport default {\n  methods: {\n    fn(e) {\n      e.preventDefault()\n    },\n    fn2(num, e) {\n      e.preventDefault()\n    }\n  }\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="v-on-事件修饰符" tabindex="-1"><a class="header-anchor" href="#v-on-事件修饰符" aria-hidden="true">#</a> v-on 事件修饰符</h3>\n<ul>\n<li>\n<p>vue中提供的事件修饰符</p>\n<p>.prevent 阻止默认行为</p>\n<p>.stop 阻止冒泡</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@click.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>去百度<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="按键修饰符" tabindex="-1"><a class="header-anchor" href="#按键修饰符" aria-hidden="true">#</a> 按键修饰符</h3>\n<p>需求: 用户输入内容, 回车, 打印输入的内容</p>\n<p>在监听键盘事件时，我们经常需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符</p>\n<ul>\n<li>\n<p>@keyup.enter  回车</p>\n</li>\n<li>\n<p>@keyup.esc  返回</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@keyup</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">@keyup.enter</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="v-if-和-v-show" tabindex="-1"><a class="header-anchor" href="#v-if-和-v-show" aria-hidden="true">#</a> v-if 和 v-show</h2>\n<h3 id="基本使用-2" tabindex="-1"><a class="header-anchor" href="#基本使用-2" aria-hidden="true">#</a> 基本使用</h3>\n<p>v-show 和 v-if 功能: 控制盒子的显示隐藏</p>\n<ol>\n<li>\n<p>v-show</p>\n<p>语法:  v-show=&quot;布尔值&quot;    (true显示, false隐藏)</p>\n<p>原理:  实质是在控制元素的 css 样式,  <code>display: none;</code></p>\n</li>\n<li>\n<p>v-if</p>\n<p>语法: v-if=&quot;布尔值&quot;   (true显示, false隐藏)</p>\n<p>原理:  实质是在动态的创建 或者 删除元素节点</p>\n</li>\n</ol>\n<p>应用场景:</p>\n<ul>\n<li>\n<p>如果是频繁的切换显示隐藏, 用 v-show</p>\n<p>v-if, 频繁切换会大量的创建和删除元素, 消耗性能</p>\n</li>\n<li>\n<p>如果是不用频繁切换, 要么显示, 要么隐藏的情况, 适合于用 v-if</p>\n<p>v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 节省一些初始渲染开销</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-show</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>v-show盒子-{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>v-if盒子-{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="v-else-和-v-else-if" tabindex="-1"><a class="header-anchor" href="#v-else-和-v-else-if" aria-hidden="true">#</a> v-else 和 v-else-if</h3>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isLogin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>尊敬的超级vip, 你好<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>你谁呀, 赶紧登陆~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age >= 60<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>60岁以上, 广场舞<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age >= 30<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>30岁以上, 搓麻将<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age >= 20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>20岁以上, 蹦迪<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>20岁以下, 唱跳rap篮球<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model" aria-hidden="true">#</a> v-model</h2>\n<h3 id="基本使用-3" tabindex="-1"><a class="header-anchor" href="#基本使用-3" aria-hidden="true">#</a> 基本使用</h3>\n<p>**作用: 给表单元素使用, 双向数据绑定 **</p>\n<ol>\n<li>\n<p>数据变化了, 视图会跟着变</p>\n</li>\n<li>\n<p>视图变化了, 数据要跟着变</p>\n<p>输入框内容变化了(监听用户的输入, 监听input事件), 数据要跟着变</p>\n</li>\n</ol>\n<p>语法: v-model=\'值\'</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n</span></code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="v-model-处理其他表单元素" tabindex="-1"><a class="header-anchor" href="#v-model-处理其他表单元素" aria-hidden="true">#</a> v-model 处理其他表单元素</h3>\n<p><strong>v-model 会忽略掉表单元素原本的value, checked等初始值</strong></p>\n<p>textarea, select, checkbox</p>\n<h3 id="v-model-修饰符" tabindex="-1"><a class="header-anchor" href="#v-model-修饰符" aria-hidden="true">#</a> v-model 修饰符</h3>\n<ul>\n<li>\n<p>number</p>\n<p>如果想自动将用户的输入值, 用parseFloat转成数字类型, ，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.number</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>number<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果这个值如果这个值无法转数字，则会返回原始的值。</p>\n</li>\n<li>\n<p>trim</p>\n<p>如果要自动过滤用户输入的首尾空白字符，可以给 <code>v-model</code> 添加 <code>trim</code> 修饰符：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.trim</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n<li>\n<p>lazy</p>\n<p>在<code>change</code>时而非<code>input</code>时更新，可以给 <code>v-model</code> 添加 <code>lazy</code> 修饰符：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model.lazy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n</ul>\n<h2 id="v-text-和-v-html" tabindex="-1"><a class="header-anchor" href="#v-text-和-v-html" aria-hidden="true">#</a> v-text 和 v-html</h2>\n<h3 id="v-text指令" tabindex="-1"><a class="header-anchor" href="#v-text指令" aria-hidden="true">#</a> v-text指令</h3>\n<ul>\n<li>解释：更新元素的 <code>textContent/innerText</code>。如果要更新部分的 <code>textContent</code> ，需要使用 <code>{{ Mustache }}</code> 插值。</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="v-html指令" tabindex="-1"><a class="header-anchor" href="#v-html指令" aria-hidden="true">#</a> v-html指令</h3>\n<ul>\n<li>解释：更新DOM对象的<code> innerHTML</code>,html标签会生效</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener noreferrer">XSS 攻击<ExternalLinkIcon/></a>。</strong></p>\n<p><strong>只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</strong></p>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/基础概念+vuecli+指令上.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"基础概念+vuecli+指令上",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/基础概念+vuecli+指令上.md",filePathRelative:"Vue/基础概念+vuecli+指令上.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/基础概念+vuecli+指令上.html.vue",componentFilePathRelative:"pages/Vue/基础概念+vuecli+指令上.html.vue",componentFileChunkName:"v-41c2a7b8",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/基础概念+vuecli+指令上.html.js",dataFilePathRelative:"pages/Vue/基础概念+vuecli+指令上.html.js",dataFileChunkName:"v-41c2a7b8",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/基础概念+vuecli+指令上.html",htmlFilePathRelative:"Vue/基础概念+vuecli+指令上.html"},{data:{key:"v-7e7a417e",path:"/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.html",title:"vue指令（下）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-for",slug:"v-for",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"虚拟DOM 和 diff算法",slug:"虚拟dom-和-diff算法",children:[]},{level:3,title:"v-for 的key的说明",slug:"v-for-的key的说明",children:[]}]},{level:2,title:"样式处理",slug:"样式处理",children:[{level:3,title:"v-bind 对于class的增强",slug:"v-bind-对于class的增强",children:[]},{level:3,title:"v-bind对于style 的增强",slug:"v-bind对于style-的增强",children:[]}]},{level:2,title:"基本使用",slug:"基本使用-1",children:[]},{level:2,title:"计算属性的缓存的问题",slug:"计算属性的缓存的问题",children:[]},{level:2,title:"计算属性的完整写法",slug:"计算属性的完整写法",children:[]},{level:2,title:"基本使用",slug:"基本使用-2",children:[]},{level:2,title:"复杂类型的监听-监听的完整写法",slug:"复杂类型的监听-监听的完整写法",children:[]},{level:2,title:"成绩案例-监听数据进行缓存",slug:"成绩案例-监听数据进行缓存",children:[]},{level:2,title:"配置步骤 （两步）",slug:"配置步骤-两步",children:[]}],git:{}},key:"v-7e7a417e",path:"/Vue/%E6%8C%87%E4%BB%A4%E4%B8%8B+%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7+%E4%BE%A6%E5%90%AC%E5%99%A8.html",title:"vue指令（下）",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-for",slug:"v-for",children:[{level:3,title:"基本使用",slug:"基本使用",children:[]},{level:3,title:"虚拟DOM 和 diff算法",slug:"虚拟dom-和-diff算法",children:[]},{level:3,title:"v-for 的key的说明",slug:"v-for-的key的说明",children:[]}]},{level:2,title:"样式处理",slug:"样式处理",children:[{level:3,title:"v-bind 对于class的增强",slug:"v-bind-对于class的增强",children:[]},{level:3,title:"v-bind对于style 的增强",slug:"v-bind对于style-的增强",children:[]}]},{level:2,title:"基本使用",slug:"基本使用-1",children:[]},{level:2,title:"计算属性的缓存的问题",slug:"计算属性的缓存的问题",children:[]},{level:2,title:"计算属性的完整写法",slug:"计算属性的完整写法",children:[]},{level:2,title:"基本使用",slug:"基本使用-2",children:[]},{level:2,title:"复杂类型的监听-监听的完整写法",slug:"复杂类型的监听-监听的完整写法",children:[]},{level:2,title:"成绩案例-监听数据进行缓存",slug:"成绩案例-监听数据进行缓存",children:[]},{level:2,title:"配置步骤 （两步）",slug:"配置步骤-两步",children:[]}],content:'# vue指令（下）\n\n## v-for \n\n### 基本使用\n\n v-for 作用: 遍历对象和数组\n\n1. 遍历数组 (常用)\n\n```jsx\nv-for="item in 数组名"  item每一项\nv-for="(item, index) in 数组名"  item每一项 index下标\n\n注意：item和index不是定死的，可以是任意的名字，但是需要注意 第一项是值  第二项是下标\n```\n\n2. 遍历对象 (一般不用)\n\n```jsx\n\x3c!--\n  v-for也可以遍历对象（不常用）\n  v-for="(值, 键) in 对象"\n--\x3e\n<ul>\n  <li v-for="value in user" :key="value">{{value}}</li>\n</ul>\n<ul>\n  <li v-for="(value, key) in user" :key="key">{{value}} ---{{key}}</li>\n</ul>\n```\n\n3. 遍历数字\n\n```jsx\n\x3c!-- \n  遍历数字\n  语法： v-for="(item, index) in 数字"\n  作用：遍历具体的次数 item从1开始  index下标从0开始的\n--\x3e\n<ul>\n  <li v-for="(item, index) in 10" :key="item">{{item}} ---{{index}}</li>\n</ul>\n```\n\n### 虚拟DOM 和 diff算法\n\n**vue就地复用策略：**Vue会尽可能的就地（同层级，同位置），对比虚拟dom，复用旧dom结构，进行差异化更新。\n\n**虚拟dom**: 本质就是一个个保存节点信息, 属性和内容的 描述真实dom的 JS 对象\n\n**diff算法：**\n\n- 策略1：\n\n  先同层级根元素比较，如果根元素变化，那么不考虑复用，整个dom树删除重建\n\n  先同层级根元素比较，如果根元素不变，对比出属性的变化更新，并考虑往下递归复用。\n\n- 策略2：\n\n  对比同级兄弟元素时，默认按照**下标**进行对比复用。\n\n  对比同级兄弟元素时，如果指定了 key，就会 **按照相同 key 的元素** 来进行对比。\n\n### v-for 的key的说明\n\n1. 设置 和 不设置 key 有什么区别？\n\n   - 不设置 key， 默认同级兄弟元素按照下标进行比较。\n   - 设置了key，按照相同key的新旧元素比较。\n\n2. key值要求是?\n\n   - 字符串或者数值，唯一不重复\n   - 有 id 用 id,  有唯一值用唯一值，实在都没有，才用索引\n\n3. key的好处?\n\n   key的作用：提高虚拟DOM的对比复用性能\n\n以后：只要是写到列表渲染，都推荐加上 key 属性。且 key 推荐是设置成 id， 实在没有，就设置成 index\n\n\n\n## 样式处理\n\n###  v-bind 对于class的增强\n\nv-bind 对于类名操作的增强, 注意点, :class 不会影响到原来的 class 属性\n\n:class="对象/数组"\n\n```jsx\n<template>\n  <div>\n    \x3c!-- \n      v-bind： 作用：设置动态属性\n      v-bind针对 class和style 进行增强\n      允许使用对象或者数组\n        对象：如果键值对的值为true，那么就有这个，否则没有这个类\n        数组：数组中所有的类都会添加到盒子上\n    --\x3e\n    \x3c!-- <div class="box" :class="isRed ? \'red\': \'\'">123</div> --\x3e\n    \x3c!-- <div class="box" :class="{red: isRed, pink: isPink}">123</div> --\x3e\n    <div class="box" :class="arr">123</div>\n  </div>\n</template>\n```\n\n### v-bind对于style 的增强\n\n```jsx\n<template>\n  <div>\n    \x3c!-- \n      :style也可以使用对象或者数组\n     --\x3e\n    <div class="box" :style="[styleObj1, styleObj2]">123</div>\n  </div>\n</template>\n```\n\n# 计算属性\n\n## 基本使用\n\n需求：翻转字符串案例\n\n> 计算属性是一个属性，写法上是一个函数，这个函数的返回值就是计算属性最终的值。\n\n> 1. 计算属性必须定义在 computed 节点中\n\n> 2. 计算属性必须是一个 function,计算属性必须有返回值\n\n> 3. 计算属性不能被当作方法调用,当成属性来用\n\n定义计算属性\n\n```jsx\n// 组件的数据： 需要计算的属性\ncomputed: {\n  reverseMsg () {\n    return this.msg.split(\'\').reverse().join(\'\')\n  }\n}\n```\n\n使用计算属性\n\n```jsx\n<p>{{ reverseMsg }}</p>\n```\n\n## 计算属性的缓存的问题\n\n计算属性： 缓存\n\n计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。\n\n计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存\n\n```jsx\n// 计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。\n// 计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存\nexport default {\n  data () {\n    return {\n      msg: \'hello\'\n    }\n  },\n  computed: {\n    reverseMsg() {\n      console.log(\'我执行了\')\n      return this.msg.split(\'\').reverse().join(\'\')\n    }\n  }\n}\n```\n\n## 计算属性的完整写法\n\n```jsx\n// 1. 计算属性默认情况下只能获取，不能修改。\n// 2. 计算属性的完整写法\n/* \n  computed: {\n    full() {},\n    full: {\n      get() {\n        return this.first + \' \' + this.last\n      },\n      set(value) {\n\n      }\n    }\n  }\n*/\ncomputed: {\n  full: {\n    get () {\n      ...\n    },\n    set (value) {\n      ...\n    }\n  }\n}\n```\n\n\n\n# 属性监听\n\n## 基本使用\n\n当需要监听某个数据是否发生改变，就要用到watch\n\n```jsx\n/* \n  watch: {\n    // 只要属性发生了改变，这个函数就会执行\n    属性: function () {\n\n    }\n  }\n*/\nwatch: {\n  // 参数1： value    变化后的值\n  // 参数2： oldValue 变化前的值\n  msg (value, oldValue) {\n    console.log(\'你变了\', value, oldValue)\n  }\n}\n```\n\n## 复杂类型的监听-监听的完整写法\n\n> 如果监听的是复杂数据类型，需要深度监听，需要指定deep为true,需要用到监听的完整的写法\n\n```jsx\n// 1. 默认情况下，watch只能监听到简单类型的数据变化,如果监听的是复杂类型，只会监听地址是否发生改变，不会监听对象内部属性的变化。\n// 2. 需要使用监听的完整写法 是一个对象\nwatch: {\n  // friend (value) {\n  //   console.log(\'你变了\', value)\n  // }\n  friend: {\n    // handler 数据发生变化，需要执行的处理程序\n    // deep: true  如果true,代表深度监听，不仅会监听地址的变化，还会监听对象内部属性的变化\n    // immediate: 立即 立刻  是否立即监听 默认是false  如果是true,代表页面一加载，会先执行一次处理程序\n    handler (value) {\n      console.log(\'你变了\', value)\n    },\n    deep: true,\n    immediate: true\n  }\n},\n```\n\n## 成绩案例-监听数据进行缓存\n\n+ 监听list的变化\n\n```jsx\nwatch: {\n  list: {\n    deep: true,\n    handler() {\n      localStorage.setItem(\'score-case\', JSON.stringify(this.list))\n    }\n  }\n},\n```\n\n+ 获取list数据的时候不能写死，从localStorage中获取\n\n```jsx\ndata() {\n  return {\n    list: JSON.parse(localStorage.getItem(\'score-case\')) || [],\n    subject: \'\',\n    score: \'\',\n  }\n},\n```\n\n\n\n\n\n# vscode断点调试\n\n前言：作为前端开发，我们经常会遇到代码错误，需要进行调试\n\n常见的调试方案：\n\n- 不调试，直接看代码找问题\n- console.log 打印日志\n- **用 VSCode 的 debugger 来调试** （**断点调试**）\n\n前两种，适合找一些简易的错误，如果短时间错误没有排查出来，建议使用 **vscode断点调试**。\n\n## 配置步骤 （两步）\n\n1. 新建 `.vscode` 目录,  `launch.json` 文件， 填入配置内容\n\n   注意：`端口号` 需要和 启动服务器 `端口号` 统一\n\n```jsx\n{\n  "configurations": [\n    {\n      "name": "Launch Chrome",\n      "request": "launch",\n      "type": "pwa-chrome",\n      "url": "http://localhost:8080",\n      "sourceMapPathOverrides": {\n        "webpack://src/*": "${workspaceFolder}/src/*"\n      }\n    }\n  ]\n}\n```\n\n\n\n2. `vue.config.js` 填入配置内容\n\n```jsx\nconst { defineConfig } = require(\'@vue/cli-service\')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  // -----------------------------------------------------------\n  configureWebpack: config => {\n    // 配置断点调试，实际上线时，可删除\n    config.output.devtoolModuleFilenameTemplate = info => {\n      const resPath = info.resourcePath\n      return `webpack://${resPath}`\n    }\n  }\n  // -----------------------------------------------------------\n})\n```\n',contentRendered:'<h1 id="vue指令-下" tabindex="-1"><a class="header-anchor" href="#vue指令-下" aria-hidden="true">#</a> vue指令（下）</h1>\n<h2 id="v-for" tabindex="-1"><a class="header-anchor" href="#v-for" aria-hidden="true">#</a> v-for</h2>\n<h3 id="基本使用" tabindex="-1"><a class="header-anchor" href="#基本使用" aria-hidden="true">#</a> 基本使用</h3>\n<p>v-for 作用: 遍历对象和数组</p>\n<ol>\n<li>遍历数组 (常用)</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in 数组名"</span>  item每一项\nv<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(item, index) in 数组名"</span>  item每一项 index下标\n\n注意：item和index不是定死的，可以是任意的名字，但是需要注意 第一项是值  第二项是下标\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="2">\n<li>遍历对象 (一般不用)</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>\n  v<span class="token operator">-</span><span class="token keyword">for</span>也可以遍历对象（不常用）\n  v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(值, 键) in 对象"</span>\n<span class="token operator">--</span><span class="token operator">></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value in user<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>value<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(value, key) in user<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>key<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token plain-text"> ---</span><span class="token punctuation">{</span><span class="token punctuation">{</span>key<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="3">\n<li>遍历数字</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> \n  遍历数字\n  语法： v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(item, index) in 数字"</span>\n  作用：遍历具体的次数 item从<span class="token number">1</span>开始  index下标从<span class="token number">0</span>开始的\n<span class="token operator">--</span><span class="token operator">></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(item, index) in 10<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token plain-text"> ---</span><span class="token punctuation">{</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="虚拟dom-和-diff算法" tabindex="-1"><a class="header-anchor" href="#虚拟dom-和-diff算法" aria-hidden="true">#</a> 虚拟DOM 和 diff算法</h3>\n<p>**vue就地复用策略：**Vue会尽可能的就地（同层级，同位置），对比虚拟dom，复用旧dom结构，进行差异化更新。</p>\n<p><strong>虚拟dom</strong>: 本质就是一个个保存节点信息, 属性和内容的 描述真实dom的 JS 对象</p>\n<p><strong>diff算法：</strong></p>\n<ul>\n<li>\n<p>策略1：</p>\n<p>先同层级根元素比较，如果根元素变化，那么不考虑复用，整个dom树删除重建</p>\n<p>先同层级根元素比较，如果根元素不变，对比出属性的变化更新，并考虑往下递归复用。</p>\n</li>\n<li>\n<p>策略2：</p>\n<p>对比同级兄弟元素时，默认按照<strong>下标</strong>进行对比复用。</p>\n<p>对比同级兄弟元素时，如果指定了 key，就会 <strong>按照相同 key 的元素</strong> 来进行对比。</p>\n</li>\n</ul>\n<h3 id="v-for-的key的说明" tabindex="-1"><a class="header-anchor" href="#v-for-的key的说明" aria-hidden="true">#</a> v-for 的key的说明</h3>\n<ol>\n<li>\n<p>设置 和 不设置 key 有什么区别？</p>\n<ul>\n<li>不设置 key， 默认同级兄弟元素按照下标进行比较。</li>\n<li>设置了key，按照相同key的新旧元素比较。</li>\n</ul>\n</li>\n<li>\n<p>key值要求是?</p>\n<ul>\n<li>字符串或者数值，唯一不重复</li>\n<li>有 id 用 id,  有唯一值用唯一值，实在都没有，才用索引</li>\n</ul>\n</li>\n<li>\n<p>key的好处?</p>\n<p>key的作用：提高虚拟DOM的对比复用性能</p>\n</li>\n</ol>\n<p>以后：只要是写到列表渲染，都推荐加上 key 属性。且 key 推荐是设置成 id， 实在没有，就设置成 index</p>\n<h2 id="样式处理" tabindex="-1"><a class="header-anchor" href="#样式处理" aria-hidden="true">#</a> 样式处理</h2>\n<h3 id="v-bind-对于class的增强" tabindex="-1"><a class="header-anchor" href="#v-bind-对于class的增强" aria-hidden="true">#</a> v-bind 对于class的增强</h3>\n<p>v-bind 对于类名操作的增强, 注意点, :class 不会影响到原来的 class 属性</p>\n<p>:class=&quot;对象/数组&quot;</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- \n      v-bind： 作用：设置动态属性\n      v-bind针对 class和style 进行增强\n      允许使用对象或者数组\n        对象：如果键值对的值为true，那么就有这个，否则没有这个类\n        数组：数组中所有的类都会添加到盒子上\n    --\x3e\n    &lt;!-- </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isRed ? <span class="token punctuation">\'</span>red<span class="token punctuation">\'</span>: <span class="token punctuation">\'</span><span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"> --\x3e\n    &lt;!-- </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{red: isRed, pink: isPink}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text"> --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>arr<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="v-bind对于style-的增强" tabindex="-1"><a class="header-anchor" href="#v-bind对于style-的增强" aria-hidden="true">#</a> v-bind对于style 的增强</h3>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- \n      :style也可以使用对象或者数组\n     --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span> <span class="token attr-name">:style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>[styleObj1, styleObj2]<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">123</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="计算属性" tabindex="-1"><a class="header-anchor" href="#计算属性" aria-hidden="true">#</a> 计算属性</h1>\n<h2 id="基本使用-1" tabindex="-1"><a class="header-anchor" href="#基本使用-1" aria-hidden="true">#</a> 基本使用</h2>\n<p>需求：翻转字符串案例</p>\n<blockquote>\n<p>计算属性是一个属性，写法上是一个函数，这个函数的返回值就是计算属性最终的值。</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>计算属性必须定义在 computed 节点中</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start="2">\n<li>计算属性必须是一个 function,计算属性必须有返回值</li>\n</ol>\n</blockquote>\n<blockquote>\n<ol start="3">\n<li>计算属性不能被当作方法调用,当成属性来用</li>\n</ol>\n</blockquote>\n<p>定义计算属性</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 组件的数据： 需要计算的属性</span>\n<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">reverseMsg</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>使用计算属性</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> reverseMsg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="计算属性的缓存的问题" tabindex="-1"><a class="header-anchor" href="#计算属性的缓存的问题" aria-hidden="true">#</a> 计算属性的缓存的问题</h2>\n<p>计算属性： 缓存</p>\n<p>计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。</p>\n<p>计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 计算属性只要计算了一次，就会把结果缓存起来，以后多次使用计算属性，直接使用缓存的结果，只会计算一次。</span>\n<span class="token comment">// 计算属性依赖的属性一旦发生了改变，计算属性会重新计算一次，并且缓存</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">msg</span><span class="token operator">:</span> <span class="token string">\'hello\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">reverseMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'我执行了\'</span><span class="token punctuation">)</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="计算属性的完整写法" tabindex="-1"><a class="header-anchor" href="#计算属性的完整写法" aria-hidden="true">#</a> 计算属性的完整写法</h2>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 1. 计算属性默认情况下只能获取，不能修改。</span>\n<span class="token comment">// 2. 计算属性的完整写法</span>\n<span class="token comment">/* \n  computed: {\n    full() {},\n    full: {\n      get() {\n        return this.first + \' \' + this.last\n      },\n      set(value) {\n\n      }\n    }\n  }\n*/</span>\n<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">full</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token operator">...</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token operator">...</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="属性监听" tabindex="-1"><a class="header-anchor" href="#属性监听" aria-hidden="true">#</a> 属性监听</h1>\n<h2 id="基本使用-2" tabindex="-1"><a class="header-anchor" href="#基本使用-2" aria-hidden="true">#</a> 基本使用</h2>\n<p>当需要监听某个数据是否发生改变，就要用到watch</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">/* \n  watch: {\n    // 只要属性发生了改变，这个函数就会执行\n    属性: function () {\n\n    }\n  }\n*/</span>\n<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 参数1： value    变化后的值</span>\n  <span class="token comment">// 参数2： oldValue 变化前的值</span>\n  <span class="token function">msg</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> oldValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'你变了\'</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="复杂类型的监听-监听的完整写法" tabindex="-1"><a class="header-anchor" href="#复杂类型的监听-监听的完整写法" aria-hidden="true">#</a> 复杂类型的监听-监听的完整写法</h2>\n<blockquote>\n<p>如果监听的是复杂数据类型，需要深度监听，需要指定deep为true,需要用到监听的完整的写法</p>\n</blockquote>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 1. 默认情况下，watch只能监听到简单类型的数据变化,如果监听的是复杂类型，只会监听地址是否发生改变，不会监听对象内部属性的变化。</span>\n<span class="token comment">// 2. 需要使用监听的完整写法 是一个对象</span>\n<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// friend (value) {</span>\n  <span class="token comment">//   console.log(\'你变了\', value)</span>\n  <span class="token comment">// }</span>\n  <span class="token literal-property property">friend</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// handler 数据发生变化，需要执行的处理程序</span>\n    <span class="token comment">// deep: true  如果true,代表深度监听，不仅会监听地址的变化，还会监听对象内部属性的变化</span>\n    <span class="token comment">// immediate: 立即 立刻  是否立即监听 默认是false  如果是true,代表页面一加载，会先执行一次处理程序</span>\n    <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'你变了\'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">immediate</span><span class="token operator">:</span> <span class="token boolean">true</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="成绩案例-监听数据进行缓存" tabindex="-1"><a class="header-anchor" href="#成绩案例-监听数据进行缓存" aria-hidden="true">#</a> 成绩案例-监听数据进行缓存</h2>\n<ul>\n<li>监听list的变化</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">deep</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">\'score-case\'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul>\n<li>获取list数据的时候不能写死，从localStorage中获取</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">\'score-case\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">subject</span><span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">score</span><span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h1 id="vscode断点调试" tabindex="-1"><a class="header-anchor" href="#vscode断点调试" aria-hidden="true">#</a> vscode断点调试</h1>\n<p>前言：作为前端开发，我们经常会遇到代码错误，需要进行调试</p>\n<p>常见的调试方案：</p>\n<ul>\n<li>不调试，直接看代码找问题</li>\n<li>console.log 打印日志</li>\n<li><strong>用 VSCode 的 debugger 来调试</strong> （<strong>断点调试</strong>）</li>\n</ul>\n<p>前两种，适合找一些简易的错误，如果短时间错误没有排查出来，建议使用 <strong>vscode断点调试</strong>。</p>\n<h2 id="配置步骤-两步" tabindex="-1"><a class="header-anchor" href="#配置步骤-两步" aria-hidden="true">#</a> 配置步骤 （两步）</h2>\n<ol>\n<li>\n<p>新建 <code>.vscode</code> 目录,  <code>launch.json</code> 文件， 填入配置内容</p>\n<p>注意：<code>端口号</code> 需要和 启动服务器 <code>端口号</code> 统一</p>\n</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token punctuation">{</span>\n  <span class="token string-property property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"Launch Chrome"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"pwa-chrome"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"url"</span><span class="token operator">:</span> <span class="token string">"http://localhost:8080"</span><span class="token punctuation">,</span>\n      <span class="token string-property property">"sourceMapPathOverrides"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token string-property property">"webpack://src/*"</span><span class="token operator">:</span> <span class="token string">"${workspaceFolder}/src/*"</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ol start="2">\n<li><code>vue.config.js</code> 填入配置内容</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'@vue/cli-service\'</span><span class="token punctuation">)</span>\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">transpileDependencies</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token comment">// -----------------------------------------------------------</span>\n  <span class="token function-variable function">configureWebpack</span><span class="token operator">:</span> <span class="token parameter">config</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 配置断点调试，实际上线时，可删除</span>\n    config<span class="token punctuation">.</span>output<span class="token punctuation">.</span><span class="token function-variable function">devtoolModuleFilenameTemplate</span> <span class="token operator">=</span> <span class="token parameter">info</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">const</span> resPath <span class="token operator">=</span> info<span class="token punctuation">.</span>resourcePath\n      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">webpack://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>resPath<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// -----------------------------------------------------------</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/指令下+计算属性+侦听器.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"指令下+计算属性+侦听器",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/指令下+计算属性+侦听器.md",filePathRelative:"Vue/指令下+计算属性+侦听器.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/指令下+计算属性+侦听器.html.vue",componentFilePathRelative:"pages/Vue/指令下+计算属性+侦听器.html.vue",componentFileChunkName:"v-7e7a417e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/指令下+计算属性+侦听器.html.js",dataFilePathRelative:"pages/Vue/指令下+计算属性+侦听器.html.js",dataFileChunkName:"v-7e7a417e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/指令下+计算属性+侦听器.html",htmlFilePathRelative:"Vue/指令下+计算属性+侦听器.html"},{data:{key:"v-a25da32e",path:"/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.html",title:"生命周期",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"研究生命周期的意义",slug:"研究生命周期的意义",children:[]},{level:2,title:"生命周期函数(钩子函数)",slug:"生命周期函数-钩子函数",children:[]},{level:2,title:"组件生命周期分类",slug:"组件生命周期分类",children:[]},{level:2,title:"SPA - 单页应用程序",slug:"spa-单页应用程序",children:[{level:3,title:"优势",slug:"优势",children:[]},{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"路由介绍",slug:"路由介绍",children:[]},{level:2,title:"vue-router介绍",slug:"vue-router介绍",children:[{level:3,title:"路由 - 组件分类",slug:"路由-组件分类",children:[]}]},{level:2,title:"vue-router使用",slug:"vue-router使用",children:[]},{level:2,title:"配置路由规则",slug:"配置路由规则",children:[]},{level:2,title:"路由的封装",slug:"路由的封装",children:[]},{level:2,title:"vue路由 - 声明式导航",slug:"vue路由-声明式导航",children:[{level:3,title:"声明式导航 - 基础使用",slug:"声明式导航-基础使用",children:[]},{level:3,title:"导航高亮",slug:"导航高亮",children:[]},{level:3,title:"路由使用巩固 - 练习",slug:"路由使用巩固-练习",children:[]},{level:3,title:"声明式导航 - 跳转传参",slug:"声明式导航-跳转传参",children:[]}]},{level:2,title:"vue路由 - 重定向和模式",slug:"vue路由-重定向和模式",children:[{level:3,title:"路由 - 重定向",slug:"路由-重定向",children:[]},{level:3,title:"路由 - 404页面",slug:"路由-404页面",children:[]},{level:3,title:"路由 - 模式设置",slug:"路由-模式设置",children:[]}]},{level:2,title:"vue路由 - 编程式导航",slug:"vue路由-编程式导航",children:[{level:3,title:"编程式导航 - 基础使用",slug:"编程式导航-基础使用",children:[]},{level:3,title:"编程式导航 - 跳转传参",slug:"编程式导航-跳转传参",children:[]}]},{level:2,title:"组件缓存 keep-alive",slug:"组件缓存-keep-alive",children:[{level:3,title:"基本语法",slug:"基本语法",children:[]},{level:3,title:"keep-alive对应的两个钩子",slug:"keep-alive对应的两个钩子",children:[]}]}],git:{}},key:"v-a25da32e",path:"/Vue/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F+%E8%B7%AF%E7%94%B1+%E7%BB%84%E4%BB%B6%E7%BC%93%E5%AD%98.html",title:"生命周期",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"研究生命周期的意义",slug:"研究生命周期的意义",children:[]},{level:2,title:"生命周期函数(钩子函数)",slug:"生命周期函数-钩子函数",children:[]},{level:2,title:"组件生命周期分类",slug:"组件生命周期分类",children:[]},{level:2,title:"SPA - 单页应用程序",slug:"spa-单页应用程序",children:[{level:3,title:"优势",slug:"优势",children:[]},{level:3,title:"缺点",slug:"缺点",children:[]}]},{level:2,title:"路由介绍",slug:"路由介绍",children:[]},{level:2,title:"vue-router介绍",slug:"vue-router介绍",children:[{level:3,title:"路由 - 组件分类",slug:"路由-组件分类",children:[]}]},{level:2,title:"vue-router使用",slug:"vue-router使用",children:[]},{level:2,title:"配置路由规则",slug:"配置路由规则",children:[]},{level:2,title:"路由的封装",slug:"路由的封装",children:[]},{level:2,title:"vue路由 - 声明式导航",slug:"vue路由-声明式导航",children:[{level:3,title:"声明式导航 - 基础使用",slug:"声明式导航-基础使用",children:[]},{level:3,title:"导航高亮",slug:"导航高亮",children:[]},{level:3,title:"路由使用巩固 - 练习",slug:"路由使用巩固-练习",children:[]},{level:3,title:"声明式导航 - 跳转传参",slug:"声明式导航-跳转传参",children:[]}]},{level:2,title:"vue路由 - 重定向和模式",slug:"vue路由-重定向和模式",children:[{level:3,title:"路由 - 重定向",slug:"路由-重定向",children:[]},{level:3,title:"路由 - 404页面",slug:"路由-404页面",children:[]},{level:3,title:"路由 - 模式设置",slug:"路由-模式设置",children:[]}]},{level:2,title:"vue路由 - 编程式导航",slug:"vue路由-编程式导航",children:[{level:3,title:"编程式导航 - 基础使用",slug:"编程式导航-基础使用",children:[]},{level:3,title:"编程式导航 - 跳转传参",slug:"编程式导航-跳转传参",children:[]}]},{level:2,title:"组件缓存 keep-alive",slug:"组件缓存-keep-alive",children:[{level:3,title:"基本语法",slug:"基本语法",children:[]},{level:3,title:"keep-alive对应的两个钩子",slug:"keep-alive对应的两个钩子",children:[]}]}],content:'# 生命周期\n\n## 研究生命周期的意义\n\n生命周期 => 一个事物从出生 到 消亡的全部过程 \n\n生命周期（Life Cycle）是指一个组件从`创建`-> `运行` -> `销毁`的整个阶段，强调的是一个时间段\n\n- 张三出生，表示这个人生命周期的开始\n- 张三离世，表示这个人生命周期的结束\n- 中间张三的一生，就是张三的生命周期\n\n我们可以把`每个 vue 组件运行的过程`，也概括为生命周期：\n\n- vue 组件的初始化，表示生命周期的开始\n- vue 组件的销毁，表示生命周期的结束\n- vue 组件中间运行的过程，就是组件的生命周期\n\n## 生命周期函数(钩子函数)\n\n**生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。**\n\n生命周期函数的作用：允许程序员在`特定的时间点`，执行某些特定的操作。\n\n例如，组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据。\n\n## 组件生命周期分类\n\nvue 组件的生命周期函数，可以分为 3 大类：\n\n- 组件`初始化阶段`的生命周期函数\n- 组件`运行阶段`的生命周期函数\n- 组件`销毁阶段`的生命周期函数\n\n```js\n1. beforeCreate：data数据初始化之前，组件还没有数据\n2. created: data数据初始化之后，可以获取到组件的数据\n3. beforeMount：DOM渲染之前，DOM还没渲染\n4. mounted：DOM渲染之后，可以操作DOM了\n5. beforeUpdate: 数据更新，DOM更新前\n6. updated: 数据更新，DOM更新后\n7. beforeDestroy: 组件销毁前\n8. destroyed: 组件销毁后\n```\n\n\n\n\n\n# 单页应用程序与路由\n\n## SPA - 单页应用程序\n\n- SPA： `Single Page Application`  单页面应用程序\n- MPA : `Multiple Page Application`多页面应用程序 \n\n[SPA ](https://baike.baidu.com/item/SPA/17536313?fr=aladdin)\n\n[网易云音乐](https://music.163.com/)\n\n### 优势\n\n- 传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面\n- 单页面应用程序只有第一次会加载完整的页面\n- 以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力\n- SPA更好的用户体验，运行更加流畅\n\n### 缺点\n\n1. 开发成本高 (需要学习路由)  `vue-router   react-router`\n2. **不利于 SEO** 搜索引擎优化    谷歌浏览器在解决这个问题    ssr:服务端渲染 server side rendering\n\n## 路由介绍\n\n- **路由** : 是浏览器 **URL 中的哈希值**( # hash) 与 **展示视图内容(组件)** 之间的对应规则\n  - 简单来说,路由就是一套映射规则(一对一的对应规则), 由开发人员制定规则.- \n  - 当 URL 中的哈希值( `#` hash) 发生改变后,路由会根据制定好的**规则**, 展示对应的视图内容(组件)\n- **为什么要学习路由?**\n  - 渐进式 =>vue => vuer-router (管理组件之间的跳转)\n  - 在 web App 中, 经常会出现通过一个页面来展示和管理整个应用的功能.\n  - SPA 往往是功能复杂的应用,为了有效管理所有视图内容,前端路由 应运而生.\n- **vue 中的路由** : 是 **hash** 和 **component** 的对应关系, **一个哈希值对应一个组件**\n\n> 目标: 设备和ip的映射关系\n\n\n\n> 目标: 路径和组件的映射关系\n\n\n\n# vue-router\n\n## vue-router介绍\n\n> 目标: 如何在Vue项目中集成路由\n\n官网: https://router.vuejs.org/zh/\n\n### 路由 - 组件分类\n\n> 目标:  .vue文件分2类, 一个是页面组件, 一个是复用组件\n\n.vue文件本质无区别, 方便大家学习和理解, 总结的一个经验\n\nsrc/views(或pages) 文件夹 和 src/components文件夹\n\n* 页面组件 - 页面展示 - 配合路由用\n* 复用组件 - 展示数据/常用于复用\n\n\n\n> 总结: views下的页面组件, 配合路由切换, components下的一般引入到views下的vue中复用展示数据\n\n## vue-router使用\n\n> 目标: 学会vue官方提供的vue-router路由系统功能模块使用\n\nApp.vue - 页面标签和样式准备(==可复制继续写==)\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <a href="#/find">发现音乐</a>\n      <a href="#/my">我的音乐</a>\n      <a href="#/part">朋友</a>\n    </div>\n    <div class="top">\n      \n    </div>\n  </div>\n</template>\n\n<script>\nexport default {};\n<\/script>\n\n<style scoped>\n.footer_wrap {\n  position: fixed;\n  left: 0;\n  top: 0;\n  display: flex;\n  width: 100%;\n  text-align: center;\n  background-color: #333;\n  color: #ccc;\n}\n.footer_wrap a {\n  flex: 1;\n  text-decoration: none;\n  padding: 20px 0;\n  line-height: 20px;\n  background-color: #333;\n  color: #ccc;\n  border: 1px solid black;\n}\n.footer_wrap a:hover {\n  background-color: #555;\n}\n.top {\n  padding-top: 62px;\n}\n</style>\n```\n\n[vue-router文档](https://router.vuejs.org/zh/)\n\n- 安装\n\n```bash\nyarn add vue-router@3.5.3\n```\n\n+ 导入路由 `main.js`中\n\n```js\nimport VueRouter from \'vue-router\'\n```\n\n+ 使用路由插件\n\n```jsx\n// 在vue中，使用使用vue的插件，都需要调用Vue.use()\nVue.use(VueRouter)\n```\n\n+ 创建路由对象\n\n```jsx\nconst router = new VueRouter({\n})\n```\n\n+ 关联到vue实例\n\n```jsx\nnew Vue({\n  router\n})\n```\n\n==效果：地址栏中自动增加了 #==\n\n## 配置路由规则\n\n```js\n// 4. 创建一个路由对象\nconst router = new VueRouter({\n  // 路由的规则\n  // route: 一条路由规则\n  routes: [\n    {\n      // 路径 锚点\n      // 组件\n      path: \'/find\',\n      component: Find,\n    },\n    {\n      path: \'/my\',\n      component: My,\n    },\n    {\n      path: \'/friend\',\n      component: Friend,\n    },\n  ],\n})\n```\n\n==必须指定路由的出口==\n\n```js\n<div class="top">\n  \x3c!-- 路由的出口 --\x3e\n  <router-view></router-view>\n</div>\n```\n\n## 路由的封装\n\n+ 新建文件`router/index.js`\n\n```js\nimport Vue from \'vue\'\n// 2. 导入VueRouter\nimport VueRouter from \'vue-router\'\n\nimport Find from \'../views/Find\'\nimport My from \'../views/My\'\nimport Friend from \'../views/Friend\'\n\n// 3. 使用vue插件  vue的插件想要生效必须调用一个方法  Vue.use(XXXX)\nVue.use(VueRouter)\n\n// 4. 创建一个路由对象\nconst router = new VueRouter({\n  // 路由的规则\n  // route: 一条路由规则\n  routes: [\n    {\n      // 路径 锚点\n      // 组件\n      path: \'/find\',\n      component: Find,\n    },\n    {\n      path: \'/my\',\n      component: My,\n    },\n    {\n      path: \'/friend\',\n      component: Friend,\n    },\n  ],\n})\n\nexport default router\n\n```\n\n+ main.js中\n\n```js\nimport router from \'./router\'\n\nnew Vue({\n  // 5. 关联路由对象和vue实例 data methods\n  render: (h) => h(App),\n  router,\n}).$mount(\'#app\')\n```\n\n\n\n## vue路由 - 声明式导航\n\n### 声明式导航 - 基础使用\n\n> 目标: 可用全局组件router-link来替代a标签\n\n1.  vue-router提供了一个全局组件 router-link\n2.  router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#)\n3.  router-link提供了声明式导航高亮的功能(自带类名)\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <router-link to="/find">发现音乐</router-link>\n      <router-link to="/my">我的音乐</router-link>\n      <router-link to="/part">朋友</router-link>\n    </div>\n    <div class="top">\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {};\n<\/script>\n\n<style scoped>\n/* 省略了 其他样式 */\n.router-link-exact-active,\n.router-link-active {\n  background-color: #555 !important;\n}\n</style>\n```\n\n> 总结: 链接导航, 用router-link配合to, 实现点击切换路由\n\n### 导航高亮\n\n> RouterLink会自动给当前导航添加两个类名\n\n```jsx\n\x3c!-- \n  RouterLink会自动给当前的链接添加两个类名\n    router-link-active: 激活的导航链接   模糊匹配\n    router-link-exact-active:  激活的导航链接 精确匹配\n\n    exact: 必须要精确匹配\n  --\x3e\n <RouterLink to="/" exact>发现音乐</RouterLink>\n<RouterLink to="/my">我的音乐</RouterLink>\n<RouterLink to="/friend">朋友</RouterLink>\n      \n```\n\n可以修改默认高亮的类名\n\n```js\nconst router = new VueRouter({\n  linkActiveClass: \'aa\',\n  linkExactActiveClass: \'aa\',\n  // route: 一条规则\n}\n```\n\n\n\n\n\n### 路由使用巩固 - 练习\n\n目标：实现以下切换效果\n\n### 声明式导航 - 跳转传参\n\n> 目标: 在跳转路由时, 可以给路由对应的组件内传值\n\n在router-link上的to属性传值, 语法格式如下\n\n* /path?参数名=值\n\n* /path/:id – 需要路由对象提前配置 path: “/path/参数名”\n\n对应页面组件接收传递过来的值\n\n* $route.query.参数名\n\n* $route.params.参数名\n\n1. 创建views/Part.vue - 准备接收路由上传递的参数和值\n\n   ```vue\n   <template>\n     <div>\n         <p>关注明星</p>\n         <p>发现精彩</p>\n         <p>寻找伙伴</p>\n         <p>加入我们</p>\n         <p>人名: {{ $route.query.name }} -- {{ $route.params.username }}</p>\n     </div>\n   </template>\n   ```\n\n2. 路由定义\n\n   ```js\n   {\n       path: "/part",\n       component: Part\n     },\n     {\n       path: "/part/:username", // 有:的路径代表要接收具体的值\n       component: Part\n     },\n   ```\n\n3. 导航跳转, 传值给MyGoods.vue组件\n\n   ```vue\n   <router-link to="/part?name=小传">朋友-小传</router-link>\n   <router-link to="/part/小智">朋友-小智</router-link>\n   ```\n\n\n\n## vue路由 - 重定向和模式\n\n### 路由 - 重定向\n\n> 目标: 匹配path后, 强制切换到目标path上\n\n* 网页打开url默认hash值是/路径\n* redirect是设置要重定向到哪个路由路径\n\n例如: 网页默认打开, 匹配路由"/", 强制切换到"/find"上\n\n```js\nconst routes = [\n  {\n    path: "/", // 默认hash值路径\n    redirect: "/find" // 重定向到/find\n    // 浏览器url中#后的路径被改变成/find-重新匹配数组规则\n  }\n]\n```\n\n> 总结: 强制重定向后, 还会重新来数组里匹配一次规则\n\n### 路由 - 404页面\n\n> 目标: 如果路由hash值, 没有和数组里规则匹配\n\n默认给一个404页面\n\n语法: 路由最后, path匹配*(任意路径) – 前面不匹配就命中最后这个, 显示对应组件页面\n\n1. 创建NotFound页面\n\n   ```vue\n   <template>\n     <img src="../assets/404.png" alt="">\n   </template>\n   \n   <script>\n   export default {\n   \n   }\n   <\/script>\n   \n   <style scoped>\n       img{\n           width: 100%;\n       }\n   </style>\n   ```\n\n2. 在main.js - 修改路由配置\n\n   ```js\n   import NotFound from \'@/views/NotFound\'\n   \n   const routes = [\n     // ...省略了其他配置\n     // 404在最后(规则是从前往后逐个比较path)\n     {\n       path: "*",\n       component: NotFound\n     }\n   ]\n   ```\n\n> 总结: 如果路由未命中任何规则, 给出一个兜底的404页面\n\n### 路由 - 模式设置\n\n> 目标: 修改路由在地址栏的模式\n\nhash路由例如:  http://localhost:8080/#/home\n\nhistory路由例如: http://localhost:8080/home  (以后上线需要服务器端支持)\n\n[模式文档](https://router.vuejs.org/zh/api/#mode)\n\nrouter/index.js\n\n```js\nconst router = new VueRouter({\n  routes,\n  mode: "history" // 打包上线后需要后台支持, 模式是hash\n})\n```\n\n## vue路由 - 编程式导航\n\n> 编程式导航用JS代码跳转\n>\n> 声明式导航用a标签\n\n### 编程式导航 - 基础使用\n\n> 目标: 用JS代码来进行跳转\n\n语法:\n\n```js\nthis.$router.push({\n    path: "路由路径", // 都去 router/index.js定义\n    name: "路由名"\n})\n```\n\n1. main.js - 路由数组里, 给路由起名字\n\n```json\n{\n    path: "/find",\n    name: "Find",\n    component: Find\n},\n{\n    path: "/my",\n    name: "My",\n    component: My\n},\n{\n    path: "/part",\n    name: "Part",\n    component: Part\n},\n```\n\n2. App.vue - 换成span 配合js的编程式导航跳转\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <span @click="btn(\'/find\', \'Find\')">发现音乐</span>\n      <span @click="btn(\'/my\', \'My\')">我的音乐</span>\n      <span @click="btn(\'/part\', \'Part\')">朋友</span>\n    </div>\n    <div class="top">\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\n// 目标: 编程式导航 - js方式跳转路由\n// 语法:\n// this.$router.push({path: "路由路径"})\n// this.$router.push({name: "路由名"})\n// 注意:\n// 虽然用name跳转, 但是url的hash值还是切换path路径值\n// 场景:\n// 方便修改: name路由名(在页面上看不见随便定义)\n// path可以在url的hash值看到(尽量符合组内规范)\nexport default {\n  methods: {\n    btn(targetPath, targetName){\n      // 方式1: path跳转\n      this.$router.push({\n        // path: targetPath,\n        name: targetName\n      })\n    }\n  }\n};\n<\/script>\n```\n\n### 编程式导航 - 跳转传参\n\n> 目标: JS跳转路由, 传参\n\n语法 query / params 任选 一个\n\n```js\nthis.$router.push({\n    path: "路由路径"\n    name: "路由名",\n    query: {\n    \t"参数名": 值\n    }\n    params: {\n\t\t"参数名": 值\n    }\n})\n\n// 对应路由接收   $route.params.参数名   取值\n// 对应路由接收   $route.query.参数名    取值\n```\n\n==格外注意: 使用path会自动忽略params==\n\nApp.vue\n\n```vue\n<template>\n  <div>\n    <div class="footer_wrap">\n      <span @click="btn(\'/find\', \'Find\')">发现音乐</span>\n      <span @click="btn(\'/my\', \'My\')">我的音乐</span>\n      <span @click="oneBtn">朋友-小传</span>\n      <span @click="twoBtn">朋友-小智</span>\n    </div>\n    <div class="top">\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\n// 目标: 编程式导航 - 跳转路由传参\n// 方式1:\n// params => $route.params.参数名\n// 方式2:\n// query => $route.query.参数名\n// 重要: path会自动忽略params\n// 推荐: name+query方式传参\n// 注意: 如果当前url上"hash值和?参数"与你要跳转到的"hash值和?参数"一致, 爆出冗余导航的问题, 不会跳转路由\nexport default {\n  methods: {\n    btn(targetPath, targetName){\n      // 方式1: path跳转\n      this.$router.push({\n        // path: targetPath,\n        name: targetName\n      })\n    },\n    oneBtn(){\n      this.$router.push({\n        name: \'Part\',\n        params: {\n          username: \'小传\'\n        }\n      })\n    },\n    twoBtn(){\n      this.$router.push({\n        name: \'Part\',\n        query: {\n          name: \'小智\'\n        }\n      })\n    }\n  }\n};\n<\/script>\n```\n\n## 组件缓存 keep-alive\n\n### 基本语法\n\n思考：从面经 点到 收藏，又点回 面经，面经的数据需要重新加载么？不需要，希望缓存下来！\n\n如果希望组件被缓存下来，可以在外面包一个 keep-alive 组件 ~\n\n![image-20220613022957478](images/image-20220613022957478.png)\n\n`src/views/Layout.vue`\n\n```jsx\n<template>\n  <div class="h5-wrapper">\n    <div class="content">\n      <keep-alive>\n        <router-view></router-view>\n      </keep-alive>\n    </div>\n    <nav class="tabbar">\n      <router-link to="/article">面经</router-link>\n      <router-link to="/collect">收藏</router-link>\n      <router-link to="/like">喜欢</router-link>\n      <router-link to="/user">我的</router-link>\n    </nav>\n  </div>\n</template>\n```\n\n\n\n### keep-alive对应的两个钩子\n\n当组件被keep-alive管理时，会多出两个生命周期钩子，activated  /  deactivated\n\n`src/views/Article.vue`\n\n```jsx\nexport default {\n  name: \'ArticlePage\',\n  data() {\n    return {\n      articles: []\n    };\n  },\n  async created() {\n    const { data } = await axios.get(\n      \'https://mock.boxuegu.com/mock/3083/articles\',\n    );\n    this.articles = data.result.rows;\n    console.log(this.articles)\n  },\n  activated() {\n    console.log(\'缓存组件被激活\')\n  },\n  deactivated() {\n    console.log(\'缓存组件被隐藏\')\n  }\n};\n```\n\n\n\n\n\n',contentRendered:'<h1 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h1>\n<h2 id="研究生命周期的意义" tabindex="-1"><a class="header-anchor" href="#研究生命周期的意义" aria-hidden="true">#</a> 研究生命周期的意义</h2>\n<p>生命周期 =&gt; 一个事物从出生 到 消亡的全部过程</p>\n<p>生命周期（Life Cycle）是指一个组件从<code>创建</code>-&gt; <code>运行</code> -&gt; <code>销毁</code>的整个阶段，强调的是一个时间段</p>\n<ul>\n<li>张三出生，表示这个人生命周期的开始</li>\n<li>张三离世，表示这个人生命周期的结束</li>\n<li>中间张三的一生，就是张三的生命周期</li>\n</ul>\n<p>我们可以把<code>每个 vue 组件运行的过程</code>，也概括为生命周期：</p>\n<ul>\n<li>vue 组件的初始化，表示生命周期的开始</li>\n<li>vue 组件的销毁，表示生命周期的结束</li>\n<li>vue 组件中间运行的过程，就是组件的生命周期</li>\n</ul>\n<h2 id="生命周期函数-钩子函数" tabindex="-1"><a class="header-anchor" href="#生命周期函数-钩子函数" aria-hidden="true">#</a> 生命周期函数(钩子函数)</h2>\n<p><strong>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行。</strong></p>\n<p>生命周期函数的作用：允许程序员在<code>特定的时间点</code>，执行某些特定的操作。</p>\n<p>例如，组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据。</p>\n<h2 id="组件生命周期分类" tabindex="-1"><a class="header-anchor" href="#组件生命周期分类" aria-hidden="true">#</a> 组件生命周期分类</h2>\n<p>vue 组件的生命周期函数，可以分为 3 大类：</p>\n<ul>\n<li>组件<code>初始化阶段</code>的生命周期函数</li>\n<li>组件<code>运行阶段</code>的生命周期函数</li>\n<li>组件<code>销毁阶段</code>的生命周期函数</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token number">1.</span> beforeCreate：data数据初始化之前，组件还没有数据\n<span class="token number">2.</span> <span class="token literal-property property">created</span><span class="token operator">:</span> data数据初始化之后，可以获取到组件的数据\n<span class="token number">3.</span> beforeMount：<span class="token constant">DOM</span>渲染之前，<span class="token constant">DOM</span>还没渲染\n<span class="token number">4.</span> mounted：<span class="token constant">DOM</span>渲染之后，可以操作<span class="token constant">DOM</span>了\n<span class="token number">5.</span> <span class="token literal-property property">beforeUpdate</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新前\n<span class="token number">6.</span> <span class="token literal-property property">updated</span><span class="token operator">:</span> 数据更新，<span class="token constant">DOM</span>更新后\n<span class="token number">7.</span> <span class="token literal-property property">beforeDestroy</span><span class="token operator">:</span> 组件销毁前\n<span class="token number">8.</span> <span class="token literal-property property">destroyed</span><span class="token operator">:</span> 组件销毁后\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h1 id="单页应用程序与路由" tabindex="-1"><a class="header-anchor" href="#单页应用程序与路由" aria-hidden="true">#</a> 单页应用程序与路由</h1>\n<h2 id="spa-单页应用程序" tabindex="-1"><a class="header-anchor" href="#spa-单页应用程序" aria-hidden="true">#</a> SPA - 单页应用程序</h2>\n<ul>\n<li>SPA： <code>Single Page Application</code>  单页面应用程序</li>\n<li>MPA : <code>Multiple Page Application</code>多页面应用程序</li>\n</ul>\n<p><a href="https://baike.baidu.com/item/SPA/17536313?fr=aladdin" target="_blank" rel="noopener noreferrer">SPA <ExternalLinkIcon/></a></p>\n<p><a href="https://music.163.com/" target="_blank" rel="noopener noreferrer">网易云音乐<ExternalLinkIcon/></a></p>\n<h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h3>\n<ul>\n<li>传统的多页面应用程序，每次请求服务器返回的都是一整个完整的页面</li>\n<li>单页面应用程序只有第一次会加载完整的页面</li>\n<li>以后每次请求仅仅获取必要的数据，减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>\n<li>SPA更好的用户体验，运行更加流畅</li>\n</ul>\n<h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3>\n<ol>\n<li>开发成本高 (需要学习路由)  <code>vue-router   react-router</code></li>\n<li><strong>不利于 SEO</strong> 搜索引擎优化    谷歌浏览器在解决这个问题    ssr:服务端渲染 server side rendering</li>\n</ol>\n<h2 id="路由介绍" tabindex="-1"><a class="header-anchor" href="#路由介绍" aria-hidden="true">#</a> 路由介绍</h2>\n<ul>\n<li><strong>路由</strong> : 是浏览器 <strong>URL 中的哈希值</strong>( # hash) 与 <strong>展示视图内容(组件)</strong> 之间的对应规则\n<ul>\n<li>简单来说,路由就是一套映射规则(一对一的对应规则), 由开发人员制定规则.-</li>\n<li>当 URL 中的哈希值( <code>#</code> hash) 发生改变后,路由会根据制定好的<strong>规则</strong>, 展示对应的视图内容(组件)</li>\n</ul>\n</li>\n<li><strong>为什么要学习路由?</strong>\n<ul>\n<li>渐进式 =&gt;vue =&gt; vuer-router (管理组件之间的跳转)</li>\n<li>在 web App 中, 经常会出现通过一个页面来展示和管理整个应用的功能.</li>\n<li>SPA 往往是功能复杂的应用,为了有效管理所有视图内容,前端路由 应运而生.</li>\n</ul>\n</li>\n<li><strong>vue 中的路由</strong> : 是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系, <strong>一个哈希值对应一个组件</strong></li>\n</ul>\n<blockquote>\n<p>目标: 设备和ip的映射关系</p>\n</blockquote>\n<blockquote>\n<p>目标: 路径和组件的映射关系</p>\n</blockquote>\n<h1 id="vue-router" tabindex="-1"><a class="header-anchor" href="#vue-router" aria-hidden="true">#</a> vue-router</h1>\n<h2 id="vue-router介绍" tabindex="-1"><a class="header-anchor" href="#vue-router介绍" aria-hidden="true">#</a> vue-router介绍</h2>\n<blockquote>\n<p>目标: 如何在Vue项目中集成路由</p>\n</blockquote>\n<p>官网: https://router.vuejs.org/zh/</p>\n<h3 id="路由-组件分类" tabindex="-1"><a class="header-anchor" href="#路由-组件分类" aria-hidden="true">#</a> 路由 - 组件分类</h3>\n<blockquote>\n<p>目标:  .vue文件分2类, 一个是页面组件, 一个是复用组件</p>\n</blockquote>\n<p>.vue文件本质无区别, 方便大家学习和理解, 总结的一个经验</p>\n<p>src/views(或pages) 文件夹 和 src/components文件夹</p>\n<ul>\n<li>页面组件 - 页面展示 - 配合路由用</li>\n<li>复用组件 - 展示数据/常用于复用</li>\n</ul>\n<blockquote>\n<p>总结: views下的页面组件, 配合路由切换, components下的一般引入到views下的vue中复用展示数据</p>\n</blockquote>\n<h2 id="vue-router使用" tabindex="-1"><a class="header-anchor" href="#vue-router使用" aria-hidden="true">#</a> vue-router使用</h2>\n<blockquote>\n<p>目标: 学会vue官方提供的vue-router路由系统功能模块使用</p>\n</blockquote>\n<p>App.vue - 页面标签和样式准备(==可复制继续写==)</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/find<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/my<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#/part<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      \n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.footer_wrap</span> <span class="token punctuation">{</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> #ccc<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.footer_wrap a</span> <span class="token punctuation">{</span>\n  <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n  <span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 20px 0<span class="token punctuation">;</span>\n  <span class="token property">line-height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #333<span class="token punctuation">;</span>\n  <span class="token property">color</span><span class="token punctuation">:</span> #ccc<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.footer_wrap a:hover</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #555<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.top</span> <span class="token punctuation">{</span>\n  <span class="token property">padding-top</span><span class="token punctuation">:</span> 62px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">vue-router文档<ExternalLinkIcon/></a></p>\n<ul>\n<li>安装</li>\n</ul>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code><span class="token function">yarn</span> <span class="token function">add</span> vue-router@3.5.3\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>导入路由 <code>main.js</code>中</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">\'vue-router\'</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul>\n<li>使用路由插件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 在vue中，使用使用vue的插件，都需要调用Vue.use()</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul>\n<li>创建路由对象</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul>\n<li>关联到vue实例</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  router\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>==效果：地址栏中自动增加了 #==</p>\n<h2 id="配置路由规则" tabindex="-1"><a class="header-anchor" href="#配置路由规则" aria-hidden="true">#</a> 配置路由规则</h2>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 4. 创建一个路由对象</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 路由的规则</span>\n  <span class="token comment">// route: 一条路由规则</span>\n  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token comment">// 路径 锚点</span>\n      <span class="token comment">// 组件</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/find\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Find<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/my\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> My<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/friend\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Friend<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>==必须指定路由的出口==</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"top"</span><span class="token operator">></span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 路由的出口 <span class="token operator">--</span><span class="token operator">></span>\n  <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="路由的封装" tabindex="-1"><a class="header-anchor" href="#路由的封装" aria-hidden="true">#</a> 路由的封装</h2>\n<ul>\n<li>新建文件<code>router/index.js</code></li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token comment">// 2. 导入VueRouter</span>\n<span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">\'vue-router\'</span>\n\n<span class="token keyword">import</span> Find <span class="token keyword">from</span> <span class="token string">\'../views/Find\'</span>\n<span class="token keyword">import</span> My <span class="token keyword">from</span> <span class="token string">\'../views/My\'</span>\n<span class="token keyword">import</span> Friend <span class="token keyword">from</span> <span class="token string">\'../views/Friend\'</span>\n\n<span class="token comment">// 3. 使用vue插件  vue的插件想要生效必须调用一个方法  Vue.use(XXXX)</span>\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span>\n\n<span class="token comment">// 4. 创建一个路由对象</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 路由的规则</span>\n  <span class="token comment">// route: 一条路由规则</span>\n  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token comment">// 路径 锚点</span>\n      <span class="token comment">// 组件</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/find\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Find<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/my\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> My<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token punctuation">{</span>\n      <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">\'/friend\'</span><span class="token punctuation">,</span>\n      <span class="token literal-property property">component</span><span class="token operator">:</span> Friend<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> router\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><ul>\n<li>main.js中</li>\n</ul>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> router <span class="token keyword">from</span> <span class="token string">\'./router\'</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 5. 关联路由对象和vue实例 data methods</span>\n  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  router<span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="vue路由-声明式导航" tabindex="-1"><a class="header-anchor" href="#vue路由-声明式导航" aria-hidden="true">#</a> vue路由 - 声明式导航</h2>\n<h3 id="声明式导航-基础使用" tabindex="-1"><a class="header-anchor" href="#声明式导航-基础使用" aria-hidden="true">#</a> 声明式导航 - 基础使用</h3>\n<blockquote>\n<p>目标: 可用全局组件router-link来替代a标签</p>\n</blockquote>\n<ol>\n<li>vue-router提供了一个全局组件 router-link</li>\n<li>router-link实质上最终会渲染成a链接 to属性等价于提供 href属性(to无需#)</li>\n<li>router-link提供了声明式导航高亮的功能(自带类名)</li>\n</ol>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/find<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/my<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/part<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token comment">/* 省略了 其他样式 */</span>\n<span class="token selector">.router-link-exact-active,\n.router-link-active</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> #555 <span class="token important">!important</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><blockquote>\n<p>总结: 链接导航, 用router-link配合to, 实现点击切换路由</p>\n</blockquote>\n<h3 id="导航高亮" tabindex="-1"><a class="header-anchor" href="#导航高亮" aria-hidden="true">#</a> 导航高亮</h3>\n<blockquote>\n<p>RouterLink会自动给当前导航添加两个类名</p>\n</blockquote>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> \n  RouterLink会自动给当前的链接添加两个类名\n    router<span class="token operator">-</span>link<span class="token operator">-</span>active<span class="token operator">:</span> 激活的导航链接   模糊匹配\n    router<span class="token operator">-</span>link<span class="token operator">-</span>exact<span class="token operator">-</span>active<span class="token operator">:</span>  激活的导航链接 精确匹配\n\n    <span class="token literal-property property">exact</span><span class="token operator">:</span> 必须要精确匹配\n  <span class="token operator">--</span><span class="token operator">></span>\n <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RouterLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span> <span class="token attr-name">exact</span><span class="token punctuation">></span></span><span class="token plain-text">发现音乐</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RouterLink</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RouterLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/my<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我的音乐</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RouterLink</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">RouterLink</span></span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/friend<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">朋友</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">RouterLink</span></span><span class="token punctuation">></span></span>\n      \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以修改默认高亮的类名</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token literal-property property">linkActiveClass</span><span class="token operator">:</span> <span class="token string">\'aa\'</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">linkExactActiveClass</span><span class="token operator">:</span> <span class="token string">\'aa\'</span><span class="token punctuation">,</span>\n  <span class="token comment">// route: 一条规则</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="路由使用巩固-练习" tabindex="-1"><a class="header-anchor" href="#路由使用巩固-练习" aria-hidden="true">#</a> 路由使用巩固 - 练习</h3>\n<p>目标：实现以下切换效果</p>\n<h3 id="声明式导航-跳转传参" tabindex="-1"><a class="header-anchor" href="#声明式导航-跳转传参" aria-hidden="true">#</a> 声明式导航 - 跳转传参</h3>\n<blockquote>\n<p>目标: 在跳转路由时, 可以给路由对应的组件内传值</p>\n</blockquote>\n<p>在router-link上的to属性传值, 语法格式如下</p>\n<ul>\n<li>\n<p>/path?参数名=值</p>\n</li>\n<li>\n<p>/path/:id – 需要路由对象提前配置 path: “/path/参数名”</p>\n</li>\n</ul>\n<p>对应页面组件接收传递过来的值</p>\n<ul>\n<li>\n<p>$route.query.参数名</p>\n</li>\n<li>\n<p>$route.params.参数名</p>\n</li>\n</ul>\n<ol>\n<li>\n<p>创建views/Part.vue - 准备接收路由上传递的参数和值</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>关注明星<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>发现精彩<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>寻找伙伴<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>加入我们<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>人名: {{ $route.query.name }} -- {{ $route.params.username }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li>\n<li>\n<p>路由定义</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/part"</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">component</span><span class="token operator">:</span> Part\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/part/:username"</span><span class="token punctuation">,</span> <span class="token comment">// 有:的路径代表要接收具体的值</span>\n    <span class="token literal-property property">component</span><span class="token operator">:</span> Part\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li>\n<li>\n<p>导航跳转, 传值给MyGoods.vue组件</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/part?name=小传<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小传<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/part/小智<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小智<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li>\n</ol>\n<h2 id="vue路由-重定向和模式" tabindex="-1"><a class="header-anchor" href="#vue路由-重定向和模式" aria-hidden="true">#</a> vue路由 - 重定向和模式</h2>\n<h3 id="路由-重定向" tabindex="-1"><a class="header-anchor" href="#路由-重定向" aria-hidden="true">#</a> 路由 - 重定向</h3>\n<blockquote>\n<p>目标: 匹配path后, 强制切换到目标path上</p>\n</blockquote>\n<ul>\n<li>网页打开url默认hash值是/路径</li>\n<li>redirect是设置要重定向到哪个路由路径</li>\n</ul>\n<p>例如: 网页默认打开, 匹配路由&quot;/&quot;, 强制切换到&quot;/find&quot;上</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token comment">// 默认hash值路径</span>\n    <span class="token literal-property property">redirect</span><span class="token operator">:</span> <span class="token string">"/find"</span> <span class="token comment">// 重定向到/find</span>\n    <span class="token comment">// 浏览器url中#后的路径被改变成/find-重新匹配数组规则</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><blockquote>\n<p>总结: 强制重定向后, 还会重新来数组里匹配一次规则</p>\n</blockquote>\n<h3 id="路由-404页面" tabindex="-1"><a class="header-anchor" href="#路由-404页面" aria-hidden="true">#</a> 路由 - 404页面</h3>\n<blockquote>\n<p>目标: 如果路由hash值, 没有和数组里规则匹配</p>\n</blockquote>\n<p>默认给一个404页面</p>\n<p>语法: 路由最后, path匹配*(任意路径) – 前面不匹配就命中最后这个, 显示对应组件页面</p>\n<ol>\n<li>\n<p>创建NotFound页面</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>../assets/404.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n    <span class="token selector">img</span><span class="token punctuation">{</span>\n        <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li>\n<li>\n<p>在main.js - 修改路由配置</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">import</span> NotFound <span class="token keyword">from</span> <span class="token string">\'@/views/NotFound\'</span>\n\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token comment">// ...省略了其他配置</span>\n  <span class="token comment">// 404在最后(规则是从前往后逐个比较path)</span>\n  <span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"*"</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">component</span><span class="token operator">:</span> NotFound\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li>\n</ol>\n<blockquote>\n<p>总结: 如果路由未命中任何规则, 给出一个兜底的404页面</p>\n</blockquote>\n<h3 id="路由-模式设置" tabindex="-1"><a class="header-anchor" href="#路由-模式设置" aria-hidden="true">#</a> 路由 - 模式设置</h3>\n<blockquote>\n<p>目标: 修改路由在地址栏的模式</p>\n</blockquote>\n<p>hash路由例如:  http://localhost:8080/#/home</p>\n<p>history路由例如: http://localhost:8080/home  (以后上线需要服务器端支持)</p>\n<p><a href="https://router.vuejs.org/zh/api/#mode" target="_blank" rel="noopener noreferrer">模式文档<ExternalLinkIcon/></a></p>\n<p>router/index.js</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token punctuation">,</span>\n  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">"history"</span> <span class="token comment">// 打包上线后需要后台支持, 模式是hash</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="vue路由-编程式导航" tabindex="-1"><a class="header-anchor" href="#vue路由-编程式导航" aria-hidden="true">#</a> vue路由 - 编程式导航</h2>\n<blockquote>\n<p>编程式导航用JS代码跳转</p>\n<p>声明式导航用a标签</p>\n</blockquote>\n<h3 id="编程式导航-基础使用" tabindex="-1"><a class="header-anchor" href="#编程式导航-基础使用" aria-hidden="true">#</a> 编程式导航 - 基础使用</h3>\n<blockquote>\n<p>目标: 用JS代码来进行跳转</p>\n</blockquote>\n<p>语法:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"路由路径"</span><span class="token punctuation">,</span> <span class="token comment">// 都去 router/index.js定义</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"路由名"</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol>\n<li>main.js - 路由数组里, 给路由起名字</li>\n</ol>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">"/find"</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">"Find"</span><span class="token punctuation">,</span>\n    component<span class="token operator">:</span> Find\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">"/my"</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">"My"</span><span class="token punctuation">,</span>\n    component<span class="token operator">:</span> My\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">"/part"</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span> <span class="token string">"Part"</span><span class="token punctuation">,</span>\n    component<span class="token operator">:</span> Part\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ol start="2">\n<li>App.vue - 换成span 配合js的编程式导航跳转</li>\n</ol>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/find<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>Find<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/my<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>My<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/part<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>Part<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token comment">// 目标: 编程式导航 - js方式跳转路由</span>\n<span class="token comment">// 语法:</span>\n<span class="token comment">// this.$router.push({path: "路由路径"})</span>\n<span class="token comment">// this.$router.push({name: "路由名"})</span>\n<span class="token comment">// 注意:</span>\n<span class="token comment">// 虽然用name跳转, 但是url的hash值还是切换path路径值</span>\n<span class="token comment">// 场景:</span>\n<span class="token comment">// 方便修改: name路由名(在页面上看不见随便定义)</span>\n<span class="token comment">// path可以在url的hash值看到(尽量符合组内规范)</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">btn</span><span class="token punctuation">(</span><span class="token parameter">targetPath<span class="token punctuation">,</span> targetName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token comment">// 方式1: path跳转</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token comment">// path: targetPath,</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> targetName\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h3 id="编程式导航-跳转传参" tabindex="-1"><a class="header-anchor" href="#编程式导航-跳转传参" aria-hidden="true">#</a> 编程式导航 - 跳转传参</h3>\n<blockquote>\n<p>目标: JS跳转路由, 传参</p>\n</blockquote>\n<p>语法 query / params 任选 一个</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"路由路径"</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"路由名"</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    \t<span class="token string-property property">"参数名"</span><span class="token operator">:</span> 值\n    <span class="token punctuation">}</span>\n    <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n\t\t<span class="token string-property property">"参数名"</span><span class="token operator">:</span> 值\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 对应路由接收   $route.params.参数名   取值</span>\n<span class="token comment">// 对应路由接收   $route.query.参数名    取值</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>==格外注意: 使用path会自动忽略params==</p>\n<p>App.vue</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer_wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/find<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>Find<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>发现音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn(<span class="token punctuation">\'</span>/my<span class="token punctuation">\'</span>, <span class="token punctuation">\'</span>My<span class="token punctuation">\'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我的音乐<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>oneBtn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小传<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>twoBtn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>朋友-小智<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token comment">// 目标: 编程式导航 - 跳转路由传参</span>\n<span class="token comment">// 方式1:</span>\n<span class="token comment">// params => $route.params.参数名</span>\n<span class="token comment">// 方式2:</span>\n<span class="token comment">// query => $route.query.参数名</span>\n<span class="token comment">// 重要: path会自动忽略params</span>\n<span class="token comment">// 推荐: name+query方式传参</span>\n<span class="token comment">// 注意: 如果当前url上"hash值和?参数"与你要跳转到的"hash值和?参数"一致, 爆出冗余导航的问题, 不会跳转路由</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">btn</span><span class="token punctuation">(</span><span class="token parameter">targetPath<span class="token punctuation">,</span> targetName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token comment">// 方式1: path跳转</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token comment">// path: targetPath,</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> targetName\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">oneBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'Part\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">\'小传\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">twoBtn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'Part\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">query</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'小智\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br></div></div><h2 id="组件缓存-keep-alive" tabindex="-1"><a class="header-anchor" href="#组件缓存-keep-alive" aria-hidden="true">#</a> 组件缓存 keep-alive</h2>\n<h3 id="基本语法" tabindex="-1"><a class="header-anchor" href="#基本语法" aria-hidden="true">#</a> 基本语法</h3>\n<p>思考：从面经 点到 收藏，又点回 面经，面经的数据需要重新加载么？不需要，希望缓存下来！</p>\n<p>如果希望组件被缓存下来，可以在外面包一个 keep-alive 组件 ~</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20220613022957478" originSrc="images/image-20220613022957478.png" data="aurora"></p>\n<p><code>src/views/Layout.vue</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>h5-wrapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">></span></span><span class="token plain-text">\n        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tabbar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/article<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">面经</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/collect<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">收藏</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/like<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">喜欢</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我的</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="keep-alive对应的两个钩子" tabindex="-1"><a class="header-anchor" href="#keep-alive对应的两个钩子" aria-hidden="true">#</a> keep-alive对应的两个钩子</h3>\n<p>当组件被keep-alive管理时，会多出两个生命周期钩子，activated  /  deactivated</p>\n<p><code>src/views/Article.vue</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'ArticlePage\'</span><span class="token punctuation">,</span>\n  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">articles</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">async</span> <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">await</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>\n      <span class="token string">\'https://mock.boxuegu.com/mock/3083/articles\'</span><span class="token punctuation">,</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>articles <span class="token operator">=</span> data<span class="token punctuation">.</span>result<span class="token punctuation">.</span>rows<span class="token punctuation">;</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>articles<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">activated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'缓存组件被激活\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">deactivated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'缓存组件被隐藏\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/生命周期+路由+组件缓存.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"生命周期+路由+组件缓存",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/生命周期+路由+组件缓存.md",filePathRelative:"Vue/生命周期+路由+组件缓存.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/生命周期+路由+组件缓存.html.vue",componentFilePathRelative:"pages/Vue/生命周期+路由+组件缓存.html.vue",componentFileChunkName:"v-a25da32e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/生命周期+路由+组件缓存.html.js",dataFilePathRelative:"pages/Vue/生命周期+路由+组件缓存.html.js",dataFileChunkName:"v-a25da32e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/生命周期+路由+组件缓存.html",htmlFilePathRelative:"Vue/生命周期+路由+组件缓存.html"},{data:{key:"v-1054ac98",path:"/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",title:"组件化开发",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"什么是组件化开发",slug:"什么是组件化开发",children:[]},{level:2,title:"组件的注册",slug:"组件的注册",children:[{level:3,title:"局部注册",slug:"局部注册",children:[]}]},{level:2,title:"全局注册组件",slug:"全局注册组件",children:[{level:3,title:"组件名的大小写",slug:"组件名的大小写",children:[]},{level:3,title:"通过 name 注册组件 (了解)",slug:"通过-name-注册组件-了解",children:[]}]},{level:2,title:"组件的样式冲突  scoped",slug:"组件的样式冲突-scoped",children:[]},{level:2,title:"组件通信 - 父传子 props 传值",slug:"组件通信-父传子-props-传值",children:[]},{level:2,title:"v-for 遍历展示组件练习",slug:"v-for-遍历展示组件练习",children:[]},{level:2,title:"单向数据流",slug:"单向数据流",children:[]},{level:2,title:"组件通信 - 子传父",slug:"组件通信-子传父",children:[]},{level:2,title:"props 校验",slug:"props-校验",children:[]}],git:{}},key:"v-1054ac98",path:"/Vue/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80+%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",title:"组件化开发",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"什么是组件化开发",slug:"什么是组件化开发",children:[]},{level:2,title:"组件的注册",slug:"组件的注册",children:[{level:3,title:"局部注册",slug:"局部注册",children:[]}]},{level:2,title:"全局注册组件",slug:"全局注册组件",children:[{level:3,title:"组件名的大小写",slug:"组件名的大小写",children:[]},{level:3,title:"通过 name 注册组件 (了解)",slug:"通过-name-注册组件-了解",children:[]}]},{level:2,title:"组件的样式冲突  scoped",slug:"组件的样式冲突-scoped",children:[]},{level:2,title:"组件通信 - 父传子 props 传值",slug:"组件通信-父传子-props-传值",children:[]},{level:2,title:"v-for 遍历展示组件练习",slug:"v-for-遍历展示组件练习",children:[]},{level:2,title:"单向数据流",slug:"单向数据流",children:[]},{level:2,title:"组件通信 - 子传父",slug:"组件通信-子传父",children:[]},{level:2,title:"props 校验",slug:"props-校验",children:[]}],content:"# 组件化开发\n\n## 什么是组件化开发\n\n**组件化开发** 指的是：根据封装的思想，把页面上 `可重用的部分` 封装为 `组件`，从而方便项目的 开发 和 维护。\n\n**一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为**\n\n例如：http://www.ibootstrap.cn/ 所展示的效果，就契合了组件化开发的思想。\n\n用户可以通过拖拽组件的方式，快速生成一个页面的布局结构。\n\n\n\n前端组件化开发的好处主要体现在以下两方面：\n\n- 提高了前端代码的**复用性和灵活性**  \n\n- 提升了开发效率和后期的**可维护性**\n\n\nvue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 `.vue`。\n\n## 组件的注册\n\n刚才我们创建使用的是 App.vue 根组件, 这个比较特殊, 是最大的一个根组件\n\n而App.vue根组件内, 还可以写入一些小组件, 而这些组件, 要使用, 就需要先注册!\n\n**注册组件有两种注册方式**:  分为“全局注册”和“局部注册”两种\n\n- 被全局注册的组件，可以在任意的组件模板范围中使用 通过`Vue.component()`\n- 被局部注册的组件，只能在当前注册的组件模板范围内使用 通过`components`\n\n### 局部注册\n\n+ 把独立的组件封装一个`.vue文件中`，推荐放到`components`文件夹\n\n```jsx\ncomponents\n  -- HmHeader.vue\n  -- HmContent.vue\n  -- HmFooter.vue\n```\n\n+ 通过组件的`components`配置 局部注册组件\n\n```jsx\nimport HmHeader from './components/HmHeader'\nimport HmContent from './components/HmContent'\nimport HmFooter from './components/HmFooter'\n\nexport default {\n  // data methods filters computed watch\n  components: {\n    // 组件名: 组件\n    // 组件名：注意，不能和html内置的标签重名\n    // 使用的时候：直接通过组件名去使用\n    // HmHeader  HmHeader  hm-header\n    HmHeader,\n    HmContent,\n    HmFooter\n  }\n}\n```\n\n==注意点：注册的组件的名字不能和HTML内置的标签重名==\n\n+ 可以在模板中使用组件，，，，使用组件和使用html的标签是一样的，，，可以多次使用\n\n```jsx\n<template>\n  <div>\n    \x3c!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    <hm-header></hm-header>\n    <hm-content></hm-content>\n    <hm-footer></hm-footer>\n  </div>\n</template>\n```\n\n==局部注册的组件只能在当前组件中使用==\n\n## 全局注册组件\n\n+ 在`components`文件夹中创建一些新的组件\n\n```jsx\ncomponents\n  -- HmHeader.vue\n  -- HmContent.vue\n  -- HmFooter.vue\n```\n\n+ 在`main.js`中通过`Vue.component()`全局注册组件\n\n```jsx\nimport HmHeader from './components/HmHeader'\nimport HmContent from './components/HmContent'\nimport HmFooter from './components/HmFooter'\n\n// 全局注册\n// Vue.component(名字, 组件)\nVue.component('HmHeader', HmHeader)\nVue.component('HmContent', HmContent)\nVue.component('HmFooter', HmFooter)\n```\n\n+ 使用\n\n```jsx\n<template>\n  <div>\n    \x3c!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    <hm-header></hm-header>\n    <hm-content></hm-content>\n    <hm-footer></hm-footer>\n  </div>\n</template>\n```\n\n==注意：全局注册的组件 可以在任意的组件中去使用==\n\n\n\n### 组件名的大小写\n\n在进行组件的注册时，定义组件名的方式有两种：\n\n- 注册使用短横线命名法，例如 hm-header 和 hm-main\n\n  ```js\n  Vue.component('hm-button', HmButton)\n  ```\n\n  使用时 `<hm-button> </hm-button>`\n\n- 注册使用大驼峰命名法，例如 HmHeader 和 HmMain\n\n  ```jsx\n  Vue.component('HmButton', HmButton)\n  ```\n\n  使用时 `<HmButton> </HmButton>` 和 `<hm-button> </hm-button>`  都可以\n\n推荐定义组件名时, 用大驼峰命名法, 更加方便\n\n全局注册\n\n```jsx\nVue.component('HmButton', HmButton)\n```\n\n局部注册:\n\n```jsx\ncomponents: {\n  HmHeader,\n  HmMain,\n  HmFooter\n}\n```\n\n使用时, 推荐遵循html5规范, 小写横杠隔开\n\n```jsx\n<hm-header></hm-header>\n<hm-main></hm-main>\n<hm-footer></hm-footer>\n```\n\n### 通过 name 注册组件 (了解)\n\n> 组件在开发者工具中显示的名字可以通过name进行修改\n\n在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的 name 属性作为注册后组件的名称\n\n组件内容:\n\n```jsx\n<template>\n  <button>按钮组件</button>\n</template>\n\n<script>\nexport default {\n  name: 'HmButton'\n}\n<\/script>\n\n<style lang=\"less\">\nbutton {\n  width: 80px;\n  height: 50px;\n  border-radius: 5px;\n  background-color: pink;\n}\n</style>\n```\n\n进行注册:\n\n```jsx\nimport HmButton from './components/hm-button.vue'\nVue.component(HmButton.name, HmButton)  // 等价于 app.component('HmButton', HmButton)\n```\n\n## 组件的样式冲突  `scoped`\n\n默认情况下，写在组件中的样式会`全局生效`，因此很容易造成多个组件之间的样式冲突问题。\n\n组件样式默认会作用到全局, 就会影响到整个 index.html 中的 dom 元素\n\n- `全局样式`: 默认组件中的样式会作用到全局\n\n- `局部样式`: 可以给组件加上 scoped 属性, 可以让样式只作用于当前组件\n\n```jsx\n<style lang=\"less\" scoped>\ndiv {\n  background-color: pink;\n}\n</style>\n```\n\n原理:\n\n1. 添加scoped后, 会给当前组件中所有元素, 添加上一个自定义属性\n\n2. 添加scoped后,  每个style样式, 也会加上对应的属性选择器\n\n\n最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到\n\n# 组件通信\n\n每个组件都有自己的数据, 提供在data中, 每个组件的数据是独立的, 组件数据无法互相直接访问 (合理的)\n\n但是如果需要跨组件访问数据, 就需要用到组件通信\n\n组件通信的方式有很多: 现在先关注两种,  父传子  子传父\n\n## 组件通信 - 父传子 props 传值\n\n语法:\n\n1. 父组件通过给子组件加属性传值\n\n```jsx\n<Son price=\"100\" title=\"不错\" :info=\"msg\"></Son>\n```\n\n2. 子组件中, 通过props属性接收\n\n```js\nprops: ['price', 'title', 'info']\n```\n\n**需求: 封装一个商品组件 my-product**\n\n`my-product.vue`\n\n```vue\n<template>\n  <div class=\"my-product\">\n    <h3>标题: {{ title }}</h3>\n    <p>价格: {{ price }}元</p>\n    <p>{{ info }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: ['title', 'price', 'info']\n}\n<\/script>\n\n<style>\n.my-product {\n  width: 400px;\n  padding: 20px;\n  border: 2px solid #000;\n  border-radius: 5px;\n  margin: 10px;\n}\n</style>\n```\n\n\n\n## v-for 遍历展示组件练习\n\n**需求: 遍历展示商品列表**\n\n假定, 发送请求回来的商品数据, \n\n```jsx\nlist: [\n  { id: 1, proname: '超级好吃的棒棒糖', proprice: 18.8 },\n  { id: 2, proname: '超级好吃的大鸡腿', proprice: 34.2 },\n  { id: 3, proname: '超级无敌的冰激凌', proprice: 14.2 }\n]\n```\n\nv-for 遍历展示\n\n```jsx\n<template>\n  <div class=\"container\">\n    <h3>我是app组件的内容</h3>\n    <my-product \n      v-for=\"item in list\" :key=\"item.id\" \n      :price=\"item.proprice\" \n      :title=\"item.proname\" \n      :info=\"msg\">\n    </my-product>\n  </div>\n</template>\n```\n\n## 单向数据流\n\n```jsx\n/* \n  在vue中需要遵循单向数据流原则\n  1. 父组件的数据发生了改变，子组件会自动跟着变\n  2. 子组件不能直接修改父组件传递过来的props  props是只读的\n*/\n```\n\n==如果父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，，，，也应该避免==\n\n## 组件通信 - 子传父\n\n**需求: 砍价**\n\n1. 子组件可以通过 `this.$emit('事件名', 参数1, 参数2, ...)` 触发事件的同时传参的\n\n   ```jsx\n   this.$emit('sayPrice', 2)\n   ```\n\n2. 父组件给子组件注册一个自定义事件\n\n   ```jsx\n   <my-product \n     ...\n     @sayPrice=\"sayPrice\">\n   </my-product>\n   ```\n\n   父组件并提供对应的函数接收参数\n\n   ```jsx\n   methods: {\n     sayPrice (num) {\n       console.log(num)\n     }\n   },\n   ```\n\n## props 校验\n\n**props 是父传子, 传递给子组件的数据, 为了提高 子组件被使用时 的稳定性, 可以进行props校验**, 验证传递的数据是否符合要求\n\n默认的数组形式, 不会进行校验, 如果希望校验, 需要提供对象形式的 props\n\n风格指南：https://cn.vuejs.org/v2/style-guide/#Prop-%E5%AE%9A%E4%B9%89%E5%BF%85%E8%A6%81\n\n```jsx\nprops: {\n\t...\n}\n```\n\nprops 提供了多种数据验证方案，例如：\n\n- 基础的类型检查  Number\n- 多个可能的类型 [String, Number]\n- 必填项校验   required: true\n- 默认值 default: 100\n- 自定义验证函数\n\n官网语法: [地址](https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81)\n\n```js\n{\n  props: {\n    // 基础的类型检查\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // -------------------------------------------------------------------------\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n}\n```\n\n\n",contentRendered:'<h1 id="组件化开发" tabindex="-1"><a class="header-anchor" href="#组件化开发" aria-hidden="true">#</a> 组件化开发</h1>\n<h2 id="什么是组件化开发" tabindex="-1"><a class="header-anchor" href="#什么是组件化开发" aria-hidden="true">#</a> 什么是组件化开发</h2>\n<p><strong>组件化开发</strong> 指的是：根据封装的思想，把页面上 <code>可重用的部分</code> 封装为 <code>组件</code>，从而方便项目的 开发 和 维护。</p>\n<p><strong>一个页面， 可以拆分成一个个组件，一个组件就是一个整体, 每个组件可以有自己独立的 结构 样式 和 行为</strong></p>\n<p>例如：http://www.ibootstrap.cn/ 所展示的效果，就契合了组件化开发的思想。</p>\n<p>用户可以通过拖拽组件的方式，快速生成一个页面的布局结构。</p>\n<p>前端组件化开发的好处主要体现在以下两方面：</p>\n<ul>\n<li>\n<p>提高了前端代码的<strong>复用性和灵活性</strong></p>\n</li>\n<li>\n<p>提升了开发效率和后期的<strong>可维护性</strong></p>\n</li>\n</ul>\n<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 <code>.vue</code>。</p>\n<h2 id="组件的注册" tabindex="-1"><a class="header-anchor" href="#组件的注册" aria-hidden="true">#</a> 组件的注册</h2>\n<p>刚才我们创建使用的是 App.vue 根组件, 这个比较特殊, 是最大的一个根组件</p>\n<p>而App.vue根组件内, 还可以写入一些小组件, 而这些组件, 要使用, 就需要先注册!</p>\n<p><strong>注册组件有两种注册方式</strong>:  分为“全局注册”和“局部注册”两种</p>\n<ul>\n<li>被全局注册的组件，可以在任意的组件模板范围中使用 通过<code>Vue.component()</code></li>\n<li>被局部注册的组件，只能在当前注册的组件模板范围内使用 通过<code>components</code></li>\n</ul>\n<h3 id="局部注册" tabindex="-1"><a class="header-anchor" href="#局部注册" aria-hidden="true">#</a> 局部注册</h3>\n<ul>\n<li>把独立的组件封装一个<code>.vue文件中</code>，推荐放到<code>components</code>文件夹</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>components\n  <span class="token operator">--</span> HmHeader<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmContent<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmFooter<span class="token punctuation">.</span>vue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>通过组件的<code>components</code>配置 局部注册组件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> HmHeader <span class="token keyword">from</span> <span class="token string">\'./components/HmHeader\'</span>\n<span class="token keyword">import</span> HmContent <span class="token keyword">from</span> <span class="token string">\'./components/HmContent\'</span>\n<span class="token keyword">import</span> HmFooter <span class="token keyword">from</span> <span class="token string">\'./components/HmFooter\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// data methods filters computed watch</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 组件名: 组件</span>\n    <span class="token comment">// 组件名：注意，不能和html内置的标签重名</span>\n    <span class="token comment">// 使用的时候：直接通过组件名去使用</span>\n    <span class="token comment">// HmHeader  HmHeader  hm-header</span>\n    HmHeader<span class="token punctuation">,</span>\n    HmContent<span class="token punctuation">,</span>\n    HmFooter\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>==注意点：注册的组件的名字不能和HTML内置的标签重名==</p>\n<ul>\n<li>可以在模板中使用组件，，，，使用组件和使用html的标签是一样的，，，可以多次使用</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-header</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-content</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-footer</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>==局部注册的组件只能在当前组件中使用==</p>\n<h2 id="全局注册组件" tabindex="-1"><a class="header-anchor" href="#全局注册组件" aria-hidden="true">#</a> 全局注册组件</h2>\n<ul>\n<li>在<code>components</code>文件夹中创建一些新的组件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>components\n  <span class="token operator">--</span> HmHeader<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmContent<span class="token punctuation">.</span>vue\n  <span class="token operator">--</span> HmFooter<span class="token punctuation">.</span>vue\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul>\n<li>在<code>main.js</code>中通过<code>Vue.component()</code>全局注册组件</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> HmHeader <span class="token keyword">from</span> <span class="token string">\'./components/HmHeader\'</span>\n<span class="token keyword">import</span> HmContent <span class="token keyword">from</span> <span class="token string">\'./components/HmContent\'</span>\n<span class="token keyword">import</span> HmFooter <span class="token keyword">from</span> <span class="token string">\'./components/HmFooter\'</span>\n\n<span class="token comment">// 全局注册</span>\n<span class="token comment">// Vue.component(名字, 组件)</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmHeader\'</span><span class="token punctuation">,</span> HmHeader<span class="token punctuation">)</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmContent\'</span><span class="token punctuation">,</span> HmContent<span class="token punctuation">)</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmFooter\'</span><span class="token punctuation">,</span> HmFooter<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul>\n<li>使用</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;!-- 组件注册好了，就跟使用html标签一样了 --\x3e\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-header</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-content</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-footer</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>==注意：全局注册的组件 可以在任意的组件中去使用==</p>\n<h3 id="组件名的大小写" tabindex="-1"><a class="header-anchor" href="#组件名的大小写" aria-hidden="true">#</a> 组件名的大小写</h3>\n<p>在进行组件的注册时，定义组件名的方式有两种：</p>\n<ul>\n<li>\n<p>注册使用短横线命名法，例如 hm-header 和 hm-main</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'hm-button\'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>使用时 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code></p>\n</li>\n<li>\n<p>注册使用大驼峰命名法，例如 HmHeader 和 HmMain</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmButton\'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>使用时 <code>&lt;HmButton&gt; &lt;/HmButton&gt;</code> 和 <code>&lt;hm-button&gt; &lt;/hm-button&gt;</code>  都可以</p>\n</li>\n</ul>\n<p>推荐定义组件名时, 用大驼峰命名法, 更加方便</p>\n<p>全局注册</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">\'HmButton\'</span><span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>局部注册:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  HmHeader<span class="token punctuation">,</span>\n  HmMain<span class="token punctuation">,</span>\n  HmFooter\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>使用时, 推荐遵循html5规范, 小写横杠隔开</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-header</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-header</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-main</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hm-footer</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>hm-footer</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="通过-name-注册组件-了解" tabindex="-1"><a class="header-anchor" href="#通过-name-注册组件-了解" aria-hidden="true">#</a> 通过 name 注册组件 (了解)</h3>\n<blockquote>\n<p>组件在开发者工具中显示的名字可以通过name进行修改</p>\n</blockquote>\n<p>在注册组件期间，除了可以直接提供组件的注册名称之外，还可以把组件的 name 属性作为注册后组件的名称</p>\n<p>组件内容:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">按钮组件</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token plain-text">\nexport default {\n  name: \'HmButton\'\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>less<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\nbutton {\n  width: 80px;\n  height: 50px;\n  border-radius: 5px;\n  background-color: pink;\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>进行注册:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> HmButton <span class="token keyword">from</span> <span class="token string">\'./components/hm-button.vue\'</span>\nVue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span>HmButton<span class="token punctuation">.</span>name<span class="token punctuation">,</span> HmButton<span class="token punctuation">)</span>  <span class="token comment">// 等价于 app.component(\'HmButton\', HmButton)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="组件的样式冲突-scoped" tabindex="-1"><a class="header-anchor" href="#组件的样式冲突-scoped" aria-hidden="true">#</a> 组件的样式冲突  <code>scoped</code></h2>\n<p>默认情况下，写在组件中的样式会<code>全局生效</code>，因此很容易造成多个组件之间的样式冲突问题。</p>\n<p>组件样式默认会作用到全局, 就会影响到整个 index.html 中的 dom 元素</p>\n<ul>\n<li>\n<p><code>全局样式</code>: 默认组件中的样式会作用到全局</p>\n</li>\n<li>\n<p><code>局部样式</code>: 可以给组件加上 scoped 属性, 可以让样式只作用于当前组件</p>\n</li>\n</ul>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>less<span class="token punctuation">"</span></span> <span class="token attr-name">scoped</span><span class="token punctuation">></span></span><span class="token plain-text">\ndiv {\n  background-color: pink;\n}\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>原理:</p>\n<ol>\n<li>\n<p>添加scoped后, 会给当前组件中所有元素, 添加上一个自定义属性</p>\n</li>\n<li>\n<p>添加scoped后,  每个style样式, 也会加上对应的属性选择器</p>\n</li>\n</ol>\n<p>最终效果: 必须是当前组件的元素, 才会有这个自定义属性, 才会被这个样式作用到</p>\n<h1 id="组件通信" tabindex="-1"><a class="header-anchor" href="#组件通信" aria-hidden="true">#</a> 组件通信</h1>\n<p>每个组件都有自己的数据, 提供在data中, 每个组件的数据是独立的, 组件数据无法互相直接访问 (合理的)</p>\n<p>但是如果需要跨组件访问数据, 就需要用到组件通信</p>\n<p>组件通信的方式有很多: 现在先关注两种,  父传子  子传父</p>\n<h2 id="组件通信-父传子-props-传值" tabindex="-1"><a class="header-anchor" href="#组件通信-父传子-props-传值" aria-hidden="true">#</a> 组件通信 - 父传子 props 传值</h2>\n<p>语法:</p>\n<ol>\n<li>父组件通过给子组件加属性传值</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Son</span></span> <span class="token attr-name">price</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>不错<span class="token punctuation">"</span></span> <span class="token attr-name">:info</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Son</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2">\n<li>子组件中, 通过props属性接收</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'price\'</span><span class="token punctuation">,</span> <span class="token string">\'title\'</span><span class="token punctuation">,</span> <span class="token string">\'info\'</span><span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>需求: 封装一个商品组件 my-product</strong></p>\n<p><code>my-product.vue</code></p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my-product<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>标题: {{ title }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>价格: {{ price }}元<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{ info }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'title\'</span><span class="token punctuation">,</span> <span class="token string">\'price\'</span><span class="token punctuation">,</span> <span class="token string">\'info\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n<span class="token selector">.my-product</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 2px solid #000<span class="token punctuation">;</span>\n  <span class="token property">border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="v-for-遍历展示组件练习" tabindex="-1"><a class="header-anchor" href="#v-for-遍历展示组件练习" aria-hidden="true">#</a> v-for 遍历展示组件练习</h2>\n<p><strong>需求: 遍历展示商品列表</strong></p>\n<p>假定, 发送请求回来的商品数据,</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">list</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">proname</span><span class="token operator">:</span> <span class="token string">\'超级好吃的棒棒糖\'</span><span class="token punctuation">,</span> <span class="token literal-property property">proprice</span><span class="token operator">:</span> <span class="token number">18.8</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">proname</span><span class="token operator">:</span> <span class="token string">\'超级好吃的大鸡腿\'</span><span class="token punctuation">,</span> <span class="token literal-property property">proprice</span><span class="token operator">:</span> <span class="token number">34.2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">proname</span><span class="token operator">:</span> <span class="token string">\'超级无敌的冰激凌\'</span><span class="token punctuation">,</span> <span class="token literal-property property">proprice</span><span class="token operator">:</span> <span class="token number">14.2</span> <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>v-for 遍历展示</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">我是app组件的内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-product</span> \n      <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item in list<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span> \n      <span class="token attr-name">:price</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.proprice<span class="token punctuation">"</span></span> \n      <span class="token attr-name">:title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.proname<span class="token punctuation">"</span></span> \n      <span class="token attr-name">:info</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-product</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="单向数据流" tabindex="-1"><a class="header-anchor" href="#单向数据流" aria-hidden="true">#</a> 单向数据流</h2>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">/* \n  在vue中需要遵循单向数据流原则\n  1. 父组件的数据发生了改变，子组件会自动跟着变\n  2. 子组件不能直接修改父组件传递过来的props  props是只读的\n*/</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>==如果父组件传给子组件的是一个对象，子组件修改对象的属性，是不会报错的，，，，也应该避免==</p>\n<h2 id="组件通信-子传父" tabindex="-1"><a class="header-anchor" href="#组件通信-子传父" aria-hidden="true">#</a> 组件通信 - 子传父</h2>\n<p><strong>需求: 砍价</strong></p>\n<ol>\n<li>\n<p>子组件可以通过 <code>this.$emit(\'事件名\', 参数1, 参数2, ...)</code> 触发事件的同时传参的</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">\'sayPrice\'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li>\n<li>\n<p>父组件给子组件注册一个自定义事件</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>my<span class="token operator">-</span>product \n  <span class="token operator">...</span>\n  @sayPrice<span class="token operator">=</span><span class="token string">"sayPrice"</span><span class="token operator">></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-product</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>父组件并提供对应的函数接收参数</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">sayPrice</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li>\n</ol>\n<h2 id="props-校验" tabindex="-1"><a class="header-anchor" href="#props-校验" aria-hidden="true">#</a> props 校验</h2>\n<p><strong>props 是父传子, 传递给子组件的数据, 为了提高 子组件被使用时 的稳定性, 可以进行props校验</strong>, 验证传递的数据是否符合要求</p>\n<p>默认的数组形式, 不会进行校验, 如果希望校验, 需要提供对象形式的 props</p>\n<p>风格指南：https://cn.vuejs.org/v2/style-guide/#Prop-%E5%AE%9A%E4%B9%89%E5%BF%85%E8%A6%81</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n\t<span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>props 提供了多种数据验证方案，例如：</p>\n<ul>\n<li>基础的类型检查  Number</li>\n<li>多个可能的类型 [String, Number]</li>\n<li>必填项校验   required: true</li>\n<li>默认值 default: 100</li>\n<li>自定义验证函数</li>\n</ul>\n<p>官网语法: <a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener noreferrer">地址<ExternalLinkIcon/></a></p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span>\n  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 基础的类型检查</span>\n    <span class="token literal-property property">propA</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>\n    <span class="token comment">// 多个可能的类型</span>\n    <span class="token literal-property property">propB</span><span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token comment">// 必填的字符串</span>\n    <span class="token literal-property property">propC</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">type</span><span class="token operator">:</span> String<span class="token punctuation">,</span>\n      <span class="token literal-property property">required</span><span class="token operator">:</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// 带有默认值的数字</span>\n    <span class="token literal-property property">propD</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">type</span><span class="token operator">:</span> Number<span class="token punctuation">,</span>\n      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">100</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// -------------------------------------------------------------------------</span>\n    <span class="token comment">// 自定义验证函数</span>\n    <span class="token literal-property property">propF</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n      <span class="token function-variable function">validator</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 这个值必须匹配下列字符串中的一个</span>\n        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">\'success\'</span><span class="token punctuation">,</span> <span class="token string">\'warning\'</span><span class="token punctuation">,</span> <span class="token string">\'danger\'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/组件基础+组件通讯.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"组件基础+组件通讯",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/组件基础+组件通讯.md",filePathRelative:"Vue/组件基础+组件通讯.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件基础+组件通讯.html.vue",componentFilePathRelative:"pages/Vue/组件基础+组件通讯.html.vue",componentFileChunkName:"v-1054ac98",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件基础+组件通讯.html.js",dataFilePathRelative:"pages/Vue/组件基础+组件通讯.html.js",dataFileChunkName:"v-1054ac98",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/组件基础+组件通讯.html",htmlFilePathRelative:"Vue/组件基础+组件通讯.html"},{data:{key:"v-1e97db11",path:"/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.html",title:"v-model",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-model 语法糖",slug:"v-model-语法糖",children:[]},{level:2,title:"v-model给组件使用",slug:"v-model给组件使用",children:[]},{level:2,title:"动态组件的基本使用",slug:"动态组件的基本使用",children:[]},{level:2,title:"自定义指令说明",slug:"自定义指令说明",children:[]},{level:2,title:"自定义指令 - 局部注册",slug:"自定义指令-局部注册",children:[]},{level:2,title:"自定义指令 - 全局注册",slug:"自定义指令-全局注册",children:[]},{level:2,title:"自定义指令 - 指令的值",slug:"自定义指令-指令的值",children:[]},{level:2,title:"默认插槽 slot",slug:"默认插槽-slot",children:[]},{level:2,title:"后备内容 (默认值)",slug:"后备内容-默认值",children:[]},{level:2,title:"具名插槽",slug:"具名插槽",children:[{level:3,title:"插槽的分类:",slug:"插槽的分类",children:[]},{level:3,title:"具名插槽的使用步骤",slug:"具名插槽的使用步骤",children:[]},{level:3,title:"具名插槽的简写",slug:"具名插槽的简写",children:[]}]},{level:2,title:"作用域插槽",slug:"作用域插槽",children:[]}],git:{}},key:"v-1e97db11",path:"/Vue/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6.html",title:"v-model",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"v-model 语法糖",slug:"v-model-语法糖",children:[]},{level:2,title:"v-model给组件使用",slug:"v-model给组件使用",children:[]},{level:2,title:"动态组件的基本使用",slug:"动态组件的基本使用",children:[]},{level:2,title:"自定义指令说明",slug:"自定义指令说明",children:[]},{level:2,title:"自定义指令 - 局部注册",slug:"自定义指令-局部注册",children:[]},{level:2,title:"自定义指令 - 全局注册",slug:"自定义指令-全局注册",children:[]},{level:2,title:"自定义指令 - 指令的值",slug:"自定义指令-指令的值",children:[]},{level:2,title:"默认插槽 slot",slug:"默认插槽-slot",children:[]},{level:2,title:"后备内容 (默认值)",slug:"后备内容-默认值",children:[]},{level:2,title:"具名插槽",slug:"具名插槽",children:[{level:3,title:"插槽的分类:",slug:"插槽的分类",children:[]},{level:3,title:"具名插槽的使用步骤",slug:"具名插槽的使用步骤",children:[]},{level:3,title:"具名插槽的简写",slug:"具名插槽的简写",children:[]}]},{level:2,title:"作用域插槽",slug:"作用域插槽",children:[]}],content:'# v-model\r\n\r\n## v-model 语法糖\r\n\r\n语法糖：v-model本质上是 value属性和input事件的一层包装\r\n\r\n  v-model的作用：提供数据的双向绑定\r\n\r\n- 数据发生了改变，页面会自动变  v-bind:value\r\n- 页面输入改变 ，   数据会自动变化  v-on:input\r\n\r\nv-model是语法糖， v-model等价于 给一个input框提供了 :value属性以及 @input事件\r\n\r\n很显然如果每次使用input框，都需要提供value和input事件，比较麻烦，所以使用v-model\r\n\r\n```jsx\r\n<template>\r\n  <div>\r\n    <input type="text" v-model="msg">\r\n    <input type="text" :value="msg" @input="msg = $event.target.value">\r\n\r\n    <input type="text" :value="car" @input="car = $event.target.value">\r\n    <input type="text" v-model="car">\r\n  </div>\r\n</template>\r\n```\r\n\r\n\r\n\r\n## v-model给组件使用\r\n\r\n我们经常遇到一种场景： \r\n\r\n1. 父组件提供一个数据给子组件使用（父传子）\r\n2. 子组件又需要修改父组件传过来的这个数据，所以需要子传父把值传给父组件。\r\n\r\n 这种场景可以使用v-model进行简写。\r\n\r\n+ 定义组件的时候，注意接收的值叫value， 子传父触发的事件叫 input\r\n\r\n\r\n+ 父传子给子组件传递value属性和input事件\r\n\r\n# ref 和 $refs \r\n\r\n利用 ref 和 $refs 可以用于获取 dom 元素, 或者组件实例\r\n\r\n每个 vue 的组件实例上，都包含一个$refs 对象，里面存储着对应的DOM 元素或组件的引用。\r\n\r\n1 给需要获取的 dom 元素或者组件, 添加 ref 属性\r\n\r\n```jsx\r\n<div>\r\n  <div ref="box">我是div盒子</div>\r\n  <jack ref="jack"></jack>\r\n  <button @click="fn">按钮</button>\r\n</div>\r\n```\r\n\r\n2 通过 `this.$refs.xxx` 获取, 拿到组件可以调用组件的方法\r\n\r\n```jsx\r\nimport Jack from \'./jack.vue\'\r\nexport default {\r\n  methods: {\r\n    fn () {\r\n      console.log(this.$refs.box)\r\n      console.log(this.$refs.jack)\r\n      this.$refs.jack.sayHi()\r\n    }\r\n  },\r\n  components: {\r\n    Jack\r\n  }\r\n}\r\n```\r\n\r\n# $nextTick\r\n\r\n**需求1: 点击按钮, 切换显示输入框**\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    \x3c!-- 需求: 点击按钮, 切换显示输入框 --\x3e\r\n    <input type="text" v-if="isShowInput">\r\n    <button @click="fn" v-else>点此搜索</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      isShowInput: false\r\n    }\r\n  },\r\n  methods: {\r\n    fn () {\r\n      this.isShowInput = true\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n**需求2: 显示输入框的同时, 要获取焦点**\r\n\r\n当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。\r\n\r\n直接调用会报错, 因为 vue 是 异步dom更新的 (提升渲染效率),  `this.isShowInput = true` 执行完时, 实际的 dom 还没渲染出来\r\n\r\n```jsx\r\n<input ref="inp" type="text" v-if="isShowInput">\r\n\r\nfn () {\r\n  this.isShowInput = true\r\n  this.$refs.inp.focus()\r\n}\r\n```\r\n\r\n组件的 `$nextTick(callback)` 方法，会把 callback 回调推迟到下一个 DOM 更新周期之后执行。\r\n\r\n通俗的理解是：**等组件的DOM 刷新之后，再执行 callback 回调函数**。从而能保证 callback 函数可以操作到最新的 DOM 元素。\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    \x3c!-- 需求: 点击按钮, 切换显示输入框 --\x3e\r\n    <input ref="inp" type="text" v-if="isShowInput">\r\n    <button @click="fn" v-else>点此搜索</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data () {\r\n    return {\r\n      isShowInput: false\r\n    }\r\n  },\r\n  methods: {\r\n    fn () {\r\n      this.isShowInput = true\r\n      this.$nextTick(() => {\r\n        this.$refs.inp.focus()\r\n      })\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n# dynamic 动态组件\r\n\r\n## 动态组件的基本使用\r\n\r\n什么是动态组件:   让多个组件使用同一个挂载点，并动态切换，这就是动态组件 \r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    <h3>动态组件的演示</h3>\r\n    \x3c!-- 动态组件 => 多个组件使用同一个挂载点, 并可以动态的切换展示 --\x3e\r\n    <button @click="comName = \'my-swiper\'">swiper</button>\r\n    <button @click="comName = \'my-nav\'">nav</button>\r\n    \r\n    \x3c!-- \r\n      <my-nav></my-nav>\r\n      <my-swiper></my-swiper> \r\n    --\x3e\r\n    <component :is="comName"></component>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport MyNav from \'./my-nav.vue\'\r\nimport MySwiper from \'./my-swiper.vue\'\r\nexport default {\r\n  data () {\r\n    return {\r\n      comName: \'my-nav\'\r\n    }\r\n  },\r\n  components: {\r\n    MyNav,\r\n    MySwiper\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n# 自定义指令\r\n\r\n## 自定义指令说明\r\n\r\nhttps://www.vue3js.cn/docs/zh/guide/custom-directive.html\r\n\r\n除了核心功能默认内置的指令 (`v-model` 和 `v-show`)，Vue 也允许注册自定义指令。 `v-xxx`  \r\n\r\n注意，代码复用和抽象的主要形式是组件。\r\n\r\n然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。\r\n\r\n## 自定义指令 - 局部注册\r\n\r\n例如需求:  当页面加载时，让元素将获得焦点 , (autofocus 在 safari 浏览器有兼容性)\r\n\r\n```less\r\n<template>\r\n  <div>\r\n    <h3>自定义指令</h3>\r\n    <input ref="inp" type="text" v-focus>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  directives: {\r\n    // 自定义一个局部指令\r\n    focus: {\r\n      inserted (el) {\r\n        el.focus()\r\n      }\r\n    }\r\n  }\r\n}\r\n<\/script>\r\n```\r\n\r\n## 自定义指令 - 全局注册\r\n\r\n```jsx\r\n// 注册全局自定义指令\r\nVue.directive(\'focus\', {\r\n  inserted (el) {\r\n    el.focus()\r\n  }\r\n})\r\n```\r\n\r\n## 自定义指令 - 指令的值\r\n\r\n在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值\r\n\r\n需求: v-color="color" 给对应的颜色, 就能改对应的字体颜色\r\n\r\n```jsx\r\n<div v-color="color">我是内容</div>\r\n```\r\n\r\n实现:\r\n\r\n```jsx\r\ndirectives: {\r\n  // 自定义一个局部指令\r\n  color: {\r\n    // 指令所在的元素渲染的时候\r\n    inserted (el, {value}) {\r\n      el.style.color = value\r\n    },\r\n    // update指令的值改变时触发, binding.value指令的值修改触发\r\n    update (el, binding) {\r\n      el.style.color = binding.value\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n# 插槽\r\n\r\n插槽（Slot）是 vue 为组件的封装者提供的能力。\r\n\r\n允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。\r\n\r\n## 默认插槽 slot\r\n\r\n**需求: 要在页面中显示一个对话框, 封装成一个组件**\r\n\r\n通过父传子, 固然可以完成一定层面的组件的定制, 但是自定义性较差, \r\n\r\n如果希望能够自定义组件内部的一些结构 => 就需要用到插槽\r\n\r\n\r\n\r\n**插槽作用: 用于实现组件的内容分发, 通过 slot 标签, 可以接收到写在组件标签内的内容**\r\n\r\n插槽：slot  作用：占位置\r\n\r\n基本示例:\r\n\r\n```jsx\r\n<my-dialog>\r\n  <p>请输入正确的手机号码</p>\r\n</my-dialog>\r\n```\r\n\r\n`my-dialog.vue`\r\n\r\n```less\r\n<template>\r\n  <div class="my-dialog">\r\n    <div class="header">\r\n      <h3>友情提示</h3>\r\n    </div>\r\n    <div class="content">\r\n      <slot></slot>\r\n    </div>\r\n    <div class="footer">\r\n      <button>关闭</button>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n\r\n}\r\n<\/script>\r\n\r\n<style lang="less" scoped>\r\n.my-dialog {\r\n  width: 400px;\r\n  padding: 10px 20px;\r\n  border: 3px solid #000;\r\n  border-radius: 5px;\r\n  margin: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n\r\n## 后备内容 (默认值)\r\n\r\n封装组件时，可以为预留的 `<slot>` 插槽提供后备内容（默认内容）。\r\n\r\n如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。\r\n\r\n```jsx\r\n<template>\r\n  <div class="my-dialog">\r\n    <div class="header">\r\n      <h3>友情提示</h3>\r\n    </div>\r\n    <div class="content">\r\n      <slot>这是后备内容</slot>\r\n    </div>\r\n    <div class="footer">\r\n      <button>关闭</button>\r\n    </div>\r\n  </div>\r\n</template>\r\n```\r\n\r\n\r\n\r\n## 具名插槽\r\n\r\n### 插槽的分类:\r\n\r\n**1 默认插槽(匿名插槽)**\r\n\r\n`<slot></slot>` 只要没有具体分发的内容, 都会给到默认插槽\r\n\r\n`<slot name="default"></slot>` 是默认插槽完整的写法 和 `<slot></slot>` 完全等价\r\n\r\n**2 具名插槽: 具有名字的插槽 (配置了名字),  可以实现定向分发**\r\n\r\n一旦配置了名字, 只会接收对应的内容, 不是分发给他的, 就不要\r\n\r\n\r\n\r\n### 具名插槽的使用步骤\r\n\r\n(1) 给插槽起名字 \r\n\r\n```jsx\r\n<div class="header">\r\n  <slot name="header"></slot>\r\n</div>\r\n<div class="content">\r\n  <slot>这是后备内容</slot>\r\n</div>\r\n<div class="footer">\r\n  <slot name="footer"></slot>\r\n</div>\r\n```\r\n\r\n(2) 需要使用 template 标签, 将内容包裹成一个整体\r\n\r\n(3) 通过 v-slot:插槽名, 指定具体分发给谁\r\n\r\n```html\r\n<my-dialog>\r\n  <template v-slot:header>\r\n    <h3>这是大标题</h3>\r\n  </template>\r\n\r\n  <template v-slot:default>\r\n    <p>这是内容</p>\r\n  </template>\r\n\r\n  <template v-slot:footer>\r\n    <button>确认</button>\r\n    <button>取消</button>\r\n  </template>\r\n</my-dialog>\r\n```\r\n\r\n\r\n\r\n### 具名插槽的简写\r\n\r\n跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。\r\n\r\n例如 v-slot:header 可以被简写为 #header\r\n\r\n```jsx\r\n<my-dialog>\r\n  <template #header>\r\n    <h3>这是大标题</h3>\r\n  </template>\r\n\r\n  <template #default>\r\n    <p>这是内容</p>\r\n  </template>\r\n\r\n  <template #footer>\r\n    <button>确认</button>\r\n    <button>取消</button>\r\n  </template>\r\n</my-dialog>\r\n```\r\n\r\n\r\n\r\n## 作用域插槽\r\n\r\n作用域插槽: **定义 slot 插槽的同时, 是可以传值的**, 将来在分发内容时, 可以使用\r\n\r\n1. 给 slot 标签, 以 添加属性的方式传值\r\n\r\n```jsx\r\n<slot name="bottom" :yes="yes" :no="no" money="100"></slot>\r\n```\r\n\r\n2. 所有添加的属性, 都会被收集到一个对象中\r\n\r\n```js\r\n{ yes: \'确认\', no: \'取消\', money: \'100\' }\r\n```\r\n\r\n3. 在template中, 通过  `v-slot:插槽名= "obj"` 接收\r\n\r\n```jsx\r\n<template #bottom="obj">\r\n  \x3c!-- {{ obj }} --\x3e\r\n  <button>{{ obj.yes }}</button>\r\n  <button>{{ obj.no }}</button>\r\n  <button>{{ obj.money }}</button>\r\n</template>\r\n```\r\n\r\n4. 可以使用解构赋值简化数据的接收\r\n\r\n```jsx\r\n<template #bottom="{ yes, no, money }">\r\n  <button>{{ yes }}</button>\r\n  <button>{{ no }}</button>\r\n  <button>{{ money }}</button>\r\n</template>\r\n```\r\n',contentRendered:'<h1 id="v-model" tabindex="-1"><a class="header-anchor" href="#v-model" aria-hidden="true">#</a> v-model</h1>\n<h2 id="v-model-语法糖" tabindex="-1"><a class="header-anchor" href="#v-model-语法糖" aria-hidden="true">#</a> v-model 语法糖</h2>\n<p>语法糖：v-model本质上是 value属性和input事件的一层包装</p>\n<p>v-model的作用：提供数据的双向绑定</p>\n<ul>\n<li>数据发生了改变，页面会自动变  v-bind:value</li>\n<li>页面输入改变 ，   数据会自动变化  v-on:input</li>\n</ul>\n<p>v-model是语法糖， v-model等价于 给一个input框提供了 :value属性以及 @input事件</p>\n<p>很显然如果每次使用input框，都需要提供value和input事件，比较麻烦，所以使用v-model</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>msg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;input type="text" :value="msg" @input="msg = $event.target.value">\n\n    &lt;input type="text" :value="car" @input="car = $event.target.value">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>car<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="v-model给组件使用" tabindex="-1"><a class="header-anchor" href="#v-model给组件使用" aria-hidden="true">#</a> v-model给组件使用</h2>\n<p>我们经常遇到一种场景：</p>\n<ol>\n<li>父组件提供一个数据给子组件使用（父传子）</li>\n<li>子组件又需要修改父组件传过来的这个数据，所以需要子传父把值传给父组件。</li>\n</ol>\n<p>这种场景可以使用v-model进行简写。</p>\n<ul>\n<li>\n<p>定义组件的时候，注意接收的值叫value， 子传父触发的事件叫 input</p>\n</li>\n<li>\n<p>父传子给子组件传递value属性和input事件</p>\n</li>\n</ul>\n<h1 id="ref-和-refs" tabindex="-1"><a class="header-anchor" href="#ref-和-refs" aria-hidden="true">#</a> ref 和 $refs</h1>\n<p>利用 ref 和 $refs 可以用于获取 dom 元素, 或者组件实例</p>\n<p>每个 vue 的组件实例上，都包含一个$refs 对象，里面存储着对应的DOM 元素或组件的引用。</p>\n<p>1 给需要获取的 dom 元素或者组件, 添加 ref 属性</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我是div盒子</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jack</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jack<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jack</span><span class="token punctuation">></span></span><span class="token plain-text">\n  &lt;button @click="fn">按钮</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>2 通过 <code>this.$refs.xxx</code> 获取, 拿到组件可以调用组件的方法</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">import</span> Jack <span class="token keyword">from</span> <span class="token string">\'./jack.vue\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>box<span class="token punctuation">)</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>jack<span class="token punctuation">)</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>jack<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    Jack\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick" aria-hidden="true">#</a> $nextTick</h1>\n<p><strong>需求1: 点击按钮, 切换显示输入框</strong></p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 需求: 点击按钮, 切换显示输入框 --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowInput<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>点此搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">isShowInput</span><span class="token operator">:</span> <span class="token boolean">false</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>isShowInput <span class="token operator">=</span> <span class="token boolean">true</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>需求2: 显示输入框的同时, 要获取焦点</strong></p>\n<p>当文本框展示出来之后，如果希望它立即获得焦点，则可以为其添加 ref 引用，并调用原生 DOM 对象的.focus() 方法即可。</p>\n<p>直接调用会报错, 因为 vue 是 异步dom更新的 (提升渲染效率),  <code>this.isShowInput = true</code> 执行完时, 实际的 dom 还没渲染出来</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowInput<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n\nfn () </span><span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>isShowInput <span class="token operator">=</span> <span class="token boolean">true</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token plain-text">\n</span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>组件的 <code>$nextTick(callback)</code> 方法，会把 callback 回调推迟到下一个 DOM 更新周期之后执行。</p>\n<p>通俗的理解是：<strong>等组件的DOM 刷新之后，再执行 callback 回调函数</strong>。从而能保证 callback 函数可以操作到最新的 DOM 元素。</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 需求: 点击按钮, 切换显示输入框 --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>inp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>isShowInput<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fn<span class="token punctuation">"</span></span> <span class="token attr-name">v-else</span><span class="token punctuation">></span></span>点此搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">isShowInput</span><span class="token operator">:</span> <span class="token boolean">false</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>isShowInput <span class="token operator">=</span> <span class="token boolean">true</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>inp<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h1 id="dynamic-动态组件" tabindex="-1"><a class="header-anchor" href="#dynamic-动态组件" aria-hidden="true">#</a> dynamic 动态组件</h1>\n<h2 id="动态组件的基本使用" tabindex="-1"><a class="header-anchor" href="#动态组件的基本使用" aria-hidden="true">#</a> 动态组件的基本使用</h2>\n<p>什么是动态组件:   让多个组件使用同一个挂载点，并动态切换，这就是动态组件</p>\n<div class="language-vue ext-vue line-numbers-mode"><pre v-pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>动态组件的演示<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 动态组件 => 多个组件使用同一个挂载点, 并可以动态的切换展示 --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>comName = <span class="token punctuation">\'</span>my-swiper<span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>swiper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>comName = <span class="token punctuation">\'</span>my-nav<span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>nav<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n    \n    <span class="token comment">&lt;!-- \n      &lt;my-nav>&lt;/my-nav>\n      &lt;my-swiper>&lt;/my-swiper> \n    --\x3e</span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>comName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> MyNav <span class="token keyword">from</span> <span class="token string">\'./my-nav.vue\'</span>\n<span class="token keyword">import</span> MySwiper <span class="token keyword">from</span> <span class="token string">\'./my-swiper.vue\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token literal-property property">comName</span><span class="token operator">:</span> <span class="token string">\'my-nav\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    MyNav<span class="token punctuation">,</span>\n    MySwiper\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h1 id="自定义指令" tabindex="-1"><a class="header-anchor" href="#自定义指令" aria-hidden="true">#</a> 自定义指令</h1>\n<h2 id="自定义指令说明" tabindex="-1"><a class="header-anchor" href="#自定义指令说明" aria-hidden="true">#</a> 自定义指令说明</h2>\n<p>https://www.vue3js.cn/docs/zh/guide/custom-directive.html</p>\n<p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。 <code>v-xxx</code></p>\n<p>注意，代码复用和抽象的主要形式是组件。</p>\n<p>然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>\n<h2 id="自定义指令-局部注册" tabindex="-1"><a class="header-anchor" href="#自定义指令-局部注册" aria-hidden="true">#</a> 自定义指令 - 局部注册</h2>\n<p>例如需求:  当页面加载时，让元素将获得焦点 , (autofocus 在 safari 浏览器有兼容性)</p>\n<div class="language-less ext-less line-numbers-mode"><pre v-pre class="language-less"><code><span class="token selector">&lt;template>\n  &lt;div>\n    &lt;h3>自定义指令&lt;/h3>\n    &lt;input ref="inp" type="text" v-focus>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nexport default</span> <span class="token punctuation">{</span>\n  <span class="token selector">directives:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 自定义一个局部指令</span>\n    <span class="token selector">focus:</span> <span class="token punctuation">{</span>\n      <span class="token selector">inserted (el)</span> <span class="token punctuation">{</span>\n        el.<span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n&lt;<span class="token operator">/</span>script>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="自定义指令-全局注册" tabindex="-1"><a class="header-anchor" href="#自定义指令-全局注册" aria-hidden="true">#</a> 自定义指令 - 全局注册</h2>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 注册全局自定义指令</span>\nVue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">\'focus\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function">inserted</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="自定义指令-指令的值" tabindex="-1"><a class="header-anchor" href="#自定义指令-指令的值" aria-hidden="true">#</a> 自定义指令 - 指令的值</h2>\n<p>在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值</p>\n<p>需求: v-color=&quot;color&quot; 给对应的颜色, 就能改对应的字体颜色</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-color</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">我是内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>实现:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token literal-property property">directives</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 自定义一个局部指令</span>\n  <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 指令所在的元素渲染的时候</span>\n    <span class="token function">inserted</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> value\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token comment">// update指令的值改变时触发, binding.value指令的值修改触发</span>\n    <span class="token function">update</span> <span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> binding<span class="token punctuation">.</span>value\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="插槽" tabindex="-1"><a class="header-anchor" href="#插槽" aria-hidden="true">#</a> 插槽</h1>\n<p>插槽（Slot）是 vue 为组件的封装者提供的能力。</p>\n<p>允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。</p>\n<h2 id="默认插槽-slot" tabindex="-1"><a class="header-anchor" href="#默认插槽-slot" aria-hidden="true">#</a> 默认插槽 slot</h2>\n<p><strong>需求: 要在页面中显示一个对话框, 封装成一个组件</strong></p>\n<p>通过父传子, 固然可以完成一定层面的组件的定制, 但是自定义性较差,</p>\n<p>如果希望能够自定义组件内部的一些结构 =&gt; 就需要用到插槽</p>\n<p><strong>插槽作用: 用于实现组件的内容分发, 通过 slot 标签, 可以接收到写在组件标签内的内容</strong></p>\n<p>插槽：slot  作用：占位置</p>\n<p>基本示例:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-dialog</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">请输入正确的手机号码</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-dialog</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>my-dialog.vue</code></p>\n<div class="language-less ext-less line-numbers-mode"><pre v-pre class="language-less"><code><span class="token selector">&lt;template>\n  &lt;div class="my-dialog">\n    &lt;div class="header">\n      &lt;h3>友情提示&lt;/h3>\n    &lt;/div>\n    &lt;div class="content">\n      &lt;slot>&lt;/slot>\n    &lt;/div>\n    &lt;div class="footer">\n      &lt;button>关闭&lt;/button>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nexport default</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span>\n<span class="token selector">&lt;/script>\n\n&lt;style lang="less" scoped>\n.my-dialog</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">padding</span><span class="token punctuation">:</span> 10px 20px<span class="token punctuation">;</span>\n  <span class="token property">border</span><span class="token punctuation">:</span> 3px solid #000<span class="token punctuation">;</span>\n  <span class="token property">border-radius</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n&lt;<span class="token operator">/</span>style>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h2 id="后备内容-默认值" tabindex="-1"><a class="header-anchor" href="#后备内容-默认值" aria-hidden="true">#</a> 后备内容 (默认值)</h2>\n<p>封装组件时，可以为预留的 <code>&lt;slot&gt;</code> 插槽提供后备内容（默认内容）。</p>\n<p>如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my-dialog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">友情提示</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">这是后备内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">关闭</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="具名插槽" tabindex="-1"><a class="header-anchor" href="#具名插槽" aria-hidden="true">#</a> 具名插槽</h2>\n<h3 id="插槽的分类" tabindex="-1"><a class="header-anchor" href="#插槽的分类" aria-hidden="true">#</a> 插槽的分类:</h3>\n<p><strong>1 默认插槽(匿名插槽)</strong></p>\n<p><code>&lt;slot&gt;&lt;/slot&gt;</code> 只要没有具体分发的内容, 都会给到默认插槽</p>\n<p><code>&lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</code> 是默认插槽完整的写法 和 <code>&lt;slot&gt;&lt;/slot&gt;</code> 完全等价</p>\n<p><strong>2 具名插槽: 具有名字的插槽 (配置了名字),  可以实现定向分发</strong></p>\n<p>一旦配置了名字, 只会接收对应的内容, 不是分发给他的, 就不要</p>\n<h3 id="具名插槽的使用步骤" tabindex="-1"><a class="header-anchor" href="#具名插槽的使用步骤" aria-hidden="true">#</a> 具名插槽的使用步骤</h3>\n<p>(1) 给插槽起名字</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">这是后备内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>(2) 需要使用 template 标签, 将内容包裹成一个整体</p>\n<p>(3) 通过 v-slot:插槽名, 指定具体分发给谁</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-dialog</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>header</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>这是大标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>这是内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>footer</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>确认<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>取消<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-dialog</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="具名插槽的简写" tabindex="-1"><a class="header-anchor" href="#具名插槽的简写" aria-hidden="true">#</a> 具名插槽的简写</h3>\n<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。</p>\n<p>例如 v-slot:header 可以被简写为 #header</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-dialog</span><span class="token punctuation">></span></span><span class="token plain-text">\n  &lt;template #header>\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">这是大标题</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n  &lt;template #default>\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">这是内容</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n\n  &lt;template #footer>\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">确认</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">取消</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-dialog</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="作用域插槽" tabindex="-1"><a class="header-anchor" href="#作用域插槽" aria-hidden="true">#</a> 作用域插槽</h2>\n<p>作用域插槽: <strong>定义 slot 插槽的同时, 是可以传值的</strong>, 将来在分发内容时, 可以使用</p>\n<ol>\n<li>给 slot 标签, 以 添加属性的方式传值</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>bottom<span class="token punctuation">"</span></span> <span class="token attr-name">:yes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>yes<span class="token punctuation">"</span></span> <span class="token attr-name">:no</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>no<span class="token punctuation">"</span></span> <span class="token attr-name">money</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2">\n<li>所有添加的属性, 都会被收集到一个对象中</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token punctuation">{</span> <span class="token literal-property property">yes</span><span class="token operator">:</span> <span class="token string">\'确认\'</span><span class="token punctuation">,</span> <span class="token literal-property property">no</span><span class="token operator">:</span> <span class="token string">\'取消\'</span><span class="token punctuation">,</span> <span class="token literal-property property">money</span><span class="token operator">:</span> <span class="token string">\'100\'</span> <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="3">\n<li>在template中, 通过  <code>v-slot:插槽名= &quot;obj&quot;</code> 接收</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>template #bottom<span class="token operator">=</span><span class="token string">"obj"</span><span class="token operator">></span>\n  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> obj <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">--</span><span class="token operator">></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>yes <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>no <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> obj<span class="token punctuation">.</span>money <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="4">\n<li>可以使用解构赋值简化数据的接收</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token operator">&lt;</span>template #bottom<span class="token operator">=</span><span class="token string">"{ yes, no, money }"</span><span class="token operator">></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> yes <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> no <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> money <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div>',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/Vue/组件进阶.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"组件进阶",filePath:"D:/桌面文件/Blog/blog-demo/docs/Vue/组件进阶.md",filePathRelative:"Vue/组件进阶.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件进阶.html.vue",componentFilePathRelative:"pages/Vue/组件进阶.html.vue",componentFileChunkName:"v-1e97db11",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/Vue/组件进阶.html.js",dataFilePathRelative:"pages/Vue/组件进阶.html.js",dataFileChunkName:"v-1e97db11",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/Vue/组件进阶.html",htmlFilePathRelative:"Vue/组件进阶.html"},{data:{key:"v-0a97e47a",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.html",title:"HTML基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. HTML 文件中的 DOCTYPE 是什么作用？",slug:"_1-html-文件中的-doctype-是什么作用",children:[]},{level:2,title:"2. HTML、XML、XHTML 之间有什么区别？",slug:"_2-html、xml、xhtml-之间有什么区别",children:[]},{level:2,title:"3. 前缀为 data- 开头的元素属性是什么？",slug:"_3-前缀为-data-开头的元素属性是什么",children:[]},{level:2,title:"4. 谈谈你对 HTML 语义化的理解？",slug:"_4-谈谈你对-html-语义化的理解",children:[]},{level:2,title:"5. HTML5 对比 HTML4 有哪些不同之处？",slug:"_5-html5-对比-html4-有哪些不同之处",children:[]},{level:2,title:"6. meta 标签有哪些常用用法？",slug:"_6-meta-标签有哪些常用用法",children:[]},{level:2,title:"7. img 标签的 srcset 的作用是什么？",slug:"_7-img-标签的-srcset-的作用是什么",children:[]},{level:2,title:"8. 响应式图片处理优化: Picture 标签",slug:"_8-响应式图片处理优化-picture-标签",children:[]},{level:2,title:"9. 在 script 标签上使用 defer 和 async 的区别是什么？",slug:"_9-在-script-标签上使用-defer-和-async-的区别是什么",children:[]},{level:2,title:"10. 前端做本地数据存储的方式有哪些？",slug:"_10-前端做本地数据存储的方式有哪些",children:[]},{level:2,title:"11. 以上几种前端存储的区别是什么？",slug:"_11-以上几种前端存储的区别是什么",children:[]},{level:2,title:"1. CSS选择器的优先级是怎么样的？",slug:"_1-css选择器的优先级是怎么样的",children:[]},{level:2,title:"2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？",slug:"_2-通过-css-的哪些方式可以实现隐藏页面上的元素",children:[]},{level:2,title:"3. px、em、rem之间有什么区别？",slug:"_3-px、em、rem之间有什么区别",children:[]},{level:2,title:"4. 让元素水平居中的方法有哪些？",slug:"_4-让元素水平居中的方法有哪些",children:[]},{level:2,title:"5. 在 CSS 中有哪些定位方式？",slug:"_5-在-css-中有哪些定位方式",children:[]},{level:2,title:"6. 如何理解 z-index？",slug:"_6-如何理解-z-index",children:[]},{level:2,title:"7. 如何清除浮动 ？",slug:"_7-如何清除浮动",children:[]},{level:2,title:"8. 谈谈你对 BFC 的理解？",slug:"_8-谈谈你对-bfc-的理解",children:[]},{level:2,title:"9. 什么是CSS Sprites以及它的好处？",slug:"_9-什么是css-sprites以及它的好处",children:[]},{level:2,title:"10. 你对媒体查询的理解是什么样的？",slug:"_10-你对媒体查询的理解是什么样的",children:[]},{level:2,title:"11. 你对盒子模型的理解是什么样的？",slug:"_11-你对盒子模型的理解是什么样的",children:[]},{level:2,title:"12. 标准盒模型和怪异盒模型有哪些区别？",slug:"_12-标准盒模型和怪异盒模型有哪些区别",children:[]},{level:2,title:"13. 说说伪类和伪元素的区别？",slug:"_13-说说伪类和伪元素的区别",children:[]},{level:2,title:"14. 谈谈你对 flex 的理解？",slug:"_14-谈谈你对-flex-的理解",children:[]},{level:2,title:"1. 解释下什么是变量声明提升？",slug:"_1-解释下什么是变量声明提升",children:[]},{level:2,title:"2. JS 的参数是以什么方式进行传递的？",slug:"_2-js-的参数是以什么方式进行传递的",children:[]},{level:2,title:"3. JavaScript垃圾回收是怎么做的？",slug:"_3-javascript垃圾回收是怎么做的",children:[{level:3,title:"3.1 内存的生命周期",slug:"_3-1-内存的生命周期",children:[]},{level:3,title:"3.2 垃圾回收算法说明",slug:"_3-2-垃圾回收算法说明",children:[]},{level:3,title:"3.3 引用计数",slug:"_3-3-引用计数",children:[]},{level:3,title:"3.4 标记清除算法",slug:"_3-4-标记清除算法",children:[]}]},{level:2,title:"4. 谈谈你对 JavaScript 作用域链的理解？",slug:"_4-谈谈你对-javascript-作用域链的理解",children:[]},{level:2,title:"5. 谈谈你对闭包的理解？",slug:"_5-谈谈你对闭包的理解",children:[]},{level:2,title:"6. JavaScript中数据类型的隐式转换规则(了解)",slug:"_6-javascript中数据类型的隐式转换规则-了解",children:[]},{level:2,title:"7. 谈谈你对原型链的理解？",slug:"_7-谈谈你对原型链的理解",children:[]},{level:2,title:"6. 谈谈对于继承的理解",slug:"_6-谈谈对于继承的理解",children:[{level:3,title:"6.1 继承 - 原型继承",slug:"_6-1-继承-原型继承",children:[]},{level:3,title:"6.2 继承 - 组合继承",slug:"_6-2-继承-组合继承",children:[]},{level:3,title:"6.3 继承 - 寄生组合继承",slug:"_6-3-继承-寄生组合继承",children:[]},{level:3,title:"6.4 es6 - class 实现继承 extends",slug:"_6-4-es6-class-实现继承-extends",children:[]}]},{level:2,title:"8. 如何判断是否是数组？",slug:"_8-如何判断是否是数组",children:[]},{level:2,title:"9. 谈谈你对this的理解？",slug:"_9-谈谈你对this的理解",children:[]},{level:2,title:"10. 箭头函数中的this指向什么？",slug:"_10-箭头函数中的this指向什么",children:[]},{level:2,title:"11. Promise 的静态方法",slug:"_11-promise-的静态方法",children:[]},{level:2,title:"12. 宏任务 微任务 是什么",slug:"_12-宏任务-微任务-是什么",children:[]},{level:2,title:"13. async/await是什么？",slug:"_13-async-await是什么",children:[]},{level:2,title:"14. 相较于 Promise，async/await有何优势？",slug:"_14-相较于-promise-async-await有何优势",children:[]},{level:2,title:"15. 深拷贝 浅拷贝",slug:"_15-深拷贝-浅拷贝",children:[]},{level:2,title:"1. HTTP有哪些⽅法？",slug:"_1-http有哪些方法",children:[]},{level:2,title:"2. 各个HTTP方法的具体作用是什么？",slug:"_2-各个http方法的具体作用是什么",children:[]},{level:2,title:"3. GET方法和POST方法有何区别？",slug:"_3-get方法和post方法有何区别",children:[]},{level:2,title:"4. HTTP请求报文是什么样的？",slug:"_4-http请求报文是什么样的",children:[]},{level:2,title:"5. HTTP响应报文是什么样的？",slug:"_5-http响应报文是什么样的",children:[]},{level:2,title:"6. 你了解的HTTP状态码有哪些？",slug:"_6-你了解的http状态码有哪些",children:[]},{level:2,title:"7. HTTP的keep-alive是什么作用？",slug:"_7-http的keep-alive是什么作用",children:[]},{level:2,title:"8. 为什么需要HTTPS？",slug:"_8-为什么需要https",children:[]},{level:2,title:"9. HTTPS是如何保证安全的？",slug:"_9-https是如何保证安全的",children:[{level:3,title:"9.1 什么是对称加密？",slug:"_9-1-什么是对称加密",children:[]},{level:3,title:"9.2 什么是⾮对称加密？",slug:"_9-2-什么是非对称加密",children:[]},{level:3,title:"9.3 HTTPS 加密解决⽅案",slug:"_9-3-https-加密解决方案",children:[]},{level:3,title:"9.4 数字证书",slug:"_9-4-数字证书",children:[]},{level:3,title:"9.5 数字签名",slug:"_9-5-数字签名",children:[]}]},{level:2,title:"10. HTTP2和HTTP1.x比，有什么优势和特点？",slug:"_10-http2和http1-x比-有什么优势和特点",children:[]},{level:2,title:"11. http缓存控制",slug:"_11-http缓存控制",children:[{level:3,title:"11.1 基本认知",slug:"_11-1-基本认知",children:[]},{level:3,title:"11.2 强缓存  (食品过期时间判断)",slug:"_11-2-强缓存-食品过期时间判断",children:[]},{level:3,title:"11.3 协商缓存 (找供货商专家协商)",slug:"_11-3-协商缓存-找供货商专家协商",children:[]},{level:3,title:"11.4 整体请求缓存流程",slug:"_11-4-整体请求缓存流程",children:[]}]},{level:2,title:"TCP的特性",slug:"tcp的特性",children:[]},{level:2,title:"简述 TCP 和 UDP 的区别",slug:"简述-tcp-和-udp-的区别",children:[]},{level:2,title:"什么是 TCP 粘包，怎么处理？",slug:"什么是-tcp-粘包-怎么处理",children:[]},{level:2,title:"你知道哪些常用的端口号，以及它们对应的服务？",slug:"你知道哪些常用的端口号-以及它们对应的服务",children:[]},{level:2,title:"一次完整的HTTP服务过程是什么",slug:"一次完整的http服务过程是什么",children:[]},{level:2,title:"什么是DNS 解析",slug:"什么是dns-解析",children:[]},{level:2,title:"什么是三次握手？",slug:"什么是三次握手",children:[]},{level:2,title:"什么是四次挥手？",slug:"什么是四次挥手",children:[]},{level:2,title:"TCP 三次握手理解 (双方确认)",slug:"tcp-三次握手理解-双方确认",children:[]},{level:2,title:"关闭TCP连接四次挥手的理解 (客气挽留)",slug:"关闭tcp连接四次挥手的理解-客气挽留",children:[]},{level:2,title:"浏览器解析响应",slug:"浏览器解析响应",children:[]},{level:2,title:"DOM的事件模型是什么？",slug:"dom的事件模型是什么",children:[]},{level:2,title:"DOM的事件流是什么？",slug:"dom的事件流是什么",children:[]},{level:2,title:"说说什么是事件委托？",slug:"说说什么是事件委托",children:[]},{level:2,title:"常见的浏览器内核有哪些？",slug:"常见的浏览器内核有哪些",children:[]},{level:2,title:"浏览器是如何进行界面渲染的？",slug:"浏览器是如何进行界面渲染的",children:[]},{level:2,title:"浏览器是如何解析CSS选择器的？",slug:"浏览器是如何解析css选择器的",children:[]},{level:2,title:"DOM树是如何构建的？",slug:"dom树是如何构建的",children:[]},{level:2,title:"浏览器重绘与重排的区别是什么？",slug:"浏览器重绘与重排的区别是什么",children:[]},{level:2,title:"如何触发重排和重绘？",slug:"如何触发重排和重绘",children:[]},{level:2,title:"如何避免重排或重绘？",slug:"如何避免重排或重绘",children:[]},{level:2,title:"前端如何实现即时通讯？",slug:"前端如何实现即时通讯",children:[]},{level:2,title:"什么是浏览器的同源策略？",slug:"什么是浏览器的同源策略",children:[]},{level:2,title:"如何实现跨域？",slug:"如何实现跨域",children:[]},{level:2,title:"Babel的原理是什么？",slug:"babel的原理是什么",children:[]},{level:2,title:"如何编写一个Babel插件？",slug:"如何编写一个babel插件",children:[]},{level:2,title:"你们的Git工作流是什么样的？",slug:"你们的git工作流是什么样的",children:[]},{level:2,title:"Git的rebase和merge的区别是什么？",slug:"git的rebase和merge的区别是什么",children:[]},{level:2,title:"什么是MVVM？",slug:"什么是mvvm",children:[]},{level:2,title:"MVVM的优缺点有哪些？",slug:"mvvm的优缺点有哪些",children:[]},{level:2,title:"谈谈对Vue生命周期的理解？",slug:"谈谈对vue生命周期的理解",children:[]},{level:2,title:"在Vue中网络请求应该放在哪个生命周期中发起？",slug:"在vue中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"Vue组件之间如何进行通信？",slug:"vue组件之间如何进行通信",children:[]},{level:2,title:"computed和watch的区别是什么？",slug:"computed和watch的区别是什么",children:[]},{level:2,title:"Vue双向绑定原理？",slug:"vue双向绑定原理",children:[]},{level:2,title:"Object.defineProperty和Proxy的优缺点？",slug:"object-defineproperty和proxy的优缺点",children:[]},{level:2,title:"如何理解Vue的响应式系统？",slug:"如何理解vue的响应式系统",children:[{level:3,title:"基本原理",slug:"基本原理",children:[]},{level:3,title:"观察者模式",slug:"观察者模式",children:[]}]},{level:2,title:"Vue中的key到底有什么用？",slug:"vue中的key到底有什么用",children:[{level:3,title:"diff算法",slug:"diff算法",children:[]},{level:3,title:"key的常见应用场景",slug:"key的常见应用场景",children:[]}]},{level:2,title:"React最新的生命周期是怎么样的？",slug:"react最新的生命周期是怎么样的",children:[]},{level:2,title:"在React中网络请求应该放在哪个生命周期中发起？",slug:"在react中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"setState是同步的还是异步的？",slug:"setstate是同步的还是异步的",children:[]},{level:2,title:"React中如何实现组件间的通信？",slug:"react中如何实现组件间的通信",children:[]},{level:2,title:"React存在哪些性能优化手段？",slug:"react存在哪些性能优化手段",children:[]},{level:2,title:"React中如何进行组件和逻辑的复用？",slug:"react中如何进行组件和逻辑的复用",children:[]},{level:2,title:"Mixin、HoC、Render props、React Hooks的优缺点分别是什么？",slug:"mixin、hoc、render-props、react-hooks的优缺点分别是什么",children:[]},{level:2,title:"Redux的工作流程是怎么样的？",slug:"redux的工作流程是怎么样的",children:[]},{level:2,title:"react-redux这个库是如何工作的？",slug:"react-redux这个库是如何工作的",children:[]},{level:2,title:"Redux和Mobx的区别？",slug:"redux和mobx的区别",children:[]},{level:2,title:"在Redux中如何进行异步操作？",slug:"在redux中如何进行异步操作",children:[]}],git:{}},key:"v-0a97e47a",path:"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%8C.html",title:"HTML基础",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1. HTML 文件中的 DOCTYPE 是什么作用？",slug:"_1-html-文件中的-doctype-是什么作用",children:[]},{level:2,title:"2. HTML、XML、XHTML 之间有什么区别？",slug:"_2-html、xml、xhtml-之间有什么区别",children:[]},{level:2,title:"3. 前缀为 data- 开头的元素属性是什么？",slug:"_3-前缀为-data-开头的元素属性是什么",children:[]},{level:2,title:"4. 谈谈你对 HTML 语义化的理解？",slug:"_4-谈谈你对-html-语义化的理解",children:[]},{level:2,title:"5. HTML5 对比 HTML4 有哪些不同之处？",slug:"_5-html5-对比-html4-有哪些不同之处",children:[]},{level:2,title:"6. meta 标签有哪些常用用法？",slug:"_6-meta-标签有哪些常用用法",children:[]},{level:2,title:"7. img 标签的 srcset 的作用是什么？",slug:"_7-img-标签的-srcset-的作用是什么",children:[]},{level:2,title:"8. 响应式图片处理优化: Picture 标签",slug:"_8-响应式图片处理优化-picture-标签",children:[]},{level:2,title:"9. 在 script 标签上使用 defer 和 async 的区别是什么？",slug:"_9-在-script-标签上使用-defer-和-async-的区别是什么",children:[]},{level:2,title:"10. 前端做本地数据存储的方式有哪些？",slug:"_10-前端做本地数据存储的方式有哪些",children:[]},{level:2,title:"11. 以上几种前端存储的区别是什么？",slug:"_11-以上几种前端存储的区别是什么",children:[]},{level:2,title:"1. CSS选择器的优先级是怎么样的？",slug:"_1-css选择器的优先级是怎么样的",children:[]},{level:2,title:"2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？",slug:"_2-通过-css-的哪些方式可以实现隐藏页面上的元素",children:[]},{level:2,title:"3. px、em、rem之间有什么区别？",slug:"_3-px、em、rem之间有什么区别",children:[]},{level:2,title:"4. 让元素水平居中的方法有哪些？",slug:"_4-让元素水平居中的方法有哪些",children:[]},{level:2,title:"5. 在 CSS 中有哪些定位方式？",slug:"_5-在-css-中有哪些定位方式",children:[]},{level:2,title:"6. 如何理解 z-index？",slug:"_6-如何理解-z-index",children:[]},{level:2,title:"7. 如何清除浮动 ？",slug:"_7-如何清除浮动",children:[]},{level:2,title:"8. 谈谈你对 BFC 的理解？",slug:"_8-谈谈你对-bfc-的理解",children:[]},{level:2,title:"9. 什么是CSS Sprites以及它的好处？",slug:"_9-什么是css-sprites以及它的好处",children:[]},{level:2,title:"10. 你对媒体查询的理解是什么样的？",slug:"_10-你对媒体查询的理解是什么样的",children:[]},{level:2,title:"11. 你对盒子模型的理解是什么样的？",slug:"_11-你对盒子模型的理解是什么样的",children:[]},{level:2,title:"12. 标准盒模型和怪异盒模型有哪些区别？",slug:"_12-标准盒模型和怪异盒模型有哪些区别",children:[]},{level:2,title:"13. 说说伪类和伪元素的区别？",slug:"_13-说说伪类和伪元素的区别",children:[]},{level:2,title:"14. 谈谈你对 flex 的理解？",slug:"_14-谈谈你对-flex-的理解",children:[]},{level:2,title:"1. 解释下什么是变量声明提升？",slug:"_1-解释下什么是变量声明提升",children:[]},{level:2,title:"2. JS 的参数是以什么方式进行传递的？",slug:"_2-js-的参数是以什么方式进行传递的",children:[]},{level:2,title:"3. JavaScript垃圾回收是怎么做的？",slug:"_3-javascript垃圾回收是怎么做的",children:[{level:3,title:"3.1 内存的生命周期",slug:"_3-1-内存的生命周期",children:[]},{level:3,title:"3.2 垃圾回收算法说明",slug:"_3-2-垃圾回收算法说明",children:[]},{level:3,title:"3.3 引用计数",slug:"_3-3-引用计数",children:[]},{level:3,title:"3.4 标记清除算法",slug:"_3-4-标记清除算法",children:[]}]},{level:2,title:"4. 谈谈你对 JavaScript 作用域链的理解？",slug:"_4-谈谈你对-javascript-作用域链的理解",children:[]},{level:2,title:"5. 谈谈你对闭包的理解？",slug:"_5-谈谈你对闭包的理解",children:[]},{level:2,title:"6. JavaScript中数据类型的隐式转换规则(了解)",slug:"_6-javascript中数据类型的隐式转换规则-了解",children:[]},{level:2,title:"7. 谈谈你对原型链的理解？",slug:"_7-谈谈你对原型链的理解",children:[]},{level:2,title:"6. 谈谈对于继承的理解",slug:"_6-谈谈对于继承的理解",children:[{level:3,title:"6.1 继承 - 原型继承",slug:"_6-1-继承-原型继承",children:[]},{level:3,title:"6.2 继承 - 组合继承",slug:"_6-2-继承-组合继承",children:[]},{level:3,title:"6.3 继承 - 寄生组合继承",slug:"_6-3-继承-寄生组合继承",children:[]},{level:3,title:"6.4 es6 - class 实现继承 extends",slug:"_6-4-es6-class-实现继承-extends",children:[]}]},{level:2,title:"8. 如何判断是否是数组？",slug:"_8-如何判断是否是数组",children:[]},{level:2,title:"9. 谈谈你对this的理解？",slug:"_9-谈谈你对this的理解",children:[]},{level:2,title:"10. 箭头函数中的this指向什么？",slug:"_10-箭头函数中的this指向什么",children:[]},{level:2,title:"11. Promise 的静态方法",slug:"_11-promise-的静态方法",children:[]},{level:2,title:"12. 宏任务 微任务 是什么",slug:"_12-宏任务-微任务-是什么",children:[]},{level:2,title:"13. async/await是什么？",slug:"_13-async-await是什么",children:[]},{level:2,title:"14. 相较于 Promise，async/await有何优势？",slug:"_14-相较于-promise-async-await有何优势",children:[]},{level:2,title:"15. 深拷贝 浅拷贝",slug:"_15-深拷贝-浅拷贝",children:[]},{level:2,title:"1. HTTP有哪些⽅法？",slug:"_1-http有哪些方法",children:[]},{level:2,title:"2. 各个HTTP方法的具体作用是什么？",slug:"_2-各个http方法的具体作用是什么",children:[]},{level:2,title:"3. GET方法和POST方法有何区别？",slug:"_3-get方法和post方法有何区别",children:[]},{level:2,title:"4. HTTP请求报文是什么样的？",slug:"_4-http请求报文是什么样的",children:[]},{level:2,title:"5. HTTP响应报文是什么样的？",slug:"_5-http响应报文是什么样的",children:[]},{level:2,title:"6. 你了解的HTTP状态码有哪些？",slug:"_6-你了解的http状态码有哪些",children:[]},{level:2,title:"7. HTTP的keep-alive是什么作用？",slug:"_7-http的keep-alive是什么作用",children:[]},{level:2,title:"8. 为什么需要HTTPS？",slug:"_8-为什么需要https",children:[]},{level:2,title:"9. HTTPS是如何保证安全的？",slug:"_9-https是如何保证安全的",children:[{level:3,title:"9.1 什么是对称加密？",slug:"_9-1-什么是对称加密",children:[]},{level:3,title:"9.2 什么是⾮对称加密？",slug:"_9-2-什么是非对称加密",children:[]},{level:3,title:"9.3 HTTPS 加密解决⽅案",slug:"_9-3-https-加密解决方案",children:[]},{level:3,title:"9.4 数字证书",slug:"_9-4-数字证书",children:[]},{level:3,title:"9.5 数字签名",slug:"_9-5-数字签名",children:[]}]},{level:2,title:"10. HTTP2和HTTP1.x比，有什么优势和特点？",slug:"_10-http2和http1-x比-有什么优势和特点",children:[]},{level:2,title:"11. http缓存控制",slug:"_11-http缓存控制",children:[{level:3,title:"11.1 基本认知",slug:"_11-1-基本认知",children:[]},{level:3,title:"11.2 强缓存  (食品过期时间判断)",slug:"_11-2-强缓存-食品过期时间判断",children:[]},{level:3,title:"11.3 协商缓存 (找供货商专家协商)",slug:"_11-3-协商缓存-找供货商专家协商",children:[]},{level:3,title:"11.4 整体请求缓存流程",slug:"_11-4-整体请求缓存流程",children:[]}]},{level:2,title:"TCP的特性",slug:"tcp的特性",children:[]},{level:2,title:"简述 TCP 和 UDP 的区别",slug:"简述-tcp-和-udp-的区别",children:[]},{level:2,title:"什么是 TCP 粘包，怎么处理？",slug:"什么是-tcp-粘包-怎么处理",children:[]},{level:2,title:"你知道哪些常用的端口号，以及它们对应的服务？",slug:"你知道哪些常用的端口号-以及它们对应的服务",children:[]},{level:2,title:"一次完整的HTTP服务过程是什么",slug:"一次完整的http服务过程是什么",children:[]},{level:2,title:"什么是DNS 解析",slug:"什么是dns-解析",children:[]},{level:2,title:"什么是三次握手？",slug:"什么是三次握手",children:[]},{level:2,title:"什么是四次挥手？",slug:"什么是四次挥手",children:[]},{level:2,title:"TCP 三次握手理解 (双方确认)",slug:"tcp-三次握手理解-双方确认",children:[]},{level:2,title:"关闭TCP连接四次挥手的理解 (客气挽留)",slug:"关闭tcp连接四次挥手的理解-客气挽留",children:[]},{level:2,title:"浏览器解析响应",slug:"浏览器解析响应",children:[]},{level:2,title:"DOM的事件模型是什么？",slug:"dom的事件模型是什么",children:[]},{level:2,title:"DOM的事件流是什么？",slug:"dom的事件流是什么",children:[]},{level:2,title:"说说什么是事件委托？",slug:"说说什么是事件委托",children:[]},{level:2,title:"常见的浏览器内核有哪些？",slug:"常见的浏览器内核有哪些",children:[]},{level:2,title:"浏览器是如何进行界面渲染的？",slug:"浏览器是如何进行界面渲染的",children:[]},{level:2,title:"浏览器是如何解析CSS选择器的？",slug:"浏览器是如何解析css选择器的",children:[]},{level:2,title:"DOM树是如何构建的？",slug:"dom树是如何构建的",children:[]},{level:2,title:"浏览器重绘与重排的区别是什么？",slug:"浏览器重绘与重排的区别是什么",children:[]},{level:2,title:"如何触发重排和重绘？",slug:"如何触发重排和重绘",children:[]},{level:2,title:"如何避免重排或重绘？",slug:"如何避免重排或重绘",children:[]},{level:2,title:"前端如何实现即时通讯？",slug:"前端如何实现即时通讯",children:[]},{level:2,title:"什么是浏览器的同源策略？",slug:"什么是浏览器的同源策略",children:[]},{level:2,title:"如何实现跨域？",slug:"如何实现跨域",children:[]},{level:2,title:"Babel的原理是什么？",slug:"babel的原理是什么",children:[]},{level:2,title:"如何编写一个Babel插件？",slug:"如何编写一个babel插件",children:[]},{level:2,title:"你们的Git工作流是什么样的？",slug:"你们的git工作流是什么样的",children:[]},{level:2,title:"Git的rebase和merge的区别是什么？",slug:"git的rebase和merge的区别是什么",children:[]},{level:2,title:"什么是MVVM？",slug:"什么是mvvm",children:[]},{level:2,title:"MVVM的优缺点有哪些？",slug:"mvvm的优缺点有哪些",children:[]},{level:2,title:"谈谈对Vue生命周期的理解？",slug:"谈谈对vue生命周期的理解",children:[]},{level:2,title:"在Vue中网络请求应该放在哪个生命周期中发起？",slug:"在vue中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"Vue组件之间如何进行通信？",slug:"vue组件之间如何进行通信",children:[]},{level:2,title:"computed和watch的区别是什么？",slug:"computed和watch的区别是什么",children:[]},{level:2,title:"Vue双向绑定原理？",slug:"vue双向绑定原理",children:[]},{level:2,title:"Object.defineProperty和Proxy的优缺点？",slug:"object-defineproperty和proxy的优缺点",children:[]},{level:2,title:"如何理解Vue的响应式系统？",slug:"如何理解vue的响应式系统",children:[{level:3,title:"基本原理",slug:"基本原理",children:[]},{level:3,title:"观察者模式",slug:"观察者模式",children:[]}]},{level:2,title:"Vue中的key到底有什么用？",slug:"vue中的key到底有什么用",children:[{level:3,title:"diff算法",slug:"diff算法",children:[]},{level:3,title:"key的常见应用场景",slug:"key的常见应用场景",children:[]}]},{level:2,title:"React最新的生命周期是怎么样的？",slug:"react最新的生命周期是怎么样的",children:[]},{level:2,title:"在React中网络请求应该放在哪个生命周期中发起？",slug:"在react中网络请求应该放在哪个生命周期中发起",children:[]},{level:2,title:"setState是同步的还是异步的？",slug:"setstate是同步的还是异步的",children:[]},{level:2,title:"React中如何实现组件间的通信？",slug:"react中如何实现组件间的通信",children:[]},{level:2,title:"React存在哪些性能优化手段？",slug:"react存在哪些性能优化手段",children:[]},{level:2,title:"React中如何进行组件和逻辑的复用？",slug:"react中如何进行组件和逻辑的复用",children:[]},{level:2,title:"Mixin、HoC、Render props、React Hooks的优缺点分别是什么？",slug:"mixin、hoc、render-props、react-hooks的优缺点分别是什么",children:[]},{level:2,title:"Redux的工作流程是怎么样的？",slug:"redux的工作流程是怎么样的",children:[]},{level:2,title:"react-redux这个库是如何工作的？",slug:"react-redux这个库是如何工作的",children:[]},{level:2,title:"Redux和Mobx的区别？",slug:"redux和mobx的区别",children:[]},{level:2,title:"在Redux中如何进行异步操作？",slug:"在redux中如何进行异步操作",children:[]}],content:'# HTML基础\r\n\r\n## 1. HTML 文件中的 DOCTYPE 是什么作用？\r\n\r\nHTML超文本标记语言: 是一个标记语言, 就有对应的语法标准\r\n\r\nDOCTYPE 即 Document Type，网页文件的文档类型标准。\r\n\r\n主要作用是告诉浏览器的解析器要使用哪种  **HTML规范** 或 **XHTML规范** 来解析页面。\r\n\r\nDOCTYPE 需要放置在 HTML 文件的 `<html>`标签之前，如：\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  ...\r\n</html> (目前主流)\r\n```\r\n\r\n```html\r\n<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">\r\n<html>\r\n  ...\r\n</html> (早期)\r\n```\r\n\r\n\r\n\r\n## 2. HTML、XML、XHTML 之间有什么区别？\r\n\r\n它们都属于标记语言。  \r\n\r\n| 语言  | 中文名               | 说明                                                         |\r\n| ----- | -------------------- | ------------------------------------------------------------ |\r\n| HTML4 | 超文本标记语言       | 主要用于做界面呈现。HTML 是先有实现，后面才慢慢制定标准的，导致HTML⾮常混乱和松散，语法非常的不严谨。 |\r\n| XML   | 可扩展标记语言       | 主要⽤于存储数据和结构。语法严谨，可扩展性强。由于 JSON 也有类似作⽤但更轻量⾼效， XML 的市场变得越来越⼩。 |\r\n| XHTML | 可扩展超文本标记语言 | 属于加强版 HTML，为解决 HTML 的混乱问题而生，在语法方面变得和 XML 一样严格。另外，XHTML 的出现也催生了 HTML 5，让HTML向规范化严谨化过渡。 |\r\n| HTML5 | 超文本标记语言       | 在HTML的基础上进行拓展，用于页面呈现 (目前标准)              |\r\n\r\nXML的要求会比较严格:\r\n\r\n1. 有且只能有一个根元素\r\n\r\n2. 大小写敏感\r\n\r\n3. 正确嵌套\r\n\r\n4. 必须双引号\r\n\r\n5. 必须闭合标签\r\n\r\n   ...\r\n\r\n```jsx\r\n<?xml version="1.0" encoding="utf-8"?>\r\n<root>\r\n  <father id=\'box\'>\r\n    <child>小张</child>\r\n    <child>小王</child>\r\n  </father>\r\n</root>\r\n```\r\n\r\nXHTML 和 HTML5 的历史延展: https://www.cnblogs.com/my-freedom/p/5796915.html\r\n\r\n\r\n\r\n**番外:** 所以 HTML5 是HTML的新一代标准, 所谓的 H5 工程师这一词, 其实是国产词, 泛指新一代的web开发工程师, \r\n\r\n具体H5工程师, 做什么工作方向, 还是要看需求 (比如: 移动端开发, PC端网页开发, H5小游戏开发....)\r\n\r\n\r\n\r\n## 3. 前缀为 `data-` 开头的元素属性是什么？\r\n\r\n这是一种为 HTML 元素添加额外数据信息的方式，被称为 **自定义属性**。\r\n\r\n我们可以直接在元素标签上声明这样的数据属性：\r\n\r\n```html\r\n<div id="mydiv" data-message="Hello,world" data-num="123"></div>\r\n```\r\n\r\n也可以使用 JavaScript 来操作元素的数据属性：\r\n\r\n```js\r\nlet mydiv = document.getElementById(\'mydiv\')\r\n\r\n// 读取\r\nconsole.log(mydiv.dataset.message)\r\n\r\n// 写入\r\nmydiv.dataset.foo = "bar!!!"\r\n```\r\n\r\n**注意：在各种现代前端框架出现后，这种原生的自定义属性已经变得不太常用了, 以前的使用频率非常高, 所以我们知道即可。**\r\n\r\n例如: vue实现删除功能时需要 id, 可以直接传值\r\n\r\n```jsx\r\n<tr v-for="item in list" :key="item.id">\r\n  <td>张三</td>\r\n  <td>18</td>\r\n  <td>体育好</td>\r\n  <td>\r\n    <button @click="del(item.id)">删除</button>\r\n    <button>编辑</button>\r\n  </td>\r\n</tr>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 4. 谈谈你对 HTML 语义化的理解？\r\n\r\n考察核心点: 语义化的好处 (利于SEO, 可阅读性更好)\r\n\r\n**语义化之前：**\r\n\r\n在提倡语义化之前，你可能会使用各种各样的标签去实现同样的功能，比如：\r\n\r\n- 使用 span、div、p、a 等做文字, 做按钮\r\n- 使用 div 做一切\r\n\r\n从功能方面来说，这确实是不存在什么问题的，完全可以达到功能效果。但这不符合直觉，非常不友好：\r\n\r\n- 对人不友好：阅读代码的人不能一眼看出代码的功能\r\n- 对机器不友好：解析代码的程序不能很好的对这些元素进行分类处理\r\n\r\n\r\n\r\n**语义化之后：**\r\n\r\n为了解决上面说的问题，HTML5 规范提倡语义化标签，即使⽤恰当语义的 HTML 标签让⻚⾯具有良好的结构与含义，⽐如：\r\n\r\n- `<p>` 标签就代表段落\r\n- `<article>` 代表正⽂内容\r\n- `<button> `代表按钮\r\n- `<header>` 代表头部\r\n- 等等...\r\n\r\n语义化的好处：\r\n\r\n| 对开发者的好处                                               | 对机器/程序的好处                                            |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| 使⽤了语义化标签的程序，可读性明显增强，开发者可以比容易和清晰地看出⽹⻚的结构；这也更利于整个开发团队的协作开发和后续维护工作 | 带有语义的网页代码在⽂字类应用上的表现⼒丰富，利于搜索引擎爬⾍程序来爬取和提取出有效的信息；语义化标签还⽀持读屏软件，根据⽂章可以⾃动⽣成⽬录等，方便特殊人群无障碍的使用这些网页程序。 |\r\n\r\n**语义化的适用性：**\r\n\r\n语义化适合内容型的网站来使用（如简书、知乎），对其⽹站内容的传播有很⼤帮助。\r\n\r\n\r\n\r\n## 5. HTML5 对比 HTML4 有哪些不同之处？\r\n\r\n**考察点: 是否了解 html5 新增的一些新特性**\r\n\r\n| 不同点                                  | 备注说明                                                     |\r\n| --------------------------------------- | ------------------------------------------------------------ |\r\n| 只有一种 DOCTYPE ⽂件类型声明(统一标准) | `<!DOCTYPE html>`                                            |\r\n| 增加了一些新的标签元素(功能, 语义化)    | **section**, **video**, progress, **nav**, meter, time, **aside**, <br/>**canvas**, command, datalist, details, embed, figcaption, <br/>figure, **footer**, **header**, hgroup... |\r\n| input 支持了几个新的类型值              | `date, email, url` 等等                                      |\r\n| 新增了一些标签属性                      | charset（⽤于 meta 标签）；async（⽤于 script 标签）         |\r\n| 新增的全域属性                          | contenteditable, draggable... <br/>hidden...                 |\r\n| 新增API                                 | 本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket... |\r\n\r\n获取地理定位: navigator.geolocation.getCurrentPosition(successCallback, errorCallback) (为了安全, 需要在 https 网站使用)\r\n\r\n记忆角度: 更标准, 新增标签, 新增type表单属性, 新增全域属性, 新增API...\r\n\r\n\r\n\r\n\r\n\r\n## 6. meta 标签有哪些常用用法？\r\n\r\n`<meta>` 标签的具体功能一般由 name/http-equiv 和 content 两部分属性来定义。\r\n\r\n- 如果设置 name 属性，则它描述的是网页文档的信息（例如：作者、⽇期和时间、⽹⻚描述、 关键词）\r\n- 如果设置 http-equiv 属性，则它描述的相当于是 HTTP 响应头信息（例如：网页内容信息, 网页缓存等）\r\n\r\n**一些常用的功能及写法：**\r\n\r\n1. 设置网页关键词 (SEO)\r\n\r\n```html\r\n<meta name="keywords" content="电商,好货,便宜">\r\n```\r\n\r\n2. 设置网页视口（viewport）控制视⼝的⼤⼩、缩放和⽐例等 (移动端开发)\r\n\r\n```html\r\n<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">\r\n```\r\n\r\n3. 设置 http 响应头：Content-Type 网页内容类型  (字符集)\r\n\r\n```html\r\n<meta http-equiv="content-type" content="text/html;charset=utf-8">\r\n\r\n\x3c!-- 设置字符集可简写为 --\x3e\r\n<meta charset="utf-8">\r\n```\r\n\r\n\r\n\r\n## 7. img 标签的 srcset 的作用是什么？\r\n\r\n**考察点: 处理响应式图片的方式** (css媒体查询换的是背景图片, 而不是 img 标签的 src)\r\n\r\n开发者和设计师们竞相寻求 **处理响应式图片** 的方法。这的确是一个[棘手的问题](https://css-tricks.com/responsive-images-hard/) ，因为我们对同一个网站在众多设备宽度下，\r\n\r\n使用同一图像源。你愿意在一个大显示屏上显示模糊地、马赛克状的图像？\r\n\r\n你愿意在你的手机上加载一个巨大的（虽然更漂亮的）图像？这个问题令人左右为难。 [博客链接](https://www.jiangweishan.com/article/response-srcset-sizes.html)\r\n\r\n其实通过使用 img 标签的 srcset 属性，可定义一组额外的图片集合，让浏览器根据不同的屏幕状况选取合适的图片来显示。\r\n\r\n> 也就是图片的响应式处理能力。\r\n\r\n如果你的响应式需求比较简单，只需要针对屏幕的不同 dpr （device pixel ratio，设备像素比）来决定图片的显示的话，\r\n\r\ndpr 设备像素比, 越高, 能够显示的越清晰  (dpr: 2, dpr: 3)\r\n\r\n那么就只要这么写：\r\n\r\n```html\r\n<img srcset="320.png 1x, 640.png 2x, 960.png 3x" />\r\n```\r\n\r\n对于可变宽度的图像，我们使用`srcset`搭配`w`描述符以及`sizes`属性 。\r\n\r\n- `w`描述符告诉浏览器列表中的每个图象的宽度。\r\n\r\n- `sizes`属性需要至少包含两个值，是由逗号分隔的列表。\r\n\r\n根据最新规范，如果`srcset`中任何图像使用了`w`描述符，那么必须要设置`sizes`属性。\r\n\r\n`sizes`属性有两个值：\r\n\r\n1. 第一个是媒体查询条件；\r\n\r\n2. 第二个是图片对应的尺寸值，\r\n\r\n   在特定媒体条件下，此值决定了图片的宽度。\r\n\r\n   需要注意是，源图尺寸值不能使用百分比，如果要用100%,  `vw`是唯一可用的CSS单位。\r\n\r\n```html\r\n<img alt="img元素srcset属性浅析"\r\n  srcset="\r\n    320.png 320w, \r\n    480.png 480w, \r\n    640.png 640w"\r\n  sizes="\r\n    (max-width: 320px) 100vw, \r\n    (max-width: 360px) 320px,\r\n    (max-width: 480px) 360px,\r\n    (max-width: 640px) 480px,\r\n    640px"\r\n  src="640.png"\r\n/>\r\n```\r\n\r\n为 img 定义以上属性后，浏览器的工作流程如下：\r\n\r\n1. 检查设备的实际宽度\r\n2. 检查 img 标签的 sizes 属性中定义的媒体查询条件列表，并计算哪个条件最先匹配到\r\n3. 得到图片此时的响应式宽度\r\n4. 加载 srcset 中最接近, 最适合媒体查询匹配到的宽度的图片\r\n\r\n注意: 测试时, 清除缓存测试, 因为一旦加载了高清图, 就不会也没有必要, 回过去再用小图替换了\r\n\r\n且我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。\r\n\r\n(译者注：srcset和size列表是对浏览器的一个建议(hint)，而非指令。由浏览器根据其能力、网络等因素来决定。)\r\n\r\n\r\n\r\n## 8. 响应式图片处理优化: Picture 标签\r\n\r\n**考察点: 响应式图片处理**\r\n\r\n`picture`元素就像是图像和其源的容器。浏览器仍然需要`img`元素，用来表明需要加载的图片\r\n\r\n在 `<picture>` 下可放置零个或多个`<source>`标签、以及一个`<img>`标签，为不同的屏幕设备和场景显示不同的图片。\r\n\r\n如果source匹配到了, 就会优先用匹配到的, 如果没有匹配到会往下继续找\r\n\r\n使用`picture`元素选择图像，不会有歧义。\r\n\r\n浏览器的工作流程如下：\r\n\r\n- 浏览器会先根据当前的情况，去匹配和使用`<source>`提供的图片\r\n\r\n- 如果未匹配到合适的`<source>`，就使用`<img>`标签提供的图片\r\n\r\n```html\r\n<picture>\r\n  <source srcset="640.png" media="(min-width: 640px)">\r\n  <source srcset="480.png" media="(min-width: 480px)">\r\n  <img src="320.png" alt="">\r\n</picture>\r\n```\r\n\r\n\r\n\r\n## 9. 在 script 标签上使用 defer 和 async 的区别是什么？\r\n\r\n**明确: defer 和 async 的使用, 可以用于提升网页性能**\r\n\r\nscript标签存在两个属性，defer和async，因此 script标签 的使用分为三种情况：\r\n\r\n1. `<script src="example.js"><\/script>`\r\n\r\n   没有defer或async属性，浏览器会立即加载并执行相应的脚本。\r\n\r\n   不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载\r\n\r\n2. `<script async src="example.js"><\/script>`\r\n\r\n   有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；\r\n\r\n3. `<script defer src="example.js"><\/script>`\r\n\r\n   有了defer属性，加载后续文档的过程和js脚本的加载是并行进行的(异步)，此时的js脚本仅加载不执行, js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。\r\n\r\n下图是使用了 defer、async、和未使用时的运行情况对比：\r\n\r\n<img src="\\images\\image-20210209172314832.png" alt="image-20210209172314832" />\r\n\r\n> 【上图的图例说明】\r\n>\r\n> 绿线：HTML 的解析时间\r\n>\r\n> 蓝线：JS 脚本的加载时间\r\n>\r\n> 红色：JS 脚本的执行时间\r\n\r\n从图中我们可以明确一下几点：\r\n\r\n　　1.defer和async在网络加载过程是一致的，都是异步执行的；(放在页面顶部, 也不会阻塞页面的加载, 与页面加载同时进行)\r\n\r\n　　2.两者的区别, 脚本加载完成之后, async是立刻执行, defer会等一等 (等前面的defer脚本执行, 等dom的加载)\r\n\r\n所以, js脚本加上 async 或 defer, 放在头部可以减少网页的下载加载时间, 如果不考虑兼容性, 可以用于优化页面加载的性能\r\n\r\n```jsx\r\n<script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js"><\/script>\r\n<script src="https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js"><\/script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 10. 前端做本地数据存储的方式有哪些？\r\n\r\n<img src="\\images\\image-20210209174438863.png" alt="image-20210209174438863" />\r\n\r\n1. Cookies\r\n2. localStorage\r\n3. sessionStorage\r\n4. Web SQL\r\n5. IndexedDB\r\n\r\n\r\n\r\n## 11. 以上几种前端存储的区别是什么？\r\n\r\n| 方式名称       | 标准说明     | 功能说明                                                     |\r\n| -------------- | ------------ | ------------------------------------------------------------ |\r\n| Cookies        | HTML5 前加入 | 1.会为每个请求自动携带所有的Cookies数据，比较方便，但是也是缺点，浪费流量；<br>2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie) |\r\n| localStorage   | HTML5 加入   | 1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M |\r\n| sessionStorage | HTML5 加入   | 1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储 |\r\n| Web SQL        | 非标准功能   | 1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作； |\r\n| IndexedDB      | HTML5 加入   | 1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限 |\r\n\r\n---\r\n\r\n\r\n\r\n# CSS基础\r\n\r\n## 1. CSS选择器的优先级是怎么样的？\r\n\r\n**CSS选择器的优先级顺序：**\r\n\r\n`内联样式` > `ID选择器` > `类选择器` > `标签选择器`\r\n\r\n**优先级的计算：**\r\n\r\n优先级是由 A、B、C、D 四个值来决定的，具体计算规则如下\r\n\r\n- A={如果存在内联样式则为1，否则为0}\r\n- B={ID选择器出现的次数}\r\n- C={类选择器、属性选择器、伪类选择器出现的总次数}\r\n- D={标签选择器、伪元素选择器出现的总次数}\r\n\r\n**计算示例：**\r\n\r\n样式一：\r\n\r\n```css\r\n/*\r\n  A=0   不存在内联样式\r\n  B=0   不存在ID选择器\r\n  C=1   有一个类选择器\r\n  D=3   有三个标签选择器\r\n\r\n  最终计算结果：{0,0,1,3}\r\n*/\r\ndiv ul li .red { ... }\r\n```\r\n\r\n样式二：\r\n\r\n```css\r\n/*\r\n  A=0   不存在内联样式\r\n  B=1   有一个ID选择器\r\n  C=0   不存在类选择器\r\n  D=0   不存在标签选择器\r\n\r\n  最终计算结果：{0,1,0,0}\r\n*/\r\n#mydiv { ... }\r\n```\r\n\r\n计算完成后，我们通过从A到D的顺序进行值的大小比较，权重由A到D从高到低，只要比较出最大值即可。例如上面的两个样式：\r\n\r\n```md\r\n1. 样式一的A=0，样式二的A=0  【相等，继续往下比较】\r\n2. 样式一的B=0 < 样式二的B=1 【样式二的大，不继续往下比了，即认为样式二的优先级更高】\r\n```\r\n\r\n\r\n\r\n## 2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？\r\n\r\n| 方式                  | 说明                                                         |\r\n| --------------------- | ------------------------------------------------------------ |\r\n| opacity: 0            | 通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互 |\r\n| visibility: hidden    | 与透明度为0的方案非常类似，会占据空间，但不可以进行交互      |\r\n| overflow: hidden      | 只会隐藏元素溢出的部分；占据空间且不可交互                   |\r\n| display: none         | 可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局 |\r\n| z-index: -9999        | 通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果 |\r\n| transform: scale(0,0) | 通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互      |\r\n| left: -9999px         | 通过将元素定位到屏幕外面，达到看起来看不到的效果             |\r\n\r\n\r\n\r\n## 3. px、em、rem之间有什么区别？\r\n\r\n**考察点: 相对单位, 绝对单位, 以及适配问题**\r\n\r\n| 单位名称 | 说明                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| px       | 绝对单位。代表像素数量，页面会按照给出的精确像素进行展示     |\r\n| em       | 相对单位。默认的基准点为父元素的字体大小，而如果自身定义了字体大小则按自身的来算。所以即使在同一个页面内，1em可能不是一个固定的值。 |\r\n| rem      | 相对单位。可以理解为 `root em`，即基准点为根元素`<html>`的字体大小。rem是CSS3中新增单位，Chrome/FireFox/IE9+都支持, 一般用于做移动端适配 |\r\n\r\n正常开发 px 使用率较高, 如果要做 rem 适配, 会用到 rem 单位!\r\n\r\nrem布局的原理:\r\n\r\n1. 使用 rem 为单位\r\n2. 动态的设置 html font-size (媒体查询, js设置, 插件设置都可以)\r\n\r\nwebpack有工具, 可以写 px, 自动转 rem  https://youzan.github.io/vant/#/zh-CN/advanced-usage\r\n\r\n\r\n\r\n\r\n\r\n## 4. 让元素水平居中的方法有哪些？\r\n\r\n**方法一：使用 margin**\r\n\r\n通过为元素设置左右的 margin 为 auto，实现让元素居中。\r\n\r\n```html\r\n<div class="center">本内容会居中</div>\r\n```\r\n\r\n```scss\r\n.center {\r\n   height: 500px;\r\n   width: 500px;\r\n   background-color: pink;\r\n   margin: 0 auto;\r\n}\r\n```\r\n\r\n\r\n\r\n**方式二: 转成行内块,  给父盒子设置 text-align: center**\r\n\r\n```html\r\n<div class="father">\r\n\t<div class="center">我是内容盒子</div>\r\n</div>\r\n```\r\n\r\n```css\r\n.father {\r\n  text-align: center;\r\n}\r\n.center {\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: pink;\r\n  display: inline-block;\r\n}\r\n```\r\n\r\n\r\n\r\n**方法三：使用 flex 布局**\r\n\r\n使用 flex 提供的子元素居中排列功能，对元素进行居中。\r\n\r\n```html\r\n<div class="father">\r\n\t<div class="center">我是内容盒子</div>\r\n</div>\r\n```\r\n\r\n```css\r\n.father {\r\n  display: flex;\r\n  background-color: skyblue;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n.center {\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: pink;\r\n}\r\n```\r\n\r\n\r\n\r\n**方式四: 使用定位布局**\r\n\r\n```html\r\n<div class="father">\r\n  <div class="center">我是内容盒子</div>\r\n</div>\r\n```\r\n\r\n```css\r\n.father {\r\n  background-color: skyblue;\r\n  position: relative;\r\n  height: 500px;\r\n}\r\n.center {\r\n  width: 400px;\r\n  height: 400px;\r\n  background-color: pink;\r\n  position: absolute;\r\n  left: 50%;\r\n  top: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n```\r\n\r\n[【更多方式参考】实现水平居中垂直居中](https://www.cnblogs.com/chengxs/p/11231906.html)\r\n\r\n\r\n\r\n## 5. 在 CSS 中有哪些定位方式？\r\n\r\n也就是 position 样式的几个属性。\r\n\r\n\r\n\r\n**static 正常文档流定位**\r\n\r\n- 此时设置 top、right、bottom、left 以及 z-index 都无效\r\n\r\n- 块级元素遵循从上往下纵向排列，行级元素遵循从左到右排列\r\n\r\n\r\n\r\n**relative 相对定位**\r\n\r\n这个 **“相对”** 是指相对于正常文档流的位置。\r\n\r\n\r\n\r\n**absolute 绝对定位**\r\n\r\n当前元素相对于 **最近的非 static 定位的祖先元素 **来确定自己的偏移位置。\r\n\r\n例如，当前为 absolute 的元素的父元素、祖父元素都为 relative，则当前元素会相对于父元素进行偏移定位。\r\n\r\n\r\n\r\n**fixed 固定定位**\r\n\r\n当前元素相对于屏幕视口 viewport 来确定自己的位置。并且当屏幕滚动时，当前元素的位置也不会发生改变。\r\n\r\n\r\n\r\n**sticky 粘性定位**\r\n\r\n这个定位方式有点像 relative 和 fixed 的结合。当它的父元素在视口区域、并进入 top 值给定的范围内时，当前元素就以 fixed 的方式进行定位，否则就以 relative 的方式进行定位。\r\n\r\n```html\r\n<style>\r\n  * {\r\n    margin: 0;\r\n    padding: 0;\r\n  }\r\n  .header {\r\n    width: 100%;\r\n    height: 100px;\r\n    background-color: orange;\r\n  }\r\n  .nav {\r\n    width: 100%;\r\n    height: 200px;\r\n    background-color: pink;\r\n    position: sticky;\r\n    top: 0px;\r\n  }\r\n  .main {\r\n    width: 100%;\r\n    height: 100px;\r\n    background-color: skyblue;\r\n  }\r\n\r\n</style>\r\n\r\n<div class="header">我是头部</div>\r\n<div class="nav">我是导航</div>\r\n<div class="container">\r\n    <div class="main">我是主体部分1</div>\r\n    <div class="main">我是主体部分2</div>\r\n    <div class="main">我是主体部分3</div>\r\n    <div class="main">我是主体部分4</div>\r\n    <div class="main">我是主体部分5</div>\r\n    <div class="main">我是主体部分6</div>\r\n    <div class="main">我是主体部分7</div>\r\n    <div class="main">我是主体部分8</div>\r\n</div>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 6. 如何理解 z-index？\r\n\r\n可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。\r\n\r\n元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。\r\n\r\n\r\n\r\n<img src="\\images\\image-20210209212043708.png" alt="image-20210209212043708" style="zoom:70%;" />\r\n\r\n可以将这种关系想象成一摞书本，通过 z-index 可以改变一本书在这摞书中的上下位置。\r\n\r\nz-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级\r\n\r\n```html\r\n<style>\r\n  .father {\r\n    width: 100%;\r\n    height: 200px;\r\n    position: relative;\r\n    background-color: skyblue;\r\n    z-index: 1;\r\n  }\r\n  .son {\r\n    position: absolute;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: red;\r\n    left: 0;\r\n    top: 0;\r\n    z-index: 999;\r\n  }\r\n  .box2 {\r\n    position: absolute;\r\n    width: 100px;\r\n    height: 100px;\r\n    background-color: blue;\r\n    left: 0;\r\n    top: 0;\r\n    z-index: 100;\r\n  }\r\n</style>\r\n\r\n<div class="father">\r\n  <div class="son"></div>\r\n</div>\r\n\r\n<div class="box2"></div>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 7. 如何清除浮动 ？\r\n\r\n**考察: css基本功**\r\n\r\n可以有以下几种方式：\r\n\r\n1. 定高法\r\n\r\n2. 使用一个空的div，并设置样式\r\n\r\n```html\r\n<div style="clear:both"></div>\r\n```\r\n\r\n3. 为父元素添加 `overflow: hidden`\r\n\r\n4. 定义一个 clearfix 样式类\r\n\r\n```css\r\n.clearfix:after {\r\n  content: "";  \t\t\t/*设置内容为空*/\r\n  height: 0;    \t\t\t/*高度为0*/\r\n  line-height: 0;\t\t\t/*行高为0*/\r\n  display: block;\t\t\t/*将文本转为块级元素*/\r\n  visibility: hidden;\t/*将元素隐藏*/\r\n  clear: both; \t\t\t\t/*清除浮动*/\r\n}\r\n\r\n.clearfix {\r\n  zoom: 1; \t\t\t\t/*为了兼容IE*/\r\n}\r\n```\r\n\r\n说明：当前 flex 已成为主流布局方式，适应性强, 且稳定, 所以浮动使用率目前已逐步降低。 \r\n\r\n\r\n\r\n## 8. 谈谈你对 BFC 的理解？\r\n\r\n**什么是 BFC：**\r\n\r\nBFC 的全称是 Block Formatting Context，块级格式化上下文。这是一个用于在盒模型下布局块级盒子的独立渲染区域，\r\n\r\n将处于BFC区域内和区域外的元素进行互相隔离。\r\n\r\n\r\n\r\n**何时会形成 BFC：**\r\n\r\n满足下列条件之一就可触发BFC：\r\n\r\n- HTML根元素\r\n- position 值为 `absolute` 或 `fixed`\r\n- float 值不为 `none`\r\n- overflow 值不为 `visible`\r\n- display 值为 `inline-block`、`table-cell` 或 `table-caption`\r\n\r\n\r\n\r\n**BFC 的应用场景：**\r\n\r\n1. 场景一：防止两个相邻块级元素的上下 margin 发生重叠 (**上下margin合并问题**)\r\n\r\n属于同一 BFC 的, 两个相邻块级子元素的上下 margin 会重叠，如果想让它们不重叠，可通过让这两个相邻块级子元素分属于不同的BFC。\r\n\r\n以下示例代码中的两个盒子的上下外边距会重合（即它们都设置了10px的外边距，我们期望它们之间的间距是 20px，但实际效果却只有 10px）：\r\n\r\n```html\r\n<style>\r\n  .box1 {\r\n    width: 200px;\r\n    height: 100px;\r\n    background-color: red;\r\n    margin-bottom: 10px; /* 下外边距为 10px */\r\n  }\r\n\r\n  .box2 {\r\n    width: 200px;\r\n    height: 100px;\r\n    background-color: green;\r\n    margin-top: 10px;  /* 上外边距为 10px */\r\n  }\r\n</style>\r\n\r\n<div class="box1"></div>\r\n<div class="box2"></div>\r\n```\r\n\r\n<img src="/images/image-20210217142711472.png" alt="image-20210217142711472" style="zoom:50%;" />\r\n\r\n下面我们让其中一个盒子触发BFC，从而达到间隔 20px 的期望效果：\r\n\r\n```css\r\n.box2 {\r\n  width: 200px;\r\n  height: 100px;\r\n  background-color: green;\r\n  margin-top: 10px;\r\n  display: inline-block; /* 通过设置 display 为 inline-block 可以触发 BFC */\r\n}\r\n```\r\n\r\n<img src="/images/image-20210217143506046.png" alt="image-20210217143506046" style="zoom:50%;" />\r\n\r\n\r\n\r\n\r\n\r\n2. 场景二：**清除浮动**\r\n\r\n以下示例代码中， 容器元素 box1 的高度会没有高：\r\n\r\n```html\r\n<style>\r\n  .box1 {\r\n    width: 200px;\r\n    background-color: red;\r\n  }\r\n\r\n  .box2 {\r\n    float: left;\r\n    background-color: green;\r\n  }\r\n</style>\r\n\r\n<div class="box1">\r\n  <div class="box2">Hello,world</div>\r\n  <div class="box2">Hello,world</div>\r\n  <div class="box2">Hello,world</div>\r\n</div>\r\n```\r\n\r\n而通过为 box1 添加 BFC 触发条件，可以让它的高度变回正常状态：\r\n\r\n```css\r\n.box1 {\r\n  width: 200px;\r\n  background-color: red;\r\n  overflow: hidden;\r\n}\r\n```\r\n\r\n\r\n\r\n3. 场景三：**实现自适应布局**, 防止元素被浮动元素覆盖(左边固定, 右边自适应)\r\n\r\n以下示例中，box2 会被设置了浮动的 box1 覆盖：\r\n\r\n```html\r\n<style>\r\n  .box1 {\r\n    float: left;\r\n    width: 300px;\r\n    background-color: red;\r\n    height: 400px;\r\n  }\r\n\r\n  .box2 {\r\n    background-color: blue;\r\n    height: 600px;\r\n  }\r\n</style>\r\n\r\n<div class="box1"></div>\r\n<div class="box2"></div>\r\n```\r\n\r\n<img src="/images/image-20210217145325690.png" alt="image-20210217145325690" style="zoom:30%;" />\r\n\r\n要避免这种覆盖行为，可以让 box2 触发 BFC,  实现布局效果, 左边固定右边自适应：\r\n\r\n```css\r\n.box2 {\r\n  background-color: blue;\r\n  height: 600px;\r\n  overflow: hidden; /* 将 overflow 设置为非 visible 值可触发 BFC */\r\n}\r\n```\r\n\r\n<img src="/images/image-20210217145504963.png" alt="image-20210217145504963" style="zoom:30%;" />\r\n\r\n\r\n\r\n[参考文章：深入理解BFC](https://www.cnblogs.com/xiaohuochai/p/5248536.html)\r\n\r\n\r\n\r\n## 9. 什么是CSS Sprites以及它的好处？\r\n\r\n**考察: 性能优化的方案**\r\n\r\nCSS Sprites，俗称雪碧图、精灵图。这是一种CSS图片合并技术，就是将CSS中原先引用的一些较小的图片，合并成一张稍大的图片后再引用的技术方案。它可以减少请求多张小图片带来的网络消耗（因为发起的HTTP请求数变少了），并实现提前加载资源的效果。\r\n\r\n**操作方式：**\r\n\r\n可以手工使用图片编辑软件（如Photoshop），将多张小图片合并编辑变成一张大图片，并针对这张大图片，编写CSS样式来引用这张大图片中对应位置的小图片（涉及到的样式：background-image、background-position、background-size）。然后在HTML元素中使用这些样式即可。\r\n\r\nhttps://img.alicdn.com/tfs/TB1eiXTXlTH8KJjy0FiXXcRsXXa-24-595.png\r\n\r\n**缺点：**\r\n\r\n- CSS Sprites中任意一张小图的改动，都需要重新生成大图；并且用户端需要重新下载整张大图，这就降低了浏览器缓存的优势\r\n- 随着HTTP2的逐渐普及，HTTP2的多路复用机制可以解决请求多个小图片所创建多个HTTP请求的消耗，让CSS Sprites存在的价值降低了\r\n- 图片如果放大, 是会失真\r\n\r\n目前其他主流的处理图片的方案:  iconfont 字体图标, svg矢量图...\r\n\r\n\r\n\r\n## 10. 你对媒体查询的理解是什么样的？\r\n\r\n**考察点: 响应式适配**, 根据不同的屏幕尺寸, 显示不同的效果 (设置盒子的样式)\r\n\r\n媒体查询是自 CSS3 开始加入的一个功能。它可以进行响应式适配展示。\r\n\r\n媒体查询由两部分组成：\r\n\r\n- 一个可选的媒体类型（如 screen、print 等）\r\n- 零个或多个媒体功能限定表达式（如 max-width: 500px、orientation: landscape 等）\r\n\r\n这两部分最终都会被解析为 true 或 false 值，然后整个媒体查询值为 true，则和该媒体查询关联的样式就生效，否则就不生效。\r\n\r\n**使用示例：**\r\n\r\n```css\r\n/* 在css样式表的定义中直接使用媒体查询 */ \r\n.container {\r\n  width: 600px;\r\n  height: 200px;\r\n  background-color: pink;\r\n  margin: 0 auto;\r\n}\r\n@media screen and (max-width: 767px) {\r\n  .container {\r\n    width: 100%;\r\n  }\r\n}\r\n@media screen and (min-width: 768px) and (max-width: 991px) {\r\n  .container {\r\n    width: 750px;\r\n  }\r\n}\r\n@media screen and (min-width: 992px) and (max-width: 1199px) {\r\n  .container {\r\n    width: 980px;\r\n  }\r\n}\r\n@media screen and (min-width: 1200px) {\r\n  .container {\r\n    width: 1170px;\r\n  }\r\n}\r\n@media screen and (width: 1200px) {\r\n  .container {\r\n    background-color: skyblue;\r\n  }\r\n}\r\n```\r\n\r\n[参考文章：深入理解CSS媒体查询](https://www.cnblogs.com/xiaohuochai/p/5848612.html)\r\n\r\n\r\n\r\n## 11. 你对盒子模型的理解是什么样的？\r\n\r\n浏览器的渲染引擎在对网页文档进行布局时，会按照 “CSS 基础盒模型” （CSS Basic Box Model）标准，将文档中的所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）。\r\n\r\n\r\n\r\n下图就是盒模型示意图，它由几部分组成：\r\n\r\n- 内容（content）\r\n- 内边距（padding）\r\n- 边框（border）\r\n- 外边距（margin）\r\n\r\n<img src="/images/image-20210214144941345.png" alt="image-20210214144941345" style="zoom:25%;" />\r\n\r\n\r\n\r\n\r\n\r\n## 12. 标准盒模型和怪异盒模型有哪些区别？\r\n\r\n两者的区别主要体现在元素尺寸的表示上。\r\n\r\n**盒模型的指定：**\r\n\r\n在CSS3中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：\r\n\r\n- content-box    标准盒模型\r\n- border-box     怪异盒模型\r\n\r\n**标准盒模型：**\r\n\r\nbox-sizing: content-box; (默认值)\r\n\r\n在标准盒模型下，元素的宽（width）和高（height）值即为盒模型中内容（content）的实际宽高值。\r\n\r\n<img src="/images/image-20210214150511841.png" alt="image-20210214150511841" style="zoom:25%;" />\r\n\r\n\r\n\r\n因此，计算一个元素宽度的公式如下(不考虑margin, margin是外边距,  如果是计算占用页面的空间, 就要带上margin)：\r\n\r\n> 盒子宽度 =  `border-left` + `padding-left` + `width` + `padding-right` + `border-right`\r\n>\r\n> 占据页面宽度 = `margin-left` + `border-left` + `padding-left` + `width` + `padding-right` + `border-right` + `margin-right`\r\n\r\n\r\n\r\n**怪异盒模型：**\r\n\r\nbox-sizing: border-box; (目前主流常用值)\r\n\r\n在怪异盒模型下，元素的 width 和 height 值却不是 content 的实际宽高，而是去除 margin 后剩下的元素占用区域的宽高，即：\r\n\r\n<img src="/images/image-20210214151037552.png" alt="image-20210214151037552" style="zoom:25%;" />\r\n\r\n\r\n\r\n因此，计算一个元素占用了页面总宽度的公式如下：\r\n\r\n> 盒子宽度 =  `width`\r\n>\r\n> 盒子占据页面宽度 = `margin-left` + `width` + `margin-right`\r\n\r\n[参考文章：深入理解盒模型](https://www.cnblogs.com/xiaohuochai/p/5202597.html)\r\n\r\n\r\n\r\n\r\n\r\n## 13. 说说伪类和伪元素的区别？\r\n\r\n**什么是伪类？**\r\n\r\n伪类（pseudo-class）是以冒号`:`为前缀，可被添加到⼀个选择器的末尾的关键字。\r\n\r\n它用于让样式在元素的特定状态下才被应用到实际的元素上。比如：`:checked`、`:hover`、`:disabled`、 `:first-child`等。\r\n\r\n:hover\r\n\r\n:nth-child(1)\r\n\r\n:nth-child(2)\r\n\r\n:checked\r\n\r\n注意: 伪类, 虽然是写法比较特殊, css选择器的权重, 和类一致的\r\n\r\n\r\n\r\n**什么是伪元素？**\r\n\r\n:before / :after\r\n\r\n伪元素⽤于创建⼀些并不在 DOM 树中的元素，并为其添加样式。伪元素的语法和伪类类似，可以一个冒号或两个冒号为前缀。\r\n\r\n⽐如，可以通过 `:before` 、`:after` 来在⼀个元素前、后增加⼀些额外的⽂本并为它们添加样式；\r\n\r\n并且，虽然⽤户可以看到这些⽂本，但其实它们并不在 DOM 树中。(**坑: 伪元素是无法注册事件的, 所以不要通过js控制伪元素**)\r\n\r\n\r\n\r\n**两者的区别**\r\n\r\n虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。\r\n\r\n- 伪类是用来匹配元素的特殊状态的\r\n- 伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现\r\n\r\n[参考文章：伪类与伪元素](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)\r\n\r\n\r\n\r\n## 14. 谈谈你对 flex 的理解？\r\n\r\n在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。\r\n\r\nflex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。 \r\n\r\n你能联想到的flex语法有哪些呢?\r\n\r\nflex-direction: 调整主轴方向\r\n\r\n```txt\r\nrow：主轴方向为水平向右\r\ncolumn：主轴方向为竖直向下\r\nrow-reverse:主轴方向为水平向左\r\ncolumn-reverse:主轴方向是竖直向上。\r\n```\r\n\r\njustify-content主要用来设置**主轴方向的对齐方式**\r\n\r\n```\r\nflex-start: 弹性盒子元素将向起始位置对齐\r\nflex-end: 弹性盒子元素将向结束位置对齐。\r\ncenter: 弹性盒子元素将向行中间位置对齐\r\nspace-around: 弹性盒子元素会平均地分布在行里\r\nspace-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。\r\n```\r\n\r\nalign-items用于调整**侧轴的对齐方式**\r\n\r\n```txt\r\nflex-start： 元素在侧轴的起始位置对齐。 \r\nflex-end： 元素在侧轴的结束位置对齐。\r\ncenter： 元素在侧轴上居中对齐。\r\nstretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。\r\n```\r\n\r\nflex-wrap属性控制flex容器是单行或者多行,默认不换行\r\n\r\n```txt\r\nnowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。\r\nwrap： 当宽度不够的时候，会换行。\r\n```\r\n\r\nalign-content用来设置多行的flex容器的排列方式\r\n\r\n```txt\r\nflex-start： 各行向侧轴的起始位置堆叠。 \r\nflex-end： 各行向弹性盒容器的结束位置堆叠。\r\ncenter： 各行向弹性盒容器的中间位置堆叠。\r\nspace-around： 各行在侧轴中平均分布。 \r\nspace-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 \r\nstretch：拉伸，不设置高度的情况下。\r\n```\r\n\r\n> 可参考 [flex布局教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\r\n\r\n---\r\n\r\n\r\n\r\n# JavaScript基础\r\n\r\n## 1. 解释下什么是变量声明提升？\r\n\r\n变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。\r\n\r\nJS引擎在运行一份代码的时候，会按照下面的步骤进行工作：\r\n\r\n1. 首先，对代码进行预解析，并获取声明的所有变量\r\n\r\n2. 然后，将这些变量的声明语句统一放到代码的最前面\r\n\r\n3. 最后，开始一行一行运行代码\r\n\r\n\r\n\r\n我们通过一段代码来解释这个运行过程：\r\n\r\n```js\r\nconsole.log(a) \r\n\r\nvar a = 1 \r\n\r\nfunction b() { \r\n  console.log(a) \r\n}\r\n\r\nb() // 1\r\n```\r\n\r\n\r\n\r\n上⾯这段代码的实际执⾏顺序为: \r\n\r\n1. JS引擎将 `var a = 1` 分解为两个部分：变量声明语句 `var a = undefined` 和变量赋值语句 `a = 1` \r\n2. JS引擎将 `var a = undefined` 放到代码的最前面，而 `a = 1` 保留在原地 \r\n\r\n\r\n\r\n也就是说经过了转换，代码就变成了:\r\n\r\n```js\r\nvar a = undefined\r\n\r\nconsole.log(a) // undefined \r\n\r\na = 1\r\n\r\nfunction b() { \r\n  console.log(a) \r\n}\r\n\r\nb() // 1\r\n```\r\n\r\n\r\n\r\n变量的这一转换过程，就被称为变量的声明提升。\r\n\r\n而这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题\r\n\r\n\r\n\r\n## 2. JS 的参数是以什么方式进行传递的？\r\n\r\n基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。\r\n\r\n**基本类型：是值传递**！\r\n\r\n基本类型的传递方式比较简单，是按照 `值传递` 进行的。\r\n\r\n```js\r\nlet a = 1\r\n\r\nfunction test(x) { \r\n  x = 10  // 并不会改变实参的值\r\n  console.log(x)\r\n}\r\n\r\ntest(a) // 10 \r\nconsole.log(a) // 1\r\n```\r\n\r\n\r\n\r\n**复杂类型: 传递的是地址! (变量中存的就是地址)**\r\n\r\n![image-20210305165413588](images/image-20210305165413588.png)\r\n\r\n来看下面的代码：\r\n\r\n```js\r\nlet a = {\r\n  count: 1 \r\n}\r\n\r\nfunction test(x) { \r\n  x.count = 10\r\n  console.log(x)\r\n}\r\n\r\ntest(a) // { count: 10 }\r\nconsole.log(a) // { count: 10 }\r\n```\r\n\r\n从运行结果来看，函数内改变了参数对象内的 `count` 后，外部的实参对象 `a` 的内容也跟着改变了，所以传递的是地址。\r\n\r\n思考题:\r\n\r\n```js\r\nlet a = {\r\n  count: 1 \r\n}; \r\n\r\nfunction test(x) { \r\n  x = { count: 20 };\r\n  console.log(x); \r\n}\r\n\r\ntest(a); // { count: 20 }\r\nconsole.log(a); // { count: 1 }\r\n```\r\n\r\n![image-20210305165848781](images/image-20210305165848781.png)\r\n\r\n我们会发现外部的实参对象 `a` 并没有因为在函数内对形参的重新赋值而被改变！\r\n\r\n因为当我们直接为这个形参变量重新赋值时，其实只是让形参变量指向了别的堆内存地址，而外部实参变量的指向还是不变的。\r\n\r\n下图展示的是复杂类型参数传递后的状态：\r\n\r\n<img src="/images/image-20210218233241397.png" alt="image-20210218233241397" style="zoom:50%;" />\r\n\r\n下图展示的是重新为形参赋值后的状态：\r\n\r\n<img src="/images/image-20210218233343016.png" alt="image-20210218233343016" style="zoom:50%;" />\r\n\r\n\r\n\r\n\r\n\r\n## 3. JavaScript垃圾回收是怎么做的？\r\n\r\nJS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。\r\n\r\n正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，\r\n\r\n但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。\r\n\r\n###  3.1 内存的生命周期\r\n\r\nJS环境中分配的内存, 一般有如下生命周期：\r\n\r\n1. 内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存\r\n\r\n2. 内存使用：即读写内存，也就是使用变量、函数等\r\n\r\n3. 内存回收：使用完毕，由垃圾回收自动回收不再使用的内存\r\n\r\n   全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉\r\n\r\n内存分配:\r\n\r\n```jsx\r\n// 为变量分配内存\r\nlet i = 11\r\nlet s = "ifcode"\r\n\r\n// 为对象分配内存\r\nlet person = {\r\n    age: 22,\r\n    name: \'ifcode\'\r\n}\r\n\r\n// 为函数分配内存\r\nfunction sum(a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n### 3.2 垃圾回收算法说明\r\n\r\n所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉\r\n\r\n下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法\r\n\r\n### 3.3 引用计数\r\n\r\nIE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。\r\n\r\n如果没有任何变量指向它了，说明该对象已经不再需要了。\r\n\r\n```jsx\r\n// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1\r\nlet person = {\r\n    age: 22,\r\n    name: \'ifcode\'\r\n}\r\n\r\nlet p = person   // 两个变量指向一块内存空间, 该内存空间的引用数为 2\r\nperson = 1       // 原来的person对象被赋值为1，对象内存空间的引用数-1,\r\n                 // 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收\r\n\r\np = null         // 原person对象已经没有引用，会被回收\r\n```\r\n\r\n由上面可以看出，引用计数算法是个简单有效的算法。\r\n\r\n**但它却存在一个致命的问题：循环引用。**\r\n\r\n如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。\r\n\r\n```jsx\r\nfunction cycle() {\r\n    let o1 = {}\r\n    let o2 = {}\r\n    o1.a = o2\r\n    o2.a = o1 \r\n    return "Cycle reference!"\r\n}\r\n\r\ncycle()\r\n```\r\n\r\n![image-20210305172448582](images/image-20210305172448582.png)\r\n\r\n\r\n\r\n### 3.4 标记清除算法\r\n\r\n现代的浏览器已经不再使用引用计数算法了。\r\n\r\n现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。\r\n\r\n标记清除法:\r\n\r\n- 标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 \r\n\r\n- 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。\r\n\r\n- 凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。\r\n\r\n从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。\r\n\r\n根据这个概念，上面的例子可以正确被垃圾回收处理了。\r\n\r\n参考文章：[JavaScript内存管理](https://www.jianshu.com/p/84a8fd5fa0ee)\r\n\r\n\r\n\r\n## 4. 谈谈你对 JavaScript 作用域链的理解？\r\n\r\nJavaScript 在执⾏过程中会创建一个个的**可执⾏上下⽂**。 (每个函数执行都会创建这么一个可执行上下文)\r\n\r\n每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。\r\n\r\n这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。\r\n\r\n\r\n\r\n简而言之: 函数内部 可以访问到 函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,\r\n\r\n这样的变量作用域访问的链式结构, 被称之为作用域链\r\n\r\n```js\r\nlet num = 1\r\n\r\nfunction fn () {\r\n  let a = 100\r\n  function inner () {\r\n    console.log(a)\r\n    console.log(num)\r\n  }\r\n  inner()\r\n}\r\nfn()\r\n```\r\n\r\n\r\n\r\n下图为由多个可执行上下文组成的调用栈：\r\n\r\n- 栈最底部为`全局可执行上下文`\r\n- `全局可执行上下文` 之上有多个 `函数可执行上下文`\r\n- 每个可执行上下文中包含了指向外部其他可执行上下文的引用，直到 `全局可执行上下文` 时它指向 `null`\r\n\r\n<img src="/images/image-20210218143938843.png" alt="image-20210218143938843" style="zoom:30%;" />\r\n\r\n![image-20210306093300970](images/image-20210306093300970.png)\r\n\r\njs全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈\r\n\r\n每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用 \r\n\r\n**=> 就形成了作用域链**\r\n\r\n\r\n\r\n\r\n\r\n## 5. 谈谈你对闭包的理解？\r\n\r\n这个问题想考察的主要有两个方面：\r\n\r\n- 对闭包的基本概念的理解\r\n- 对闭包的作用的了解\r\n\r\n**什么是闭包？**\r\n\r\nMDN的官方解释：\r\n\r\n> 闭包是函数和声明该函数的词法环境的组合\r\n\r\n更通俗一点的解释是：\r\n\r\n> 内层函数, 引用外层函数上的变量, 就可以形成闭包\r\n\r\n需求: 定义一个计数器方法, 每次执行一次函数, 就调用一次进行计数\r\n\r\n```js\r\nlet count = 0\r\nfunction fn () {\r\n  count++\r\n  console.log(\'fn函数被调用了\' + count + \'次\')\r\n}\r\nfn()\r\n```\r\n\r\n这样不好! count 定义成了全局变量, 太容易被别人修改了,  我们可以利用闭包解决\r\n\r\n闭包实例:\r\n\r\n```jsx\r\nfunction fn () {\r\n  let count = 0\r\n\r\n  function add () {\r\n    count++\r\n    console.log(\'fn函数被调用了\' + count + \'次\')\r\n  }\r\n\r\n  return add\r\n}\r\nconst addFn = fn()\r\naddFn()\r\naddFn()\r\naddFn()\r\n```\r\n\r\n\r\n\r\n**闭包的主要作用是什么？**\r\n\r\n在实际开发中，闭包最大的作用就是用来 **变量私有**。\r\n\r\n下面再来看一个简单示例：\r\n\r\n```js\r\nfunction Person() {\r\n  // 以 let 声明一个局部变量，而不是 this.name\r\n  // this.name = \'zs\'     =>  p.name\r\n  let name = \'hm_programmer\' // 数据私有\r\n  \r\n  this.getName = function(){ \r\n    return name\r\n  }\r\n  \r\n  this.setName = function(value){ \r\n    name = value\r\n  }\r\n}\r\n\r\n// new:\r\n// 1. 创建一个新的对象\r\n// 2. 让构造函数的this指向这个新对象\r\n// 3. 执行构造函数\r\n// 4. 返回实例\r\nconst p = new Person()\r\nconsole.log(p.getName()) // hm_programmer\r\n\r\np.setName(\'Tom\')\r\nconsole.log(p.getName()) // Tom\r\n\r\np.name // 访问不到 name 变量：undefined\r\n```\r\n\r\n在此示例中，变量 `name` 只能通过 Person 的实例方法进行访问，外部不能直接通过实例进行访问，形成了一个私有变量。\r\n\r\n\r\n\r\n## 6. JavaScript中数据类型的隐式转换规则(了解)\r\n\r\n在if语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。\r\n\r\n下表展示了一系列原始值，通过隐式转换成数字、字符串、布尔类型后所得到的值：\r\n\r\n<img src="/images/image-20210218171603780.png" alt="image-20210218171603780" style="zoom:45%;" />\r\n\r\n坑: 判断时,  尽量不要用 `= =` , 要用 `= = =` ( 两个等号判断,  如果类型不同,  默认会进行隐式类型转换再比较)\r\n\r\n\r\n\r\n## 7. 谈谈你对原型链的理解？\r\n\r\n要讲清楚这个问题，主要着重这几个方面：\r\n\r\n- 什么是原型对象\r\n- 构造函数, 原型对象, 实例的三角关系图\r\n- 原型链如何形成\r\n\r\n![image-20210306104516852](images/image-20210306104516852.png)\r\n\r\n**原型对象**\r\n\r\n在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 `prototype` 的属性，指向原型对象，\r\n\r\n基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。\r\n\r\n例如我们的 `hasOwnProperty`, `toString` ⽅法等其实是 Obejct 原型对象的方法，它可以被任何对象当做⾃⼰的⽅法来使⽤。\r\n\r\n`hasOwnProperty` 用于判断, 某个属性, 是不是自己的  (还是原型链上的)\r\n\r\n来看一段代码：\r\n\r\n```js\r\nlet person = { \r\n  name: "Tom", \r\n  age: 18, \r\n  job: "student"\r\n}\r\n\r\nconsole.log(person.hasOwnProperty("name")) // true \r\nconsole.log(person.hasOwnProperty("hasOwnProperty")) // false \r\nconsole.log(Object.prototype.hasOwnProperty("hasOwnProperty")) // true\r\n```\r\n\r\n可以看到，`hasOwnProperty` 并不是 `person` 对象的属性，但是 `person` 却能调用它。\r\n\r\n那么 `person` 对象是如何找到 Object 原型中的 `hasOwnProperty` 的呢？这就要靠原型链的能力了。\r\n\r\n需求: 简单绘制原型三角关系图!\r\n\r\n\r\n\r\n**原型链**\r\n\r\n在 JavaScript 中，每个对象中都有一个 `__proto__` 属性，这个属性指向了当前对象的构造函数的原型。\r\n\r\n对象可以通过自身的 `__proto__`属性与它的构造函数的原型对象连接起来，\r\n\r\n而因为它的原型对象也有 `__proto__`，因此这样就串联形成一个链式结构，也就是我们称为的原型链。\r\n\r\n<img src="/images/image-20210218212449526.png" alt="image-20210218212449526" style="zoom:50%;" />\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 6. 谈谈对于继承的理解\r\n\r\n**为什么要学习继承 ?**\r\n\r\n写的构造函数, 定义了一个类型 (人类), 万一项目非常大, 又有了细化的多个类型 (老师, 工人, 学生)\r\n\r\n学习继承, 可以让多个构造函数之间建立关联, 便于管理和复用\r\n\r\n**什么是继承 ?**\r\n\r\n继承: 从别人那里, 继承东西过来 (财产, 房产)\r\n\r\n代码层面的继承: 继承一些属性和方法\r\n\r\n### 6.1 继承 - 原型继承\r\n\r\n原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!\r\n\r\n分析需求:\r\n\r\n​\t人类, 属性: name, age\r\n\r\n​\t学生, 属性: name, age, className\r\n\r\n​\t工人, 属性: name, age, companyName\r\n\r\n无论学生, 还是工人, => 都是人类, 所以人类原型上有的方法, 他们都应该要有\r\n\r\n```js\r\n// 1. 定义Person构造函数\r\nfunction Person (name, age) {\r\n  this.name = name\r\n  this.age = age\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(\'人类会说话\')\r\n}\r\n\r\n// 2. 定义Student构造函数\r\nfunction Student (name, age, className) {\r\n  this.name = name\r\n  this.age = age\r\n  this.className = className\r\n}\r\n// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法\r\n// 语法: 子构造函数.prototype = new 父构造函数()\r\nStudent.prototype = new Person()\r\nStudent.prototype.study = function() {\r\n  console.log(\'学生在学习\')\r\n}\r\n\r\nlet stu = new Student(\'张三\', 18, \'80期\')\r\nstu.say()\r\nconsole.log(stu)\r\n```\r\n\r\n![image-20210306111112493](images/image-20210306111112493.png)\r\n\r\n\r\n\r\n\r\n\r\n### 6.2 继承 - 组合继承\r\n\r\n组合继承有时候也叫伪经典继承，指的是将原型链 和 借用构造函数 call 技术组合到一块，\r\n\r\n从而发挥二者之长的一种继承模式，其背后的思路: **是使用原型链实现对原型属性和方法的继承 (主要是方法)，**\r\n\r\n**而通过借用构造函数来实现对实例属性构造的继承**。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的自己的属性。\r\n\r\n```js\r\n// 1. 定义Person构造函数\r\nfunction Person (name, age) {\r\n  this.name = name\r\n  this.age = age\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(\'人类会说话\')\r\n}\r\n\r\n// 2. 定义Student构造函数\r\nfunction Student (name, age, className) {\r\n  Person.call(this, name, age) // 实现构造属性的继承\r\n  this.className = className\r\n}\r\n\r\n// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法\r\n// 语法: 子构造函数.prototype = new 父构造函数()\r\nStudent.prototype = new Person()\r\nStudent.prototype.study = function() {\r\n  console.log(\'学生在学习\')\r\n}\r\n\r\nlet stu = new Student(\'张三\', 18, \'80期\')\r\nstu.say()\r\nconsole.log(stu)\r\n\r\n// 方法通过 原型继承\r\n// 属性通过 父构造函数的.call(this, name, age)\r\n```\r\n\r\n\r\n\r\n### 6.3 继承 - 寄生组合继承\r\n\r\nstudent实例上有 name age,  而原型 `__proto__`上不需要再有这些属性, 所以利用 Object.create 改装下\r\n\r\nObject.create(参数对象),  \r\n\r\n1. Object.create 会创建一个新对象,\r\n2. 并且这个新对象的`__proto__` 会指向传入的参数对象\r\n\r\n```js\r\n// 1. 定义Person构造函数\r\nfunction Person (name, age) {\r\n  this.name = name\r\n  this.age = age\r\n}\r\nPerson.prototype.say = function () {\r\n  console.log(\'人类会说话\')\r\n}\r\n\r\n// 2. 定义Student构造函数\r\nfunction Student (name, age, className) {\r\n  Person.call(this, name, age)\r\n  this.className = className\r\n}\r\n\r\n// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法\r\n// 语法: 子构造函数.prototype = new 父构造函数()\r\nStudent.prototype = Object.create(Person.prototype)\r\nStudent.prototype.study = function() {\r\n  console.log(\'学生在学习\')\r\n}\r\n\r\nlet stu = new Student(\'张三\', 18, \'80期\')\r\nstu.say()\r\nconsole.log(stu)\r\n\r\n\r\n// 总结:\r\n// Object.create() 以参数的对象, 作为新建对象的__proto__属性的值, 返回新建的对象\r\n```\r\n\r\n![image-20210306114638139](images/image-20210306114638139.png)\r\n\r\n\r\n\r\n\r\n\r\n### 6.4 es6 - class 实现继承 extends\r\n\r\n```jsx\r\n// 继承关键字 => extends\r\nclass Person {\r\n  constructor (name, age) {\r\n    this.name = name\r\n    this.age = age\r\n  }\r\n  jump () {\r\n    console.log(\'会跳\')\r\n  }\r\n}\r\n\r\nclass Teacher extends Person {\r\n  constructor (name, age, lesson) {\r\n    super(name, age) // extends 中, 必须调用 super(), 会触发执行父类的构造函数\r\n    this.lesson = lesson\r\n    console.log(\'构造函数执行了\')\r\n  }\r\n  sayHello () {\r\n    console.log(\'会打招呼\')\r\n  }\r\n}\r\n\r\nlet teacher1 = new Teacher(\'zs\', 18, \'体育\')\r\nconsole.log(teacher1)\r\n```\r\n\r\n\r\n\r\n## 8. 如何判断是否是数组？\r\n\r\n方法一：使用 `toString` 方法\r\n\r\n```js\r\nfunction isArray(arg) {\r\n\treturn Object.prototype.toString.call(arg) === \'[object Array]\'\r\n}\r\n\r\nlet arr = [1,2,3]\r\nisArray(arr)  // true\r\n```\r\n\r\n方法二：使用 ES6 新增的 `Array.isArray` 方法\r\n\r\n```js\r\nlet arr = [1,2,3]\r\nArray.isArray(arr) // true\r\n```\r\n\r\n\r\n\r\n## 9. 谈谈你对this的理解？\r\n\r\n`this` 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。\r\n\r\n\r\n\r\n**默认绑定** (指向window的情况)  (函数调用模式 fn() )\r\n\r\n默认情况下，`this` 会被绑定到全局对象上，比如在浏览器环境中就为`window`对象，在node.js环境下为`global`对象。\r\n\r\n如下代码展示了这种绑定关系：\r\n\r\n```js\r\nmessage = "Hello"; \r\n\r\nfunction test () { \r\n  console.log(this.message); \r\n}\r\n\r\ntest() // "Hello"\r\n```\r\n\r\n\r\n\r\n**隐式绑定** (谁调用, this指向谁) (方法调用模式 obj.fn() )\r\n\r\n如果函数的调用是从对象上发起时，则该函数中的 `this` 会被自动隐式绑定为对象：\r\n\r\n```js\r\nfunction test() {\r\n\tconsole.log(this.message); \r\n}\r\n\r\nlet obj = {\r\n  message: "hello,world",\r\n  test: test\r\n}\r\n\r\nobj.test() // "hello,world"\r\n```\r\n\r\n\r\n\r\n**显式绑定** (又叫做硬绑定)  (上下文调用模式, 想让this指向谁, this就指向谁)\r\n\r\n硬绑定 => call  apply  bind\r\n\r\n可以显式的进行绑定：\r\n\r\n```js\r\nfunction test() {\r\n\tconsole.log(this.message); \r\n}\r\n\r\nlet obj1 = {\r\n  message: "你好世界123"\r\n}\r\n\r\nlet obj2 = {\r\n  message: "你好世界456"\r\n}\r\n\r\ntest.bind(obj1)() // "你好世界123"\r\ntest.bind(obj2)() // "你好世界456"\r\n```\r\n\r\n\r\n\r\n**new 绑定** (构造函数模式)\r\n\r\n另外，在使用 `new` 创建对象时也会进行 `this` 绑定\r\n\r\n当使用 `new` 调用构造函数时，会创建一个新的对象并将该对象绑定到构造函数的 `this` 上：\r\n\r\n```js\r\nfunction Greeting(message) {\r\n\tthis.message = message;\r\n}\r\n\r\nvar obj = new Greeting("hello,world")\r\nobj.message // "hello,world"\r\n```\r\n\r\n小测试:\r\n\r\n```jsx\r\nlet obj = {\r\n    a: {\r\n        fn: function () {\r\n            console.log(this)\r\n        },\r\n        b: 10\r\n    }\r\n}\r\nobj.a.fn()\r\nlet temp = obj.a.fn;\r\ntemp()\r\n\r\n// -------------------------------------------------------------\r\n\r\nfunction Person(theName, theAge){\r\n    this.name = theName\r\n    this.age = theAge\r\n}\r\nPerson.prototype.sayHello = function(){ // 定义函数\r\n    console.log(this)\r\n}\r\n\r\nlet per = new Person("小黑", 18)\r\nper.sayHello()\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 10. 箭头函数中的this指向什么？\r\n\r\n箭头函数不同于传统函数，它其实没有属于⾃⼰的 `this`，\r\n\r\n它所谓的 `this` 是, 捕获其外层  上下⽂的 `this` 值作为⾃⼰的 `this` 值。\r\n\r\n并且由于箭头函数没有属于⾃⼰的 `this` ，它是不能被 `new` 调⽤的。\r\n\r\n\r\n\r\n我们可以通过 Babel 转换前后的代码来更清晰的理解箭头函数:\r\n\r\n```js\r\n// 转换前的 ES6 代码\r\nconst obj = { \r\n  test() { \r\n    return () => { \r\n      console.log(this === obj)\r\n    }\r\n  } \r\n}\r\n```\r\n\r\n```js\r\n// 转换后的 ES5 代码\r\nvar obj = { \r\n  test: function getArrow() { \r\n    var that = this\r\n    return function () { \r\n      console.log(that === obj)\r\n    }\r\n  } \r\n}\r\n```\r\n\r\n这里我们看到，箭头函数中的 `this` 就是它上层上下文函数中的 `this`。\r\n\r\n\r\n\r\n## 11. Promise 的静态方法\r\n\r\npromise的三个状态: pending(默认)   fulfilled(成功)   rejected(失败)\r\n\r\n1. resolve函数被执行时, 会将promise的状态从 pending 改成 fulfilled 成功\r\n2. reject函数被执行时, 会将promise的状态从pending 改成 rejected 失败\r\n\r\nPromise.reject()\r\n\r\n```js\r\nnew Promise((resolve, reject) => {\r\n\treject()\r\n})\r\n```\r\n\r\nPromise.resolve()\r\n\r\n```jsx\r\nnew Promise((resolve, reject) => {\r\n\tresolve()\r\n})\r\n```\r\n\r\n**Promise.all([promise1, promise2, promise3])**  等待原则, 是在所有promise都完成后执行, 可以用于处理一些`并发的任务`\r\n\r\n```jsx\r\n// 后面的.then中配置的函数, 是在前面的所有promise都完成后执行, 可以用于处理一些并发的任务\r\nPromise.all([promise1, promise2, promise3]).then((values) => {\r\n  // values 是一个数组, 会收集前面promise的结果 values[0] => promise1的成功的结果\r\n})\r\n```\r\n\r\nPromise.race([promise1, promise2, promise3]) 赛跑, 竞速原则, 只要三个promise中有一个满足条件, 就会执行.then(用的较少)\r\n\r\n![image-20210306144638905](images/image-20210306144638905.png)\r\n\r\n\r\n\r\n\r\n\r\n## 12. 宏任务 微任务 是什么\r\n\r\n小例题:\r\n\r\n```jsx\r\nconsole.log(1)\r\n\r\nsetTimeout(function() {\r\n\tconsole.log(2)\r\n}, 0)\r\n\r\nconsole.log(3)\r\n```\r\n\r\n宏任务: 主线程代码, setTimeout 等属于宏任务,  上一个宏任务执行完, 才会考虑执行下一个宏任务\r\n\r\n微任务: promise .then .catch的需要执行的内容, 属于微任务, 满足条件的微任务, 会被添加到当前宏任务的最后去执行\r\n\r\n![image-20201208040306978](images/image-20201208040306978.png)\r\n\r\n**事件循环队列 eventLoop**\r\n\r\n![image-20201208040235602](images/image-20201208040235602.png)\r\n\r\n例题1:\r\n\r\n```jsx\r\n  console.log(1)\r\n\r\n  setTimeout(function() {\r\n    console.log(2) // 宏任务\r\n  }, 0)\r\n\r\n  const p = new Promise((resolve, reject) => {\r\n    resolve(1000)\r\n  })\r\n  p.then(data => {\r\n    console.log(data)  // 微任务\r\n  })\r\n\r\n  console.log(3)\r\n```\r\n\r\n![image-20210306151137688](images/image-20210306151137688.png)\r\n\r\n\r\n\r\n例题2:\r\n\r\n```jsx\r\nasync function fn () {\r\n  console.log(111)\r\n}\r\nfn()\r\nconsole.log(222)\r\n```\r\n\r\n例题3:\r\n\r\n```jsx\r\nasync function fn () {\r\n  const res = await 2\r\n  console.log(res)\r\n}\r\nfn()\r\nconsole.log(222)\r\n```\r\n\r\n例题4:\r\n\r\n```jsx\r\nasync function fn () {\r\n  console.log(\'嘿嘿\')\r\n  const res = await fn2()\r\n  console.log(res)  // 微任务\r\n}\r\nasync function fn2 () {\r\n  console.log(\'gaga\')\r\n}\r\nfn()\r\nconsole.log(222)\r\n```\r\n\r\n![image-20210306152010989](images/image-20210306152010989.png)\r\n\r\n考察点: async 函数只有从 await 往下才是异步的开始\r\n\r\n\r\n\r\n## 13. async/await是什么？\r\n\r\nES7 标准中新增的 `async` 函数，从目前的内部实现来说其实就是 `Generator` 函数的语法糖。\r\n\r\n它基于 Promise，并与所有现存的基于Promise 的 API 兼容。 \r\n\r\n**async 关键字**\r\n\r\n1. `async` 关键字用于声明⼀个异步函数（如 `async function asyncTask1() {...}`） \r\n\r\n2. `async` 会⾃动将常规函数转换成 Promise，返回值也是⼀个 Promise 对象 \r\n\r\n4. `async` 函数内部可以使⽤ `await` \r\n\r\n**await 关键字**\r\n\r\n1. `await` 用于等待异步的功能执⾏完毕 `var result = await someAsyncCall()` \r\n\r\n2. `await` 放置在 Promise 调⽤之前，会强制async函数中其他代码等待，直到 Promise 完成并返回结果 \r\n\r\n3. `await` 只能与 Promise ⼀起使⽤\r\n\r\n4. `await` 只能在 `async` 函数内部使⽤ \r\n\r\n\r\n\r\n## 14. 相较于 Promise，async/await有何优势？\r\n\r\n1. 同步化代码的阅读体验（Promise 虽然摆脱了回调地狱，但 then 链式调⽤的阅读负担还是存在的）\r\n3. 和同步代码更一致的错误处理方式（ async/await 可以⽤成熟的 try/catch 做处理，比 Promise 的错误捕获更简洁直观） \r\n4. 调试时的阅读性, 也相对更友好\r\n\r\n\r\n\r\n## 15. 深拷贝 浅拷贝\r\n\r\n引用类型, 进行赋值时, 赋值的是地址\r\n\r\n1. 浅拷贝\r\n\r\n   ```jsx\r\n   let obj = {\r\n   \tname: \'zs\',\r\n   \tage: 18\r\n   }\r\n   let obj2 = {\r\n       ...obj\r\n   }\r\n   ```\r\n\r\n2. 深拷贝\r\n\r\n   ```jsx\r\n   let obj = {\r\n   \tname: \'zs\',\r\n   \tage: 18,\r\n       car: {\r\n           brand: \'宝马\',\r\n           price: 100\r\n       }\r\n   }\r\n   \r\n   let obj2 = JSON.parse(JSON.stringify(obj))\r\n   console.log(obj2)\r\n   ```\r\n\r\n   当然递归也能解决, 只是比较麻烦~\r\n   \r\n   ...\r\n\r\n其他方案, 可以参考一些博客\r\n\r\n---\r\n\r\n\r\n\r\n# HTTP协议\r\n\r\n## 1. HTTP有哪些⽅法？\r\n\r\nHTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD\r\n\r\nHTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT\r\n\r\n\r\n\r\n## 2. 各个HTTP方法的具体作用是什么？\r\n\r\n|  方法   | 功能                                                         |\r\n| :-----: | ------------------------------------------------------------ |\r\n|   GET   | 通常⽤于请求服务器发送某些资源                               |\r\n|  POST   | 发送数据给服务器                                             |\r\n|  HEAD   | 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源 |\r\n|   PUT   | ⽤于全量修改⽬标资源 (看接口, 也可以用于添加)                |\r\n| DELETE  | ⽤于删除指定的资源                                           |\r\n| OPTIONS | ⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全) |\r\n|  TRACE  | 该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断 |\r\n| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户) |\r\n|  PATCH  | ⽤于对资源进⾏部分修改                                       |\r\n\r\n\r\n\r\nGET POST PUT PATCH DELETE\r\n\r\nGET/DELETE  参数是在地址栏中传递的\r\n\r\nPUT/PATCH/POST 参数是在请求体传递的\r\n\r\n\r\n\r\n## 3. GET方法和POST方法有何区别？\r\n\r\n默认的http请求的内容, 在网络中传输, 明文的形式传递的  (https 对内容加密)\r\n\r\n|                  | GET方法                                                      | POST方法                                           |\r\n| ---------------- | ------------------------------------------------------------ | -------------------------------------------------- |\r\n| **数据传输⽅式** | 通过URL传输数据 (地址栏拼接参数)                             | 通过请求体传输                                     |\r\n| **数据安全**     | 数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息 | 数据因为在请求主体内，<br />所以有⼀定的安全性保证 |\r\n| **数据类型**     | 只允许 ASCII 字符                                            | ⽆限制                                             |\r\n| **GET⽆害**      | 刷新、后退等浏览器操作是⽆害的                               | 可能会引起重复提交表单                             |\r\n| **功能特性**     | 安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br />**幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）** | ⾮安全(会引起服务器端的变化)、**⾮幂等**           |\r\n\r\n\r\n\r\n## 4. HTTP请求报文是什么样的？\r\n\r\nHTTP 请求报⽂的组成：请求⾏、请求头、(空⾏)、请求体。\r\n\r\n实际请求报文实例:\r\n\r\n![image-20210305232854139](images/image-20210305232854139.png)\r\n\r\n**请求行**\r\n\r\n包含了请求⽅法、URL、HTTP 协议版本，它们之间⽤空格进行分隔。例如：\r\n\r\n```bash\r\nGET http://www.abc.com/articles HTTP/1.1\r\n```\r\n\r\n**请求头**\r\n\r\n请求头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号`:`进行分隔。例如：\r\n\r\n```\r\nContent-Type: application/json\r\nHost: www.abc.com\r\n```\r\n\r\n**请求体**\r\n\r\n请求体中放置 POST、PUT、PATCH 等请求方法所需要携带的数据。\r\n\r\n\r\n\r\n## 5. HTTP响应报文是什么样的？\r\n\r\nHTTP 响应报⽂的组成: 响应⾏、响应头、空⾏、响应体。\r\n\r\n<img src="/images/image-20210219125038371.png" alt="image-20210219125038371" style="zoom:40%;" />\r\n\r\n**响应行**\r\n\r\n响应行由协议版本、状态码、状态码的原因短语3个内容组成，中间以空格分隔。例如：\r\n\r\n```bash\r\nHTTP/1.1 200 OK\r\n```\r\n\r\n\r\n\r\n**响应头**\r\n\r\n响应头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号`:`进行分隔。例如：\r\n\r\n```\r\nContent-Length: 1024\r\nContent-Type: application/json\r\n```\r\n\r\n\r\n\r\n**响应体**\r\n\r\n服务器发送过来的数据。\r\n\r\n小结:\r\n\r\n![image-20210306161216371](images/image-20210306161216371.png)\r\n\r\n\r\n\r\n## 6. 你了解的HTTP状态码有哪些？\r\n\r\n**成功（2XX）**\r\n\r\n| 状态码 | 原因短语        | 说明                                                         |\r\n| ------ | --------------- | ------------------------------------------------------------ |\r\n| 200    | OK              | 表示从客户端发来的请求在服务器端被正确处理                   |\r\n| 201    | Created         | 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴<br />通常是在POST请求，或是某些PUT请求之后创建了内容, 进行的返回的响应 |\r\n| 202    | Accepted        | 请求服务器已接受，但是尚未处理，不保证完成请求<br />适合异步任务或者说需要处理时间比较长的请求，避免HTTP连接一直占用 |\r\n| 204    | No content      | 表示请求成功，但响应报⽂不含实体的主体部分                   |\r\n| 206    | Partial Content | 进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求<br />响应头中会包含获取的内容范围 (常用于分段下载) |\r\n\r\n\r\n\r\n**重定向（3XX）**\r\n\r\n| 状态码  | 原因短语           | 说明                                                         |\r\n| ------- | ------------------ | ------------------------------------------------------------ |\r\n| 301     | Moved Permanently  | 永久性重定向，表示资源已被分配了新的 URL<br />比如，我们访问 **http**://www.baidu.com 会跳转到 **https**://www.baidu.com |\r\n| 302     | Found              | 临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br />首页, 个人中心, 遇到了需要登录才能操作的内容, 重定向 到 登录页 |\r\n| 303     | See Other          | 对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。 |\r\n| **304** | **Not Modified**   | **自从上次请求后，请求的网页内容未修改过。<br />服务器返回此响应时，不会返回网页内容。(协商缓存)** |\r\n| 307     | Temporary Redirect | 对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。<br />不对请求做额外处理, 正常发送请求, 请求location中的url地址 |\r\n\r\n因为post请求, 是非幂等的,  从302中, 细化出了 303 和 307\r\n\r\n简而言之: \r\n\r\n- 301  302  307  都是重定向\r\n- 304 协商缓存\r\n\r\n\r\n\r\n**客户端错误（4XX）**\r\n\r\n| 状态码  | 原因短语        | 说明                                        |\r\n| ------- | --------------- | ------------------------------------------- |\r\n| **400** | **Bad Request** | **请求报⽂存在语法错误(（传参格式不正确）** |\r\n| 401     | UnAuthorized    | 权限认证未通过(没有权限)                    |\r\n| 403     | Forbidden       | 表示对请求资源的访问被服务器拒绝            |\r\n| 404     | Not Found       | 表示在服务器上没有找到请求的资源            |\r\n| 408     | Request Timeout | 客户端请求超时                              |\r\n| 409     | Confict         | 请求的资源可能引起冲突                      |\r\n\r\n\r\n\r\n**服务端错误（5XX）**\r\n\r\n| 状态码 | 原因短语                   | 说明                                                         |\r\n| ------ | -------------------------- | ------------------------------------------------------------ |\r\n| 500    | Internal Sever Error       | 表示服务器端在执⾏请求时发⽣了错误                           |\r\n| 501    | Not Implemented            | 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br />或者请求是服务器不⽀持的某个⽅法 |\r\n| 503    | Service Unavailable        | 表明服务器暂时处于超负载或正在停机维护，⽆法处理请求         |\r\n| 505    | Http Version Not Supported | 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本           |\r\n\r\n\r\n\r\n## 7. HTTP的keep-alive是什么作用？\r\n\r\n作用：使客户端到服务器端的连接**持续有效**(长连接)，当出现对服务器的后继请求时，\r\n\r\nKeep-Alive功能避免了建立或者重新建立连接。\r\n\r\n\r\n\r\n早期 HTTP/1.0 在每次请求的时候，都要创建⼀个新的连接，⽽创建连接的过程需要消耗资源和时间，\r\n\r\n为了减少资源消耗、缩短响应时间，就需要复⽤已有连接。\r\n\r\n\r\n\r\n在后来的 HTTP/1.0 以及 HTTP/1.1 中引⼊了复⽤连接的机制，也就是在请求头中加⼊Connection: keep-alive，\r\n\r\n以此告诉对⽅这个请求响应完成后不要关闭连接，下⼀次还⽤这个请求的连接进行后续交流。\r\n\r\n**协议规定，如果想要保持连接，则需要在请求头中加上 Connection: keep-alive。** \r\n\r\n\r\n\r\n**keep-alive 的优点** (复用连接)\r\n\r\n- 较少的 CPU 和内存的占⽤（因为要打开的连接数变少了, 复用了连接） \r\n- 减少了后续请求的延迟（⽆需再进⾏握⼿） \r\n- ...\r\n\r\n缺点: 因为在处理的暂停期间，本来可以释放的资源仍旧被占用。请求已经都结束了, 但是还一直连接着也不合适\r\n\r\n解决：Keep-Alive: timeout=5, max=100\r\n\r\n- timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），\r\n\r\n- max是最多一百次请求，强制断掉连接。\r\n\r\n  就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。\r\n\r\n\r\n\r\n## 8. 为什么需要HTTPS？\r\n\r\nHTTPS 是安全版的 HTTP。\r\n\r\nHTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。\r\n\r\n而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。\r\n\r\n\r\n\r\n## 9. HTTPS是如何保证安全的？\r\n\r\nHTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。\r\n\r\n那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。\r\n\r\n目前常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。\r\n\r\n\r\n\r\n### 9.1 **什么是对称加密？**\r\n\r\n对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，\r\n\r\n这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难\r\n\r\n通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。 \r\n\r\n![image-20210306005550796](images/image-20210306005550796.png)\r\n\r\n对称加密的特点是：\r\n\r\n- 优点:\r\n\r\n  计算量小、加密速度快、加密效率高。\r\n\r\n- 缺点: \r\n\r\n  在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。\r\n\r\n  如果一方的秘钥被泄露，那么加密信息也就不安全了\r\n\r\n使用场景：本地数据加密、https通信、网络传输等\r\n\r\n常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6\r\n\r\n\r\n\r\n### 9.2 **什么是⾮对称加密？**\r\n\r\n而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，\r\n\r\n这样就避免了直接传递密钥。这种新的加密模式被称为"非对称加密算法"。\r\n\r\n通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。\r\n\r\n特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容\r\n\r\n![image-20210306011528361](images/image-20210306011528361.png)\r\n\r\n非对称加密的特点是：\r\n\r\n- 优点：非对称加密与对称加密相比其安全性更好\r\n\r\n- 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。\r\n\r\n使用场景：https会话前期、CA数字证书、信息加密、登录认证等\r\n\r\n常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）\r\n\r\n\r\n\r\n### 9.3 **HTTPS 加密解决⽅案** \r\n\r\n结合了两种加密⽅式：\r\n\r\n- 将 `对称加密的密钥` ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 `对称加密密钥`\r\n\r\n- 双⽅沟通时使⽤ `对称加密密钥` 进⾏\r\n\r\n**可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。**\r\n\r\nHTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议 \r\n\r\n它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输\r\n\r\n\r\n\r\n### 9.4 数字证书\r\n\r\n为了安全性, 一般还需要签发数字证书! \r\n\r\n客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息\r\n\r\n进而进行非对称加密, 使用公钥, 加密`对称加密密钥`, 传递给服务器, 后续通信都使用对称加密!\r\n\r\n![image-20210306020401732](images/image-20210306020401732.png)\r\n\r\n**问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!**\r\n\r\n\r\n\r\n所以, 就需要有数字证书(CA证书),  一般是CA机构颁发的, 证明这个公钥是安全可靠的!\r\n\r\n**CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性**\r\n\r\n![image-20210306014409595](images/image-20210306014409595.png)\r\n\r\n\r\n\r\n当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端\r\n\r\n![image-20210306021013686](images/image-20210306021013686.png)\r\n\r\n而客户端, 接收到消息后, 就可以查看证书\r\n\r\n1. 如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!! \r\n\r\n2. 如果签发证书的机构, 不权威, 发出警告 \r\n\r\n   ![image-20210306021532010](images/image-20210306021532010.png)\r\n\r\n3. 如果证书过期了, 浏览器也会发出警告\r\n\r\n\r\n\r\n### 9.5 数字签名\r\n\r\n但这还是有问题：如果证书被篡改了怎么办?\r\n\r\n这时就需要用⼀个技术：**数字签名**。 (根据证书内容, 生成的一个唯一标识) \r\n\r\n数字签名就是先⽤ **CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要**，然后使⽤ CA 私钥进行加密，组成数字签名。\r\n\r\n当别⼈把他的证书发过来时，**接收方⽤同样的算法再次⽣成摘要**，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,\r\n\r\n就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。\r\n\r\n[博客参考](https://blog.csdn.net/u014044812/article/details/80723009)\r\n\r\n\r\n\r\n## 10. HTTP2和HTTP1.x比，有什么优势和特点？\r\n\r\n1. HTTP/2 采⽤`⼆进制格式`来传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议`解析起来更⾼效`\r\n2. HTTP/2 采用一些`头部压缩技术`，减少在请求和响应头中重复携带的数据，`降低网络负担`\r\n3. HTTP/2 采⽤`服务器推送`方式，主动向客户端推送资源，提高页面加载效率\r\n4. HTTP/2 采⽤`多路复用机制`，减少需要创建的连接数量，降低资源占用和性能消耗\r\n\r\n下面是一些与之关联的技术知识。\r\n\r\n\r\n\r\n**⼆进制格式分帧**\r\n\r\n帧：HTTP/2 数据通信的最⼩单位消息，是指 HTTP/2 中逻辑上的 HTTP 消息（例如请求、响应等）。消息由⼀个或多个帧组成 \r\n\r\n流：存在于连接中的⼀个虚拟通道，它可以承载双向消息，且每个流都有唯⼀的整数ID\r\n\r\n\r\n\r\n**头部压缩**\r\n\r\n在 HTTP/1.x 中，请求和响应中会重复携带一些不常改变、冗⻓的头数据，给⽹络带来额外负担。\r\n\r\n在 HTTP/2 中，客户端和服务端使⽤ **“⾸部表”** 来跟踪和存储之前发送过的键值对，\r\n\r\n相同的数据不再随着每次请求和响应发送。⾸部表在连接存续期间始终存在，由客户端和服务器共同渐进更新。\r\n\r\n每个新的⾸部键值对，要么被追加到当前表的末尾，要么替换表中已存在的键值对。\r\n\r\n> 可以简单的理解为：只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量\r\n\r\n\r\n\r\n下图为首部表的更新示意图：\r\n\r\n<img src="/images/image-20210219160534616.png" alt="image-20210219160534616" style="zoom:30%;" />\r\n\r\n\r\n\r\n**服务器推送**\r\n\r\n服务端可以在发送⻚⾯ HTML 内容时，再主动推送一些其它资源，⽽不⽤等到浏览器解析到相应的位置时发起请求后再作响应。\r\n\r\n例如，服务端可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。 \r\n\r\n\r\n\r\n不过，服务端的主动推送行为，客户端有权利选择是否要接收。\r\n\r\n如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。\r\n\r\n\r\n\r\n**多路复用**\r\n\r\n在 HTTP 1.x 中如果想并发多个请求的话，必须使⽤多个 TCP 链接，但浏览器为了控制资源，\r\n\r\n会对单个域名有 6-8 个 TCP 链接的数量限制。而在 HTTP 2 中： \r\n\r\n- 同域名下的所有通信，都在单个连接上完成 \r\n- 单个连接可以承载任意数量的双向数据流 \r\n- 数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成（多个帧可以乱序发送，因为可以根据帧⾸部的流标识来重新组装）\r\n\r\n![image-20210306023912779](images/image-20210306023912779.png)\r\n\r\n[参考文章：HTTP/2特性及其在实际应用中的表现](https://zhuanlan.zhihu.com/p/30166894)\r\n\r\n\r\n\r\n## 11. http缓存控制\r\n\r\n### 11.1 基本认知\r\n\r\n**Web 服务缓存** 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。\r\n\r\n**浏览器缓存** 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。**`这里我们只讨论 HTTP 缓存相关内容`。**\r\n\r\n**HTTP缓存**:\r\n\r\n- **强缓存**\r\n- **协商缓存**\r\n\r\n在具体了解 HTTP 缓存之前先来明确几个术语：\r\n\r\n- 缓存命中率：从缓存中得到数据的请求数  与    所有请求数的比率。理想状态是越高越好。\r\n- 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。\r\n- 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。\r\n- 失效：失效就是把内容从缓存中移除。\r\n\r\n**浏览器缓存主要是 HTTP 协议定义的缓存机制。**\r\n\r\n\r\n\r\n**浏览器缓存, HTTP缓存分类**\r\n\r\n浏览器缓存分为`强缓存 `和 `协商缓存`，浏览器加载一个页面的简单流程如下：\r\n\r\n1. 浏览器先根据这个资源的  **http头信息**  来 **判断是否命中强缓存**。\r\n\r\n   如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）\r\n\r\n2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。\r\n\r\n   服务器来判断浏览器本地缓存是否失效。\r\n\r\n   若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）\r\n\r\n3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）\r\n\r\n\r\n\r\n### 11.2 强缓存  (食品过期时间判断)\r\n\r\n**(进行判断, 是否资源过期, 如果未过期, 直接用缓存)**\r\n\r\n**强缓存**\r\n\r\n命中强缓存时，浏览器并不会将请求发送给服务器。\r\n\r\n在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。\r\n\r\n![img](images/940884-20180423141536107-329179455.png)\r\n\r\n\r\n\r\n强缓存是利用http的返回的响应头中的Expires或者Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。\r\n\r\nExpires: 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读\r\n\r\nCache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s\r\n\r\n\r\n\r\n**Expires**\r\n\r\n缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。 \r\n\r\nExpires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\r\n\r\n![image-20201209080705571](D:/z_work/72期/面试加强课-day02/02-笔记/asset/image-20201209080705571.png)\r\n\r\n该字段会返回一个时间，比如Expires:  Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在xx年xx月xx日时间之前都是有效的，即命中缓存。\r\n\r\n这种方式有一个明显的缺点，由于失效时间是一个`绝对时间`，所以当 **服务器与客户端 时间偏差很大**  以后，就会导致缓存混乱。于是发展出了Cache-Control。\r\n\r\n\r\n\r\n**Cache-Control**\r\n\r\nCache-Control是一个`相对时间`，例如Cache-Control:max-age 3600，代表着资源的有效期是3600秒。\r\n\r\n由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。\r\n\r\nCache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。\r\n\r\nCache-Control 可以由多个字段组合而成，主要有以下几个取值：\r\n\r\n1. **max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。\r\n\r\n   例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，\r\n\r\n   第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。\r\n\r\n   ![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141638673-1917674992.png)\r\n\r\n   在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。\r\n\r\n2. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。\r\n\r\n   不是字面意思上的不缓存。 \r\n\r\n3. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。\r\n\r\n\r\n\r\n### 11.3 协商缓存 (找供货商专家协商)\r\n\r\n看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求)   强缓存\r\n\r\n食品过期时间过了,  能不能吃呢?  问问专家(服务器),  专家瞅了一眼, 没过期 (响应304, 不返回内容) , 直接吃          (协商缓存) \r\n\r\n如果问过专家(服务器), 专家瞅了一眼, 呀真过期了, 原来的不要了, 我重新给你发一个 (响应200, 并返回内容)\r\n\r\n**协商缓存**\r\n\r\n若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。\r\n\r\n服务器根据http头信息中的`Last-Modify/If-Modify-Since`或`Etag/If-None-Match`来判断是否命中协商缓存。\r\n\r\n如果命中，则http返回码为304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。\r\n\r\n\r\n\r\n**Last-Modify/If-Modify-Since**\r\n\r\n浏览器第一次请求一个资源的时候, 服务器返回的header中会加上Last-Modify，\r\n\r\nLast-modify是一个时间标识该资源的**最后修改时间**，例如`Last-Modify: Thu,31 Dec 2037 23:59:59 GMT`。\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141852114-1757065670.png)\r\n\r\n当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，**该值为缓存之前返回的Last-Modify**。\r\n\r\n服务器收到If-Modify-Since后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。\r\n\r\n![img](images/940884-20180423141732879-1484228353.png)\r\n\r\n如果命中缓存，则返回 **http304**，并且不会返回资源内容，并且不会返回Last-Modify。\r\n\r\n由于对比的是服务端时间，所以客户端与服务端时间差距不会导致问题。\r\n\r\n**但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。**\r\n\r\n比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了,  **于是出现了ETag/If-None-Match。**\r\n\r\n\r\n\r\n**ETag/If-None-Match**\r\n\r\n与Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。\r\n\r\nETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。\r\n\r\nETag值的变更则说明资源状态已经被修改。\r\n\r\n服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141918779-1206116367.png)\r\n\r\nETag生成靠以下几种因子\r\n\r\n1. 文件的i-node编号，是Linux/Unix用来识别文件的编号。 \r\n\r\n2. 文件最后修改时间\r\n\r\n3. 文件大小\r\n\r\n   ...\r\n\r\n生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值\r\n\r\n\r\n\r\n**既生 Last-Modified 何生 Etag ？**\r\n\r\n你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？\r\n\r\nEtag的出现主要是为了解决几个Last-Modified比较难解决的问题：\r\n\r\n1. Last-Modified标注的最后修改只能精确到秒级\r\n\r\n   如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间\r\n\r\n3. 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形\r\n\r\nEtag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 **准确的控制缓存。** \r\n\r\n不会仅仅只根据最后的修改时间判断是否进行使用缓存\r\n\r\nLast-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，\r\n\r\n最后才决定是否返回304。\r\n\r\n\r\n\r\n小结:\r\n\r\n- 强缓存: 大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读 \r\n\r\n- 协商缓存: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间,  唯一标识etag), 去问服务器, 是否真的过期了\r\n\r\n  如果验证通过,  服务器会直接响应 304, 且不会返回资源\r\n\r\n\r\n\r\n### 11.4 整体请求缓存流程\r\n\r\n**浏览器第一次请求**\r\n\r\n\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141945261-83532090.png)\r\n\r\n**浏览器第二次请求**\r\n\r\n![img](D:/z_work/72期/面试加强课-day02/02-笔记/asset/940884-20180423141951735-912699213.png)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n# TCP\r\n\r\n## TCP的特性\r\n\r\n主要有以下5点特性：\r\n\r\n1. TCP 提供⼀种⾯向连接的、可靠的字节流服务 \r\n\r\n2. 在⼀个 TCP 连接中，仅有两⽅进⾏彼此通信（⼴播和多播不能⽤于 TCP）\r\n\r\n3. TCP 使⽤校验、确认和重传机制来保证可靠传输 \r\n\r\n4. TCP 将数据分节进⾏排序，并使⽤累积来确认保证数据的顺序不变和⾮重复 \r\n\r\n5. TCP 使⽤滑动窗⼝机制来实现流量控制，通过动态改变窗⼝的⼤⼩进⾏拥塞控制 \r\n\r\n\r\n\r\n## 简述 TCP 和 UDP 的区别\r\n\r\n| 协议 | 连接性   | 双工性     | 可靠性                 | 有序性            | 有界性             | 拥塞控制 | 传输速度 | 量级 | 头部大小  |\r\n| ---- | -------- | ---------- | ---------------------- | ----------------- | ------------------ | -------- | -------- | ---- | --------- |\r\n| TCP  | ⾯向连接 | 全双工 1:1 | 可靠，有重传机制       | 有序，通过SYN排序 | 无边界，有粘包情况 | 有       | 慢       | 低   | 20~60字节 |\r\n| UDP  | 无连接   | n:m        | 不可靠，丢包后数据丢失 | 无序              | 有边界，无粘包     | 无       | 快       | 高   | 8字节     |\r\n\r\n\r\n\r\nUDP socket ⽀持 n 对 m 的连接状态。在 Node.js 官⽅⽂档中有写到在 `dgram.createSocket(options[, callback]) ` 中的 `options` 中可指定 `reuseAddr` 为 `SO_REUSEADDR` 标志，通过它可以简单的实现 n 对 m 的多播特性 (仅在⽀持多播的操作系统上才有用)。\r\n\r\n\r\n\r\n## 什么是 TCP 粘包，怎么处理？\r\n\r\nTCP 连接在默认情况下会启⽤延迟传送算法 (Nagle算法)，它在数据发送前进行缓存数据，如短时间内有多个数据发送，会缓冲后再作⼀次发送操作 (缓冲区⼤⼩可⻅ `socket.bufferSize`)，这样可以减少 IO 产生的消耗，提⾼了性能。\r\n\r\n \r\n\r\n在传输⽂件的情况下，不⽤处理粘包问题，接收到⼀个包就拼接⼀个包就行了。但是，如果是传输多条消息、或是别的⽤途的数据，那么就需要处理粘包。可参⻅⽹上流传甚⼴的⼀个例⼦：连续调⽤两次 `send` 分别发送两段数据 data1 和 data2，则在接收端会有以下⼏种常⻅情况出现: \r\n\r\n- A. 先收到 data1，然后收到 data2\r\n\r\n- B. 先收到 data1 的部分数据，然后收到 data1 余下的部分以及 data2 的全部\r\n\r\n- C. 先收到 data1 的全部数据和 data2 的部分数据，然后收到 data2 的余下的数据\r\n\r\n- D. ⼀次性收到 data1 和 data2 的全部数据\r\n\r\n\r\n\r\n以上情况中的 `B、C、D` 三种，就是常⻅的粘包情况。而处理粘包问题的常⻅⽅案有：\r\n\r\n\r\n\r\n**方案一：多次发送之前间隔⼀个等待时间** \r\n\r\n只需等待⼀段时间再做下⼀次`send` 发送操作就可以了。\r\n\r\n- 它适⽤于交互频率特别低的场景\r\n\r\n- 对于交互频繁的场景来说， 其传输效率太低。\r\n\r\n\r\n\r\n**方案二：关闭 Nagle 算法** \r\n\r\n在 Node.js 中你可以通过 `socket.setNoDelay()` ⽅法来关闭 Nagle 算法，让每次 send 都不缓冲而直接发送。 \r\n\r\n- 该⽅法适⽤于每次发送的数据都⽐较⼤ (但不是如⽂件那么⼤)， 并且频率不特别⾼的场景\r\n- 如果是每次发送的数据量⽐较⼩且频率特别⾼的话，这种方式纯属⾃废武功\r\n\r\n- 该⽅法也不适⽤于⽹络较差的情况，因为 Nagle 算法是在服务端进⾏的包合并情况，但如果短时间内客户端的⽹络 \r\n\r\n情况不好、或者应⽤层由于某些原因不能及时将 TCP 的数据 `recv`，就会造成多个包在客户端缓冲从⽽粘包的情况\r\n\r\n\r\n\r\n**方案三：进⾏封包/拆包**\r\n\r\n这是⽬前业内最常⻅的解决⽅案，即在发送每个数据包之前，将⼀些有特征的数据放在数据包前/后，然后在收到数据的时 \r\n\r\n候，根据特征数据来分割出各个数据包。\r\n\r\n\r\n\r\n## 你知道哪些常用的端口号，以及它们对应的服务？\r\n\r\n| 端口     | 用途                                                         |\r\n| -------- | ------------------------------------------------------------ |\r\n| 21       | 主要⽤于FTP（File Transfer Protocol，⽂件传输协议）服务      |\r\n| 23       | 主要⽤于Telnet（远程登录）服务，是Internet上普遍采⽤的登录和仿真程序 |\r\n| 25       | 为 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务器所开放，主要⽤于发送邮件，如今绝⼤多数邮件服务器都使⽤该协议 |\r\n| 53       | 为DNS（Domain Name Server，域名服务器）服务器所开放，主要⽤于域名解析，DNS服务在NT系统中使⽤的最为⼴泛 |\r\n| 67、68   | 分别是为 Bootp 服务的 Bootstrap Protocol Server（引导程序协议服务端）和 Bootstrap Protocol Client（引导程序协议客户端）开放的端⼝ |\r\n| 69       | TFTP是Cisco公司开发的⼀个简单⽂件传输协议，类似于FTP         |\r\n| 79       | 为Finger服务开放的，主要⽤于查询远程主机在线⽤户、操作系统类型以及是否缓冲区溢出等⽤户的详细信息 |\r\n| 80       | 为HTTP（HyperText Transport Protocol，超⽂本传输协议）开放的，这是上⽹冲浪使⽤最多的协议，主要⽤于在WWW（World WideWeb，万维⽹）服务上传输信息的协议 |\r\n| 99       | ⽤于⼀个名为“Metagram Relay”（亚对策延时）的服务，该服务⽐较少⻅，⼀般是⽤不到的 |\r\n| 109、110 | 为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，110 端⼝是为 POP3（邮件协议3）服务开放的，POP2、POP3都是主要⽤于接收邮件的 |\r\n| 111      | 是SUN公司的 RPC（Remote ProcedureCall，远程过程调⽤）服务所开放的端⼝，主要⽤于分布式系统中不同计算机的内部进程通信，RPC在多种⽹络服务中都是很重要的组件 |\r\n| 113      | 主要⽤于Windows的“Authentication Service”（验证服务）        |\r\n| 119      | 是为“Network News TransferProtocol”（⽹络新闻组传输协议，简称NNTP）开放的 |\r\n| 135      | 主要⽤于使⽤RPC（Remote Procedure Call，远程过程调⽤）协议并提供DCOM（分布式组件对象模型）服务 |\r\n| 137      | 主要⽤于“NetBIOS Name Service”（NetBIOS名称服务）            |\r\n| 139      | 是为“NetBIOS Session Service”提供的，主要⽤于提供Windows⽂件和打印机共享以及Unix中的Samba服务 |\r\n| 143      | 主要是⽤于“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP） |\r\n| 161      | 是⽤于“Simple Network Management Protocol”（简单⽹络管理协议，简称SNMP） |\r\n| 443      | ⽹⻚浏览端⼝，主要是⽤于HTTPS服务，是提供加密和通过安全端⼝传输的另⼀种HTTP |\r\n| 554      | 默认情况下⽤于“Real Time Streaming Protocol”（实时流协议，简称RTSP） |\r\n| 1024     | ⼀般不固定分配给某个服务，在英⽂中的解释是“Reserved”（保留） |\r\n| 1080     | 是Socks代理服务使⽤的端⼝，⼤家平时上⽹使⽤的WWW服务使⽤的是HTTP协议的代理服务 |\r\n| 1755     | 默认情况下⽤于“Microsoft Media Server”（微软媒体服务器，简称MMS） |\r\n| 4000     | 是⽤于⼤家经常使⽤的QQ聊天⼯具的，再细说就是为QQ客户端开放的端⼝，QQ服务端使⽤的端⼝是8000 |\r\n| 5554     | ⼀种针对微软lsass服务的新蠕⾍病毒——震荡波（Worm.Sasser）利⽤TCP 5554端⼝开启⼀个FTP服务，主要被⽤于病毒的传播 |\r\n| 5632     | 5632端⼝是被⼤家所熟悉的远程控制软件pcAnywhere所开启的端⼝   |\r\n| 8080     | 8080端⼝同80端⼝，是被⽤于WWW代理服务的，可以实现⽹⻚        |\r\n\r\n\r\n\r\n## 一次完整的HTTP服务过程是什么\r\n\r\n当我们在web浏览器的地址栏中输入：`www.baidu.com`，具体发生了什么？\r\n\r\n1. 对`www.baidu.com`这个网址进行DNS域名解析，得到对应的IP地址\r\n2. 根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) ) \r\n3. 建立TCP连接后发起HTTP请求\r\n4. 服务器响应HTTP请求，浏览器得到html代码\r\n5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）\r\n6. 浏览器对页面进行渲染呈现给用户\r\n7. 服务器关闭关闭TCP连接\r\n\r\n注：\r\n\r\n1.DNS怎么找到域名的？\r\n\r\n> DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存->缓存找不到就去找根域名服务器->根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器\r\n\r\n2.为什么HTTP协议要基于TCP来实现？  \r\n\r\n> TCP是一个端到端的可靠面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）\r\n\r\n3.最后一步浏览器是如何对页面进行渲染的？  \r\n\r\n> a）解析html文件构成 DOM树\r\n> b）解析CSS文件构成渲染树\r\n> c）边解析，边渲染\r\n> d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载\r\n\r\n\r\n\r\n## 什么是DNS 解析\r\n\r\n**DNS解析（域名解析服务器）**\r\n\r\n假定请求的是 www.baidu.com\r\n\r\na）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）\r\n\r\nb）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存\r\n\r\nc）如果还没有找到，那么尝试从 hosts 文件里面去找\r\n\r\nd）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找(就近查找)，具体过程如下\r\n\r\n![dns域名解析](images/5rxqugj8dh.png)\r\n\r\nDNS优化两个方面：DNS缓存、DNS负载均衡 (准备多台dns服务器, 进行dns解析)\r\n\r\n\r\n\r\n## 什么是三次握手？\r\n\r\n三次握⼿（Three-way Handshake）是指在建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送 3 个包。\r\n\r\n \r\n\r\n三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信 \r\n\r\n息。在 socket 编程中，客户端调用执行 `connect()` 时将触发三次握⼿。\r\n\r\n\r\n\r\n下图为三次握手的示意图：\r\n\r\n![image-20210219192116213](/images/image-20210219192116213.png)\r\n\r\n**第⼀次握⼿（SYN=1, seq=x）** \r\n\r\n客户端发送⼀个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号（Sequence Number）字段⾥。\r\n\r\n发送完毕后，客户端进⼊ SYN_SEND 状态。 \r\n\r\n\r\n\r\n**第⼆次握⼿（SYN=1, ACK=1, seq=y, ACKnum=x+1）**\r\n\r\n服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域⾥，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加1，即 X + 1。 \r\n\r\n发送完毕后，服务器端进⼊ SYN_RCVD 状态。 \r\n\r\n\r\n\r\n**第三次握⼿（ACK=1，ACKnum=y+1）** \r\n\r\n客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写 ISN 的 +1。\r\n\r\n发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿结束。\r\n\r\n\r\n\r\n## 什么是四次挥手？\r\n\r\n四次挥⼿（Four-way handshake），也叫做改进的三次握⼿，TCP 连接的拆除需要发送四个包，客户端或服务器均可主动发起挥⼿动作，在 socket 编程中，任何⼀⽅执⾏ `close()` 操作即可产⽣挥⼿操作。\r\n\r\n\r\n\r\n下图为四次挥手示意图：\r\n\r\n![image-20210219192659983](/images/image-20210219192659983.png)\r\n\r\n\r\n\r\n**第⼀次挥⼿（FIN=1，seq=x）** \r\n\r\n假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为1的包，表示⾃⼰已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进⼊ FIN_WAIT_1 状态。\r\n\r\n \r\n\r\n**第⼆次挥⼿（ACK=1，ACKnum=x+1）** \r\n\r\n服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务器端关闭连接。 \r\n\r\n\r\n\r\n**第三次挥⼿（FIN=1，seq=y）** \r\n\r\n服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个ACK。 \r\n\r\n\r\n\r\n**第四次挥⼿（ACK=1，ACKnum=y+1）** \r\n\r\n客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## TCP 三次握手理解 (双方确认)\r\n\r\nTCP是一个端到端的  **可靠**  面相连接的协议，\r\n\r\nHTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）\r\n\r\n根据这个IP，找到对应的服务器，发起TCP的三次握手 ([tcp 三次握手四次挥手](https://blog.csdn.net/qq_38950316/article/details/81087809) ) \r\n\r\n![image-20201209160422978](images/image-20201209160422978.png)\r\n\r\n**为什么要3次握手**\r\n\r\n我们假定第一次发送的请求,  因为网络延迟很慢才到达服务端，\r\n\r\n然后客户端以为这服务器居然不叼我，然后默默的关闭的等待连接的请求，走开了（好比追女神）；\r\n\r\n但事实呢？女神（服务器）是因为各种各样的原因，很晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！\r\n\r\n但是，A早已经远走高飞，这个请求A完全不会收到（在第二次握手，服务端打开连接，等待客户端的响应），\r\n\r\n那么女生呢，以为对方收到了，就会一直等待，这样B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；\r\n\r\n而三次握手, 就不会发生，服务端同意连接了，但是A缺一直没有下一步的动作，导致资源浪费；\r\n\r\n\r\n\r\n\r\n\r\n## 关闭TCP连接四次挥手的理解 (客气挽留)\r\n\r\n关闭连接(四次挥手)\r\n\r\n![image-20201209162908979](images/image-20201209162908979.png)\r\n\r\n 这和有礼貌的好友道别一样：（a：客户端 b:服务端）\r\n1、一开始A想要回家离开，但是呢？怕B还有事情要交代，那么呢？只好先想B打招呼，我要走了，请求停止交谈（此时，a到B的连接没有断开，依旧可以进行通信）；\r\n2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看,  你等等,  等我说完你再走。\r\n3、B确实没啥要补充的了，就告知你我可以散伙了\r\n4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )\r\n\r\n\r\n\r\n\r\n\r\n## 浏览器解析响应\r\n\r\n**浏览器解析html代码，并请求html代码中的资源**\r\n\r\n**浏览器对页面进行渲染呈现给用户**\r\n\r\n最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。\r\n\r\n首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。\r\n\r\nDOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repaint。\r\n\r\n**页面在首次加载时必然会经历reflow和repaint。**\r\n\r\nreflow过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。\r\n\r\n所以我们应该尽可能少的减少 reflow (重新布局) 。  例如: transform 变换, 只会触发重绘, 不会触发重排 (效率非常高)\r\n\r\n...\r\n\r\n页面首次渲染, 必然会进行一次 reflow 和 一次 repaint\r\n\r\n1. reflow: 重排 (布局相关的)\r\n2. repaint: 重绘(绘制, 颜色, 字体, .... 跟结构无关的)\r\n\r\n\r\n\r\n**完整的一次 http 请求流程才算结束**\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n# DOM\r\n\r\n## DOM的事件模型是什么？\r\n\r\nDOM的事件模型(注册事件的方式)分为：\r\n\r\n- 脚本模型\r\n- 内联模型（同类一个，后者覆盖前者）\r\n- 动态绑定（同类可多个）\r\n\r\n**脚本模型**\r\n\r\n```html\r\n\x3c!-- 脚本模型：⾏内绑定 --\x3e\r\n<button onclick="javascrpt:alert(\'Hello\')">Hello1</button>\r\n```\r\n\r\n**内联模型**\r\n\r\n```html\r\n\x3c!-- 内联模型：同⼀个元素的同类事件只能添加⼀个，如果添加多个则后添加的会覆盖之前添加的 --\x3e\r\n<button onclick="sayHello()">Hello2</button>\r\n\r\n<script>\r\n  function sayHello() { \r\n    alert("Hello"); \r\n  }\r\n<\/script>\r\n```\r\n\r\n**动态绑定**\r\n\r\n```html\r\n\x3c!-- 动态绑定 --\x3e\r\n<button id="btn">Hello3</button>\r\n\r\n<script>\r\n  var btn = document.getElementById("btn");\r\n\r\n  /* 1. 这种方式只能给同一个元素添加一个事件 */\r\n  btn.onclick = function () { alert("Hello"); }\r\n\r\n  /* 2. 这种方式可以给同⼀个元素添加多个同类事件 */\r\n  btn.addEventListener("click", function () { alert("hello1"); });\r\n  btn.addEventListener("click", function () { alert("hello2"); })\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n## DOM的事件流是什么？\r\n\r\n**事件**\r\n\r\n事件是HTML⽂档或浏览器窗⼝中发⽣的⼀些特定的交互瞬间。\r\n\r\n**事件流**\r\n\r\n⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2级事件规定的事件流包括了3个阶段：\r\n\r\n- 事件捕获阶段（capture phase）\r\n- 处于⽬标阶段（target phase）\r\n- 事件冒泡阶段（bubbling phase）\r\n\r\n![image-20210219222213633](/images/image-20210219222213633.png)\r\n\r\n如上图所示，事件流的触发顺序是：\r\n\r\n1. 事件捕获阶段，为截获事件提供了机会 \r\n2. 实际的⽬标元素接收到事件\r\n3. 事件冒泡阶段，可在这个阶段对事件做出响应\r\n\r\n\r\n\r\n**事件冒泡（Event Bubbling）**\r\n\r\n事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。\r\n\r\n\r\n\r\n```html\r\n<html>\r\n  \r\n  <head> \r\n    <title>Document</title> \r\n  </head>\r\n  \r\n  <body> \r\n    <button>按钮</button> \r\n  </body> \r\n  \r\n</html>\r\n```\r\n\r\n如果点击了上面页面代码中的 `<button>` 按钮，那么该 `click` 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：\r\n\r\n1. button 元素\r\n2. body 元素\r\n3. html 元素\r\n4. document 对象\r\n\r\n\r\n\r\n**事件捕获（Event Capturing）**\r\n\r\n事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。\r\n\r\n事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。\r\n\r\n\r\n\r\n如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 `click` 事件，然后再沿着 DOM 树依次向下，直到 `<button>`。具体顺序如下：\r\n\r\n1. document 对象\r\n2. html 元素\r\n3. body 元素\r\n4. button 元素\r\n\r\n\r\n\r\n## 说说什么是事件委托？\r\n\r\n事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。\r\n\r\n\r\n\r\n**示例**\r\n\r\n```html\r\n<ul id="list">\r\n    <li>111</li>\r\n    <li>222</li>\r\n    <li>333</li>\r\n</ul>\r\n\r\n<script type="text/javascript">\r\n    // ⽗元素 \r\n    var list = document.getElementById(\'list\');\r\n\r\n    // 为⽗元素绑定事件，委托管理它的所有⼦元素的点击事件 \r\n    list.onclick = function (event) {\r\n        var currentTarget = event.target;\r\n        if (currentTarget.tagName.toLowerCase() === \'li\') {\r\n            alert(currentTarget.innerText)\r\n        }\r\n    }\r\n<\/script>\r\n```\r\n\r\n\r\n\r\n> 适用场景：在绑定大量事件的时候，可以选择事件委托\r\n\r\n**优点**\r\n\r\n- 事件委托可以减少事件注册数量，节省内存占⽤!\r\n- 当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素 \r\n\r\n---\r\n\r\n\r\n\r\n# 浏览器与新技术\r\n\r\n## 常见的浏览器内核有哪些？\r\n\r\n浏览器的内核，通常指的是渲染引擎，但现在JS引擎也成为浏览器的重要部分，所以下表展示了当前一些比较流行的常规浏览器、无头浏览器、以及JS运行时所含的渲染引擎和JS引擎：\r\n\r\n|     浏览器/运行时      |           内核（即渲染引擎）            |         JS引擎          |\r\n| :--------------------: | :-------------------------------------: | :---------------------: |\r\n|         Chrome         | Webkit (Chrome 27) / Blink (Chrome 28+) |           V8            |\r\n|        FireFox         |                  Gecko                  |      SpiderMonkey       |\r\n|         Safari         |                 Webkit                  |     JavaScriptCore      |\r\n|          Edge          |                EdgeHTML                 | Chakra (for JavaScript) |\r\n|           IE           |                 Trident                 |  Chakra (for JScript)   |\r\n| PhantomJS (无头浏览器) |                 Webkit                  |     JavaScriptCore      |\r\n| Puppeteer (无头浏览器) | Webkit (Chrome 27) / Blink (Chrome 28+) |           V8            |\r\n|        Node.js         |                   无                    |           V8            |\r\n\r\n\r\n\r\n\r\n\r\n## 浏览器是如何进行界面渲染的？\r\n\r\n不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 webkit 的渲染流程来说明：\r\n\r\n<img src="/images/image-20210220214851409.png" alt="image-20210220214851409" style="zoom:45%;" />\r\n\r\n上图展示的流程是：\r\n\r\n1. 获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）\r\n\r\n2. 解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）\r\n\r\n3. 根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）\r\n\r\n4. 进行布局（Layout），即为每个节点分配⼀个在屏幕上应显示的确切坐标位置 \r\n\r\n5. 进⾏绘制（Paint），遍历渲染树节点，调⽤ GPU 将元素呈现出来 \r\n\r\n\r\n\r\n## 浏览器是如何解析CSS选择器的？\r\n\r\n在生成渲染树的过程中，渲染引擎会根据选择器提供的信息来遍历 DOM 树，找到对应的 DOM 节点后将样式规则附加到上面。\r\n\r\n\r\n\r\n来看一段样式选择器代码、以及一段要应用样式的 HTML：\r\n\r\n```css\r\n.mod-nav h3 span {\r\n\tfont-size: 16px;\r\n}\r\n```\r\n\r\n```html\r\n<div class="mod-nav">\r\n  <header>\r\n    <h3>\r\n      <span>标题</span>\r\n    </h3>\r\n  </header>\r\n  \r\n  <div>\r\n    <ul>\r\n      <li><a href="#">项目一</a></li>\r\n      <li><a href="#">项目一</a></li>\r\n      <li><a href="#">项目一</a></li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n```\r\n\r\n\r\n\r\n渲染引擎是怎么根据以上样式选择器去遍历这个 DOM 树的呢？是按照从左往右的选择器顺序去匹配，还是从右往左呢？\r\n\r\n\r\n\r\n为了更直观的观查，我们先将这棵 DOM 树先绘制成图：\r\n\r\n<img src="/images/image-20210220222103787.png" alt="image-20210220222103787" style="zoom:30%;" />\r\n\r\n然后我们来对比一下两种顺序的匹配：\r\n\r\n\r\n\r\n**从左往右：`.mod-nav > h3 > span`**\r\n\r\n1. 从 `.mod-nav` 开始遍历⼦节点 `header`、`div`\r\n2. 然后向各⾃的⼦节点遍历\r\n3. 在右侧 `div` 的分⽀中，当遍历到叶节点 `a` 后，发现不符合规则。则重新回溯到 `ul` 节点，再遍历下⼀个 `li` - `a`\r\n\r\n\r\n\r\n**从右往左：`span > h3 > .mod-nav`**\r\n\r\n1. 先找到所有的 `span` 节点 ，然后基于每⼀个 `span` 再向上查找 `h3` \r\n\r\n2. 由 `h3` 再向上查找 `.mod-nav` 的节点\r\n\r\n3. 最后触及根元素 `html` 结束该分⽀遍历\r\n\r\n\r\n\r\n可以看到，从右向左的匹配规则可以在第⼀步时就筛选掉⼤量不符合条件的叶节点；⽽从左向右的匹配规则需要消耗大量时间在失败的查找上，这在真实页面中⼀棵 DOM 树的节点成百上千的情况下，这种遍历方式的效率会非常的低，根本不适合采用。\r\n\r\n\r\n\r\n因此，浏览器遵循 “从右往左” 的规则来解析 CSS 选择器！\r\n\r\n\r\n\r\n## DOM树是如何构建的？\r\n\r\n构建的过程如下：\r\n\r\n1. 浏览器将接收到的⼆进制数据，按指定编码格式转换为 HTML 字符串 \r\n\r\n2. 开始解析，将 HTML 字符串解析成 Tokens \r\n\r\n3. 构建节点，对节点添加特定的属性，并通过指针确定节点的⽗、⼦、兄弟关系、以及所属 treeScope \r\n\r\n4. 通过已确定的节点⽗、⼦、兄弟关系，构建出 DOM 树 \r\n\r\n\r\n\r\n下图为以上描述过程的图示：\r\n\r\n<img src="/images/image-20210220230003937.png" alt="image-20210220230003937" style="zoom:50%;" />\r\n\r\n\r\n\r\n## 浏览器重绘与重排的区别是什么？\r\n\r\n**重排**\r\n\r\n重排是指部分或整个渲染树需要重新分析，并且节点的尺⼨需要重新计算。\r\n\r\n表现为重新⽣成布局，重新排列元素。\r\n\r\n\r\n\r\n**重绘**\r\n\r\n重绘是由于节点的⼏何属性发⽣改变，或由于样式发⽣改变（例如：改变元素背景⾊）。\r\n\r\n表现为某些元素的外观被改变。\r\n\r\n\r\n\r\n**两者的关系**\r\n\r\n> 重绘不⼀定会出现重排，重排必定会出现重绘。\r\n\r\n只改变元素的外观不会引发⽹⻚重排；但若浏览器进行重排后，将会重绘受此次重排影响的部分。\r\n\r\n重排和重绘的代价都很⾼昂，破坏⽤户体验、让界面显示变迟缓。\r\n\r\n但相⽐之下，重排的性能影响会更⼤，在⽆法避免的情况下，⼀般宁可选择代价较⼩的重绘。 \r\n\r\n\r\n\r\n## 如何触发重排和重绘？\r\n\r\n改变任意的⽤于构建渲染树的信息，都会引发⼀次重排或重绘。比如： \r\n\r\n- 添加、删除、更新 DOM 节点 \r\n\r\n- 通过 `display: none` 隐藏 DOM 节点（同时会触发重排和重绘）\r\n\r\n- 通过 `visibility: hidden` 隐藏 DOM节点（只会触发重绘，因为没有⼏何变化 ）\r\n\r\n- 移动 DOM 节点，或是给⻚⾯中的 DOM 节点添加动画 \r\n\r\n- 添加⼀个样式表，调整样式属性 \r\n\r\n- ⽤户⾏为，例如：调整浏览器窗⼝的⼤⼩，改变字号，或者滚动页面\r\n\r\n\r\n\r\n## 如何避免重排或重绘？\r\n\r\n主要有三大方式来避免：\r\n\r\n- 集中修改样式\r\n- 使用文档碎片（DocumentFragment）\r\n- 将元素提升为合成层\r\n\r\n\r\n\r\n**集中修改样式**\r\n\r\n通常以改 class 的⽅式，实现样式的集中修改。\r\n\r\n```js\r\nel.setAttribute(\'className\', isDark ? \'dark\' : \'light\')\r\n```\r\n\r\n\r\n\r\n**使用文档碎片**\r\n\r\n通过 `document.createDocumentFragment` 可创建⼀个游离于 DOM 树外的节点，在该节点上做批量操作后再将它插⼊ DOM 树中，只会引发⼀次重排。\r\n\r\n```js\r\n// 创建碎片节点\r\nconst fragment = document.createDocumentFragment()\r\n\r\n// 多次操作碎片节点\r\nfor (let i = 0; i< 10; i++) { \r\n  const node = document.createElement("p")\r\n  node.innerHTML = i\r\n  fragment.appendChild(node)\r\n}\r\n\r\n// 一次性添加到 DOM 树中\r\ndocument.body.appendChild(fragment)\r\n```\r\n\r\n\r\n\r\n**将元素提升为合成层**\r\n\r\n将元素提升为合成层的最好⽅式是使⽤ CSS 的 `will-change` 属性： \r\n\r\n```css\r\n#target {\r\n  will-change: transform; \r\n}\r\n```\r\n\r\n\r\n\r\n提升为合成层有下列几个优点： \r\n\r\n- 合成层的位图会由 GPU 合成，⽐由 CPU 处理更快 \r\n\r\n- 当需要重绘时只重绘本身，不影响其他层 \r\n\r\n- `transform` 和 `opacity` 不会触发重排和重绘\r\n\r\n\r\n\r\n## 前端如何实现即时通讯？\r\n\r\n基于Web的前端，存在以下几种可实现即时通讯的方式：\r\n\r\n- 短轮询\r\n- Comet\r\n- SSE\r\n- WebSocket\r\n\r\n\r\n\r\n**短轮询**\r\n\r\n短轮询就是客户端定时发送请求，获取服务器上的最新数据。不是真正的即时通讯，但一定程度上可以模拟即时通讯的效果。\r\n\r\n\r\n\r\n优缺点：\r\n\r\n- 优点：浏览器兼容性好，实现简单\r\n- 缺点：实时性不高，资源消耗高，存在较多无用请求，影响性能\r\n\r\n\r\n\r\n**Comet**\r\n\r\n有两种实现 Comet 的方式：\r\n\r\n1. 使用 Ajax 长轮询（long-polling）\r\n2. 使用 HTTP 长连接（基于 iframe 和 htmlfile 的流）\r\n\r\n\r\n\r\n优缺点：\r\n\r\n- 优点：浏览器兼容性好，即时性好，不存在⽆⽤请求 \r\n\r\n- 缺点：服务器压力较大（维护⻓连接会消耗较多服务器资源）\r\n\r\n\r\n\r\n[参考文章：Comet技术详解](http://www.52im.net/thread-334-1-1.html)\r\n\r\n\r\n\r\n**SSE**\r\n\r\n服务端推送事件（Server-Sent Event），它是⼀种允许服务端向客户端推送新数据的 HTML5 技术。 \r\n\r\n优缺点：\r\n\r\n- 优点：基于 HTTP，无需太多改造就能使⽤；相比 WebSocket 要简单方便很多\r\n\r\n- 缺点：基于⽂本传输，效率没有 WebSocket ⾼；不是严格的双向通信，客户端⽆法复⽤连接来向服务端发送请求，\r\n\r\n  而是每次都需重新创建新请求\r\n\r\n[参考文章：SSE教程](https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html)\r\n\r\n\r\n\r\n**WebSocket**\r\n\r\n这是基于 TCP 协议的全新、独⽴的协议，作⽤是在服务器和客户端之间建⽴实时的双向通信。\r\n\r\nWebSocket 协议与 HTTP 协议保持兼容，但它不会融⼊ HTTP 协议，仅作为 HTML 5 的⼀部分。 \r\n\r\n优缺点：\r\n\r\n- 优点：真正意义上的双向实时通信，性能好、延迟低 \r\n\r\n- 缺点：由于是独⽴于 HTTP 的协议，因此要使用的话需要对项⽬作改造；使⽤复杂度较⾼，通常需要引⼊成熟的库；并且⽆法兼容低版本的浏览器\r\n\r\nHTTP 和 WebSocket 的连接通信比较图：\r\n\r\n<img src="/images/image-20210221101152845.png" alt="image-20210221101152845" style="zoom:30%;" />\r\n\r\n\r\n\r\n\r\n\r\n## 什么是浏览器的同源策略？\r\n\r\n首先，同源是指资源地址的 "协议 + 域名 + 端⼝" 三者都相同，即使两个不同域名指向了同⼀ IP 地址，也被判断为⾮同源。\r\n\r\n下面是一些地址的同源判断示例：\r\n\r\n![image-20210221103114013](/images/image-20210221103114013.png)\r\n\r\n\r\n\r\n了解了什么是同源，再来说同源策略。\r\n\r\n> 同源策略是一种⽤于隔离潜在恶意⽂件的重要安全保护机制，它用于限制从⼀个源加载的⽂档或脚本与来⾃另⼀个源的资源进⾏交互。\r\n\r\n\r\n\r\n在浏览器中，⼤部分内容都受同源策略限制，除了以下三个标签：\r\n\r\n- `<img>`\r\n- `<link>`\r\n- `script`\r\n\r\n\r\n\r\n## 如何实现跨域？\r\n\r\n历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：\r\n\r\n- JSONP\r\n- CORS\r\n- 服务器代理(webpack代理, Nginx反向代理)\r\n\r\n**JSONP** \r\n\r\n这是一种非常经典的跨域方案，它利用了`<script>` 标签不受同源策略的限制的特性，实现跨域效果。\r\n\r\n优点：\r\n\r\n- 实现简单\r\n- 兼容性好\r\n\r\n缺点：\r\n\r\n- 只支持 GET 请求 （因为 `<script>` 标签只能发送 GET 请求）\r\n- 存在被 XSS 攻击的可能，缺乏安全性保证\r\n- 需要服务端配合改造\r\n\r\n实现示例：\r\n\r\n```js\r\n// 1. JSONP 发送请求的函数封装\r\nfunction JSONP({ url, params, callbackKey, callback }) {\r\n  // 在参数中指定 callback 名字 \r\n  params = params || {} params[callbackKey] = \'jsonpCallback\'\r\n  \r\n  // 预留 callback \r\n  window.jsonpCallback = callback \r\n  \r\n  // 拼接参数字符串\r\n  const queryString = Object.keys(params).map(key => `${key}=${params[key]}`).join(\'&\')\r\n  \r\n  // 创建 script 标签\r\n  const script = document.createElement(\'script\') \r\n  script.setAttribute(\'src\', `${url}?${queryString}`) \r\n  \r\n  // 插⼊ DOM 树\r\n  document.body.appendChild(script) \r\n}\r\n\r\n// 2. 调用示例\r\nJSONP({ \r\n  url: \'http://s.weibo.com/ajax/jsonp/suggestion\', \r\n  params: {\r\n  \tkey: \'test\'\r\n\t},\r\n  callbackKey: \'_cb\',\r\n  callback(res) { \r\n    console.log(res.data) \r\n  } \r\n})\r\n```\r\n\r\n\r\n\r\n**CORS**\r\n\r\n跨域资源共享（CORS），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 HTTP 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。\r\n\r\n当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 HTTP 请求。 \r\n\r\n如果你⽤的是 Node.js 的 Express 框架，则可以这样来进行设置：\r\n\r\n```js\r\n// 创建一个 CORS 中间件 \r\nfunction allowCrossDomain(req, res, next) { \r\n  res.header(\'Access-Control-Allow-Origin\', \'http://example.com\'); \r\n  res.header(\'Access-Control-Allow-Methods\', \'GET,PUT,POST,DELETE\'); \r\n  res.header(\'Access-Control-Allow-Headers\', \'Content-Type\'); \r\n  next(); \r\n}\r\n\r\n//...\r\n\r\napp.configure(function() { \r\n  // ...\r\n  \r\n  // 为 Express 配置 CORS 中间件\r\n  app.use(allowCrossDomain); \r\n  \r\n  // ...\r\n});\r\n```\r\n\r\n在实际项目中，建议使用一些已经比较成熟的开源中间件。\r\n\r\n\r\n\r\n**Nginx反向代理**\r\n\r\n这是目前最方便，最推荐使用的跨域解决方案。Nginx 本身是⼀款极其强⼤的 Web 服务器，轻量级、启动快、⾼并发。 \r\n\r\n\r\n\r\n现在的后端服务程序，通常会使用 Nginx 进行反向代理：\r\n\r\n<img src="/images/image-20210221111025585.png" alt="image-20210221111025585" style="zoom:33%;" />\r\n\r\n反向代理的原理其实很简单：\r\n\r\n> Nginx 作为代理服务器，所有客户端的请求都必须先经过 Nginx 的处理，然后再将请求转发给其他后端程序（比如 Node.js 或Java 程序），这样就规避同源策略的影响\r\n\r\n\r\n\r\n下面是一个配置 Nginx 反向代理的示例配置文件：\r\n\r\n```nginx\r\n# 进程, 可更具 cpu 数量调整\r\nworker_processes 1; \r\n\r\nevents { \r\n  # 连接数 \r\n  worker_connections 1024; \r\n}\r\n\r\nhttp {\r\n  include mime.types; \r\n  default_type application/octet-stream;\r\n  \r\n  sendfile on;\r\n  \r\n  #连接超时时间，服务器会在这个时间过后关闭连接。 \r\n  keepalive_timeout 10;\r\n  \r\n  # 开启 Gzip 压缩\r\n  gzip on;\r\n  \r\n  # 直接请求nginx也是会报跨域错误的这⾥设置允许跨域 \r\n  # 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了) \r\n  add_header Access-Control-Allow-Origin *; \r\n  add_header Access-Control-Allow-Headers X-Requested-With; \r\n  add_header Access-Control-Allow-Methods GET,POST,OPTIONS;\r\n  \r\n  # srever模块配置是http模块中的⼀个⼦模块，⽤来定义⼀个虚拟访问主机\r\n  server { \r\n    listen 80; \r\n    server_name localhost; \r\n    \r\n    # 根路径指到index.html \r\n    location / { \r\n      root html; \r\n      index index.html index.htm; \r\n    }\r\n    \r\n    # 请求转发：\r\n    # 例如 http://localhost/api 的请求会被转发到 http://192.168.0.103:8080\r\n    location /api {\r\n      proxy_set_header Host $host; \r\n      proxy_set_header X-Real-IP $remote_addr; \r\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \r\n      proxy_pass http://192.168.0.103:8080; \r\n    }\r\n    \r\n    # 重定向错误⻚⾯到/50x.html \r\n    error_page 500 502 503 504 /50x.html; \r\n    \r\n    location = /50x.html { \r\n      root html; \r\n    } \r\n  } \r\n}\r\n```\r\n\r\n[参考文章：跨域方式实现原理](https://juejin.cn/post/6844903767226351623#heading-19)\r\n\r\n\r\n\r\n# 前端工程化\r\n\r\n## Babel的原理是什么？\r\n\r\nBabel 的主要工作是对代码进行转译。\r\n\r\n转译分为三阶段：\r\n\r\n- 解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程 \r\n\r\n- 转换（Transform），对 AST 进⾏变换方面的⼀系列操作。通过 babel-traverse，对 AST 进⾏遍历并作添加、更新、删除等操作\r\n\r\n- ⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码\r\n\r\n\r\n\r\n转译流程示意图：\r\n\r\n![image-20210221114506275](/images/image-20210221114506275.png)\r\n\r\n\r\n\r\n## 如何编写一个Babel插件？\r\n\r\nBabel 插件的主要工作阶段是在 Babel 将代码解析成 AST 之后，插件们对 AST 进行各种操作后，再由 Babel 输出最终的代码。\r\n\r\n要编写一个 Babel 插件模块，则需要为模块代码导出一个函数，且该函数返回一个对象，对象内应包含有 `visitor` 属性：\r\n\r\n```js\r\nmodule.exports = function (babel) {\r\n  return {\r\n    visitor: {}\r\n  }\r\n}\r\n```\r\n\r\n`visitor` 是针对各类 AST 节点作处理的地⽅。我们可以通过 `console.log` 打印或 [AST Explorer 工具](https://astexplorer.net/) 来查看 Babel 具体生成的 AST 节点。\r\n\r\n\r\n\r\n**示例**\r\n\r\n我们来编写一个插件，其功能是能自动将源码中的数字字面量数学运算进行预计算处理，简化代码。例如：\r\n\r\n```js\r\n// 原来的代码\r\nconst result = 1 + 2\r\n\r\n// 处理后的代码\r\nconst result = 3    // 这样优化以后，在实际运行时可以减少一次加法操作\r\n```\r\n\r\n\r\n\r\n我们可以先通过 AST Explorer 来获取 JSON 格式的 AST 结构：\r\n\r\n```json\r\n{\r\n  "type": "Program",\r\n  "start": 0,\r\n  "end": 20,\r\n  "body": [\r\n    {\r\n      "type": "VariableDeclaration",\r\n      "start": 0,\r\n      "end": 20,\r\n      "declarations": [\r\n        {\r\n          "type": "VariableDeclarator",\r\n          "start": 6,\r\n          "end": 20,\r\n          "id": {\r\n            "type": "Identifier",\r\n            "start": 6,\r\n            "end": 12,\r\n            "name": "result"\r\n          },\r\n          "init": {\r\n            "type": "BinaryExpression",\r\n            "start": 15,\r\n            "end": 20,\r\n            "left": {\r\n              "type": "Literal",\r\n              "start": 15,\r\n              "end": 16,\r\n              "value": 1,\r\n              "raw": "1"\r\n            },\r\n            "operator": "+",\r\n            "right": {\r\n              "type": "Literal",\r\n              "start": 19,\r\n              "end": 20,\r\n              "value": 2,\r\n              "raw": "2"\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      "kind": "const"\r\n    }\r\n  ],\r\n  "sourceType": "module"\r\n}\r\n```\r\n\r\n\r\n\r\n从以上 AST 结构可以知道，`1 + 2` 是一个 `BinaryExpression` 类型的节点，那么在我们编写的插件代码中的 `visitor` 里就可以这样进行处理：\r\n\r\n```js\r\nvar babel = require(\'babel-core\'); \r\nvar t = require(\'babel-types\'); \r\n\r\nvar visitor = {\r\n  BinaryExpression(path) { \r\n    const node = path.node;\r\n\r\n    let result;\r\n\r\n    // 判断表达式两边，是否都是数字 \r\n    if (t.isNumericLiteral(node.left) && t.isNumericLiteral(node.right)) { \r\n      // 根据不同的操作符作运算 \r\n      switch (node.operator) { \r\n        case "+": \r\n          result = node.left.value + node.right.value; \r\n          break;\r\n        case "-": \r\n          result = node.left.value - node.right.value; \r\n          break; \r\n        case "*": \r\n          result = node.left.value * node.right.value; \r\n          break;\r\n        case "/": \r\n          result = node.left.value / node.right.value; \r\n          break; \r\n        case "**": \r\n          let i = node.right.value; \r\n          while (--i) { \r\n            result = result || node.left.value; \r\n            result = result * node.left.value; \r\n          }\r\n          break; \r\n        default: \r\n      } \r\n    }\r\n\r\n    // 如果上⾯的运算有结果的话 \r\n    if (result !== undefined) { \r\n      // 把表达式节点替换成number字⾯量 \r\n      path.replaceWith(t.numericLiteral(result)); \r\n    } \r\n  }\r\n};\r\n\r\nmodule.exports = function (babel) { \r\n  return { visitor };\r\n}      \r\n```\r\n\r\n\r\n\r\n这个插件的基本功能就完成了，来运行试试：\r\n\r\n```js\r\nconst babel = require("babel-core");\r\n\r\nconst result = babel.transform("const result = 1 + 2;", { \r\n  plugins: [ \r\n    require("./index") \r\n  ] \r\n});\r\n\r\nconsole.log(result.code);\t// 结果：const result = 3;\r\n```\r\n\r\n转换结果符合预期。\r\n\r\n\r\n\r\n不过这个插件还不能完全正确的工作，在转换如 `const result = 1 + 2 + 3 + 4 + 5;` 这样的代码时，结果为 `const result = 3 + 3 + 4 + 5;`，也就是只转换了代码中的第一段表达式计算。\r\n\r\n如果用 AST Explorer 查看 AST 结构的话，会发现原来这个运算由层层嵌套的 `BinaryExpression` 组成：\r\n\r\n> BinaryExpression(  BinaryExpression( BinaryExpression( BinaryExpression(1 + 2) + 3 ) + 4 ) + 5 ) \r\n\r\n\r\n\r\n因此我们得改造一下之前的代码逻辑，进行遍历操作：\r\n\r\n```js\r\n// 如果上⾯的运算有结果的话 \r\nif (result !== undefined) { \r\n  // 把表达式节点替换成number字⾯量 \r\n  path.replaceWith(t.numericLiteral(result)); \r\n  \r\n  // 向上遍历⽗级节点\r\n  let parentPath = path.parentPath; \r\n  parentPath && visitor.BinaryExpression.call(this, parentPath);\r\n} \r\n```\r\n\r\n这样就能正确工作了。\r\n\r\n[参考文档：Babel插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#builders)\r\n\r\n\r\n\r\n## 你们的Git工作流是什么样的？\r\n\r\n每个公司采用的 Git 工作流都可能会有差别，有的比较规范，有的比较随意。在这里介绍一个名为 GitFlow 的 git 标准操作流程。\r\n\r\n\r\n\r\n在 GitFlow 标准下，我们的 git 仓库需要包含以下几个关键分支：\r\n\r\n- master：主分支\r\n- develop：主开发分⽀。包含确定即将发布的代码\r\n- feature：新功能分⽀。⼀个新功能对应⼀个分⽀\r\n- release：发布分⽀。发布时⽤的分⽀，⼀般测试阶段发现的 bug 在这个分⽀进⾏修复\r\n- hotfix：热补丁分支。用于修改在线上版本中发现的严重紧急 bug\r\n\r\n\r\n\r\n**GitFlow 的主要优点**\r\n\r\n1. 支持并⾏开发\r\n\r\n因为每个新功能都会建⽴⼀个新的 feature 分⽀，从⽽和其他已经完成的功能隔离开，且当只有在新功能完成开发的情况下，其对应的 feature 分⽀才会被合并到主开发分⽀（develop 分支）。\r\n\r\n另外，如果你正在开发某个功能的同时⼜有⼀个新功能需要开始开发，那么你只需把当前 feature 的代码提交后，新建另外⼀个 feature 分⽀即可开发新功能了。\r\n\r\n你也可以随时切回之前的其他 feature 分⽀继续完成该功能的开发。 \r\n\r\n\r\n\r\n- 协作开发\r\n\r\n因为每个 feature 分⽀上改动的代码都只对该 feature 对应的功能生效，所以不同 feature 分支上的代码在开发时不会互相影响，大家可以相安无事的开发自己负责的功能。\r\n\r\n同时我们可以根据分支的名称，很容易知道每个⼈都在做什么功能。 \r\n\r\n\r\n\r\n- 发布阶段\r\n\r\n当⼀个新 feature 开发完成时，它会被合并到 develop 分⽀，这就意味着 develop 分支上包含了所有已经开发完成的功能。\r\n\r\n因此，在开发新的 feature 时，我们只需从 develop 分⽀来创建新的分⽀，即可在新的 feature 分支中包含所有已完成的最新功能。 \r\n\r\n\r\n\r\n- ⽀持紧急修复\r\n\r\nhotfix 分⽀是从某个已经发布的 Tag 上创建出来来，用于紧急修复 Bug。\r\n\r\n该紧急修复只影响这个已经发布的 Tag，⽽不会影响你正在开发的其他新 feature 。\r\n\r\n\r\n\r\n**注意点**\r\n\r\n1. feature 分⽀都是从 develop 分⽀上创建的，开发完成后再合并到 develop 分⽀上，等待发布\r\n\r\n2. 当需要发布时，我们要从 develop 分⽀上创建⼀个 release 分⽀，然后该 release 分⽀会发布到测试环境进⾏测试。如果发现问题的话，就会直接在该分⽀上进⾏修复。所有问题修复之前，会不停重复 `发布` > `测试` > `修复` > `重新发布`  > `重新测试` 流程。 发布结束，该 release 分⽀会被合并到 develop 以及 master 分⽀，从⽽保证不会有代码丢失\r\n\r\n3. master 分⽀只跟踪已经发布的代码，合并到 master 上的 commit 只能来⾃ release 分⽀和 hotfix 分⽀\r\n\r\n4. hotfix 分⽀的作⽤是紧急修复⼀些 Bug，它们都是从 master 分⽀上的某个 Tag 建⽴，修复结束后再会被合并到 develop 和 master 分⽀上\r\n\r\n\r\n\r\n[参考文章：Git工作流](https://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\r\n\r\n\r\n\r\n## Git的rebase和merge的区别是什么？\r\n\r\n`git rebase` 和 `git merge` 两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。 \r\n\r\n\r\n\r\n以一个 `feature/todo` 分⽀合并到 `master`主分⽀为例，我们来看一下分别⽤ `rebase` 和 `merge` 会有什么不同。\r\n\r\n\r\n\r\n**使用 Merge**\r\n\r\n<img src="/images/image-20210222132936016.png" alt="image-20210222132936016" style="zoom:30%;" />\r\n\r\n`merge` 会⾃动创建⼀个新的 `commit`， 如果合并时遇到冲突的话，只需要修改后重新 `commit`。 \r\n\r\n- 优点：能记录真实的 `commit` 情况，包括每个分⽀的详情 \r\n\r\n- 缺点：由于每次 `merge` 会⾃动产⽣⼀个 `merge commit`，因此在使⽤⼀些可视化的 git 工具时会看到这些自动产生的 `commit`，这些 `commit` 对于程序员来说没有什么特别的意义，反而会影响阅读\r\n\r\n\r\n\r\n**使用 Rebase**\r\n\r\n<img src="/images/image-20210222133524146.png" alt="image-20210222133524146" style="zoom:30%;" />\r\n\r\n`rebase` 会合并之前的 `commit` 历史。 \r\n\r\n- 优点：可以得到更简洁的提交历史，去掉了 `merge commit`\r\n\r\n- 缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息 \r\n\r\n\r\n\r\n**建议**\r\n\r\n- 当需要保留详细的合并信息时，建议使⽤ `git merge`，特别是需要将分⽀合并进 `master` 分⽀时\r\n\r\n- 当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的提交信息对自己来说没有必要，那么可尝试使用 `git rebase`\r\n\r\n\r\n\r\n\r\n\r\n# Vue\r\n\r\n## 什么是MVVM？\r\n\r\nModel-View-ViewModel 模式，最早在 2005 年微软推出的基于 Windows 的⽤户界⾯框架 WPF 中提出，而最早采用 MVVM 的前端框架是 2010 年发布的 Knockout。\r\n\r\n\r\n\r\n<img src="/images/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" />\r\n\r\n\r\n\r\n**Model 层**\r\n\r\n对应数据层的域模型，主要用来做域模型的同步。\r\n\r\n通过 `Ajax`、`fetch` 等 API 完成客户端和服务端业务模型的同步。\r\n\r\n在分层关系中，它主要⽤于抽象出 ViewModel 层中视图的 Model。 \r\n\r\n\r\n\r\n**View 层**\r\n\r\n作为视图模板存在，其实在 MVVM 中整个 View 就是⼀个动态模板。\r\n\r\n除了用于定义结构和布局之外，它还展示了 ViewModel 层的数据和状态。\r\n\r\nView 层并不负责状态的实际处理，它只是做：数据绑定声明、 指令声明、 事件绑定声明。\r\n\r\n\r\n\r\n**ViewModel 层**\r\n\r\n负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明进行实际的业务逻辑。\r\n\r\nViewModel 底层会做好绑定属性的监听，当 ViewModel 中的数据变化时，View 层会自动进行更新；⽽当 View 中声明了数据的双向绑定（表单元素），框架也会监听 View 层（表单元素）值的变化，⼀旦变化，则 View 层绑定的 ViewModel 中的数据也会得到⾃动更新。\r\n\r\n\r\n\r\n## MVVM的优缺点有哪些？\r\n\r\n**优点**\r\n\r\n1. 实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性\r\n\r\n> ⽐如：View 可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定于不同的 "View"，当 View 发生变化时 Model 一定会随之改变，而当 Model 变化时则 View 可以不变。我们可以把⼀些视图逻辑放在⼀个 ViewModel ⾥，以此让多个 View 重⽤这段视图逻辑。\r\n\r\n2. 提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码 \r\n\r\n3. 能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来 \r\n\r\n\r\n\r\n**缺点**\r\n\r\n1. Bug 很难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 模版中的，它们没办法打断点进行 Debug \r\n\r\n2. 在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，也能很容易的保证了数据的⼀致性，但如果⻓期持有不释放内存，就会造成更多的内存消耗 \r\n\r\n3. 对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼\r\n\r\n\r\n\r\n## 谈谈对Vue生命周期的理解？\r\n\r\n**生命周期的概念**\r\n\r\n每个 Vue 实例都有⼀个完整的⽣命周期：\r\n\r\n1. 开始创建\r\n2. 初始化数据\r\n3. 编译模版\r\n4. 挂载 DOM\r\n5. 渲染、更新数据 => 重新渲染\r\n6. 卸载\r\n\r\n这⼀系列过程我们称之为 Vue 的⽣命周期。\r\n\r\n\r\n\r\n**各个生命周期的作用**\r\n\r\n| 生命周期      | 执行时机                                                     |\r\n| ------------- | ------------------------------------------------------------ |\r\n| beforeCreate  | 在组件实例被创建之初、组件的属性⽣效之前被调用               |\r\n| created       | 在组件实例已创建完毕。此时属性也已绑定，但真实DOM还未⽣成，$el 还不可⽤ |\r\n| beforeMount   | 在组件挂载开始之前被调⽤。相关的 render 函数⾸次被调⽤       |\r\n| mounted       | 在 el 被新建的 vm.$el 替换并挂载到实例上之后被调用           |\r\n| beforeUpdate  | 在组件数据更新之前调⽤。发⽣在虚拟 DOM 打补丁之前            |\r\n| update        | 在组件数据更新之后被调用                                     |\r\n| activited     | 在组件被激活时调⽤（使用了 `<keep-alive>` 的情况下）         |\r\n| deactivated   | 在组件被销毁时调⽤（使用了 `<keep-alive>` 的情况下）         |\r\n| beforeDestory | 在组件销毁前调⽤                                             |\r\n| destoryed     | 在组件销毁后调⽤                                             |\r\n\r\n\r\n\r\n**生命周期示意图**\r\n\r\n<img src="/images/image-20210224084130350.png" alt="image-20210224084130350"  />\r\n\r\n\r\n\r\n## 在Vue中网络请求应该放在哪个生命周期中发起？\r\n\r\n可以在 `mounted` 或 `created` 这两个⽣命周期中调⽤发起网络请求。\r\n\r\n\r\n\r\n## Vue组件之间如何进行通信？\r\n\r\n**`props` 和 `$emit + v-on`**\r\n\r\n通过 `props` 将数据在组件树中进行⾃上⽽下的传递；\r\n\r\n通过 `$emit` 和 `v-on` 来作信息的向上传递。 \r\n\r\n\r\n\r\n**EventBus**\r\n\r\n可通过 EventBus 进⾏信息的发布与订阅。\r\n\r\n\r\n\r\n**Vuex**\r\n\r\n全局状态管理库。可通过它来进行全局数据流的管理。\r\n\r\n \r\n\r\n**`$attrs` 和 `$listeners`**\r\n\r\n在 Vue 2.4 版本中加⼊的 `$attrs` 和 `$listeners` 可以用来作为跨级组件之间的通信机制。\r\n\r\n\r\n\r\n**`provide` 和 `inject`**\r\n\r\n由于 `provide` 和 `inject` 可以允许⼀个祖先组件向它的所有⼦孙组件注⼊⼀个依赖（不论组件层次有多深），并在其上下游关系成⽴的时间⾥始终⽣效，因此这种机制也就成为了一种跨组件通信的手段。\r\n\r\n\r\n\r\n> 另外还有一些方式使用场景有限，在此不介绍了。\r\n>\r\n> 可以阅读参考文章：[Vue中的8种组件通信方式](https://juejin.cn/post/6844903887162310669)\r\n\r\n\r\n\r\n## computed和watch的区别是什么？\r\n\r\n**computed**\r\n\r\n1. 它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景 \r\n\r\n2. 它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存，只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算 \r\n\r\n3. 它适⽤于计算⽐较消耗性能的计算场景 \r\n\r\n\r\n\r\n**watch**\r\n\r\n1. 它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。主要⽤于观察 `props`、`$emit` 或本组件的值，当这些值发生变化时，执⾏回调 \r\n\r\n2. 它不具有缓存性。当⻚⾯重新渲染时，即使值没发生变化也会执⾏\r\n\r\n\r\n\r\n**建议**\r\n\r\n1. 当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 `computed`\r\n\r\n2. 当需要在某个数据发生变化的同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ `watch`\r\n\r\n\r\n\r\n## Vue双向绑定原理？\r\n\r\n在 Vue 2.x 中，利⽤的是 `Object.defineProperty` 去劫持对象的访问器（Getter、Setter），当对象属性值发⽣变化时可获取变化，然后根据变化来作后续响应；\r\n\r\n在 Vue 3.0 中，则是通过 `Proxy` 代理对象进⾏类似的操作。\r\n\r\n\r\n\r\n## Object.defineProperty和Proxy的优缺点？\r\n\r\n**Proxy** \r\n\r\n- 可以直接监听整个对象，⽽⾮是对象的属性 \r\n\r\n- 可以直接监听数组的变化\r\n\r\n- 拦截⽅法丰富：多达13种，不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等。比 `Object.defineProperty` 强大很多 \r\n\r\n- 返回的是⼀个新对象，可以在不影响原对象的情况下，只操作新对象来达到⽬的；⽽ `Object.defineProperty` 只能遍历原对象属性并直接修改原对象\r\n\r\n- 受到各浏览器⼚商的重点持续性能优化，能享受到作为新标准的性能红利 \r\n\r\n**Object.defineProperty**\r\n\r\n- 兼容性较好（可⽀持到 IE9）\r\n\r\n\r\n\r\n## 如何理解Vue的响应式系统？\r\n\r\n(考察MVVM)   M: model数据模型,    V:view视图模型,  VM: viewModel视图数据模型\r\n\r\n双向:\r\n\r\n1. 视图变化了, 数据自动更新   =>  监听原生的事件即可,  输入框变了,  监听输入框input事件\r\n2. 数据变化了, 视图要自动更新  =>  vue2 和 vue3\r\n\r\n### 基本原理\r\n\r\nvue2.0 数据劫持:  Object.defineProperty  (es5)\r\n\r\nvue3.0 数据劫持:  Proxy   (es6)\r\n\r\n分析 :此题考查 Vue的 MVVM 原理\r\n\r\n解答:  Vue的双向绑定原理其实就是 MVVM 的基本原理, Vuejs官网已经说明, 实际就是通过 Object.defineProperty方法 完成了对于Vue实例中数据的 **`劫持`**, 通过对于 data中数据 进行set的劫持监听, 然后通过**`观察者模式`**, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新\r\n\r\n简单概述 : 通过Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新\r\n\r\n### 观察者模式\r\n\r\n观察者模式:  当对象间存在  **一对多**  关系时，则使用观察者模式（Observer Pattern）。\r\n\r\n比如，当一个对象或者数据被修改时，则会自动通知依赖它的对象。\r\n\r\n**意图：**定义对象间的一种 `一对多的依赖关系`，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\r\n\r\n\r\n\r\n拍卖会的时候，大家相互叫价，拍卖师(Dep)会观察最高标价(Object.defineProperty)，\r\n\r\n一旦最高价变化了, 然后通知给其它竞价者(watcher观察者 - 订阅者, 订阅了价格的变化)，这就是一个观察者模式 \r\n\r\n\r\n\r\n下图为Vue框架在数据初始化中使用观察者模式的示意图： \r\n\r\n![image-20201208122803496](images/image-20201208122803496.png)\r\n\r\nDep要进行 **依赖收集**，并通过一个subs数组, 记录观察者Watcher,  \r\n\r\nWatcher 分为渲染 watcher、计算属性 watcher、侦听器 watcher三种 \r\n\r\n收集依赖: 简单点说就是谁借了我的钱，我就把那个人  **记下来**  ，以后我的钱少了 我就通知他们说我没钱了 \r\n\r\n```jsx\r\n<div>\r\n  <p>{{ msg }}</p>   // Watcher1(渲染), 依赖于msg\r\n</div>\r\n\r\n<div>\r\n  <h1>{{ car }}</h1>   // Watcher2(渲染),  依赖于car\r\n</div>\r\n\r\n<div>\r\n  <h1>{{ myMsg }}</h1>   // Watcher3(渲染), 依赖于myMsg\r\n</div>\r\n\r\ncomputed: {\r\n  myMsg () {\r\n    console.log(\'计算属性重新计算了\')\r\n    return this.msg + \'20\'  // Watcher4(计算属性中), 依赖于msg, msg变了重新计算\r\n  }\r\n}\r\n\r\nwatch: {\r\n  msg (newValue) {\r\n    console.log(\'新的msg\', newValue) // Watcher5(侦听器), 将来msg变化, 这边要执行这个函数\r\n  }\r\n}\r\n\r\n------------------------------------------------------------------\r\n\r\n// 收集依赖 (dep结构有点类似于二维数组, (Map结构))   arr.type="msgDep"\r\ndep: [\r\n  msgDep: [Watcher5(侦听器依赖), Watcher4(计算属性依赖), Watcher1(渲染)],\r\n  carDep: [Watcher2(渲染)],\r\n  myMsgDep: [Watcher3(渲染)]\r\n]\r\n\r\n\r\n// Watcher\r\n{\r\n  callback: Function, (数据变化后, 需要执行的回调)\r\n  isRenderWatcher: Boolean, (是否是render的watcher, 是否要触发视图的更新, 往后放, 最后统一虚拟dom对比, 统一更新)\r\n  ...\r\n}\r\n```\r\n\r\n比如: 假定数据 money 变了, 那么没有任何与money相关的观察者, 就不需要进行任何更新操作, 也不需要执行任何的监视函数\r\n\r\n然而: 假定数据 msg 变了, 就会通知到相关的Watcher, 且优先通知侦听器Watcher和计算属性Watcher, 后进行统一的渲染更新\r\n\r\n1. 通知侦听器Watcher,  立刻执行配置的函数,  console.log(\'新的msg\', newValue) \r\n2. 通知计算属性Watcher, 计算属性依赖的值变了, 需要重新计算\r\n   且更新后, myMsg 变化了,  需要进行进行视图的渲染  (render)     (--- 要更新, 等着---)\r\n3. 通过到watcher1, 渲染Watcher  (---要更新---)\r\n4. 最后统一进行, 新旧虚拟dom的对比, 完成视图的更新\r\n\r\n\r\n\r\n**当数据状态发生改变时，会被 Object.defineProperty 监听劫持到, 会通知到 Dep,  并根据收集的依赖关系,**  \r\n\r\n**让订阅者Watcher进行数据更新（update）操作 ,  派发更新** \r\n\r\n\r\n\r\n总结概述: vue采用的是观察者模式, 是一种一对多的关系,  一上来vue在解析渲染时, 会进行依赖收集, 会将渲染 watcher、计算属性 watcher、侦听器 watcher, 都收集到dep中,将来Object.defineProperty 监听到数据变化, 就根据依赖关系, 派发更新\r\n\r\n\r\n\r\n\r\n\r\n## Vue中的key到底有什么用？\r\n\r\n`key` 是为 Vue 中的虚拟 DOM 节点（vNode）标记唯⼀性的 id。\r\n\r\n作用:  给虚拟dom添加标识,  **(优化复用对比策略, 优化渲染性能)**\r\n\r\n主要考察: \r\n\r\n1. vue 的更新机制 (差异化更新) 对比新旧虚拟dom 进行更新视图\r\n\r\n   为什么对比虚拟dom, 而不对比真实的dom ? 真实的dom太复杂, 对比起来性能太差\r\n\r\n2. 虚拟dom: 使用 js 对象的方式, 模拟真实的 dom 结构\r\n\r\n   属性的量大大的减少了, 没有真实dom的那么多无效的属性, 对比起来性能高很多\r\n\r\n3. diff 算法: 默认的对比(diff) 机制,  同层兄弟元素, 是按照下标进行对比的, 但是加了 key,  **就相当于给虚拟dom加了个标识**\r\n\r\n   对比策略, 就是对相同key的元素进行对比了, 在列表v-for中, key的使用尤为常见, 可以用于优化渲染性能\r\n\r\n### diff算法\r\n\r\ndiff 算法的基本策略 (对比新旧虚拟dom差异的一种算法):\r\n\r\n1. 由于dom结构是一个树形结构, 就算是对比新旧虚拟dom, 一样是在对比树形结构\r\n\r\n   而树形结构, 每往下都一层, 遍历成本就越高\r\n\r\n2. 为了避免一些无效的对比, diff算法, (tree diff) 优先比较树的根节点\r\n\r\n   如果根节点元素类型(组件), 是一致的, 才考虑复用元素内部的结构\r\n\r\n   如果根节点元素类型(组件), 不一致, 直接销毁, 重新构建新的结构\r\n\r\n   ```\r\n   旧\r\n   <div>\r\n   \t<span>我是内容</span>\r\n   </div>\r\n   \r\n   \r\n   新\r\n   <li>\r\n   \t<a href="#">我是内容</a>\r\n   \t<span>我是内容</span>\r\n   </li>\r\n   ```\r\n\r\n   大大的提升了对比的效率\r\n\r\n3. 同一根节点下,   同级兄弟元素, 默认的对比策略: 按照下标对比\r\n\r\n   ```\r\n   旧\r\n   <div class="box">\r\n   \t<h1>大标题</h1>\r\n   \t<p>内容</p>\r\n   </div>\r\n   \r\n   新\r\n   <div class="message">\r\n   \t<h1>测试标题</h1>\r\n   \t<p>内容</p>\r\n   </div>\r\n   ```\r\n\r\n4. 同一根节点下,   同级兄弟元素,  如果配置 key 属性, 那么对比的策略, 就不是按照下标, 而是按照key进行 一一对比\r\n\r\n   ```\r\n   旧\r\n   <div class="box">\r\n   \t<h1 key="201">大标题</h1>\r\n   \t<p key="202">内容</p>\r\n   </div>\r\n   \r\n   新\r\n   <div class="message">\r\n   \t<h1 key="200">大标题</h1>   // 新结构\r\n   \t<p key="202">内容</p>    // 对比出来, 原来结构有key="202", 进行对比, 完成了复用\r\n   </div>\r\n   ```\r\n\r\n   如果你希望一个结构, 并不进行复用, 就是希望某个组件某个结构,  能够重新构建, 可以设置一个不同的 key\r\n\r\n\r\n\r\n### key的常见应用场景\r\n\r\nkey 的常见应用场景 => v-for,  v-for 遍历的列表中的项的顺序, 非常的容易改变\r\n\r\n1 往后面加, 默认的对比策略, 按照下标,  没有任何问题\r\n\r\n```jsx\r\n// 旧\r\n<ul>\r\n  <li>张三</li>\r\n  <li>李四</li>\r\n</ul>\r\n\r\n// 新\r\n<ul>\r\n  <li>张三</li>\r\n  <li>李四</li>\r\n  <li>王五</li>\r\n</ul>\r\n```\r\n\r\n2 往前面加, 由于下标变了, 如果按照之前的下标对比, 元素是混乱的, 策略: 加上key\r\n\r\n​    一旦加上了key, 就是按照 key 进行新旧dom的对比了\r\n\r\n```jsx\r\n// 旧 \r\n<ul>\r\n  <li key="17">张三</li>\r\n  <li key="31">李四</li>\r\n</ul>\r\n\r\n// 新  [ { id: 17, name: \'张三\' }, ... ]\r\n<ul>\r\n  <li key="52">王五</li>\r\n  <li key="17">张三</li>\r\n  <li key="31">李四</li>\r\n</ul>\r\n```\r\n\r\n**总结: key 就是给 虚拟dom 添加了一个 标识, 优化了对比策略!!!**\r\n\r\n\r\n\r\n# React\r\n\r\n## React最新的生命周期是怎么样的？\r\n\r\n在 React 16 版本中，三个之前的生命周期被标识为废弃，并在 React 17 中计划全部删除它们：\r\n\r\n- componentWillMount \r\n\r\n- componentWillReceiveProps \r\n\r\n- componentWillUpdate\r\n\r\n\r\n\r\n当它们被删除后，将会只保留三个添加了`UNSAVE_`前缀的函数版本，作为向下兼容用途。因此我们在新项目中，要尽量避免使用这几个生命周期而使用最新的生命周期函数。\r\n\r\n\r\n\r\n⽬前 React 16.8+ 的⽣命周期分为三个阶段：挂载阶段、更新阶段、卸载阶段。\r\n\r\n\r\n\r\n**挂载阶段** \r\n\r\n`constructor` ：组件的构造函数，它会最先被执⾏，我们通常在构造函数⾥初始化 `state` 状态对象、或给⾃定义⽅法绑定 `this` \r\n\r\n\r\n\r\n`getDerivedStateFromProps` ：这是个静态⽅法，当我们接收到新的属性后想要去修改 `state` 时可以使用\r\n\r\n\r\n\r\n`render`：这是个只返回需要渲染内容的纯函数，不要包含其它的业务逻辑，可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 值 和 null 值等内容 \r\n\r\n\r\n\r\n`componentDidMount` ：在组件装载后被调⽤，此时可以获取 DOM 节点并操作，对服务器的请求、订阅等操作都可以写在这个地方，但记得要在 `componentWillUnmount` 中取消订阅，即释放资源\r\n\r\n\r\n\r\n**更新阶段** \r\n\r\n`getDerivedStateFromProps` ：此⽅法在更新个挂载阶段都可能会调⽤ \r\n\r\n\r\n\r\n`shouldComponentUpdate` ：该函数有两个参数 `nextProps` 和 `nextState`，表示新的属性和变化之后的状态；它返回⼀个布尔值，`true` 表示会触发重新渲染，`false` 则表示不会触发重新渲染，默认返回 `true`。我们通常利⽤该⽣命周期来优化 React 程序的性能\r\n\r\n\r\n\r\n`render` ：更新阶段也会触发此⽣命周期 \r\n\r\n\r\n\r\n`getSnapshotBeforeUpdate` ：该⽅法在 `render` 之后、在 `componentDidUpdate` 之前被调⽤，它有两个参数 `prevProps` 和`prevState`，表示之前的属性和状态，并且该函数有⼀个返回值，返回值会作为第三个参数传给 `componentDidUpdate` ，如果不想要返回值则返回 `null` 即可。该⽣命周期必须与 `componentDidUpdate` 搭配使⽤ \r\n\r\n\r\n\r\n`componentDidUpdate` ：该⽅法在 `getSnapshotBeforeUpdate` ⽅法之后被调⽤，它有三个参数 `prevProps` 、`prevState` 、`snapshot` ，表示之前的属性、之前的状态、以及`snapshot`。第三个参数是 `getSnapshotBeforeUpdate` 所返回的，如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ `getSnapshotBeforeUpdate`，然后在 `componentDidUpdate` 中统⼀触发回调或更新状态\r\n\r\n\r\n\r\n**卸载阶段**\r\n\r\n`componentWillUnmount` ：当组件被卸载或销毁时就会被调⽤，我们可以在这个函数⾥去做一些释放资源的操作，如：清除定时器、取消⽹络请求、清理⽆效的 DOM 元素等\r\n\r\n\r\n\r\n[React生命周期图形示意工具](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)\r\n\r\n\r\n\r\n## 在React中网络请求应该放在哪个生命周期中发起？\r\n\r\n有人认为 React 中的网络异步请求，应该放在 `componentWillMount` 这个生命周期函数中发起，这样可以提前进⾏异步请求，以避免⽩屏现象。其实这个观点是有问题的。\r\n\r\n\r\n\r\n由于 JavaScript 中异步事件的性质，当进行异步 API 调⽤时，浏览器会在此期间继续执⾏其他⼯作。因此，当 React 渲染⼀个组件时，它并不会等待 `componentWillMount` 执行完成任何事情，而是继续往前执行并继续做 `render` ，没有办法 “暂停” 渲染以等待远程数据的返回。\r\n\r\n\r\n\r\n⽽且，在 `componentWillMount` 中发起请求会存在⼀系列潜在问题：\r\n\r\n- 在用 React 作为服务器渲染（SSR）时，如果在 `componentWillMount` 中进行数据的获取，则 `fetch data` 会执⾏两次：⼀次在服务端，⼀次在客户端，这就造成了多余的请求\r\n\r\n- 在 React 16 使用 React Fiber 架构重写后，`componentWillMount` 可能会在⼀次渲染中被多次调⽤。 \r\n\r\n\r\n\r\n**⽬前官⽅推荐的是在 `componentDidmount` 中进行异步请求。** \r\n\r\n\r\n\r\n如遇到特殊需求，需要提前进行数据的请求，可考虑采用在 `constructor` 中进行。\r\n\r\n另外，由于在 React 17 之后 `componentWillMount` 被废弃仅保留 `UNSAFE_componentWillMount`，所以要慎用该生命周期。\r\n\r\n\r\n\r\n## setState是同步的还是异步的？\r\n\r\n答案是：有时表现出异步，有时表现出同步！\r\n\r\n- 在合成事件和生命周期钩⼦函数中是异步的\r\n- 在原⽣事件和 `setTimeout` 中是同步的\r\n\r\n\r\n\r\n`setState` 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。\r\n\r\n\r\n\r\n当然，我们可以通过使用第⼆个参数来拿到更新后的结果，它是个回调函数：\r\n\r\n```js\r\nsetState(partialState, callback)\r\n```\r\n\r\n\r\n\r\n此外，`setState` 的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和 `setTimeout` 中不会批量更新。在异步中，如果对同⼀个值进⾏多次 `setState`，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时 `setState` 多个不同的值，则会在更新时对其进⾏合并批量更新。\r\n\r\n\r\n\r\n## React中如何实现组件间的通信？\r\n\r\n组件间通信⽅式一共有如下几种： \r\n\r\n\r\n\r\n1. ⽗组件向⼦组件通讯\r\n\r\n⽗组件可以通过向⼦组件传 `props` 的⽅式来实现父到子的通讯。\r\n\r\n\r\n\r\n2. ⼦组件向⽗组件通讯\r\n\r\n可以采用 `props + 回调` 的⽅式。\r\n\r\n当⽗组件向⼦组件传递 `props` 进⾏通讯时，可在该 `props` 中传递一个回调函数，当⼦组件调⽤该函数时，可将⼦组件中想要传递给父组件的信息作为参数传递给该函数。由于 `props` 中的函数作⽤域为⽗组件⾃身，因此可以通过该函数内的 `setState` 更新到⽗组件上。 \r\n\r\n\r\n\r\n3. 兄弟组件通信\r\n\r\n可以通过兄弟节点的共同⽗节点，再结合以上2种⽅式，由⽗节点转发信息，实现兄弟间通信。 \r\n\r\n\r\n\r\n4. 跨层级通信\r\n\r\n可以采用 React 中的 `Context` 来实现跨越多层的全局数据通信。 \r\n\r\n`Context` 设计的⽬的是为在⼀个组件树中共享 “全局” 数据，如：当前已登录的⽤户、界面主题、界面语⾔等信息。\r\n\r\n\r\n\r\n5. 发布订阅模式\r\n\r\n发布者发布事件，订阅者监听到事件后做出反应。\r\n\r\n我们可以通过引⼊ `event` 模块进⾏此种方式的通信。\r\n\r\n\r\n\r\n6. 全局状态管理⼯具\r\n\r\n可以借助 `Redux` 或 `Mobx` 等全局状态管理⼯具进⾏通信，它们会维护⼀个全局状态中⼼（Store），并可以根据不同的事件产⽣新的状态。\r\n\r\n<img src="/images/image-20210223093430679.png" alt="image-20210223093430679" style="zoom:30%;" /> \r\n\r\n\r\n\r\n## React存在哪些性能优化手段？\r\n\r\n前端项目的性能手段，其实都是相通的。我们可以参考文章：[前端性能优化](https://blog.csdn.net/weixin_33976072/article/details/93168109)\r\n\r\n\r\n\r\n## React中如何进行组件和逻辑的复用？\r\n\r\nReact 中的组件抽象的技术有以下几种: \r\n\r\n- 混合（mixin，官方已废弃）\r\n\r\n- ⾼阶组件（hoc）：属性代理、反向继承 \r\n\r\n- 渲染属性（render props）\r\n\r\n- React Hooks（配合函数式组件使用，函数拆分的复用理念）\r\n\r\n\r\n\r\n## Mixin、HoC、Render props、React Hooks的优缺点分别是什么？\r\n\r\n**Mixin** \r\n\r\n- 组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖于组件的特定⽅法，但在定义组件时并不知道这种依赖关系） \r\n\r\n- 多个 Mixin 之间可能产⽣冲突，⽐如：多个 Mixin 中定义了相同的 state 字段，在一个组件中同时引入这些 Mixin 后会产生字段冲突\r\n\r\n- Mixin 倾向于增加更多状态，这降低了应⽤的可预测性，状态越多越难管理和溯源，复杂度剧增 \r\n\r\n- 隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升： \r\n\r\n  - 难以快速理解组件的⾏为，需要全盘了解所有依赖 Mixin 的扩展⾏为及其之间的相互影响 \r\n\r\n  - 33333组件⾃身的⽅法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它 \r\n\r\n  - Mixin 也难以维护，因为 Mixin 逻辑最后会被摊平合并到⼀起，很难搞清楚⼀个 Mixin 的输⼊输出\r\n\r\n\r\n\r\n**HoC**\r\n\r\n优点：\r\n\r\n相⽐ Mixin，HoC 通过外层组件传递 props 来影响内层组件的状态，⽽不是直接改变其 state，这就不存在冲突和互相⼲扰，降低了耦合度。不同于 Mixin 的打平 + 合并，HoC 天然具有层级结构（组件树结构），这⼜降低了复杂度。\r\n\r\n \r\n\r\n缺点： \r\n\r\n- 扩展性限制：HoC ⽆法从外部访问⼦组件的 state，因此⽆法通过 `shouldComponentUpdate` 滤掉不必要的更新；React 在⽀持ES6 Class 之后提供了 `React.PureComponent` 解决了这个问题 \r\n\r\n- Ref 传递问题：Ref 被隔断。后来出现了 `React.forwardRef` 来解决了这个问题 \r\n\r\n- 包装地狱（Wrapper Hell）：和回调函数类似，HoC 如果出现多层包裹组件的情况，就会和回调函数一样层层嵌套；而这种多层抽象同样也增加了复杂度和理解成本 \r\n\r\n- 命名冲突：如果⾼阶组件多次嵌套而没有使⽤命名空间，就可能会产⽣冲突，覆盖⽼的属性 \r\n\r\n- 不可⻅性：HoC 相当于在原有组件外层再包装⼀个组件，你有可能压根都不知道外层的包装是什么，对于你来说完全是⿊盒\r\n\r\n\r\n\r\n**Render Props**\r\n\r\n优点：\r\n\r\n上述所说的 HoC 缺点，使用 Render Props 都可得到解决。 \r\n\r\n\r\n\r\n缺点：\r\n\r\n- 使⽤繁琐：HoC 使⽤只需要借助装饰器语法，通常⼀⾏代码就可以进⾏复⽤，而 Render Props ⽆法做到如此简单 \r\n\r\n- 嵌套过深：Render Props 虽然摆脱了组件多层嵌套问题，但其又会走回到了回调函数的嵌套问题\r\n\r\n\r\n\r\n**React Hooks**\r\n\r\n优点：\r\n\r\n- 简洁：React Hooks 解决了 HoC 和 Render Props 的嵌套问题，代码更加简洁\r\n\r\n- 解耦：React Hooks 可以更⽅便地把 UI 和状态分离，做到更彻底的解耦\r\n\r\n- 组合：Hooks 中可以通过引⽤另外的 Hooks 以此形成新的 Hooks，变化丰富\r\n\r\n- 函数友好：React Hooks 为函数组件⽽⽣，从⽽解决了类组件的⼏⼤问题: \r\n\r\n  - this 指向容易错误 \r\n  - 分割在不同声明周期中的逻辑会使得代码难以理解和维护 \r\n\r\n  - 代码复⽤成本⾼（⾼阶组件容易使代码量剧增） \r\n\r\n\r\n\r\n缺点： \r\n\r\n- 有额外的学习成本（需要学习和区分类组件、函数组件） \r\n\r\n- 写法上有限制（不能出现在条件、循环中），并且这种写法限制会增加代码重构时的成本 \r\n\r\n- 破坏了 `PureComponent`、`React.memo` 浅⽐较的性能优化效果（为了获取最新的 props 和 state，每次 `render()` 都要重新 \r\n\r\n创建事件处理函数）\r\n\r\n- 在闭包场景中可能会引⽤到旧的 state、props 值\r\n- 内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”） \r\n- `React.memo` 并不能完全替代 `shouldComponentUpdate`（因为获取不到 state 的变化，只针对 props 的变化）\r\n\r\n\r\n\r\n## Redux的工作流程是怎么样的？\r\n\r\n**核心概念**\r\n\r\n- `Store`：一个保存数据的容器，整个应⽤只有⼀个 Store\r\n\r\n- `State`：Store 对象内包含所有数据，如想得到某一时间点的数据，就要对 Store ⽣成快照，这种时间点的数据集合，就叫 State\r\n\r\n- `Action`：State 的变化会导致 View 的变化，但⽤户是接触不到 State 的，只能接触到 View，所以 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了\r\n\r\n- `Action Creator`：View 要发送多少种消息，就需要有多少种 Action，如果都⼿写会比较麻烦，因此我们通常会定义一个用于生成 Action 的函数，该函数就被称为 Action Creator\r\n\r\n- `Reducer`：在 Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做Reducer。Reducer 是⼀个函数，它接收 Action 和当前 State 作为参数，返回值是⼀个新的 State\r\n\r\n- `dispatch`：是 View 发送 Action 的唯⼀⽅法\r\n\r\n\r\n\r\n**⼯作流程**\r\n\r\n<img src="/images/image-20210223103127034.png" alt="image-20210223103127034" style="zoom:90%;" />\r\n\r\n⼀次⽤户交互的流程如下：\r\n\r\n1. ⾸先，View（通过⽤户）发出 Action，发出⽅式就是使用 `dispatch` ⽅法 \r\n\r\n2. 然后，Store 调⽤ Reducer 并且传⼊两个参数（当前的 State 和收到的 Action），Reducer 处理后返回新的 State \r\n\r\n3. State ⼀旦有变化，则 Store 会调⽤监听函数来通知 View 进行更新\r\n\r\n\r\n\r\n注意，在整个流程中，数据都是单向流动的，我们称之为单向数据流，这种⽅式可以保证流程的清晰性。\r\n\r\n\r\n\r\n## react-redux这个库是如何工作的？\r\n\r\n**核心概念**\r\n\r\n**`Provider`**\r\n\r\nProvider 的作⽤是从最外部封装了整个应⽤，并向 `connect` 模块传递 `store` 。\r\n\r\n\r\n\r\n**`connect`**\r\n\r\n负责将 React 和 Redux 关联起来，它的作用主要如下：\r\n\r\n- 获取 `state`：`connect` 先通过 `context` 来获取存放在 `Provider` 中的 `store`，然后通过 `store.getState()` 来获取整个 `store tree` 上所存放的 `state` \r\n\r\n- 包装原组件：`connect` 将 `state` 和 `action` 通过 `props` 传⼊到原组件的内部，并调用 `wrapWithConnect` 函数来包装和返回⼀个 `Connect` 对象，`Connect` 对象重新 `render` 外部传⼊的原组件，并把 `connect` 中传⼊的 `mapStateToProps` 和 `mapDispatchToProps` 与组件原有的 `props` 合并后，通过属性的⽅式传给包装组件 \r\n\r\n- 监听 `store tree` 变化：`connect` 缓存了 `store tree` 中 `state` 的状态，通过对比当前 `state ` 和变更前 `state`，确定是否需要调⽤ `this.setState()` ⽅法，以此触发 `Connect` 及其⼦组件的重新渲染\r\n\r\n\r\n\r\n**流程图**\r\n\r\n![image-20210223104924017](/images/image-20210223104924017.png)\r\n\r\n\r\n\r\n## Redux和Mobx的区别？\r\n\r\n| 比较点     | Redux                                                        | Mobx                                                         |\r\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| 存储方式   | 保存在单⼀的 store 中                                        | 保存在分散的多个 store 中                                    |\r\n| 数据结构   | 使⽤ plain object 保存数据，需要⼿动处理变化后的操作         | 使⽤ observable 保存数据，数据变化后⾃动处理响应的操作（类似 Vuex） |\r\n| 数据可变性 | 不可变状态，只读不能直接修改，应使⽤纯函数返回⼀个新状态     | 状态是可变的，可直接进⾏修改                                 |\r\n| 难易度     | 比较复杂<br />涉及函数式编程思想，掌握起来不那么容易，同时需借助⼀些中间件处理异步和副作⽤ | 比较简单<br />使用面向对象的编程思维                         |\r\n| 调试       | 容易<br />使用纯函数，并提供了时间回溯⼯具，因此调试直观方便 | ⽐较困难<br />有更多的对象抽象和封装，调试会⽐较困难         |\r\n\r\n\r\n\r\n**使⽤场景**\r\n\r\n`Mobx`\r\n\r\n- 更适合数据不复杂的应⽤。因为 mobx 难以调试，很多状态⽆法回溯，⾯对复杂度⾼的应⽤时往往⼒不从⼼\r\n\r\n- 适合短平快的项⽬。因为 mobx上⼿简单，样板代码少，很⼤程度上提⾼了开发效率\r\n\r\n\r\n\r\n`Redux`\r\n\r\n- 适合有回溯需求的应⽤。⽐如，画板、表格等应⽤，一般有撤销、重做等操作，由于 Redux 具有不可变的特性，天然⽀持这些操作 \r\n\r\n\r\n\r\n我们也可以在一个项目中同时使用 `Mobx` 和 `Redux` ，让两者发挥各自的长处，比如：\r\n\r\n- 使用 `Redux` 作为全局状态管理\r\n- 使⽤ `Mobx `作为组件的局部状态管理器\r\n\r\n\r\n\r\n## 在Redux中如何进行异步操作？\r\n\r\n一般项目中，我们可以直接在 `componentDidMount` 中进⾏异步操作，比如发送网络请求，⽆须借助 Redux。但如果我们的项目上了一定的规模，这种方法再管理异步流的时候就比较困难。这个时候，我们会借助 Redux 的异步中间件来进⾏异步处理。 \r\n\r\nRedux 其实有多种异步中间件，但当下主流的只有两种：`redux-thunk` 和 `redux-saga`。\r\n\r\n**redux-thunk**\r\n\r\n优点：\r\n\r\n- 体积⼩：redux-thunk 的实现⽅式很简单，只有不到20⾏代码 \r\n\r\n- 使⽤简单：redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的编程范式，上⼿非常简单 \r\n\r\n\r\n\r\n缺点：\r\n\r\n- 样板代码过多：与 redux 本身⼀样，通常发送⼀个请求就需要编写⼤量代码，⽽且很多都是重复性的 \r\n\r\n- 耦合严重：异步操作与 redux 的 action 偶合在⼀起，不⽅便管理 \r\n\r\n- 功能薄弱：实际开发中常⽤的⼀些功能都需要⾃⼰封装 \r\n\r\n\r\n\r\n**redux-saga**\r\n\r\n优点：\r\n\r\n- 异步解耦：异步操作被被转移到了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中 \r\n\r\n- action 摆脱了 thunk function：dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满了 “⿊魔法” 的 thunk function \r\n- 异常处理：受益于 Generator Function 的 saga 实现，代码异常/请求失败都可直接通过 try/catch 捕获处理 \r\n\r\n- 功能强⼤：redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器，开发者⽆须自行封装、或只要简单封装即可使⽤ \r\n\r\n- 灵活：redux-saga 可将多个 Saga 进行串⾏或并⾏组合，形成⼀个⾮常实⽤的异步流程 \r\n\r\n- 易测试：提供了各种测试⽅案，包括 mock task、分⽀覆盖等\r\n\r\n\r\n\r\n缺点：\r\n\r\n- 额外的学习成本：redux-saga 不仅使⽤了难以理解的 Generator Function，⽽且存在数⼗个 API，学习成本远超 redux-thunk；最重要的是，这些额外的学习成本只能用于使用这个库的（而对于 redux-observable 来说，它虽也有学习成本，但它基于 rxjs ，这套编程思想和技术体系可以沿用到其他地方去）\r\n\r\n- 体积庞⼤：代码近 2000 ⾏（压缩后大约 25KB） \r\n\r\n- 功能过剩：其中提供的并发控制等功能，实际开发中很难会⽤到，但我们依然要引⼊这些代码 \r\n\r\n- 对 TS ⽀持不友好：yield ⽆法返回 TS 类型 \r\n\r\n\r\n\r\n**redux-observable**\r\n\r\n优点：\r\n\r\n- 功能最强：由于基于 rxjs 这个强⼤的响应式编程库，借助 rxjs 的操作符⼏乎可以做任何你能想到的异步处理 \r\n\r\n- 知识沿用：如果你已学习过 rxjs，那么 redux-observable 的学习成本并不⾼；⽽且，随着 rxjs 的升级，redux-observable 也会变得更强⼤ \r\n\r\n\r\n\r\n缺点：\r\n\r\n- 学习成本奇⾼：对于还不会 rxjs 的开发者来说，需要额外的学习两个都较为复杂的库 \r\n\r\n- 社区⼀般：redux-observable 下载量只有 redux-saga 的 1/5，社区不够活跃，而 redux-saga 仍处于领导地位 ',contentRendered:'<h1 id="html基础" tabindex="-1"><a class="header-anchor" href="#html基础" aria-hidden="true">#</a> HTML基础</h1>\n<h2 id="_1-html-文件中的-doctype-是什么作用" tabindex="-1"><a class="header-anchor" href="#_1-html-文件中的-doctype-是什么作用" aria-hidden="true">#</a> 1. HTML 文件中的 DOCTYPE 是什么作用？</h2>\n<p>HTML超文本标记语言: 是一个标记语言, 就有对应的语法标准</p>\n<p>DOCTYPE 即 Document Type，网页文件的文档类型标准。</p>\n<p>主要作用是告诉浏览器的解析器要使用哪种  <strong>HTML规范</strong> 或 <strong>XHTML规范</strong> 来解析页面。</p>\n<p>DOCTYPE 需要放置在 HTML 文件的 <code>&lt;html&gt;</code>标签之前，如：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  ...\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> (目前主流)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span> <span class="token name">PUBLIC</span> <span class="token string">"-//W3C//DTD HTML 4.01//EN"</span> <span class="token string">"http://www.w3.org/TR/html4/strict.dtd"</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  ...\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span> (早期)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_2-html、xml、xhtml-之间有什么区别" tabindex="-1"><a class="header-anchor" href="#_2-html、xml、xhtml-之间有什么区别" aria-hidden="true">#</a> 2. HTML、XML、XHTML 之间有什么区别？</h2>\n<p>它们都属于标记语言。</p>\n<table>\n<thead>\n<tr>\n<th>语言</th>\n<th>中文名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>HTML4</td>\n<td>超文本标记语言</td>\n<td>主要用于做界面呈现。HTML 是先有实现，后面才慢慢制定标准的，导致HTML⾮常混乱和松散，语法非常的不严谨。</td>\n</tr>\n<tr>\n<td>XML</td>\n<td>可扩展标记语言</td>\n<td>主要⽤于存储数据和结构。语法严谨，可扩展性强。由于 JSON 也有类似作⽤但更轻量⾼效， XML 的市场变得越来越⼩。</td>\n</tr>\n<tr>\n<td>XHTML</td>\n<td>可扩展超文本标记语言</td>\n<td>属于加强版 HTML，为解决 HTML 的混乱问题而生，在语法方面变得和 XML 一样严格。另外，XHTML 的出现也催生了 HTML 5，让HTML向规范化严谨化过渡。</td>\n</tr>\n<tr>\n<td>HTML5</td>\n<td>超文本标记语言</td>\n<td>在HTML的基础上进行拓展，用于页面呈现 (目前标准)</td>\n</tr>\n</tbody>\n</table>\n<p>XML的要求会比较严格:</p>\n<ol>\n<li>\n<p>有且只能有一个根元素</p>\n</li>\n<li>\n<p>大小写敏感</p>\n</li>\n<li>\n<p>正确嵌套</p>\n</li>\n<li>\n<p>必须双引号</p>\n</li>\n<li>\n<p>必须闭合标签</p>\n<p>...</p>\n</li>\n</ol>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>father</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">\'</span>box<span class="token punctuation">\'</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">小张</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">小王</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>father</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>XHTML 和 HTML5 的历史延展: https://www.cnblogs.com/my-freedom/p/5796915.html</p>\n<p><strong>番外:</strong> 所以 HTML5 是HTML的新一代标准, 所谓的 H5 工程师这一词, 其实是国产词, 泛指新一代的web开发工程师,</p>\n<p>具体H5工程师, 做什么工作方向, 还是要看需求 (比如: 移动端开发, PC端网页开发, H5小游戏开发....)</p>\n<h2 id="_3-前缀为-data-开头的元素属性是什么" tabindex="-1"><a class="header-anchor" href="#_3-前缀为-data-开头的元素属性是什么" aria-hidden="true">#</a> 3. 前缀为 <code>data-</code> 开头的元素属性是什么？</h2>\n<p>这是一种为 HTML 元素添加额外数据信息的方式，被称为 <strong>自定义属性</strong>。</p>\n<p>我们可以直接在元素标签上声明这样的数据属性：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mydiv<span class="token punctuation">"</span></span> <span class="token attr-name">data-message</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Hello,world<span class="token punctuation">"</span></span> <span class="token attr-name">data-num</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>123<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>也可以使用 JavaScript 来操作元素的数据属性：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> mydiv <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'mydiv\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 读取</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mydiv<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>message<span class="token punctuation">)</span>\n\n<span class="token comment">// 写入</span>\nmydiv<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">"bar!!!"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>注意：在各种现代前端框架出现后，这种原生的自定义属性已经变得不太常用了, 以前的使用频率非常高, 所以我们知道即可。</strong></p>\n<p>例如: vue实现删除功能时需要 id, 可以直接传值</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item in list<span class="token punctuation">"</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item.id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">18</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">体育好</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n    &lt;button @click="del(item.id)">删除</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">编辑</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_4-谈谈你对-html-语义化的理解" tabindex="-1"><a class="header-anchor" href="#_4-谈谈你对-html-语义化的理解" aria-hidden="true">#</a> 4. 谈谈你对 HTML 语义化的理解？</h2>\n<p>考察核心点: 语义化的好处 (利于SEO, 可阅读性更好)</p>\n<p><strong>语义化之前：</strong></p>\n<p>在提倡语义化之前，你可能会使用各种各样的标签去实现同样的功能，比如：</p>\n<ul>\n<li>使用 span、div、p、a 等做文字, 做按钮</li>\n<li>使用 div 做一切</li>\n</ul>\n<p>从功能方面来说，这确实是不存在什么问题的，完全可以达到功能效果。但这不符合直觉，非常不友好：</p>\n<ul>\n<li>对人不友好：阅读代码的人不能一眼看出代码的功能</li>\n<li>对机器不友好：解析代码的程序不能很好的对这些元素进行分类处理</li>\n</ul>\n<p><strong>语义化之后：</strong></p>\n<p>为了解决上面说的问题，HTML5 规范提倡语义化标签，即使⽤恰当语义的 HTML 标签让⻚⾯具有良好的结构与含义，⽐如：</p>\n<ul>\n<li><code>&lt;p&gt;</code> 标签就代表段落</li>\n<li><code>&lt;article&gt;</code> 代表正⽂内容</li>\n<li><code>&lt;button&gt; </code>代表按钮</li>\n<li><code>&lt;header&gt;</code> 代表头部</li>\n<li>等等...</li>\n</ul>\n<p>语义化的好处：</p>\n<table>\n<thead>\n<tr>\n<th>对开发者的好处</th>\n<th>对机器/程序的好处</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>使⽤了语义化标签的程序，可读性明显增强，开发者可以比容易和清晰地看出⽹⻚的结构；这也更利于整个开发团队的协作开发和后续维护工作</td>\n<td>带有语义的网页代码在⽂字类应用上的表现⼒丰富，利于搜索引擎爬⾍程序来爬取和提取出有效的信息；语义化标签还⽀持读屏软件，根据⽂章可以⾃动⽣成⽬录等，方便特殊人群无障碍的使用这些网页程序。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>语义化的适用性：</strong></p>\n<p>语义化适合内容型的网站来使用（如简书、知乎），对其⽹站内容的传播有很⼤帮助。</p>\n<h2 id="_5-html5-对比-html4-有哪些不同之处" tabindex="-1"><a class="header-anchor" href="#_5-html5-对比-html4-有哪些不同之处" aria-hidden="true">#</a> 5. HTML5 对比 HTML4 有哪些不同之处？</h2>\n<p><strong>考察点: 是否了解 html5 新增的一些新特性</strong></p>\n<table>\n<thead>\n<tr>\n<th>不同点</th>\n<th>备注说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>只有一种 DOCTYPE ⽂件类型声明(统一标准)</td>\n<td><code>&lt;!DOCTYPE html&gt;</code></td>\n</tr>\n<tr>\n<td>增加了一些新的标签元素(功能, 语义化)</td>\n<td><strong>section</strong>, <strong>video</strong>, progress, <strong>nav</strong>, meter, time, <strong>aside</strong>, <br/><strong>canvas</strong>, command, datalist, details, embed, figcaption, <br/>figure, <strong>footer</strong>, <strong>header</strong>, hgroup...</td>\n</tr>\n<tr>\n<td>input 支持了几个新的类型值</td>\n<td><code>date, email, url</code> 等等</td>\n</tr>\n<tr>\n<td>新增了一些标签属性</td>\n<td>charset（⽤于 meta 标签）；async（⽤于 script 标签）</td>\n</tr>\n<tr>\n<td>新增的全域属性</td>\n<td>contenteditable, draggable... <br/>hidden...</td>\n</tr>\n<tr>\n<td>新增API</td>\n<td>本地存储, 地理定位, Canvas绘图, 拖拽API, 即时通信WebSocket...</td>\n</tr>\n</tbody>\n</table>\n<p>获取地理定位: navigator.geolocation.getCurrentPosition(successCallback, errorCallback) (为了安全, 需要在 https 网站使用)</p>\n<p>记忆角度: 更标准, 新增标签, 新增type表单属性, 新增全域属性, 新增API...</p>\n<h2 id="_6-meta-标签有哪些常用用法" tabindex="-1"><a class="header-anchor" href="#_6-meta-标签有哪些常用用法" aria-hidden="true">#</a> 6. meta 标签有哪些常用用法？</h2>\n<p><code>&lt;meta&gt;</code> 标签的具体功能一般由 name/http-equiv 和 content 两部分属性来定义。</p>\n<ul>\n<li>如果设置 name 属性，则它描述的是网页文档的信息（例如：作者、⽇期和时间、⽹⻚描述、 关键词）</li>\n<li>如果设置 http-equiv 属性，则它描述的相当于是 HTTP 响应头信息（例如：网页内容信息, 网页缓存等）</li>\n</ul>\n<p><strong>一些常用的功能及写法：</strong></p>\n<ol>\n<li>设置网页关键词 (SEO)</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>电商,好货,便宜<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2">\n<li>设置网页视口（viewport）控制视⼝的⼤⼩、缩放和⽐例等 (移动端开发)</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1, maximum-scale=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="3">\n<li>设置 http 响应头：Content-Type 网页内容类型  (字符集)</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content-type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/html;charset=utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\n<span class="token comment">&lt;!-- 设置字符集可简写为 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_7-img-标签的-srcset-的作用是什么" tabindex="-1"><a class="header-anchor" href="#_7-img-标签的-srcset-的作用是什么" aria-hidden="true">#</a> 7. img 标签的 srcset 的作用是什么？</h2>\n<p><strong>考察点: 处理响应式图片的方式</strong> (css媒体查询换的是背景图片, 而不是 img 标签的 src)</p>\n<p>开发者和设计师们竞相寻求 <strong>处理响应式图片</strong> 的方法。这的确是一个<a href="https://css-tricks.com/responsive-images-hard/" target="_blank" rel="noopener noreferrer">棘手的问题<ExternalLinkIcon/></a> ，因为我们对同一个网站在众多设备宽度下，</p>\n<p>使用同一图像源。你愿意在一个大显示屏上显示模糊地、马赛克状的图像？</p>\n<p>你愿意在你的手机上加载一个巨大的（虽然更漂亮的）图像？这个问题令人左右为难。 <a href="https://www.jiangweishan.com/article/response-srcset-sizes.html" target="_blank" rel="noopener noreferrer">博客链接<ExternalLinkIcon/></a></p>\n<p>其实通过使用 img 标签的 srcset 属性，可定义一组额外的图片集合，让浏览器根据不同的屏幕状况选取合适的图片来显示。</p>\n<blockquote>\n<p>也就是图片的响应式处理能力。</p>\n</blockquote>\n<p>如果你的响应式需求比较简单，只需要针对屏幕的不同 dpr （device pixel ratio，设备像素比）来决定图片的显示的话，</p>\n<p>dpr 设备像素比, 越高, 能够显示的越清晰  (dpr: 2, dpr: 3)</p>\n<p>那么就只要这么写：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>320.png 1x, 640.png 2x, 960.png 3x<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对于可变宽度的图像，我们使用<code>srcset</code>搭配<code>w</code>描述符以及<code>sizes</code>属性 。</p>\n<ul>\n<li>\n<p><code>w</code>描述符告诉浏览器列表中的每个图象的宽度。</p>\n</li>\n<li>\n<p><code>sizes</code>属性需要至少包含两个值，是由逗号分隔的列表。</p>\n</li>\n</ul>\n<p>根据最新规范，如果<code>srcset</code>中任何图像使用了<code>w</code>描述符，那么必须要设置<code>sizes</code>属性。</p>\n<p><code>sizes</code>属性有两个值：</p>\n<ol>\n<li>\n<p>第一个是媒体查询条件；</p>\n</li>\n<li>\n<p>第二个是图片对应的尺寸值，</p>\n<p>在特定媒体条件下，此值决定了图片的宽度。</p>\n<p>需要注意是，源图尺寸值不能使用百分比，如果要用100%,  <code>vw</code>是唯一可用的CSS单位。</p>\n</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img元素srcset属性浅析<span class="token punctuation">"</span></span>\n  <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\n    320.png 320w, \n    480.png 480w, \n    640.png 640w<span class="token punctuation">"</span></span>\n  <span class="token attr-name">sizes</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>\n    (max-width: 320px) 100vw, \n    (max-width: 360px) 320px,\n    (max-width: 480px) 360px,\n    (max-width: 640px) 480px,\n    640px<span class="token punctuation">"</span></span>\n  <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640.png<span class="token punctuation">"</span></span>\n<span class="token punctuation">/></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>为 img 定义以上属性后，浏览器的工作流程如下：</p>\n<ol>\n<li>检查设备的实际宽度</li>\n<li>检查 img 标签的 sizes 属性中定义的媒体查询条件列表，并计算哪个条件最先匹配到</li>\n<li>得到图片此时的响应式宽度</li>\n<li>加载 srcset 中最接近, 最适合媒体查询匹配到的宽度的图片</li>\n</ol>\n<p>注意: 测试时, 清除缓存测试, 因为一旦加载了高清图, 就不会也没有必要, 回过去再用小图替换了</p>\n<p>且我们无法确定究竟显示哪张图像，因为每个浏览器根据我们提供的信息挑选适当图像的算法是有差异的。</p>\n<p>(译者注：srcset和size列表是对浏览器的一个建议(hint)，而非指令。由浏览器根据其能力、网络等因素来决定。)</p>\n<h2 id="_8-响应式图片处理优化-picture-标签" tabindex="-1"><a class="header-anchor" href="#_8-响应式图片处理优化-picture-标签" aria-hidden="true">#</a> 8. 响应式图片处理优化: Picture 标签</h2>\n<p><strong>考察点: 响应式图片处理</strong></p>\n<p><code>picture</code>元素就像是图像和其源的容器。浏览器仍然需要<code>img</code>元素，用来表明需要加载的图片</p>\n<p>在 <code>&lt;picture&gt;</code> 下可放置零个或多个<code>&lt;source&gt;</code>标签、以及一个<code>&lt;img&gt;</code>标签，为不同的屏幕设备和场景显示不同的图片。</p>\n<p>如果source匹配到了, 就会优先用匹配到的, 如果没有匹配到会往下继续找</p>\n<p>使用<code>picture</code>元素选择图像，不会有歧义。</p>\n<p>浏览器的工作流程如下：</p>\n<ul>\n<li>\n<p>浏览器会先根据当前的情况，去匹配和使用<code>&lt;source&gt;</code>提供的图片</p>\n</li>\n<li>\n<p>如果未匹配到合适的<code>&lt;source&gt;</code>，就使用<code>&lt;img&gt;</code>标签提供的图片</p>\n</li>\n</ul>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>picture</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640.png<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(min-width: 640px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span> <span class="token attr-name">srcset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480.png<span class="token punctuation">"</span></span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(min-width: 480px)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>320.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>picture</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_9-在-script-标签上使用-defer-和-async-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_9-在-script-标签上使用-defer-和-async-的区别是什么" aria-hidden="true">#</a> 9. 在 script 标签上使用 defer 和 async 的区别是什么？</h2>\n<p><strong>明确: defer 和 async 的使用, 可以用于提升网页性能</strong></p>\n<p>script标签存在两个属性，defer和async，因此 script标签 的使用分为三种情况：</p>\n<ol>\n<li>\n<p><code>&lt;script src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>没有defer或async属性，浏览器会立即加载并执行相应的脚本。</p>\n<p>不等待后续加载的文档元素，读到就开始加载和执行，此举会阻塞后续文档的加载</p>\n</li>\n<li>\n<p><code>&lt;script async src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；</p>\n</li>\n<li>\n<p><code>&lt;script defer src=&quot;example.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>有了defer属性，加载后续文档的过程和js脚本的加载是并行进行的(异步)，此时的js脚本仅加载不执行, js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。</p>\n</li>\n</ol>\n<p>下图是使用了 defer、async、和未使用时的运行情况对比：</p>\n<img src="\\images\\image-20210209172314832.png" alt="image-20210209172314832" />\n<blockquote>\n<p>【上图的图例说明】</p>\n<p>绿线：HTML 的解析时间</p>\n<p>蓝线：JS 脚本的加载时间</p>\n<p>红色：JS 脚本的执行时间</p>\n</blockquote>\n<p>从图中我们可以明确一下几点：</p>\n<p>1.defer和async在网络加载过程是一致的，都是异步执行的；(放在页面顶部, 也不会阻塞页面的加载, 与页面加载同时进行)</p>\n<p>2.两者的区别, 脚本加载完成之后, async是立刻执行, defer会等一等 (等前面的defer脚本执行, 等dom的加载)</p>\n<p>所以, js脚本加上 async 或 defer, 放在头部可以减少网页的下载加载时间, 如果不考虑兼容性, 可以用于优化页面加载的性能</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.0/index.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_10-前端做本地数据存储的方式有哪些" tabindex="-1"><a class="header-anchor" href="#_10-前端做本地数据存储的方式有哪些" aria-hidden="true">#</a> 10. 前端做本地数据存储的方式有哪些？</h2>\n<img src="\\images\\image-20210209174438863.png" alt="image-20210209174438863" />\n<ol>\n<li>Cookies</li>\n<li>localStorage</li>\n<li>sessionStorage</li>\n<li>Web SQL</li>\n<li>IndexedDB</li>\n</ol>\n<h2 id="_11-以上几种前端存储的区别是什么" tabindex="-1"><a class="header-anchor" href="#_11-以上几种前端存储的区别是什么" aria-hidden="true">#</a> 11. 以上几种前端存储的区别是什么？</h2>\n<table>\n<thead>\n<tr>\n<th>方式名称</th>\n<th>标准说明</th>\n<th>功能说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cookies</td>\n<td>HTML5 前加入</td>\n<td>1.会为每个请求自动携带所有的Cookies数据，比较方便，但是也是缺点，浪费流量；<br>2.每个domain(站点)限制存储20个cookie；<br/>3.容量只有4K<br/>4.浏览器API比较原始，需要自行封装操作。 (js-cookie)</td>\n</tr>\n<tr>\n<td>localStorage</td>\n<td>HTML5 加入</td>\n<td>1.兼容IE8+，操作方便；<br/>2.永久存储，除非手动删除；<br/>3.容量为5M</td>\n</tr>\n<tr>\n<td>sessionStorage</td>\n<td>HTML5 加入</td>\n<td>1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理；<br/>2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储</td>\n</tr>\n<tr>\n<td>Web SQL</td>\n<td>非标准功能</td>\n<td>1.2010年已被废弃，但一些主流浏览器中都有相关的实现；<br/>2.类似于 SQLite 数据库，是一种真正意义上的关系型数据库，⽤SQL进⾏操作；</td>\n</tr>\n<tr>\n<td>IndexedDB</td>\n<td>HTML5 加入</td>\n<td>1.是一种 NoSQL 数据库，⽤键值对进⾏储存，可进⾏快速读取操作；<br/>2.适合复杂 Web存储场景，⽤JS操作⽅便 (前端大量存数据的场景较少, 如果有, 可以用) <br />3.存储空间容量, 大于等于 250MB，甚至没有上限</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h1 id="css基础" tabindex="-1"><a class="header-anchor" href="#css基础" aria-hidden="true">#</a> CSS基础</h1>\n<h2 id="_1-css选择器的优先级是怎么样的" tabindex="-1"><a class="header-anchor" href="#_1-css选择器的优先级是怎么样的" aria-hidden="true">#</a> 1. CSS选择器的优先级是怎么样的？</h2>\n<p><strong>CSS选择器的优先级顺序：</strong></p>\n<p><code>内联样式</code> &gt; <code>ID选择器</code> &gt; <code>类选择器</code> &gt; <code>标签选择器</code></p>\n<p><strong>优先级的计算：</strong></p>\n<p>优先级是由 A、B、C、D 四个值来决定的，具体计算规则如下</p>\n<ul>\n<li>A={如果存在内联样式则为1，否则为0}</li>\n<li>B={ID选择器出现的次数}</li>\n<li>C={类选择器、属性选择器、伪类选择器出现的总次数}</li>\n<li>D={标签选择器、伪元素选择器出现的总次数}</li>\n</ul>\n<p><strong>计算示例：</strong></p>\n<p>样式一：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/*\n  A=0   不存在内联样式\n  B=0   不存在ID选择器\n  C=1   有一个类选择器\n  D=3   有三个标签选择器\n\n  最终计算结果：{0,0,1,3}\n*/</span>\n<span class="token selector">div ul li .red</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>样式二：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/*\n  A=0   不存在内联样式\n  B=1   有一个ID选择器\n  C=0   不存在类选择器\n  D=0   不存在标签选择器\n\n  最终计算结果：{0,1,0,0}\n*/</span>\n<span class="token selector">#mydiv</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>计算完成后，我们通过从A到D的顺序进行值的大小比较，权重由A到D从高到低，只要比较出最大值即可。例如上面的两个样式：</p>\n<div class="language-markdown ext-md line-numbers-mode"><pre v-pre class="language-markdown"><code><span class="token list punctuation">1.</span> 样式一的A=0，样式二的A=0  【相等，继续往下比较】\n<span class="token list punctuation">2.</span> 样式一的B=0 &lt; 样式二的B=1 【样式二的大，不继续往下比了，即认为样式二的优先级更高】\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_2-通过-css-的哪些方式可以实现隐藏页面上的元素" tabindex="-1"><a class="header-anchor" href="#_2-通过-css-的哪些方式可以实现隐藏页面上的元素" aria-hidden="true">#</a> 2. 通过 CSS 的哪些方式可以实现隐藏页面上的元素？</h2>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>opacity: 0</td>\n<td>通过将元素的透明度设置为0，实现看起来隐藏的效果；但是依然会占用空间并可以进行交互</td>\n</tr>\n<tr>\n<td>visibility: hidden</td>\n<td>与透明度为0的方案非常类似，会占据空间，但不可以进行交互</td>\n</tr>\n<tr>\n<td>overflow: hidden</td>\n<td>只会隐藏元素溢出的部分；占据空间且不可交互</td>\n</tr>\n<tr>\n<td>display: none</td>\n<td>可以彻底隐藏元素并从文档流中消失，不占据空间也不能交互，且不影响布局</td>\n</tr>\n<tr>\n<td>z-index: -9999</td>\n<td>通过将元素的层级置于最底层，让其他元素覆盖住它，达到看起来隐藏的效果</td>\n</tr>\n<tr>\n<td>transform: scale(0,0)</td>\n<td>通过将元素进行缩放，缩小为0；依然会占据空间，但不可交互</td>\n</tr>\n<tr>\n<td>left: -9999px</td>\n<td>通过将元素定位到屏幕外面，达到看起来看不到的效果</td>\n</tr>\n</tbody>\n</table>\n<h2 id="_3-px、em、rem之间有什么区别" tabindex="-1"><a class="header-anchor" href="#_3-px、em、rem之间有什么区别" aria-hidden="true">#</a> 3. px、em、rem之间有什么区别？</h2>\n<p><strong>考察点: 相对单位, 绝对单位, 以及适配问题</strong></p>\n<table>\n<thead>\n<tr>\n<th>单位名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>px</td>\n<td>绝对单位。代表像素数量，页面会按照给出的精确像素进行展示</td>\n</tr>\n<tr>\n<td>em</td>\n<td>相对单位。默认的基准点为父元素的字体大小，而如果自身定义了字体大小则按自身的来算。所以即使在同一个页面内，1em可能不是一个固定的值。</td>\n</tr>\n<tr>\n<td>rem</td>\n<td>相对单位。可以理解为 <code>root em</code>，即基准点为根元素<code>&lt;html&gt;</code>的字体大小。rem是CSS3中新增单位，Chrome/FireFox/IE9+都支持, 一般用于做移动端适配</td>\n</tr>\n</tbody>\n</table>\n<p>正常开发 px 使用率较高, 如果要做 rem 适配, 会用到 rem 单位!</p>\n<p>rem布局的原理:</p>\n<ol>\n<li>使用 rem 为单位</li>\n<li>动态的设置 html font-size (媒体查询, js设置, 插件设置都可以)</li>\n</ol>\n<p>webpack有工具, 可以写 px, 自动转 rem  https://youzan.github.io/vant/#/zh-CN/advanced-usage</p>\n<h2 id="_4-让元素水平居中的方法有哪些" tabindex="-1"><a class="header-anchor" href="#_4-让元素水平居中的方法有哪些" aria-hidden="true">#</a> 4. 让元素水平居中的方法有哪些？</h2>\n<p><strong>方法一：使用 margin</strong></p>\n<p>通过为元素设置左右的 margin 为 auto，实现让元素居中。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>本内容会居中<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-scss ext-scss line-numbers-mode"><pre v-pre class="language-scss"><code><span class="token selector">.center </span><span class="token punctuation">{</span>\n   <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n   <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n   <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n   <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>方式二: 转成行内块,  给父盒子设置 text-align: center</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是内容盒子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.father</span> <span class="token punctuation">{</span>\n  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.center</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>方法三：使用 flex 布局</strong></p>\n<p>使用 flex 提供的子元素居中排列功能，对元素进行居中。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是内容盒子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.father</span> <span class="token punctuation">{</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.center</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>方式四: 使用定位布局</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是内容盒子<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.father</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token selector">.center</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n  <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>\n  <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>\n  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">,</span> -50%<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><a href="https://www.cnblogs.com/chengxs/p/11231906.html" target="_blank" rel="noopener noreferrer">【更多方式参考】实现水平居中垂直居中<ExternalLinkIcon/></a></p>\n<h2 id="_5-在-css-中有哪些定位方式" tabindex="-1"><a class="header-anchor" href="#_5-在-css-中有哪些定位方式" aria-hidden="true">#</a> 5. 在 CSS 中有哪些定位方式？</h2>\n<p>也就是 position 样式的几个属性。</p>\n<p><strong>static 正常文档流定位</strong></p>\n<ul>\n<li>\n<p>此时设置 top、right、bottom、left 以及 z-index 都无效</p>\n</li>\n<li>\n<p>块级元素遵循从上往下纵向排列，行级元素遵循从左到右排列</p>\n</li>\n</ul>\n<p><strong>relative 相对定位</strong></p>\n<p>这个 <strong>“相对”</strong> 是指相对于正常文档流的位置。</p>\n<p><strong>absolute 绝对定位</strong></p>\n<p>当前元素相对于 **最近的非 static 定位的祖先元素 **来确定自己的偏移位置。</p>\n<p>例如，当前为 absolute 的元素的父元素、祖父元素都为 relative，则当前元素会相对于父元素进行偏移定位。</p>\n<p><strong>fixed 固定定位</strong></p>\n<p>当前元素相对于屏幕视口 viewport 来确定自己的位置。并且当屏幕滚动时，当前元素的位置也不会发生改变。</p>\n<p><strong>sticky 粘性定位</strong></p>\n<p>这个定位方式有点像 relative 和 fixed 的结合。当它的父元素在视口区域、并进入 top 值给定的范围内时，当前元素就以 fixed 的方式进行定位，否则就以 relative 的方式进行定位。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">*</span> <span class="token punctuation">{</span>\n    <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.header</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> orange<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.nav</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> sticky<span class="token punctuation">;</span>\n    <span class="token property">top</span><span class="token punctuation">:</span> 0px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.main</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是头部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是导航<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>我是主体部分8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h2 id="_6-如何理解-z-index" tabindex="-1"><a class="header-anchor" href="#_6-如何理解-z-index" aria-hidden="true">#</a> 6. 如何理解 z-index？</h2>\n<p>可以将它看做三维坐标系中的z轴方向上的图层层叠顺序。</p>\n<p>元素默认的 z-index 为 0，可通过修改 z-index 来控制设置了postion 值的元素的图层位置。</p>\n<img src="\\images\\image-20210209212043708.png" alt="image-20210209212043708" style="zoom:70%;" />\n<p>可以将这种关系想象成一摞书本，通过 z-index 可以改变一本书在这摞书中的上下位置。</p>\n<p>z-index的小坑, 如果父辈元素有定位, 且配置了z-index, 优先按照父辈元素的定位的z-index进行比较层级</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.father</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n    <span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.son</span> <span class="token punctuation">{</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">z-index</span><span class="token punctuation">:</span> 999<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n    <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\n    <span class="token property">z-index</span><span class="token punctuation">:</span> 100<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="_7-如何清除浮动" tabindex="-1"><a class="header-anchor" href="#_7-如何清除浮动" aria-hidden="true">#</a> 7. 如何清除浮动 ？</h2>\n<p><strong>考察: css基本功</strong></p>\n<p>可以有以下几种方式：</p>\n<ol>\n<li>\n<p>定高法</p>\n</li>\n<li>\n<p>使用一个空的div，并设置样式</p>\n</li>\n</ol>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">clear</span><span class="token punctuation">:</span>both</span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="3">\n<li>\n<p>为父元素添加 <code>overflow: hidden</code></p>\n</li>\n<li>\n<p>定义一个 clearfix 样式类</p>\n</li>\n</ol>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.clearfix:after</span> <span class="token punctuation">{</span>\n  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">;</span>  \t\t\t<span class="token comment">/*设置内容为空*/</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>    \t\t\t<span class="token comment">/*高度为0*/</span>\n  <span class="token property">line-height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>\t\t\t<span class="token comment">/*行高为0*/</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>\t\t\t<span class="token comment">/*将文本转为块级元素*/</span>\n  <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>\t<span class="token comment">/*将元素隐藏*/</span>\n  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span> \t\t\t\t<span class="token comment">/*清除浮动*/</span>\n<span class="token punctuation">}</span>\n\n<span class="token selector">.clearfix</span> <span class="token punctuation">{</span>\n  <span class="token property">zoom</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span> \t\t\t\t<span class="token comment">/*为了兼容IE*/</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>说明：当前 flex 已成为主流布局方式，适应性强, 且稳定, 所以浮动使用率目前已逐步降低。</p>\n<h2 id="_8-谈谈你对-bfc-的理解" tabindex="-1"><a class="header-anchor" href="#_8-谈谈你对-bfc-的理解" aria-hidden="true">#</a> 8. 谈谈你对 BFC 的理解？</h2>\n<p><strong>什么是 BFC：</strong></p>\n<p>BFC 的全称是 Block Formatting Context，块级格式化上下文。这是一个用于在盒模型下布局块级盒子的独立渲染区域，</p>\n<p>将处于BFC区域内和区域外的元素进行互相隔离。</p>\n<p><strong>何时会形成 BFC：</strong></p>\n<p>满足下列条件之一就可触发BFC：</p>\n<ul>\n<li>HTML根元素</li>\n<li>position 值为 <code>absolute</code> 或 <code>fixed</code></li>\n<li>float 值不为 <code>none</code></li>\n<li>overflow 值不为 <code>visible</code></li>\n<li>display 值为 <code>inline-block</code>、<code>table-cell</code> 或 <code>table-caption</code></li>\n</ul>\n<p><strong>BFC 的应用场景：</strong></p>\n<ol>\n<li>场景一：防止两个相邻块级元素的上下 margin 发生重叠 (<strong>上下margin合并问题</strong>)</li>\n</ol>\n<p>属于同一 BFC 的, 两个相邻块级子元素的上下 margin 会重叠，如果想让它们不重叠，可通过让这两个相邻块级子元素分属于不同的BFC。</p>\n<p>以下示例代码中的两个盒子的上下外边距会重合（即它们都设置了10px的外边距，我们期望它们之间的间距是 20px，但实际效果却只有 10px）：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.box1</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span> <span class="token comment">/* 下外边距为 10px */</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n    <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>  <span class="token comment">/* 上外边距为 10px */</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><img src="/images/image-20210217142711472.png" alt="image-20210217142711472" style="zoom:50%;" />\n<p>下面我们让其中一个盒子触发BFC，从而达到间隔 20px 的期望效果：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.box2</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n  <span class="token property">margin-top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>\n  <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span> <span class="token comment">/* 通过设置 display 为 inline-block 可以触发 BFC */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><img src="/images/image-20210217143506046.png" alt="image-20210217143506046" style="zoom:50%;" />\n<ol start="2">\n<li>场景二：<strong>清除浮动</strong></li>\n</ol>\n<p>以下示例代码中， 容器元素 box1 的高度会没有高：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.box1</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello,world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello,world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello,world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>而通过为 box1 添加 BFC 触发条件，可以让它的高度变回正常状态：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.box1</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3">\n<li>场景三：<strong>实现自适应布局</strong>, 防止元素被浮动元素覆盖(左边固定, 右边自适应)</li>\n</ol>\n<p>以下示例中，box2 会被设置了浮动的 box1 覆盖：</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">\n  <span class="token selector">.box1</span> <span class="token punctuation">{</span>\n    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token selector">.box2</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n    <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><img src="/images/image-20210217145325690.png" alt="image-20210217145325690" style="zoom:30%;" />\n<p>要避免这种覆盖行为，可以让 box2 触发 BFC,  实现布局效果, 左边固定右边自适应：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.box2</span> <span class="token punctuation">{</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment">/* 将 overflow 设置为非 visible 值可触发 BFC */</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><img src="/images/image-20210217145504963.png" alt="image-20210217145504963" style="zoom:30%;" />\n<p><a href="https://www.cnblogs.com/xiaohuochai/p/5248536.html" target="_blank" rel="noopener noreferrer">参考文章：深入理解BFC<ExternalLinkIcon/></a></p>\n<h2 id="_9-什么是css-sprites以及它的好处" tabindex="-1"><a class="header-anchor" href="#_9-什么是css-sprites以及它的好处" aria-hidden="true">#</a> 9. 什么是CSS Sprites以及它的好处？</h2>\n<p><strong>考察: 性能优化的方案</strong></p>\n<p>CSS Sprites，俗称雪碧图、精灵图。这是一种CSS图片合并技术，就是将CSS中原先引用的一些较小的图片，合并成一张稍大的图片后再引用的技术方案。它可以减少请求多张小图片带来的网络消耗（因为发起的HTTP请求数变少了），并实现提前加载资源的效果。</p>\n<p><strong>操作方式：</strong></p>\n<p>可以手工使用图片编辑软件（如Photoshop），将多张小图片合并编辑变成一张大图片，并针对这张大图片，编写CSS样式来引用这张大图片中对应位置的小图片（涉及到的样式：background-image、background-position、background-size）。然后在HTML元素中使用这些样式即可。</p>\n<p>https://img.alicdn.com/tfs/TB1eiXTXlTH8KJjy0FiXXcRsXXa-24-595.png</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>CSS Sprites中任意一张小图的改动，都需要重新生成大图；并且用户端需要重新下载整张大图，这就降低了浏览器缓存的优势</li>\n<li>随着HTTP2的逐渐普及，HTTP2的多路复用机制可以解决请求多个小图片所创建多个HTTP请求的消耗，让CSS Sprites存在的价值降低了</li>\n<li>图片如果放大, 是会失真</li>\n</ul>\n<p>目前其他主流的处理图片的方案:  iconfont 字体图标, svg矢量图...</p>\n<h2 id="_10-你对媒体查询的理解是什么样的" tabindex="-1"><a class="header-anchor" href="#_10-你对媒体查询的理解是什么样的" aria-hidden="true">#</a> 10. 你对媒体查询的理解是什么样的？</h2>\n<p><strong>考察点: 响应式适配</strong>, 根据不同的屏幕尺寸, 显示不同的效果 (设置盒子的样式)</p>\n<p>媒体查询是自 CSS3 开始加入的一个功能。它可以进行响应式适配展示。</p>\n<p>媒体查询由两部分组成：</p>\n<ul>\n<li>一个可选的媒体类型（如 screen、print 等）</li>\n<li>零个或多个媒体功能限定表达式（如 max-width: 500px、orientation: landscape 等）</li>\n</ul>\n<p>这两部分最终都会被解析为 true 或 false 值，然后整个媒体查询值为 true，则和该媒体查询关联的样式就生效，否则就不生效。</p>\n<p><strong>使用示例：</strong></p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token comment">/* 在css样式表的定义中直接使用媒体查询 */</span> \n<span class="token selector">.container</span> <span class="token punctuation">{</span>\n  <span class="token property">width</span><span class="token punctuation">:</span> 600px<span class="token punctuation">;</span>\n  <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>\n  <span class="token property">background-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">;</span>\n  <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 767px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 768px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 991px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 750px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 992px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 1199px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 980px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 1200px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 1170px<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token atrule"><span class="token rule">@media</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">width</span><span class="token punctuation">:</span> 1200px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>\n  <span class="token selector">.container</span> <span class="token punctuation">{</span>\n    <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p><a href="https://www.cnblogs.com/xiaohuochai/p/5848612.html" target="_blank" rel="noopener noreferrer">参考文章：深入理解CSS媒体查询<ExternalLinkIcon/></a></p>\n<h2 id="_11-你对盒子模型的理解是什么样的" tabindex="-1"><a class="header-anchor" href="#_11-你对盒子模型的理解是什么样的" aria-hidden="true">#</a> 11. 你对盒子模型的理解是什么样的？</h2>\n<p>浏览器的渲染引擎在对网页文档进行布局时，会按照 “CSS 基础盒模型” （CSS Basic Box Model）标准，将文档中的所有元素都表示为一个个矩形的盒子，再用 CSS 去决定这些盒子的大小尺寸、显示位置、以及其他属性（如颜色、背景、边框等）。</p>\n<p>下图就是盒模型示意图，它由几部分组成：</p>\n<ul>\n<li>内容（content）</li>\n<li>内边距（padding）</li>\n<li>边框（border）</li>\n<li>外边距（margin）</li>\n</ul>\n<img src="/images/image-20210214144941345.png" alt="image-20210214144941345" style="zoom:25%;" />\n<h2 id="_12-标准盒模型和怪异盒模型有哪些区别" tabindex="-1"><a class="header-anchor" href="#_12-标准盒模型和怪异盒模型有哪些区别" aria-hidden="true">#</a> 12. 标准盒模型和怪异盒模型有哪些区别？</h2>\n<p>两者的区别主要体现在元素尺寸的表示上。</p>\n<p><strong>盒模型的指定：</strong></p>\n<p>在CSS3中，我们可以通过设置 box-sizing 的值来决定具体使用何种盒模型：</p>\n<ul>\n<li>content-box    标准盒模型</li>\n<li>border-box     怪异盒模型</li>\n</ul>\n<p><strong>标准盒模型：</strong></p>\n<p>box-sizing: content-box; (默认值)</p>\n<p>在标准盒模型下，元素的宽（width）和高（height）值即为盒模型中内容（content）的实际宽高值。</p>\n<img src="/images/image-20210214150511841.png" alt="image-20210214150511841" style="zoom:25%;" />\n<p>因此，计算一个元素宽度的公式如下(不考虑margin, margin是外边距,  如果是计算占用页面的空间, 就要带上margin)：</p>\n<blockquote>\n<p>盒子宽度 =  <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code></p>\n<p>占据页面宽度 = <code>margin-left</code> + <code>border-left</code> + <code>padding-left</code> + <code>width</code> + <code>padding-right</code> + <code>border-right</code> + <code>margin-right</code></p>\n</blockquote>\n<p><strong>怪异盒模型：</strong></p>\n<p>box-sizing: border-box; (目前主流常用值)</p>\n<p>在怪异盒模型下，元素的 width 和 height 值却不是 content 的实际宽高，而是去除 margin 后剩下的元素占用区域的宽高，即：</p>\n<img src="/images/image-20210214151037552.png" alt="image-20210214151037552" style="zoom:25%;" />\n<p>因此，计算一个元素占用了页面总宽度的公式如下：</p>\n<blockquote>\n<p>盒子宽度 =  <code>width</code></p>\n<p>盒子占据页面宽度 = <code>margin-left</code> + <code>width</code> + <code>margin-right</code></p>\n</blockquote>\n<p><a href="https://www.cnblogs.com/xiaohuochai/p/5202597.html" target="_blank" rel="noopener noreferrer">参考文章：深入理解盒模型<ExternalLinkIcon/></a></p>\n<h2 id="_13-说说伪类和伪元素的区别" tabindex="-1"><a class="header-anchor" href="#_13-说说伪类和伪元素的区别" aria-hidden="true">#</a> 13. 说说伪类和伪元素的区别？</h2>\n<p><strong>什么是伪类？</strong></p>\n<p>伪类（pseudo-class）是以冒号<code>:</code>为前缀，可被添加到⼀个选择器的末尾的关键字。</p>\n<p>它用于让样式在元素的特定状态下才被应用到实际的元素上。比如：<code>:checked</code>、<code>:hover</code>、<code>:disabled</code>、 <code>:first-child</code>等。</p>\n<p>:hover</p>\n<p>:nth-child(1)</p>\n<p>:nth-child(2)</p>\n<p>:checked</p>\n<p>注意: 伪类, 虽然是写法比较特殊, css选择器的权重, 和类一致的</p>\n<p><strong>什么是伪元素？</strong></p>\n<p>:before / :after</p>\n<p>伪元素⽤于创建⼀些并不在 DOM 树中的元素，并为其添加样式。伪元素的语法和伪类类似，可以一个冒号或两个冒号为前缀。</p>\n<p>⽐如，可以通过 <code>:before</code> 、<code>:after</code> 来在⼀个元素前、后增加⼀些额外的⽂本并为它们添加样式；</p>\n<p>并且，虽然⽤户可以看到这些⽂本，但其实它们并不在 DOM 树中。(<strong>坑: 伪元素是无法注册事件的, 所以不要通过js控制伪元素</strong>)</p>\n<p><strong>两者的区别</strong></p>\n<p>虽然它们在语法上是一致的，但是它们的功能区别还是非常明显的。</p>\n<ul>\n<li>伪类是用来匹配元素的特殊状态的</li>\n<li>伪元素是用来匹配元素的隶属元素的，这些隶属元素可以在界面中展示，但在 DOM 中不体现</li>\n</ul>\n<p><a href="http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/" target="_blank" rel="noopener noreferrer">参考文章：伪类与伪元素<ExternalLinkIcon/></a></p>\n<h2 id="_14-谈谈你对-flex-的理解" tabindex="-1"><a class="header-anchor" href="#_14-谈谈你对-flex-的理解" aria-hidden="true">#</a> 14. 谈谈你对 flex 的理解？</h2>\n<p>在真实的应用场景中，通常会遇到各种各样不同尺⼨和分辨率的设备，为了能在所有这些设备上正常的布局我们的应用界面，就需要响应式的界⾯设计方式来满⾜这种复杂的布局需求。</p>\n<p>flex 弹性盒模型的优势在于开发⼈员只需要声明布局应该具有的⾏为，⽽不需要给出具体的实现⽅式，浏览器负责完成实际布局，当布局涉及到不定宽度，分布对⻬的场景时，就要优先考虑弹性盒布局。</p>\n<p>你能联想到的flex语法有哪些呢?</p>\n<p>flex-direction: 调整主轴方向</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>row：主轴方向为水平向右\ncolumn：主轴方向为竖直向下\nrow-reverse:主轴方向为水平向左\ncolumn-reverse:主轴方向是竖直向上。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>justify-content主要用来设置<strong>主轴方向的对齐方式</strong></p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>flex-start: 弹性盒子元素将向起始位置对齐\nflex-end: 弹性盒子元素将向结束位置对齐。\ncenter: 弹性盒子元素将向行中间位置对齐\nspace-around: 弹性盒子元素会平均地分布在行里\nspace-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>align-items用于调整<strong>侧轴的对齐方式</strong></p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>flex-start： 元素在侧轴的起始位置对齐。 \nflex-end： 元素在侧轴的结束位置对齐。\ncenter： 元素在侧轴上居中对齐。\nstretch： 元素的高度会被拉伸到最大（不给高度时, 才拉伸）。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>flex-wrap属性控制flex容器是单行或者多行,默认不换行</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>nowrap： 不换行（默认），如果宽度溢出，会压缩子盒子的宽度。\nwrap： 当宽度不够的时候，会换行。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>align-content用来设置多行的flex容器的排列方式</p>\n<div class="language-txt ext-txt line-numbers-mode"><pre v-pre class="language-txt"><code>flex-start： 各行向侧轴的起始位置堆叠。 \nflex-end： 各行向弹性盒容器的结束位置堆叠。\ncenter： 各行向弹性盒容器的中间位置堆叠。\nspace-around： 各行在侧轴中平均分布。 \nspace-between： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 \nstretch：拉伸，不设置高度的情况下。\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote>\n<p>可参考 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener noreferrer">flex布局教程<ExternalLinkIcon/></a></p>\n</blockquote>\n<hr>\n<h1 id="javascript基础" tabindex="-1"><a class="header-anchor" href="#javascript基础" aria-hidden="true">#</a> JavaScript基础</h1>\n<h2 id="_1-解释下什么是变量声明提升" tabindex="-1"><a class="header-anchor" href="#_1-解释下什么是变量声明提升" aria-hidden="true">#</a> 1. 解释下什么是变量声明提升？</h2>\n<p>变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。</p>\n<p>JS引擎在运行一份代码的时候，会按照下面的步骤进行工作：</p>\n<ol>\n<li>\n<p>首先，对代码进行预解析，并获取声明的所有变量</p>\n</li>\n<li>\n<p>然后，将这些变量的声明语句统一放到代码的最前面</p>\n</li>\n<li>\n<p>最后，开始一行一行运行代码</p>\n</li>\n</ol>\n<p>我们通过一段代码来解释这个运行过程：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> \n\n<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上⾯这段代码的实际执⾏顺序为:</p>\n<ol>\n<li>JS引擎将 <code>var a = 1</code> 分解为两个部分：变量声明语句 <code>var a = undefined</code> 和变量赋值语句 <code>a = 1</code></li>\n<li>JS引擎将 <code>var a = undefined</code> 放到代码的最前面，而 <code>a = 1</code> 保留在原地</li>\n</ol>\n<p>也就是说经过了转换，代码就变成了:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">undefined</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined </span>\n\na <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>变量的这一转换过程，就被称为变量的声明提升。</p>\n<p>而这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题</p>\n<h2 id="_2-js-的参数是以什么方式进行传递的" tabindex="-1"><a class="header-anchor" href="#_2-js-的参数是以什么方式进行传递的" aria-hidden="true">#</a> 2. JS 的参数是以什么方式进行传递的？</h2>\n<p>基本数据类型和复杂数据类型的数据在传递时，会有不同的表现。</p>\n<p><strong>基本类型：是值传递</strong>！</p>\n<p>基本类型的传递方式比较简单，是按照 <code>值传递</code> 进行的。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x <span class="token operator">=</span> <span class="token number">10</span>  <span class="token comment">// 并不会改变实参的值</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 10 </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>复杂类型: 传递的是地址! (变量中存的就是地址)</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305165413588" originSrc="images/image-20210305165413588.png" data="aurora"></p>\n<p>来看下面的代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">10</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// { count: 10 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// { count: 10 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从运行结果来看，函数内改变了参数对象内的 <code>count</code> 后，外部的实参对象 <code>a</code> 的内容也跟着改变了，所以传递的是地址。</p>\n<p>思考题:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span> \n<span class="token punctuation">}</span><span class="token punctuation">;</span> \n\n<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  x <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { count: 20 }</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { count: 1 }</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305165848781" originSrc="images/image-20210305165848781.png" data="aurora"></p>\n<p>我们会发现外部的实参对象 <code>a</code> 并没有因为在函数内对形参的重新赋值而被改变！</p>\n<p>因为当我们直接为这个形参变量重新赋值时，其实只是让形参变量指向了别的堆内存地址，而外部实参变量的指向还是不变的。</p>\n<p>下图展示的是复杂类型参数传递后的状态：</p>\n<img src="/images/image-20210218233241397.png" alt="image-20210218233241397" style="zoom:50%;" />\n<p>下图展示的是重新为形参赋值后的状态：</p>\n<img src="/images/image-20210218233343016.png" alt="image-20210218233343016" style="zoom:50%;" />\n<h2 id="_3-javascript垃圾回收是怎么做的" tabindex="-1"><a class="header-anchor" href="#_3-javascript垃圾回收是怎么做的" aria-hidden="true">#</a> 3. JavaScript垃圾回收是怎么做的？</h2>\n<p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。</p>\n<p>正因为垃圾回收器的存在，许多人认为JS不用太关心内存管理的问题，</p>\n<p>但如果不了解JS的内存管理机制，我们同样非常容易成内存泄漏（内存无法被回收）的情况。</p>\n<h3 id="_3-1-内存的生命周期" tabindex="-1"><a class="header-anchor" href="#_3-1-内存的生命周期" aria-hidden="true">#</a> 3.1 内存的生命周期</h3>\n<p>JS环境中分配的内存, 一般有如下生命周期：</p>\n<ol>\n<li>\n<p>内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存</p>\n</li>\n<li>\n<p>内存使用：即读写内存，也就是使用变量、函数等</p>\n</li>\n<li>\n<p>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</p>\n<p>全局变量一般不会回收, 一般局部变量的的值, 不用了, 会被自动回收掉</p>\n</li>\n</ol>\n<p>内存分配:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 为变量分配内存</span>\n<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">11</span>\n<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"ifcode"</span>\n\n<span class="token comment">// 为对象分配内存</span>\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'ifcode\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 为函数分配内存</span>\n<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-2-垃圾回收算法说明" tabindex="-1"><a class="header-anchor" href="#_3-2-垃圾回收算法说明" aria-hidden="true">#</a> 3.2 垃圾回收算法说明</h3>\n<p>所谓垃圾回收, 核心思想就是如何判断内存是否已经不再会被使用了, 如果是, 就视为垃圾, 释放掉</p>\n<p>下面介绍两种常见的浏览器垃圾回收算法: 引用计数 和 标记清除法</p>\n<h3 id="_3-3-引用计数" tabindex="-1"><a class="header-anchor" href="#_3-3-引用计数" aria-hidden="true">#</a> 3.3 引用计数</h3>\n<p>IE采用的引用计数算法, 定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。</p>\n<p>如果没有任何变量指向它了，说明该对象已经不再需要了。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 创建一个对象person, person指向一块内存空间, 该内存空间的引用数 +1</span>\n<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">22</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'ifcode\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> p <span class="token operator">=</span> person   <span class="token comment">// 两个变量指向一块内存空间, 该内存空间的引用数为 2</span>\nperson <span class="token operator">=</span> <span class="token number">1</span>       <span class="token comment">// 原来的person对象被赋值为1，对象内存空间的引用数-1,</span>\n                 <span class="token comment">// 但因为p指向原person对象，还剩一个对于对象空间的引用, 所以对象它不会被回收</span>\n\np <span class="token operator">=</span> <span class="token keyword">null</span>         <span class="token comment">// 原person对象已经没有引用，会被回收</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>由上面可以看出，引用计数算法是个简单有效的算法。</p>\n<p><strong>但它却存在一个致命的问题：循环引用。</strong></p>\n<p>如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    <span class="token keyword">let</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n    o1<span class="token punctuation">.</span>a <span class="token operator">=</span> o2\n    o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o1 \n    <span class="token keyword">return</span> <span class="token string">"Cycle reference!"</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">cycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305172448582" originSrc="images/image-20210305172448582.png" data="aurora"></p>\n<h3 id="_3-4-标记清除算法" tabindex="-1"><a class="header-anchor" href="#_3-4-标记清除算法" aria-hidden="true">#</a> 3.4 标记清除算法</h3>\n<p>现代的浏览器已经不再使用引用计数算法了。</p>\n<p>现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p>\n<p>标记清除法:</p>\n<ul>\n<li>\n<p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。</p>\n</li>\n<li>\n<p>简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。</p>\n</li>\n<li>\n<p>凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p>\n</li>\n</ul>\n<p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。</p>\n<p>根据这个概念，上面的例子可以正确被垃圾回收处理了。</p>\n<p>参考文章：<a href="https://www.jianshu.com/p/84a8fd5fa0ee" target="_blank" rel="noopener noreferrer">JavaScript内存管理<ExternalLinkIcon/></a></p>\n<h2 id="_4-谈谈你对-javascript-作用域链的理解" tabindex="-1"><a class="header-anchor" href="#_4-谈谈你对-javascript-作用域链的理解" aria-hidden="true">#</a> 4. 谈谈你对 JavaScript 作用域链的理解？</h2>\n<p>JavaScript 在执⾏过程中会创建一个个的<strong>可执⾏上下⽂</strong>。 (每个函数执行都会创建这么一个可执行上下文)</p>\n<p>每个可执⾏上下⽂的词法环境中包含了对外部词法环境的引⽤，可通过该引⽤来获取外部词法环境中的变量和声明等。</p>\n<p>这些引⽤串联起来，⼀直指向全局的词法环境，形成一个链式结构，被称为作⽤域链。</p>\n<p>简而言之: 函数内部 可以访问到 函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,</p>\n<p>这样的变量作用域访问的链式结构, 被称之为作用域链</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">1</span>\n\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>\n  <span class="token keyword">function</span> <span class="token function">inner</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>下图为由多个可执行上下文组成的调用栈：</p>\n<ul>\n<li>栈最底部为<code>全局可执行上下文</code></li>\n<li><code>全局可执行上下文</code> 之上有多个 <code>函数可执行上下文</code></li>\n<li>每个可执行上下文中包含了指向外部其他可执行上下文的引用，直到 <code>全局可执行上下文</code> 时它指向 <code>null</code></li>\n</ul>\n<img src="/images/image-20210218143938843.png" alt="image-20210218143938843" style="zoom:30%;" />\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306093300970" originSrc="images/image-20210306093300970.png" data="aurora"></p>\n<p>js全局有全局可执行上下文, 每个函数调用时, 有着函数的可执行上下文, 会入js调用栈</p>\n<p>每个可执行上下文, 都有者对于外部上下文词法作用域的引用, 外部上下文也有着对于再外部的上下文词法作用域的引用</p>\n<p><strong>=&gt; 就形成了作用域链</strong></p>\n<h2 id="_5-谈谈你对闭包的理解" tabindex="-1"><a class="header-anchor" href="#_5-谈谈你对闭包的理解" aria-hidden="true">#</a> 5. 谈谈你对闭包的理解？</h2>\n<p>这个问题想考察的主要有两个方面：</p>\n<ul>\n<li>对闭包的基本概念的理解</li>\n<li>对闭包的作用的了解</li>\n</ul>\n<p><strong>什么是闭包？</strong></p>\n<p>MDN的官方解释：</p>\n<blockquote>\n<p>闭包是函数和声明该函数的词法环境的组合</p>\n</blockquote>\n<p>更通俗一点的解释是：</p>\n<blockquote>\n<p>内层函数, 引用外层函数上的变量, 就可以形成闭包</p>\n</blockquote>\n<p>需求: 定义一个计数器方法, 每次执行一次函数, 就调用一次进行计数</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  count<span class="token operator">++</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'fn函数被调用了\'</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">\'次\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这样不好! count 定义成了全局变量, 太容易被别人修改了,  我们可以利用闭包解决</p>\n<p>闭包实例:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>\n\n  <span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    count<span class="token operator">++</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'fn函数被调用了\'</span> <span class="token operator">+</span> count <span class="token operator">+</span> <span class="token string">\'次\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> add\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> addFn <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token function">addFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>闭包的主要作用是什么？</strong></p>\n<p>在实际开发中，闭包最大的作用就是用来 <strong>变量私有</strong>。</p>\n<p>下面再来看一个简单示例：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 以 let 声明一个局部变量，而不是 this.name</span>\n  <span class="token comment">// this.name = \'zs\'     =>  p.name</span>\n  <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">\'hm_programmer\'</span> <span class="token comment">// 数据私有</span>\n  \n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n    <span class="token keyword">return</span> name\n  <span class="token punctuation">}</span>\n  \n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span> \n    name <span class="token operator">=</span> value\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// new:</span>\n<span class="token comment">// 1. 创建一个新的对象</span>\n<span class="token comment">// 2. 让构造函数的this指向这个新对象</span>\n<span class="token comment">// 3. 执行构造函数</span>\n<span class="token comment">// 4. 返回实例</span>\n<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// hm_programmer</span>\n\np<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">\'Tom\'</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Tom</span>\n\np<span class="token punctuation">.</span>name <span class="token comment">// 访问不到 name 变量：undefined</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>在此示例中，变量 <code>name</code> 只能通过 Person 的实例方法进行访问，外部不能直接通过实例进行访问，形成了一个私有变量。</p>\n<h2 id="_6-javascript中数据类型的隐式转换规则-了解" tabindex="-1"><a class="header-anchor" href="#_6-javascript中数据类型的隐式转换规则-了解" aria-hidden="true">#</a> 6. JavaScript中数据类型的隐式转换规则(了解)</h2>\n<p>在if语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。</p>\n<p>下表展示了一系列原始值，通过隐式转换成数字、字符串、布尔类型后所得到的值：</p>\n<img src="/images/image-20210218171603780.png" alt="image-20210218171603780" style="zoom:45%;" />\n<p>坑: 判断时,  尽量不要用 <code>= =</code> , 要用 <code>= = =</code> ( 两个等号判断,  如果类型不同,  默认会进行隐式类型转换再比较)</p>\n<h2 id="_7-谈谈你对原型链的理解" tabindex="-1"><a class="header-anchor" href="#_7-谈谈你对原型链的理解" aria-hidden="true">#</a> 7. 谈谈你对原型链的理解？</h2>\n<p>要讲清楚这个问题，主要着重这几个方面：</p>\n<ul>\n<li>什么是原型对象</li>\n<li>构造函数, 原型对象, 实例的三角关系图</li>\n<li>原型链如何形成</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306104516852" originSrc="images/image-20210306104516852.png" data="aurora"></p>\n<p><strong>原型对象</strong></p>\n<p>在 JavaScript 中，除去一部分内建函数，绝大多数的函数都会包含有一个叫做 <code>prototype</code> 的属性，指向原型对象，</p>\n<p>基于构造函数创建出来的实例, 都可以共享访问原型对象的属性。</p>\n<p>例如我们的 <code>hasOwnProperty</code>, <code>toString</code> ⽅法等其实是 Obejct 原型对象的方法，它可以被任何对象当做⾃⼰的⽅法来使⽤。</p>\n<p><code>hasOwnProperty</code> 用于判断, 某个属性, 是不是自己的  (还是原型链上的)</p>\n<p>来看一段代码：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Tom"</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">job</span><span class="token operator">:</span> <span class="token string">"student"</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"hasOwnProperty"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false </span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">"hasOwnProperty"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>可以看到，<code>hasOwnProperty</code> 并不是 <code>person</code> 对象的属性，但是 <code>person</code> 却能调用它。</p>\n<p>那么 <code>person</code> 对象是如何找到 Object 原型中的 <code>hasOwnProperty</code> 的呢？这就要靠原型链的能力了。</p>\n<p>需求: 简单绘制原型三角关系图!</p>\n<p><strong>原型链</strong></p>\n<p>在 JavaScript 中，每个对象中都有一个 <code>__proto__</code> 属性，这个属性指向了当前对象的构造函数的原型。</p>\n<p>对象可以通过自身的 <code>__proto__</code>属性与它的构造函数的原型对象连接起来，</p>\n<p>而因为它的原型对象也有 <code>__proto__</code>，因此这样就串联形成一个链式结构，也就是我们称为的原型链。</p>\n<img src="/images/image-20210218212449526.png" alt="image-20210218212449526" style="zoom:50%;" />\n<h2 id="_6-谈谈对于继承的理解" tabindex="-1"><a class="header-anchor" href="#_6-谈谈对于继承的理解" aria-hidden="true">#</a> 6. 谈谈对于继承的理解</h2>\n<p><strong>为什么要学习继承 ?</strong></p>\n<p>写的构造函数, 定义了一个类型 (人类), 万一项目非常大, 又有了细化的多个类型 (老师, 工人, 学生)</p>\n<p>学习继承, 可以让多个构造函数之间建立关联, 便于管理和复用</p>\n<p><strong>什么是继承 ?</strong></p>\n<p>继承: 从别人那里, 继承东西过来 (财产, 房产)</p>\n<p>代码层面的继承: 继承一些属性和方法</p>\n<h3 id="_6-1-继承-原型继承" tabindex="-1"><a class="header-anchor" href="#_6-1-继承-原型继承" aria-hidden="true">#</a> 6.1 继承 - 原型继承</h3>\n<p>原型继承: 通过改造原型链, 利用原型链的语法, 实现继承方法!</p>\n<p>分析需求:</p>\n<p>​\t人类, 属性: name, age</p>\n<p>​\t学生, 属性: name, age, className</p>\n<p>​\t工人, 属性: name, age, companyName</p>\n<p>无论学生, 还是工人, =&gt; 都是人类, 所以人类原型上有的方法, 他们都应该要有</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'人类会说话\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'学生在学习\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">\'张三\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'80期\'</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306111112493" originSrc="images/image-20210306111112493.png" data="aurora"></p>\n<h3 id="_6-2-继承-组合继承" tabindex="-1"><a class="header-anchor" href="#_6-2-继承-组合继承" aria-hidden="true">#</a> 6.2 继承 - 组合继承</h3>\n<p>组合继承有时候也叫伪经典继承，指的是将原型链 和 借用构造函数 call 技术组合到一块，</p>\n<p>从而发挥二者之长的一种继承模式，其背后的思路: <strong>是使用原型链实现对原型属性和方法的继承 (主要是方法)，</strong></p>\n<p><strong>而通过借用构造函数来实现对实例属性构造的继承</strong>。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它的自己的属性。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'人类会说话\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// 实现构造属性的继承</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'学生在学习\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">\'张三\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'80期\'</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n\n<span class="token comment">// 方法通过 原型继承</span>\n<span class="token comment">// 属性通过 父构造函数的.call(this, name, age)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="_6-3-继承-寄生组合继承" tabindex="-1"><a class="header-anchor" href="#_6-3-继承-寄生组合继承" aria-hidden="true">#</a> 6.3 继承 - 寄生组合继承</h3>\n<p>student实例上有 name age,  而原型 <code>__proto__</code>上不需要再有这些属性, 所以利用 Object.create 改装下</p>\n<p>Object.create(参数对象),</p>\n<ol>\n<li>Object.create 会创建一个新对象,</li>\n<li>并且这个新对象的<code>__proto__</code> 会指向传入的参数对象</li>\n</ol>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. 定义Person构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'人类会说话\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义Student构造函数</span>\n<span class="token keyword">function</span> <span class="token function">Student</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> className</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>className <span class="token operator">=</span> className\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 3. 原型继承: 利用原型链, 继承于父级构造函数, 继承原型上的方法</span>\n<span class="token comment">// 语法: 子构造函数.prototype = new 父构造函数()</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>\n<span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'学生在学习\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">\'张三\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'80期\'</span><span class="token punctuation">)</span>\nstu<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span>\n\n\n<span class="token comment">// 总结:</span>\n<span class="token comment">// Object.create() 以参数的对象, 作为新建对象的__proto__属性的值, 返回新建的对象</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306114638139" originSrc="images/image-20210306114638139.png" data="aurora"></p>\n<h3 id="_6-4-es6-class-实现继承-extends" tabindex="-1"><a class="header-anchor" href="#_6-4-es6-class-实现继承-extends" aria-hidden="true">#</a> 6.4 es6 - class 实现继承 extends</h3>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 继承关键字 => extends</span>\n<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age\n  <span class="token punctuation">}</span>\n  <span class="token function">jump</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'会跳\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Teacher</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>\n  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> lesson</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">// extends 中, 必须调用 super(), 会触发执行父类的构造函数</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>lesson <span class="token operator">=</span> lesson\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'构造函数执行了\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">sayHello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'会打招呼\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> teacher1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token string">\'zs\'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">\'体育\'</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>teacher1<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="_8-如何判断是否是数组" tabindex="-1"><a class="header-anchor" href="#_8-如何判断是否是数组" aria-hidden="true">#</a> 8. 如何判断是否是数组？</h2>\n<p>方法一：使用 <code>toString</code> 方法</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">isArray</span><span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'[object Array]\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>\n<span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>  <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>方法二：使用 ES6 新增的 <code>Array.isArray</code> 方法</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>\nArray<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_9-谈谈你对this的理解" tabindex="-1"><a class="header-anchor" href="#_9-谈谈你对this的理解" aria-hidden="true">#</a> 9. 谈谈你对this的理解？</h2>\n<p><code>this</code> 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。</p>\n<p><strong>默认绑定</strong> (指向window的情况)  (函数调用模式 fn() )</p>\n<p>默认情况下，<code>this</code> 会被绑定到全局对象上，比如在浏览器环境中就为<code>window</code>对象，在node.js环境下为<code>global</code>对象。</p>\n<p>如下代码展示了这种绑定关系：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>message <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span> \n\n<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "Hello"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>隐式绑定</strong> (谁调用, this指向谁) (方法调用模式 obj.fn() )</p>\n<p>如果函数的调用是从对象上发起时，则该函数中的 <code>this</code> 会被自动隐式绑定为对象：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"hello,world"</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">test</span><span class="token operator">:</span> test\n<span class="token punctuation">}</span>\n\nobj<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "hello,world"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>显式绑定</strong> (又叫做硬绑定)  (上下文调用模式, 想让this指向谁, this就指向谁)</p>\n<p>硬绑定 =&gt; call  apply  bind</p>\n<p>可以显式的进行绑定：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"你好世界123"</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"你好世界456"</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "你好世界123"</span>\n<span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// "你好世界456"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>new 绑定</strong> (构造函数模式)</p>\n<p>另外，在使用 <code>new</code> 创建对象时也会进行 <code>this</code> 绑定</p>\n<p>当使用 <code>new</code> 调用构造函数时，会创建一个新的对象并将该对象绑定到构造函数的 <code>this</code> 上：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greeting</span><span class="token punctuation">(</span><span class="token string">"hello,world"</span><span class="token punctuation">)</span>\nobj<span class="token punctuation">.</span>message <span class="token comment">// "hello,world"</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>小测试:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">10</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\nobj<span class="token punctuation">.</span>a<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token keyword">let</span> temp <span class="token operator">=</span> obj<span class="token punctuation">.</span>a<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>\n<span class="token function">temp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// -------------------------------------------------------------</span>\n\n<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">theName<span class="token punctuation">,</span> theAge</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> theName\n    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> theAge\n<span class="token punctuation">}</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 定义函数</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"小黑"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>\nper<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h2 id="_10-箭头函数中的this指向什么" tabindex="-1"><a class="header-anchor" href="#_10-箭头函数中的this指向什么" aria-hidden="true">#</a> 10. 箭头函数中的this指向什么？</h2>\n<p>箭头函数不同于传统函数，它其实没有属于⾃⼰的 <code>this</code>，</p>\n<p>它所谓的 <code>this</code> 是, 捕获其外层  上下⽂的 <code>this</code> 值作为⾃⼰的 <code>this</code> 值。</p>\n<p>并且由于箭头函数没有属于⾃⼰的 <code>this</code> ，它是不能被 <code>new</code> 调⽤的。</p>\n<p>我们可以通过 Babel 转换前后的代码来更清晰的理解箭头函数:</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 转换前的 ES6 代码</span>\n<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> \n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> obj<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 转换后的 ES5 代码</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> \n  <span class="token function-variable function">test</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">getArrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span>\n    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>that <span class="token operator">===</span> obj<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这里我们看到，箭头函数中的 <code>this</code> 就是它上层上下文函数中的 <code>this</code>。</p>\n<h2 id="_11-promise-的静态方法" tabindex="-1"><a class="header-anchor" href="#_11-promise-的静态方法" aria-hidden="true">#</a> 11. Promise 的静态方法</h2>\n<p>promise的三个状态: pending(默认)   fulfilled(成功)   rejected(失败)</p>\n<ol>\n<li>resolve函数被执行时, 会将promise的状态从 pending 改成 fulfilled 成功</li>\n<li>reject函数被执行时, 会将promise的状态从pending 改成 rejected 失败</li>\n</ol>\n<p>Promise.reject()</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t<span class="token function">reject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Promise.resolve()</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n\t<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>Promise.all([promise1, promise2, promise3])</strong>  等待原则, 是在所有promise都完成后执行, 可以用于处理一些<code>并发的任务</code></p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 后面的.then中配置的函数, 是在前面的所有promise都完成后执行, 可以用于处理一些并发的任务</span>\nPromise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">,</span> promise3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">values</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// values 是一个数组, 会收集前面promise的结果 values[0] => promise1的成功的结果</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Promise.race([promise1, promise2, promise3]) 赛跑, 竞速原则, 只要三个promise中有一个满足条件, 就会执行.then(用的较少)</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306144638905" originSrc="images/image-20210306144638905.png" data="aurora"></p>\n<h2 id="_12-宏任务-微任务-是什么" tabindex="-1"><a class="header-anchor" href="#_12-宏任务-微任务-是什么" aria-hidden="true">#</a> 12. 宏任务 微任务 是什么</h2>\n<p>小例题:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\tconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>宏任务: 主线程代码, setTimeout 等属于宏任务,  上一个宏任务执行完, 才会考虑执行下一个宏任务</p>\n<p>微任务: promise .then .catch的需要执行的内容, 属于微任务, 满足条件的微任务, 会被添加到当前宏任务的最后去执行</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201208040306978" originSrc="images/image-20201208040306978.png" data="aurora"></p>\n<p><strong>事件循环队列 eventLoop</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201208040235602" originSrc="images/image-20201208040235602.png" data="aurora"></p>\n<p>例题1:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 宏任务</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment">// 微任务</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306151137688" originSrc="images/image-20210306151137688.png" data="aurora"></p>\n<p>例题2:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>例题3:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">2</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>例题4:</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'嘿嘿\'</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">// 微任务</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'gaga\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306152010989" originSrc="images/image-20210306152010989.png" data="aurora"></p>\n<p>考察点: async 函数只有从 await 往下才是异步的开始</p>\n<h2 id="_13-async-await是什么" tabindex="-1"><a class="header-anchor" href="#_13-async-await是什么" aria-hidden="true">#</a> 13. async/await是什么？</h2>\n<p>ES7 标准中新增的 <code>async</code> 函数，从目前的内部实现来说其实就是 <code>Generator</code> 函数的语法糖。</p>\n<p>它基于 Promise，并与所有现存的基于Promise 的 API 兼容。</p>\n<p><strong>async 关键字</strong></p>\n<ol>\n<li>\n<p><code>async</code> 关键字用于声明⼀个异步函数（如 <code>async function asyncTask1() {...}</code>）</p>\n</li>\n<li>\n<p><code>async</code> 会⾃动将常规函数转换成 Promise，返回值也是⼀个 Promise 对象</p>\n</li>\n<li>\n<p><code>async</code> 函数内部可以使⽤ <code>await</code></p>\n</li>\n</ol>\n<p><strong>await 关键字</strong></p>\n<ol>\n<li>\n<p><code>await</code> 用于等待异步的功能执⾏完毕 <code>var result = await someAsyncCall()</code></p>\n</li>\n<li>\n<p><code>await</code> 放置在 Promise 调⽤之前，会强制async函数中其他代码等待，直到 Promise 完成并返回结果</p>\n</li>\n<li>\n<p><code>await</code> 只能与 Promise ⼀起使⽤</p>\n</li>\n<li>\n<p><code>await</code> 只能在 <code>async</code> 函数内部使⽤</p>\n</li>\n</ol>\n<h2 id="_14-相较于-promise-async-await有何优势" tabindex="-1"><a class="header-anchor" href="#_14-相较于-promise-async-await有何优势" aria-hidden="true">#</a> 14. 相较于 Promise，async/await有何优势？</h2>\n<ol>\n<li>同步化代码的阅读体验（Promise 虽然摆脱了回调地狱，但 then 链式调⽤的阅读负担还是存在的）</li>\n<li>和同步代码更一致的错误处理方式（ async/await 可以⽤成熟的 try/catch 做处理，比 Promise 的错误捕获更简洁直观）</li>\n<li>调试时的阅读性, 也相对更友好</li>\n</ol>\n<h2 id="_15-深拷贝-浅拷贝" tabindex="-1"><a class="header-anchor" href="#_15-深拷贝-浅拷贝" aria-hidden="true">#</a> 15. 深拷贝 浅拷贝</h2>\n<p>引用类型, 进行赋值时, 赋值的是地址</p>\n<ol>\n<li>\n<p>浅拷贝</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n\t<span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>obj\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li>\n<li>\n<p>深拷贝</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">\'zs\'</span><span class="token punctuation">,</span>\n\t<span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>\n    <span class="token literal-property property">car</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token literal-property property">brand</span><span class="token operator">:</span> <span class="token string">\'宝马\'</span><span class="token punctuation">,</span>\n        <span class="token literal-property property">price</span><span class="token operator">:</span> <span class="token number">100</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>当然递归也能解决, 只是比较麻烦~</p>\n<p>...</p>\n</li>\n</ol>\n<p>其他方案, 可以参考一些博客</p>\n<hr>\n<h1 id="http协议" tabindex="-1"><a class="header-anchor" href="#http协议" aria-hidden="true">#</a> HTTP协议</h1>\n<h2 id="_1-http有哪些方法" tabindex="-1"><a class="header-anchor" href="#_1-http有哪些方法" aria-hidden="true">#</a> 1. HTTP有哪些⽅法？</h2>\n<p>HTTP 1.0 标准中，定义了3种请求⽅法：GET、POST、HEAD</p>\n<p>HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT</p>\n<h2 id="_2-各个http方法的具体作用是什么" tabindex="-1"><a class="header-anchor" href="#_2-各个http方法的具体作用是什么" aria-hidden="true">#</a> 2. 各个HTTP方法的具体作用是什么？</h2>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">方法</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">GET</td>\n<td>通常⽤于请求服务器发送某些资源</td>\n</tr>\n<tr>\n<td style="text-align:center">POST</td>\n<td>发送数据给服务器</td>\n</tr>\n<tr>\n<td style="text-align:center">HEAD</td>\n<td>请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。<br />该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</td>\n</tr>\n<tr>\n<td style="text-align:center">PUT</td>\n<td>⽤于全量修改⽬标资源 (看接口, 也可以用于添加)</td>\n</tr>\n<tr>\n<td style="text-align:center">DELETE</td>\n<td>⽤于删除指定的资源</td>\n</tr>\n<tr>\n<td style="text-align:center">OPTIONS</td>\n<td>⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全)</td>\n</tr>\n<tr>\n<td style="text-align:center">TRACE</td>\n<td>该方法会  让服务器  原样返回任意客户端请求的信息内容, 用于诊断和判断</td>\n</tr>\n<tr>\n<td style="text-align:center">CONNECT</td>\n<td>HTTP/1.1协议中预留给能够将连接改为管道⽅式的代理服务器<br />(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户)</td>\n</tr>\n<tr>\n<td style="text-align:center">PATCH</td>\n<td>⽤于对资源进⾏部分修改</td>\n</tr>\n</tbody>\n</table>\n<p>GET POST PUT PATCH DELETE</p>\n<p>GET/DELETE  参数是在地址栏中传递的</p>\n<p>PUT/PATCH/POST 参数是在请求体传递的</p>\n<h2 id="_3-get方法和post方法有何区别" tabindex="-1"><a class="header-anchor" href="#_3-get方法和post方法有何区别" aria-hidden="true">#</a> 3. GET方法和POST方法有何区别？</h2>\n<p>默认的http请求的内容, 在网络中传输, 明文的形式传递的  (https 对内容加密)</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>GET方法</th>\n<th>POST方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>数据传输⽅式</strong></td>\n<td>通过URL传输数据 (地址栏拼接参数)</td>\n<td>通过请求体传输</td>\n</tr>\n<tr>\n<td><strong>数据安全</strong></td>\n<td>数据暴露在URL中，可通过浏览历史记录、缓存等很容易查到数据信息</td>\n<td>数据因为在请求主体内，<br />所以有⼀定的安全性保证</td>\n</tr>\n<tr>\n<td><strong>数据类型</strong></td>\n<td>只允许 ASCII 字符</td>\n<td>⽆限制</td>\n</tr>\n<tr>\n<td><strong>GET⽆害</strong></td>\n<td>刷新、后退等浏览器操作是⽆害的</td>\n<td>可能会引起重复提交表单</td>\n</tr>\n<tr>\n<td><strong>功能特性</strong></td>\n<td>安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br /><strong>幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）</strong></td>\n<td>⾮安全(会引起服务器端的变化)、<strong>⾮幂等</strong></td>\n</tr>\n</tbody>\n</table>\n<h2 id="_4-http请求报文是什么样的" tabindex="-1"><a class="header-anchor" href="#_4-http请求报文是什么样的" aria-hidden="true">#</a> 4. HTTP请求报文是什么样的？</h2>\n<p>HTTP 请求报⽂的组成：请求⾏、请求头、(空⾏)、请求体。</p>\n<p>实际请求报文实例:</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210305232854139" originSrc="images/image-20210305232854139.png" data="aurora"></p>\n<p><strong>请求行</strong></p>\n<p>包含了请求⽅法、URL、HTTP 协议版本，它们之间⽤空格进行分隔。例如：</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>GET http://www.abc.com/articles HTTP/1.1\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>请求头</strong></p>\n<p>请求头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号<code>:</code>进行分隔。例如：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>Content-Type: application/json\nHost: www.abc.com\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>请求体</strong></p>\n<p>请求体中放置 POST、PUT、PATCH 等请求方法所需要携带的数据。</p>\n<h2 id="_5-http响应报文是什么样的" tabindex="-1"><a class="header-anchor" href="#_5-http响应报文是什么样的" aria-hidden="true">#</a> 5. HTTP响应报文是什么样的？</h2>\n<p>HTTP 响应报⽂的组成: 响应⾏、响应头、空⾏、响应体。</p>\n<img src="/images/image-20210219125038371.png" alt="image-20210219125038371" style="zoom:40%;" />\n<p><strong>响应行</strong></p>\n<p>响应行由协议版本、状态码、状态码的原因短语3个内容组成，中间以空格分隔。例如：</p>\n<div class="language-bash ext-sh line-numbers-mode"><pre v-pre class="language-bash"><code>HTTP/1.1 <span class="token number">200</span> OK\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>响应头</strong></p>\n<p>响应头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号<code>:</code>进行分隔。例如：</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>Content-Length: 1024\nContent-Type: application/json\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>响应体</strong></p>\n<p>服务器发送过来的数据。</p>\n<p>小结:</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306161216371" originSrc="images/image-20210306161216371.png" data="aurora"></p>\n<h2 id="_6-你了解的http状态码有哪些" tabindex="-1"><a class="header-anchor" href="#_6-你了解的http状态码有哪些" aria-hidden="true">#</a> 6. 你了解的HTTP状态码有哪些？</h2>\n<p><strong>成功（2XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>200</td>\n<td>OK</td>\n<td>表示从客户端发来的请求在服务器端被正确处理</td>\n</tr>\n<tr>\n<td>201</td>\n<td>Created</td>\n<td>请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴<br />通常是在POST请求，或是某些PUT请求之后创建了内容, 进行的返回的响应</td>\n</tr>\n<tr>\n<td>202</td>\n<td>Accepted</td>\n<td>请求服务器已接受，但是尚未处理，不保证完成请求<br />适合异步任务或者说需要处理时间比较长的请求，避免HTTP连接一直占用</td>\n</tr>\n<tr>\n<td>204</td>\n<td>No content</td>\n<td>表示请求成功，但响应报⽂不含实体的主体部分</td>\n</tr>\n<tr>\n<td>206</td>\n<td>Partial Content</td>\n<td>进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求<br />响应头中会包含获取的内容范围 (常用于分段下载)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>重定向（3XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>301</td>\n<td>Moved Permanently</td>\n<td>永久性重定向，表示资源已被分配了新的 URL<br />比如，我们访问 <strong>http</strong>😕/www.baidu.com 会跳转到 <strong>https</strong>😕/www.baidu.com</td>\n</tr>\n<tr>\n<td>302</td>\n<td>Found</td>\n<td>临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br />首页, 个人中心, 遇到了需要登录才能操作的内容, 重定向 到 登录页</td>\n</tr>\n<tr>\n<td>303</td>\n<td>See Other</td>\n<td>对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。</td>\n</tr>\n<tr>\n<td><strong>304</strong></td>\n<td><strong>Not Modified</strong></td>\n<td><strong>自从上次请求后，请求的网页内容未修改过。<br />服务器返回此响应时，不会返回网页内容。(协商缓存)</strong></td>\n</tr>\n<tr>\n<td>307</td>\n<td>Temporary Redirect</td>\n<td>对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起POST请求。<br />不对请求做额外处理, 正常发送请求, 请求location中的url地址</td>\n</tr>\n</tbody>\n</table>\n<p>因为post请求, 是非幂等的,  从302中, 细化出了 303 和 307</p>\n<p>简而言之:</p>\n<ul>\n<li>301  302  307  都是重定向</li>\n<li>304 协商缓存</li>\n</ul>\n<p><strong>客户端错误（4XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>400</strong></td>\n<td><strong>Bad Request</strong></td>\n<td><strong>请求报⽂存在语法错误(（传参格式不正确）</strong></td>\n</tr>\n<tr>\n<td>401</td>\n<td>UnAuthorized</td>\n<td>权限认证未通过(没有权限)</td>\n</tr>\n<tr>\n<td>403</td>\n<td>Forbidden</td>\n<td>表示对请求资源的访问被服务器拒绝</td>\n</tr>\n<tr>\n<td>404</td>\n<td>Not Found</td>\n<td>表示在服务器上没有找到请求的资源</td>\n</tr>\n<tr>\n<td>408</td>\n<td>Request Timeout</td>\n<td>客户端请求超时</td>\n</tr>\n<tr>\n<td>409</td>\n<td>Confict</td>\n<td>请求的资源可能引起冲突</td>\n</tr>\n</tbody>\n</table>\n<p><strong>服务端错误（5XX）</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>原因短语</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>500</td>\n<td>Internal Sever Error</td>\n<td>表示服务器端在执⾏请求时发⽣了错误</td>\n</tr>\n<tr>\n<td>501</td>\n<td>Not Implemented</td>\n<td>请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br />或者请求是服务器不⽀持的某个⽅法</td>\n</tr>\n<tr>\n<td>503</td>\n<td>Service Unavailable</td>\n<td>表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</td>\n</tr>\n<tr>\n<td>505</td>\n<td>Http Version Not Supported</td>\n<td>服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</td>\n</tr>\n</tbody>\n</table>\n<h2 id="_7-http的keep-alive是什么作用" tabindex="-1"><a class="header-anchor" href="#_7-http的keep-alive是什么作用" aria-hidden="true">#</a> 7. HTTP的keep-alive是什么作用？</h2>\n<p>作用：使客户端到服务器端的连接<strong>持续有效</strong>(长连接)，当出现对服务器的后继请求时，</p>\n<p>Keep-Alive功能避免了建立或者重新建立连接。</p>\n<p>早期 HTTP/1.0 在每次请求的时候，都要创建⼀个新的连接，⽽创建连接的过程需要消耗资源和时间，</p>\n<p>为了减少资源消耗、缩短响应时间，就需要复⽤已有连接。</p>\n<p>在后来的 HTTP/1.0 以及 HTTP/1.1 中引⼊了复⽤连接的机制，也就是在请求头中加⼊Connection: keep-alive，</p>\n<p>以此告诉对⽅这个请求响应完成后不要关闭连接，下⼀次还⽤这个请求的连接进行后续交流。</p>\n<p><strong>协议规定，如果想要保持连接，则需要在请求头中加上 Connection: keep-alive。</strong></p>\n<p><strong>keep-alive 的优点</strong> (复用连接)</p>\n<ul>\n<li>较少的 CPU 和内存的占⽤（因为要打开的连接数变少了, 复用了连接）</li>\n<li>减少了后续请求的延迟（⽆需再进⾏握⼿）</li>\n<li>...</li>\n</ul>\n<p>缺点: 因为在处理的暂停期间，本来可以释放的资源仍旧被占用。请求已经都结束了, 但是还一直连接着也不合适</p>\n<p>解决：Keep-Alive: timeout=5, max=100</p>\n<ul>\n<li>\n<p>timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），</p>\n</li>\n<li>\n<p>max是最多一百次请求，强制断掉连接。</p>\n<p>就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</p>\n</li>\n</ul>\n<h2 id="_8-为什么需要https" tabindex="-1"><a class="header-anchor" href="#_8-为什么需要https" aria-hidden="true">#</a> 8. 为什么需要HTTPS？</h2>\n<p>HTTPS 是安全版的 HTTP。</p>\n<p>HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。</p>\n<p>而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。</p>\n<h2 id="_9-https是如何保证安全的" tabindex="-1"><a class="header-anchor" href="#_9-https是如何保证安全的" aria-hidden="true">#</a> 9. HTTPS是如何保证安全的？</h2>\n<p>HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。</p>\n<p>那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。</p>\n<p>目前常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。</p>\n<h3 id="_9-1-什么是对称加密" tabindex="-1"><a class="header-anchor" href="#_9-1-什么是对称加密" aria-hidden="true">#</a> 9.1 <strong>什么是对称加密？</strong></h3>\n<p>对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，</p>\n<p>这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难</p>\n<p>通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306005550796" originSrc="images/image-20210306005550796.png" data="aurora"></p>\n<p>对称加密的特点是：</p>\n<ul>\n<li>\n<p>优点:</p>\n<p>计算量小、加密速度快、加密效率高。</p>\n</li>\n<li>\n<p>缺点:</p>\n<p>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。</p>\n<p>如果一方的秘钥被泄露，那么加密信息也就不安全了</p>\n</li>\n</ul>\n<p>使用场景：本地数据加密、https通信、网络传输等</p>\n<p>常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6</p>\n<h3 id="_9-2-什么是非对称加密" tabindex="-1"><a class="header-anchor" href="#_9-2-什么是非对称加密" aria-hidden="true">#</a> 9.2 <strong>什么是⾮对称加密？</strong></h3>\n<p>而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，</p>\n<p>这样就避免了直接传递密钥。这种新的加密模式被称为&quot;非对称加密算法&quot;。</p>\n<p>通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。</p>\n<p>特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306011528361" originSrc="images/image-20210306011528361.png" data="aurora"></p>\n<p>非对称加密的特点是：</p>\n<ul>\n<li>\n<p>优点：非对称加密与对称加密相比其安全性更好</p>\n</li>\n<li>\n<p>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>\n</li>\n</ul>\n<p>使用场景：https会话前期、CA数字证书、信息加密、登录认证等</p>\n<p>常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p>\n<h3 id="_9-3-https-加密解决方案" tabindex="-1"><a class="header-anchor" href="#_9-3-https-加密解决方案" aria-hidden="true">#</a> 9.3 <strong>HTTPS 加密解决⽅案</strong></h3>\n<p>结合了两种加密⽅式：</p>\n<ul>\n<li>\n<p>将 <code>对称加密的密钥</code> ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 <code>对称加密密钥</code></p>\n</li>\n<li>\n<p>双⽅沟通时使⽤ <code>对称加密密钥</code> 进⾏</p>\n</li>\n</ul>\n<p><strong>可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。</strong></p>\n<p>HTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议</p>\n<p>它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输</p>\n<h3 id="_9-4-数字证书" tabindex="-1"><a class="header-anchor" href="#_9-4-数字证书" aria-hidden="true">#</a> 9.4 数字证书</h3>\n<p>为了安全性, 一般还需要签发数字证书!</p>\n<p>客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息</p>\n<p>进而进行非对称加密, 使用公钥, 加密<code>对称加密密钥</code>, 传递给服务器, 后续通信都使用对称加密!</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306020401732" originSrc="images/image-20210306020401732.png" data="aurora"></p>\n<p><strong>问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!</strong></p>\n<p>所以, 就需要有数字证书(CA证书),  一般是CA机构颁发的, 证明这个公钥是安全可靠的!</p>\n<p><strong>CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306014409595" originSrc="images/image-20210306014409595.png" data="aurora"></p>\n<p>当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306021013686" originSrc="images/image-20210306021013686.png" data="aurora"></p>\n<p>而客户端, 接收到消息后, 就可以查看证书</p>\n<ol>\n<li>\n<p>如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!!</p>\n</li>\n<li>\n<p>如果签发证书的机构, 不权威, 发出警告</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306021532010" originSrc="images/image-20210306021532010.png" data="aurora"></p>\n</li>\n<li>\n<p>如果证书过期了, 浏览器也会发出警告</p>\n</li>\n</ol>\n<h3 id="_9-5-数字签名" tabindex="-1"><a class="header-anchor" href="#_9-5-数字签名" aria-hidden="true">#</a> 9.5 数字签名</h3>\n<p>但这还是有问题：如果证书被篡改了怎么办?</p>\n<p>这时就需要用⼀个技术：<strong>数字签名</strong>。 (根据证书内容, 生成的一个唯一标识)</p>\n<p>数字签名就是先⽤ <strong>CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要</strong>，然后使⽤ CA 私钥进行加密，组成数字签名。</p>\n<p>当别⼈把他的证书发过来时，<strong>接收方⽤同样的算法再次⽣成摘要</strong>，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,</p>\n<p>就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。</p>\n<p><a href="https://blog.csdn.net/u014044812/article/details/80723009" target="_blank" rel="noopener noreferrer">博客参考<ExternalLinkIcon/></a></p>\n<h2 id="_10-http2和http1-x比-有什么优势和特点" tabindex="-1"><a class="header-anchor" href="#_10-http2和http1-x比-有什么优势和特点" aria-hidden="true">#</a> 10. HTTP2和HTTP1.x比，有什么优势和特点？</h2>\n<ol>\n<li>HTTP/2 采⽤<code>⼆进制格式</code>来传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议<code>解析起来更⾼效</code></li>\n<li>HTTP/2 采用一些<code>头部压缩技术</code>，减少在请求和响应头中重复携带的数据，<code>降低网络负担</code></li>\n<li>HTTP/2 采⽤<code>服务器推送</code>方式，主动向客户端推送资源，提高页面加载效率</li>\n<li>HTTP/2 采⽤<code>多路复用机制</code>，减少需要创建的连接数量，降低资源占用和性能消耗</li>\n</ol>\n<p>下面是一些与之关联的技术知识。</p>\n<p><strong>⼆进制格式分帧</strong></p>\n<p>帧：HTTP/2 数据通信的最⼩单位消息，是指 HTTP/2 中逻辑上的 HTTP 消息（例如请求、响应等）。消息由⼀个或多个帧组成</p>\n<p>流：存在于连接中的⼀个虚拟通道，它可以承载双向消息，且每个流都有唯⼀的整数ID</p>\n<p><strong>头部压缩</strong></p>\n<p>在 HTTP/1.x 中，请求和响应中会重复携带一些不常改变、冗⻓的头数据，给⽹络带来额外负担。</p>\n<p>在 HTTP/2 中，客户端和服务端使⽤ <strong>“⾸部表”</strong> 来跟踪和存储之前发送过的键值对，</p>\n<p>相同的数据不再随着每次请求和响应发送。⾸部表在连接存续期间始终存在，由客户端和服务器共同渐进更新。</p>\n<p>每个新的⾸部键值对，要么被追加到当前表的末尾，要么替换表中已存在的键值对。</p>\n<blockquote>\n<p>可以简单的理解为：只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</p>\n</blockquote>\n<p>下图为首部表的更新示意图：</p>\n<img src="/images/image-20210219160534616.png" alt="image-20210219160534616" style="zoom:30%;" />\n<p><strong>服务器推送</strong></p>\n<p>服务端可以在发送⻚⾯ HTML 内容时，再主动推送一些其它资源，⽽不⽤等到浏览器解析到相应的位置时发起请求后再作响应。</p>\n<p>例如，服务端可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。</p>\n<p>不过，服务端的主动推送行为，客户端有权利选择是否要接收。</p>\n<p>如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。</p>\n<p><strong>多路复用</strong></p>\n<p>在 HTTP 1.x 中如果想并发多个请求的话，必须使⽤多个 TCP 链接，但浏览器为了控制资源，</p>\n<p>会对单个域名有 6-8 个 TCP 链接的数量限制。而在 HTTP 2 中：</p>\n<ul>\n<li>同域名下的所有通信，都在单个连接上完成</li>\n<li>单个连接可以承载任意数量的双向数据流</li>\n<li>数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成（多个帧可以乱序发送，因为可以根据帧⾸部的流标识来重新组装）</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210306023912779" originSrc="images/image-20210306023912779.png" data="aurora"></p>\n<p><a href="https://zhuanlan.zhihu.com/p/30166894" target="_blank" rel="noopener noreferrer">参考文章：HTTP/2特性及其在实际应用中的表现<ExternalLinkIcon/></a></p>\n<h2 id="_11-http缓存控制" tabindex="-1"><a class="header-anchor" href="#_11-http缓存控制" aria-hidden="true">#</a> 11. http缓存控制</h2>\n<h3 id="_11-1-基本认知" tabindex="-1"><a class="header-anchor" href="#_11-1-基本认知" aria-hidden="true">#</a> 11.1 基本认知</h3>\n<p><strong>Web 服务缓存</strong> 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。</p>\n<p><strong>浏览器缓存</strong> 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。<strong><code>这里我们只讨论 HTTP 缓存相关内容</code>。</strong></p>\n<p><strong>HTTP缓存</strong>:</p>\n<ul>\n<li><strong>强缓存</strong></li>\n<li><strong>协商缓存</strong></li>\n</ul>\n<p>在具体了解 HTTP 缓存之前先来明确几个术语：</p>\n<ul>\n<li>缓存命中率：从缓存中得到数据的请求数  与    所有请求数的比率。理想状态是越高越好。</li>\n<li>过期内容：超过设置的有效时间，被标记为“陈旧”的内容。</li>\n<li>验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</li>\n<li>失效：失效就是把内容从缓存中移除。</li>\n</ul>\n<p><strong>浏览器缓存主要是 HTTP 协议定义的缓存机制。</strong></p>\n<p><strong>浏览器缓存, HTTP缓存分类</strong></p>\n<p>浏览器缓存分为<code>强缓存 </code>和 <code>协商缓存</code>，浏览器加载一个页面的简单流程如下：</p>\n<ol>\n<li>\n<p>浏览器先根据这个资源的  <strong>http头信息</strong>  来 <strong>判断是否命中强缓存</strong>。</p>\n<p>如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）</p>\n</li>\n<li>\n<p>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。</p>\n<p>服务器来判断浏览器本地缓存是否失效。</p>\n<p>若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</p>\n</li>\n<li>\n<p>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</p>\n</li>\n</ol>\n<h3 id="_11-2-强缓存-食品过期时间判断" tabindex="-1"><a class="header-anchor" href="#_11-2-强缓存-食品过期时间判断" aria-hidden="true">#</a> 11.2 强缓存  (食品过期时间判断)</h3>\n<p><strong>(进行判断, 是否资源过期, 如果未过期, 直接用缓存)</strong></p>\n<p><strong>强缓存</strong></p>\n<p>命中强缓存时，浏览器并不会将请求发送给服务器。</p>\n<p>在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="images/940884-20180423141536107-329179455.png" data="aurora"></p>\n<p>强缓存是利用http的返回的响应头中的Expires或者Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。</p>\n<p>Expires: 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读</p>\n<p>Cache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s</p>\n<p><strong>Expires</strong></p>\n<p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。但在上面我们提到过，cache-control的优先级更高。</p>\n<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201209080705571" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/image-20201209080705571.png" data="aurora"></p>\n<p>该字段会返回一个时间，比如Expires:  Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在xx年xx月xx日时间之前都是有效的，即命中缓存。</p>\n<p>这种方式有一个明显的缺点，由于失效时间是一个<code>绝对时间</code>，所以当 <strong>服务器与客户端 时间偏差很大</strong>  以后，就会导致缓存混乱。于是发展出了Cache-Control。</p>\n<p><strong>Cache-Control</strong></p>\n<p>Cache-Control是一个<code>相对时间</code>，例如Cache-Control:max-age 3600，代表着资源的有效期是3600秒。</p>\n<p>由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。</p>\n<p>Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。</p>\n<p>Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</p>\n<ol>\n<li>\n<p><strong>max-age</strong> 指定一个时间长度，在这个时间段内缓存是有效的，单位是s。</p>\n<p>例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，</p>\n<p>第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141638673-1917674992.png" data="aurora"></p>\n<p>在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</p>\n</li>\n<li>\n<p><strong>no-cache</strong> 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。</p>\n<p>不是字面意思上的不缓存。</p>\n</li>\n<li>\n<p><strong>no-store</strong> 禁止缓存，每次请求都要向服务器重新获取数据。</p>\n</li>\n</ol>\n<h3 id="_11-3-协商缓存-找供货商专家协商" tabindex="-1"><a class="header-anchor" href="#_11-3-协商缓存-找供货商专家协商" aria-hidden="true">#</a> 11.3 协商缓存 (找供货商专家协商)</h3>\n<p>看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求)   强缓存</p>\n<p>食品过期时间过了,  能不能吃呢?  问问专家(服务器),  专家瞅了一眼, 没过期 (响应304, 不返回内容) , 直接吃          (协商缓存)</p>\n<p>如果问过专家(服务器), 专家瞅了一眼, 呀真过期了, 原来的不要了, 我重新给你发一个 (响应200, 并返回内容)</p>\n<p><strong>协商缓存</strong></p>\n<p>若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。</p>\n<p>服务器根据http头信息中的<code>Last-Modify/If-Modify-Since</code>或<code>Etag/If-None-Match</code>来判断是否命中协商缓存。</p>\n<p>如果命中，则http返回码为304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。</p>\n<p><strong>Last-Modify/If-Modify-Since</strong></p>\n<p>浏览器第一次请求一个资源的时候, 服务器返回的header中会加上Last-Modify，</p>\n<p>Last-modify是一个时间标识该资源的<strong>最后修改时间</strong>，例如<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141852114-1757065670.png" data="aurora"></p>\n<p>当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，<strong>该值为缓存之前返回的Last-Modify</strong>。</p>\n<p>服务器收到If-Modify-Since后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="images/940884-20180423141732879-1484228353.png" data="aurora"></p>\n<p>如果命中缓存，则返回 <strong>http304</strong>，并且不会返回资源内容，并且不会返回Last-Modify。</p>\n<p>由于对比的是服务端时间，所以客户端与服务端时间差距不会导致问题。</p>\n<p><strong>但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。</strong></p>\n<p>比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了,  <strong>于是出现了ETag/If-None-Match。</strong></p>\n<p><strong>ETag/If-None-Match</strong></p>\n<p>与Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。</p>\n<p>ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。</p>\n<p>ETag值的变更则说明资源状态已经被修改。</p>\n<p>服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141918779-1206116367.png" data="aurora"></p>\n<p>ETag生成靠以下几种因子</p>\n<ol>\n<li>\n<p>文件的i-node编号，是Linux/Unix用来识别文件的编号。</p>\n</li>\n<li>\n<p>文件最后修改时间</p>\n</li>\n<li>\n<p>文件大小</p>\n<p>...</p>\n</li>\n</ol>\n<p>生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值</p>\n<p><strong>既生 Last-Modified 何生 Etag ？</strong></p>\n<p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？</p>\n<p>Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>\n<ol>\n<li>\n<p>Last-Modified标注的最后修改只能精确到秒级</p>\n<p>如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p>\n</li>\n<li>\n<p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>\n</li>\n</ol>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 <strong>准确的控制缓存。</strong></p>\n<p>不会仅仅只根据最后的修改时间判断是否进行使用缓存</p>\n<p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，</p>\n<p>最后才决定是否返回304。</p>\n<p>小结:</p>\n<ul>\n<li>\n<p>强缓存: 大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读</p>\n</li>\n<li>\n<p>协商缓存: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间,  唯一标识etag), 去问服务器, 是否真的过期了</p>\n<p>如果验证通过,  服务器会直接响应 304, 且不会返回资源</p>\n</li>\n</ul>\n<h3 id="_11-4-整体请求缓存流程" tabindex="-1"><a class="header-anchor" href="#_11-4-整体请求缓存流程" aria-hidden="true">#</a> 11.4 整体请求缓存流程</h3>\n<p><strong>浏览器第一次请求</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141945261-83532090.png" data="aurora"></p>\n<p><strong>浏览器第二次请求</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="img" originSrc="D:/z_work/72%E6%9C%9F/%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%BC%BA%E8%AF%BE-day02/02-%E7%AC%94%E8%AE%B0/asset/940884-20180423141951735-912699213.png" data="aurora"></p>\n<hr>\n<h1 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp" aria-hidden="true">#</a> TCP</h1>\n<h2 id="tcp的特性" tabindex="-1"><a class="header-anchor" href="#tcp的特性" aria-hidden="true">#</a> TCP的特性</h2>\n<p>主要有以下5点特性：</p>\n<ol>\n<li>\n<p>TCP 提供⼀种⾯向连接的、可靠的字节流服务</p>\n</li>\n<li>\n<p>在⼀个 TCP 连接中，仅有两⽅进⾏彼此通信（⼴播和多播不能⽤于 TCP）</p>\n</li>\n<li>\n<p>TCP 使⽤校验、确认和重传机制来保证可靠传输</p>\n</li>\n<li>\n<p>TCP 将数据分节进⾏排序，并使⽤累积来确认保证数据的顺序不变和⾮重复</p>\n</li>\n<li>\n<p>TCP 使⽤滑动窗⼝机制来实现流量控制，通过动态改变窗⼝的⼤⼩进⾏拥塞控制</p>\n</li>\n</ol>\n<h2 id="简述-tcp-和-udp-的区别" tabindex="-1"><a class="header-anchor" href="#简述-tcp-和-udp-的区别" aria-hidden="true">#</a> 简述 TCP 和 UDP 的区别</h2>\n<table>\n<thead>\n<tr>\n<th>协议</th>\n<th>连接性</th>\n<th>双工性</th>\n<th>可靠性</th>\n<th>有序性</th>\n<th>有界性</th>\n<th>拥塞控制</th>\n<th>传输速度</th>\n<th>量级</th>\n<th>头部大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TCP</td>\n<td>⾯向连接</td>\n<td>全双工 1:1</td>\n<td>可靠，有重传机制</td>\n<td>有序，通过SYN排序</td>\n<td>无边界，有粘包情况</td>\n<td>有</td>\n<td>慢</td>\n<td>低</td>\n<td>20~60字节</td>\n</tr>\n<tr>\n<td>UDP</td>\n<td>无连接</td>\n<td>n:m</td>\n<td>不可靠，丢包后数据丢失</td>\n<td>无序</td>\n<td>有边界，无粘包</td>\n<td>无</td>\n<td>快</td>\n<td>高</td>\n<td>8字节</td>\n</tr>\n</tbody>\n</table>\n<p>UDP socket ⽀持 n 对 m 的连接状态。在 Node.js 官⽅⽂档中有写到在 <code>dgram.createSocket(options[, callback]) </code> 中的 <code>options</code> 中可指定 <code>reuseAddr</code> 为 <code>SO_REUSEADDR</code> 标志，通过它可以简单的实现 n 对 m 的多播特性 (仅在⽀持多播的操作系统上才有用)。</p>\n<h2 id="什么是-tcp-粘包-怎么处理" tabindex="-1"><a class="header-anchor" href="#什么是-tcp-粘包-怎么处理" aria-hidden="true">#</a> 什么是 TCP 粘包，怎么处理？</h2>\n<p>TCP 连接在默认情况下会启⽤延迟传送算法 (Nagle算法)，它在数据发送前进行缓存数据，如短时间内有多个数据发送，会缓冲后再作⼀次发送操作 (缓冲区⼤⼩可⻅ <code>socket.bufferSize</code>)，这样可以减少 IO 产生的消耗，提⾼了性能。</p>\n<p>在传输⽂件的情况下，不⽤处理粘包问题，接收到⼀个包就拼接⼀个包就行了。但是，如果是传输多条消息、或是别的⽤途的数据，那么就需要处理粘包。可参⻅⽹上流传甚⼴的⼀个例⼦：连续调⽤两次 <code>send</code> 分别发送两段数据 data1 和 data2，则在接收端会有以下⼏种常⻅情况出现:</p>\n<ul>\n<li>\n<p>A. 先收到 data1，然后收到 data2</p>\n</li>\n<li>\n<p>B. 先收到 data1 的部分数据，然后收到 data1 余下的部分以及 data2 的全部</p>\n</li>\n<li>\n<p>C. 先收到 data1 的全部数据和 data2 的部分数据，然后收到 data2 的余下的数据</p>\n</li>\n<li>\n<p>D. ⼀次性收到 data1 和 data2 的全部数据</p>\n</li>\n</ul>\n<p>以上情况中的 <code>B、C、D</code> 三种，就是常⻅的粘包情况。而处理粘包问题的常⻅⽅案有：</p>\n<p><strong>方案一：多次发送之前间隔⼀个等待时间</strong></p>\n<p>只需等待⼀段时间再做下⼀次<code>send</code> 发送操作就可以了。</p>\n<ul>\n<li>\n<p>它适⽤于交互频率特别低的场景</p>\n</li>\n<li>\n<p>对于交互频繁的场景来说， 其传输效率太低。</p>\n</li>\n</ul>\n<p><strong>方案二：关闭 Nagle 算法</strong></p>\n<p>在 Node.js 中你可以通过 <code>socket.setNoDelay()</code> ⽅法来关闭 Nagle 算法，让每次 send 都不缓冲而直接发送。</p>\n<ul>\n<li>\n<p>该⽅法适⽤于每次发送的数据都⽐较⼤ (但不是如⽂件那么⼤)， 并且频率不特别⾼的场景</p>\n</li>\n<li>\n<p>如果是每次发送的数据量⽐较⼩且频率特别⾼的话，这种方式纯属⾃废武功</p>\n</li>\n<li>\n<p>该⽅法也不适⽤于⽹络较差的情况，因为 Nagle 算法是在服务端进⾏的包合并情况，但如果短时间内客户端的⽹络</p>\n</li>\n</ul>\n<p>情况不好、或者应⽤层由于某些原因不能及时将 TCP 的数据 <code>recv</code>，就会造成多个包在客户端缓冲从⽽粘包的情况</p>\n<p><strong>方案三：进⾏封包/拆包</strong></p>\n<p>这是⽬前业内最常⻅的解决⽅案，即在发送每个数据包之前，将⼀些有特征的数据放在数据包前/后，然后在收到数据的时</p>\n<p>候，根据特征数据来分割出各个数据包。</p>\n<h2 id="你知道哪些常用的端口号-以及它们对应的服务" tabindex="-1"><a class="header-anchor" href="#你知道哪些常用的端口号-以及它们对应的服务" aria-hidden="true">#</a> 你知道哪些常用的端口号，以及它们对应的服务？</h2>\n<table>\n<thead>\n<tr>\n<th>端口</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>21</td>\n<td>主要⽤于FTP（File Transfer Protocol，⽂件传输协议）服务</td>\n</tr>\n<tr>\n<td>23</td>\n<td>主要⽤于Telnet（远程登录）服务，是Internet上普遍采⽤的登录和仿真程序</td>\n</tr>\n<tr>\n<td>25</td>\n<td>为 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）服务器所开放，主要⽤于发送邮件，如今绝⼤多数邮件服务器都使⽤该协议</td>\n</tr>\n<tr>\n<td>53</td>\n<td>为DNS（Domain Name Server，域名服务器）服务器所开放，主要⽤于域名解析，DNS服务在NT系统中使⽤的最为⼴泛</td>\n</tr>\n<tr>\n<td>67、68</td>\n<td>分别是为 Bootp 服务的 Bootstrap Protocol Server（引导程序协议服务端）和 Bootstrap Protocol Client（引导程序协议客户端）开放的端⼝</td>\n</tr>\n<tr>\n<td>69</td>\n<td>TFTP是Cisco公司开发的⼀个简单⽂件传输协议，类似于FTP</td>\n</tr>\n<tr>\n<td>79</td>\n<td>为Finger服务开放的，主要⽤于查询远程主机在线⽤户、操作系统类型以及是否缓冲区溢出等⽤户的详细信息</td>\n</tr>\n<tr>\n<td>80</td>\n<td>为HTTP（HyperText Transport Protocol，超⽂本传输协议）开放的，这是上⽹冲浪使⽤最多的协议，主要⽤于在WWW（World WideWeb，万维⽹）服务上传输信息的协议</td>\n</tr>\n<tr>\n<td>99</td>\n<td>⽤于⼀个名为“Metagram Relay”（亚对策延时）的服务，该服务⽐较少⻅，⼀般是⽤不到的</td>\n</tr>\n<tr>\n<td>109、110</td>\n<td>为POP2（Post Office Protocol Version 2，邮局协议2）服务开放的，110 端⼝是为 POP3（邮件协议3）服务开放的，POP2、POP3都是主要⽤于接收邮件的</td>\n</tr>\n<tr>\n<td>111</td>\n<td>是SUN公司的 RPC（Remote ProcedureCall，远程过程调⽤）服务所开放的端⼝，主要⽤于分布式系统中不同计算机的内部进程通信，RPC在多种⽹络服务中都是很重要的组件</td>\n</tr>\n<tr>\n<td>113</td>\n<td>主要⽤于Windows的“Authentication Service”（验证服务）</td>\n</tr>\n<tr>\n<td>119</td>\n<td>是为“Network News TransferProtocol”（⽹络新闻组传输协议，简称NNTP）开放的</td>\n</tr>\n<tr>\n<td>135</td>\n<td>主要⽤于使⽤RPC（Remote Procedure Call，远程过程调⽤）协议并提供DCOM（分布式组件对象模型）服务</td>\n</tr>\n<tr>\n<td>137</td>\n<td>主要⽤于“NetBIOS Name Service”（NetBIOS名称服务）</td>\n</tr>\n<tr>\n<td>139</td>\n<td>是为“NetBIOS Session Service”提供的，主要⽤于提供Windows⽂件和打印机共享以及Unix中的Samba服务</td>\n</tr>\n<tr>\n<td>143</td>\n<td>主要是⽤于“Internet Message Access Protocol”v2（Internet消息访问协议，简称IMAP）</td>\n</tr>\n<tr>\n<td>161</td>\n<td>是⽤于“Simple Network Management Protocol”（简单⽹络管理协议，简称SNMP）</td>\n</tr>\n<tr>\n<td>443</td>\n<td>⽹⻚浏览端⼝，主要是⽤于HTTPS服务，是提供加密和通过安全端⼝传输的另⼀种HTTP</td>\n</tr>\n<tr>\n<td>554</td>\n<td>默认情况下⽤于“Real Time Streaming Protocol”（实时流协议，简称RTSP）</td>\n</tr>\n<tr>\n<td>1024</td>\n<td>⼀般不固定分配给某个服务，在英⽂中的解释是“Reserved”（保留）</td>\n</tr>\n<tr>\n<td>1080</td>\n<td>是Socks代理服务使⽤的端⼝，⼤家平时上⽹使⽤的WWW服务使⽤的是HTTP协议的代理服务</td>\n</tr>\n<tr>\n<td>1755</td>\n<td>默认情况下⽤于“Microsoft Media Server”（微软媒体服务器，简称MMS）</td>\n</tr>\n<tr>\n<td>4000</td>\n<td>是⽤于⼤家经常使⽤的QQ聊天⼯具的，再细说就是为QQ客户端开放的端⼝，QQ服务端使⽤的端⼝是8000</td>\n</tr>\n<tr>\n<td>5554</td>\n<td>⼀种针对微软lsass服务的新蠕⾍病毒——震荡波（Worm.Sasser）利⽤TCP 5554端⼝开启⼀个FTP服务，主要被⽤于病毒的传播</td>\n</tr>\n<tr>\n<td>5632</td>\n<td>5632端⼝是被⼤家所熟悉的远程控制软件pcAnywhere所开启的端⼝</td>\n</tr>\n<tr>\n<td>8080</td>\n<td>8080端⼝同80端⼝，是被⽤于WWW代理服务的，可以实现⽹⻚</td>\n</tr>\n</tbody>\n</table>\n<h2 id="一次完整的http服务过程是什么" tabindex="-1"><a class="header-anchor" href="#一次完整的http服务过程是什么" aria-hidden="true">#</a> 一次完整的HTTP服务过程是什么</h2>\n<p>当我们在web浏览器的地址栏中输入：<code>www.baidu.com</code>，具体发生了什么？</p>\n<ol>\n<li>对<code>www.baidu.com</code>这个网址进行DNS域名解析，得到对应的IP地址</li>\n<li>根据这个IP，找到对应的服务器，发起TCP的三次握手 (<a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener noreferrer">tcp 三次握手四次挥手<ExternalLinkIcon/></a> )</li>\n<li>建立TCP连接后发起HTTP请求</li>\n<li>服务器响应HTTP请求，浏览器得到html代码</li>\n<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）</li>\n<li>浏览器对页面进行渲染呈现给用户</li>\n<li>服务器关闭关闭TCP连接</li>\n</ol>\n<p>注：</p>\n<p>1.DNS怎么找到域名的？</p>\n<blockquote>\n<p>DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存-&gt;缓存找不到就去找根域名服务器-&gt;根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器</p>\n</blockquote>\n<p>2.为什么HTTP协议要基于TCP来实现？</p>\n<blockquote>\n<p>TCP是一个端到端的可靠面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）</p>\n</blockquote>\n<p>3.最后一步浏览器是如何对页面进行渲染的？</p>\n<blockquote>\n<p>a）解析html文件构成 DOM树\nb）解析CSS文件构成渲染树\nc）边解析，边渲染\nd）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载</p>\n</blockquote>\n<h2 id="什么是dns-解析" tabindex="-1"><a class="header-anchor" href="#什么是dns-解析" aria-hidden="true">#</a> 什么是DNS 解析</h2>\n<p><strong>DNS解析（域名解析服务器）</strong></p>\n<p>假定请求的是 www.baidu.com</p>\n<p>a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p>\n<p>b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p>\n<p>c）如果还没有找到，那么尝试从 hosts 文件里面去找</p>\n<p>d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找(就近查找)，具体过程如下</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="dns域名解析" originSrc="images/5rxqugj8dh.png" data="aurora"></p>\n<p>DNS优化两个方面：DNS缓存、DNS负载均衡 (准备多台dns服务器, 进行dns解析)</p>\n<h2 id="什么是三次握手" tabindex="-1"><a class="header-anchor" href="#什么是三次握手" aria-hidden="true">#</a> 什么是三次握手？</h2>\n<p>三次握⼿（Three-way Handshake）是指在建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p>\n<p>三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信</p>\n<p>息。在 socket 编程中，客户端调用执行 <code>connect()</code> 时将触发三次握⼿。</p>\n<p>下图为三次握手的示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210219192116213" originSrc="/images/image-20210219192116213.png" data="aurora"></p>\n<p><strong>第⼀次握⼿（SYN=1, seq=x）</strong></p>\n<p>客户端发送⼀个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号（Sequence Number）字段⾥。</p>\n<p>发送完毕后，客户端进⼊ SYN_SEND 状态。</p>\n<p><strong>第⼆次握⼿（SYN=1, ACK=1, seq=y, ACKnum=x+1）</strong></p>\n<p>服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域⾥，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加1，即 X + 1。</p>\n<p>发送完毕后，服务器端进⼊ SYN_RCVD 状态。</p>\n<p><strong>第三次握⼿（ACK=1，ACKnum=y+1）</strong></p>\n<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写 ISN 的 +1。</p>\n<p>发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿结束。</p>\n<h2 id="什么是四次挥手" tabindex="-1"><a class="header-anchor" href="#什么是四次挥手" aria-hidden="true">#</a> 什么是四次挥手？</h2>\n<p>四次挥⼿（Four-way handshake），也叫做改进的三次握⼿，TCP 连接的拆除需要发送四个包，客户端或服务器均可主动发起挥⼿动作，在 socket 编程中，任何⼀⽅执⾏ <code>close()</code> 操作即可产⽣挥⼿操作。</p>\n<p>下图为四次挥手示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210219192659983" originSrc="/images/image-20210219192659983.png" data="aurora"></p>\n<p><strong>第⼀次挥⼿（FIN=1，seq=x）</strong></p>\n<p>假设客户端想要关闭连接，客户端发送⼀个 FIN 标志位置为1的包，表示⾃⼰已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进⼊ FIN_WAIT_1 状态。</p>\n<p><strong>第⼆次挥⼿（ACK=1，ACKnum=x+1）</strong></p>\n<p>服务器端确认客户端的 FIN 包，发送⼀个确认包，表明⾃⼰接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进⼊ CLOSE_WAIT 状态，客户端接收到这个确认包之后，进⼊ FIN_WAIT_2 状态，等待服务器端关闭连接。</p>\n<p><strong>第三次挥⼿（FIN=1，seq=y）</strong></p>\n<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进⼊ LAST_ACK 状态，等待来⾃客户端的最后⼀个ACK。</p>\n<p><strong>第四次挥⼿（ACK=1，ACKnum=y+1）</strong></p>\n<p>客户端接收到来⾃服务器端的关闭请求，发送⼀个确认包，并进⼊ TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进⼊ CLOSED 状态。客户端等待了某个固定时间（两个最⼤段⽣命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是⾃⼰也关闭连接，进⼊ CLOSED 状态。</p>\n<h2 id="tcp-三次握手理解-双方确认" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手理解-双方确认" aria-hidden="true">#</a> TCP 三次握手理解 (双方确认)</h2>\n<p>TCP是一个端到端的  <strong>可靠</strong>  面相连接的协议，</p>\n<p>HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，可以重传）</p>\n<p>根据这个IP，找到对应的服务器，发起TCP的三次握手 (<a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener noreferrer">tcp 三次握手四次挥手<ExternalLinkIcon/></a> )</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201209160422978" originSrc="images/image-20201209160422978.png" data="aurora"></p>\n<p><strong>为什么要3次握手</strong></p>\n<p>我们假定第一次发送的请求,  因为网络延迟很慢才到达服务端，</p>\n<p>然后客户端以为这服务器居然不叼我，然后默默的关闭的等待连接的请求，走开了（好比追女神）；</p>\n<p>但事实呢？女神（服务器）是因为各种各样的原因，很晚才看到，然后说我接受你了, 同意你的要求咱们两结婚吧！</p>\n<p>但是，A早已经远走高飞，这个请求A完全不会收到（在第二次握手，服务端打开连接，等待客户端的响应），</p>\n<p>那么女生呢，以为对方收到了，就会一直等待，这样B的资源就会被浪费的（创建连接的时候，空间浪费以及端口消耗）；</p>\n<p>而三次握手, 就不会发生，服务端同意连接了，但是A缺一直没有下一步的动作，导致资源浪费；</p>\n<h2 id="关闭tcp连接四次挥手的理解-客气挽留" tabindex="-1"><a class="header-anchor" href="#关闭tcp连接四次挥手的理解-客气挽留" aria-hidden="true">#</a> 关闭TCP连接四次挥手的理解 (客气挽留)</h2>\n<p>关闭连接(四次挥手)</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201209162908979" originSrc="images/image-20201209162908979.png" data="aurora"></p>\n<p>这和有礼貌的好友道别一样：（a：客户端 b:服务端）\n1、一开始A想要回家离开，但是呢？怕B还有事情要交代，那么呢？只好先想B打招呼，我要走了，请求停止交谈（此时，a到B的连接没有断开，依旧可以进行通信）；\n2、同意A的请求，说好的，但是我这里可能还有一些话（数据）没说完。我检查看看,  你等等,  等我说完你再走。\n3、B确实没啥要补充的了，就告知你我可以散伙了\n4、A说好的，知道了，88；（B得知A走开了，关闭了自己的连接 )</p>\n<h2 id="浏览器解析响应" tabindex="-1"><a class="header-anchor" href="#浏览器解析响应" aria-hidden="true">#</a> 浏览器解析响应</h2>\n<p><strong>浏览器解析html代码，并请求html代码中的资源</strong></p>\n<p><strong>浏览器对页面进行渲染呈现给用户</strong></p>\n<p>最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。</p>\n<p>首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>\n<p>DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repaint。</p>\n<p><strong>页面在首次加载时必然会经历reflow和repaint。</strong></p>\n<p>reflow过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。</p>\n<p>所以我们应该尽可能少的减少 reflow (重新布局) 。  例如: transform 变换, 只会触发重绘, 不会触发重排 (效率非常高)</p>\n<p>...</p>\n<p>页面首次渲染, 必然会进行一次 reflow 和 一次 repaint</p>\n<ol>\n<li>reflow: 重排 (布局相关的)</li>\n<li>repaint: 重绘(绘制, 颜色, 字体, .... 跟结构无关的)</li>\n</ol>\n<p><strong>完整的一次 http 请求流程才算结束</strong></p>\n<hr>\n<h1 id="dom" tabindex="-1"><a class="header-anchor" href="#dom" aria-hidden="true">#</a> DOM</h1>\n<h2 id="dom的事件模型是什么" tabindex="-1"><a class="header-anchor" href="#dom的事件模型是什么" aria-hidden="true">#</a> DOM的事件模型是什么？</h2>\n<p>DOM的事件模型(注册事件的方式)分为：</p>\n<ul>\n<li>脚本模型</li>\n<li>内联模型（同类一个，后者覆盖前者）</li>\n<li>动态绑定（同类可多个）</li>\n</ul>\n<p><strong>脚本模型</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 脚本模型：⾏内绑定 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token literal-property property">javascrpt</span><span class="token operator">:</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">\'Hello\'</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Hello1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>内联模型</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 内联模型：同⼀个元素的同类事件只能添加⼀个，如果添加多个则后添加的会覆盖之前添加的 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Hello2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>动态绑定</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token comment">&lt;!-- 动态绑定 --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n  <span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">/* 1. 这种方式只能给同一个元素添加一个事件 */</span>\n  btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>\n\n  <span class="token comment">/* 2. 这种方式可以给同⼀个元素添加多个同类事件 */</span>\n  btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"hello2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="dom的事件流是什么" tabindex="-1"><a class="header-anchor" href="#dom的事件流是什么" aria-hidden="true">#</a> DOM的事件流是什么？</h2>\n<p><strong>事件</strong></p>\n<p>事件是HTML⽂档或浏览器窗⼝中发⽣的⼀些特定的交互瞬间。</p>\n<p><strong>事件流</strong></p>\n<p>⼜称为事件传播，是⻚⾯中接收事件的顺序。DOM2级事件规定的事件流包括了3个阶段：</p>\n<ul>\n<li>事件捕获阶段（capture phase）</li>\n<li>处于⽬标阶段（target phase）</li>\n<li>事件冒泡阶段（bubbling phase）</li>\n</ul>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210219222213633" originSrc="/images/image-20210219222213633.png" data="aurora"></p>\n<p>如上图所示，事件流的触发顺序是：</p>\n<ol>\n<li>事件捕获阶段，为截获事件提供了机会</li>\n<li>实际的⽬标元素接收到事件</li>\n<li>事件冒泡阶段，可在这个阶段对事件做出响应</li>\n</ol>\n<p><strong>事件冒泡（Event Bubbling）</strong></p>\n<p>事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。</p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span> \n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span> \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span> \n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span> \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span> \n  \n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果点击了上面页面代码中的 <code>&lt;button&gt;</code> 按钮，那么该 <code>click</code> 点击事件会沿着 DOM 树向上逐级传播，在途经的每个节点上都会发生，具体顺序如下：</p>\n<ol>\n<li>button 元素</li>\n<li>body 元素</li>\n<li>html 元素</li>\n<li>document 对象</li>\n</ol>\n<p><strong>事件捕获（Event Capturing）</strong></p>\n<p>事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。</p>\n<p>事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。</p>\n<p>如果仍以上面那段 HTML 代码为例，当点击按钮后，在事件捕获的过程中，document 对象会首先接收到这个 <code>click</code> 事件，然后再沿着 DOM 树依次向下，直到 <code>&lt;button&gt;</code>。具体顺序如下：</p>\n<ol>\n<li>document 对象</li>\n<li>html 元素</li>\n<li>body 元素</li>\n<li>button 元素</li>\n</ol>\n<h2 id="说说什么是事件委托" tabindex="-1"><a class="header-anchor" href="#说说什么是事件委托" aria-hidden="true">#</a> 说说什么是事件委托？</h2>\n<p>事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子孙元素上的某一类的所有事件。</p>\n<p><strong>示例</strong></p>\n<div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">\n    <span class="token comment">// ⽗元素 </span>\n    <span class="token keyword">var</span> list <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">\'list\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// 为⽗元素绑定事件，委托管理它的所有⼦元素的点击事件 </span>\n    list<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">var</span> currentTarget <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">;</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTarget<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">\'li\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">alert</span><span class="token punctuation">(</span>currentTarget<span class="token punctuation">.</span>innerText<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><blockquote>\n<p>适用场景：在绑定大量事件的时候，可以选择事件委托</p>\n</blockquote>\n<p><strong>优点</strong></p>\n<ul>\n<li>事件委托可以减少事件注册数量，节省内存占⽤!</li>\n<li>当新增⼦元素时，⽆需再次做事件绑定，因此非常适合动态添加元素</li>\n</ul>\n<hr>\n<h1 id="浏览器与新技术" tabindex="-1"><a class="header-anchor" href="#浏览器与新技术" aria-hidden="true">#</a> 浏览器与新技术</h1>\n<h2 id="常见的浏览器内核有哪些" tabindex="-1"><a class="header-anchor" href="#常见的浏览器内核有哪些" aria-hidden="true">#</a> 常见的浏览器内核有哪些？</h2>\n<p>浏览器的内核，通常指的是渲染引擎，但现在JS引擎也成为浏览器的重要部分，所以下表展示了当前一些比较流行的常规浏览器、无头浏览器、以及JS运行时所含的渲染引擎和JS引擎：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">浏览器/运行时</th>\n<th style="text-align:center">内核（即渲染引擎）</th>\n<th style="text-align:center">JS引擎</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">Chrome</td>\n<td style="text-align:center">Webkit (Chrome 27) / Blink (Chrome 28+)</td>\n<td style="text-align:center">V8</td>\n</tr>\n<tr>\n<td style="text-align:center">FireFox</td>\n<td style="text-align:center">Gecko</td>\n<td style="text-align:center">SpiderMonkey</td>\n</tr>\n<tr>\n<td style="text-align:center">Safari</td>\n<td style="text-align:center">Webkit</td>\n<td style="text-align:center">JavaScriptCore</td>\n</tr>\n<tr>\n<td style="text-align:center">Edge</td>\n<td style="text-align:center">EdgeHTML</td>\n<td style="text-align:center">Chakra (for JavaScript)</td>\n</tr>\n<tr>\n<td style="text-align:center">IE</td>\n<td style="text-align:center">Trident</td>\n<td style="text-align:center">Chakra (for JScript)</td>\n</tr>\n<tr>\n<td style="text-align:center">PhantomJS (无头浏览器)</td>\n<td style="text-align:center">Webkit</td>\n<td style="text-align:center">JavaScriptCore</td>\n</tr>\n<tr>\n<td style="text-align:center">Puppeteer (无头浏览器)</td>\n<td style="text-align:center">Webkit (Chrome 27) / Blink (Chrome 28+)</td>\n<td style="text-align:center">V8</td>\n</tr>\n<tr>\n<td style="text-align:center">Node.js</td>\n<td style="text-align:center">无</td>\n<td style="text-align:center">V8</td>\n</tr>\n</tbody>\n</table>\n<h2 id="浏览器是如何进行界面渲染的" tabindex="-1"><a class="header-anchor" href="#浏览器是如何进行界面渲染的" aria-hidden="true">#</a> 浏览器是如何进行界面渲染的？</h2>\n<p>不同的渲染引擎的具体做法稍有差异，但是大体流程都是差不多的，下面以 webkit 的渲染流程来说明：</p>\n<img src="/images/image-20210220214851409.png" alt="image-20210220214851409" style="zoom:45%;" />\n<p>上图展示的流程是：</p>\n<ol>\n<li>\n<p>获取 HTML ⽂件并进⾏解析，生成一棵 DOM 树（DOM Tree）</p>\n</li>\n<li>\n<p>解析 HTML 的同时也会解析 CSS，⽣成样式规则（Style Rules）</p>\n</li>\n<li>\n<p>根据 DOM 树和样式规则，生成一棵渲染树（Render Tree）</p>\n</li>\n<li>\n<p>进行布局（Layout），即为每个节点分配⼀个在屏幕上应显示的确切坐标位置</p>\n</li>\n<li>\n<p>进⾏绘制（Paint），遍历渲染树节点，调⽤ GPU 将元素呈现出来</p>\n</li>\n</ol>\n<h2 id="浏览器是如何解析css选择器的" tabindex="-1"><a class="header-anchor" href="#浏览器是如何解析css选择器的" aria-hidden="true">#</a> 浏览器是如何解析CSS选择器的？</h2>\n<p>在生成渲染树的过程中，渲染引擎会根据选择器提供的信息来遍历 DOM 树，找到对应的 DOM 节点后将样式规则附加到上面。</p>\n<p>来看一段样式选择器代码、以及一段要应用样式的 HTML：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">.mod-nav h3 span</span> <span class="token punctuation">{</span>\n\t<span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-html ext-html line-numbers-mode"><pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mod-nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span>\n  \n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>项目一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>项目一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>项目一<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>渲染引擎是怎么根据以上样式选择器去遍历这个 DOM 树的呢？是按照从左往右的选择器顺序去匹配，还是从右往左呢？</p>\n<p>为了更直观的观查，我们先将这棵 DOM 树先绘制成图：</p>\n<img src="/images/image-20210220222103787.png" alt="image-20210220222103787" style="zoom:30%;" />\n<p>然后我们来对比一下两种顺序的匹配：</p>\n<p><strong>从左往右：<code>.mod-nav &gt; h3 &gt; span</code></strong></p>\n<ol>\n<li>从 <code>.mod-nav</code> 开始遍历⼦节点 <code>header</code>、<code>div</code></li>\n<li>然后向各⾃的⼦节点遍历</li>\n<li>在右侧 <code>div</code> 的分⽀中，当遍历到叶节点 <code>a</code> 后，发现不符合规则。则重新回溯到 <code>ul</code> 节点，再遍历下⼀个 <code>li</code> - <code>a</code></li>\n</ol>\n<p><strong>从右往左：<code>span &gt; h3 &gt; .mod-nav</code></strong></p>\n<ol>\n<li>\n<p>先找到所有的 <code>span</code> 节点 ，然后基于每⼀个 <code>span</code> 再向上查找 <code>h3</code></p>\n</li>\n<li>\n<p>由 <code>h3</code> 再向上查找 <code>.mod-nav</code> 的节点</p>\n</li>\n<li>\n<p>最后触及根元素 <code>html</code> 结束该分⽀遍历</p>\n</li>\n</ol>\n<p>可以看到，从右向左的匹配规则可以在第⼀步时就筛选掉⼤量不符合条件的叶节点；⽽从左向右的匹配规则需要消耗大量时间在失败的查找上，这在真实页面中⼀棵 DOM 树的节点成百上千的情况下，这种遍历方式的效率会非常的低，根本不适合采用。</p>\n<p>因此，浏览器遵循 “从右往左” 的规则来解析 CSS 选择器！</p>\n<h2 id="dom树是如何构建的" tabindex="-1"><a class="header-anchor" href="#dom树是如何构建的" aria-hidden="true">#</a> DOM树是如何构建的？</h2>\n<p>构建的过程如下：</p>\n<ol>\n<li>\n<p>浏览器将接收到的⼆进制数据，按指定编码格式转换为 HTML 字符串</p>\n</li>\n<li>\n<p>开始解析，将 HTML 字符串解析成 Tokens</p>\n</li>\n<li>\n<p>构建节点，对节点添加特定的属性，并通过指针确定节点的⽗、⼦、兄弟关系、以及所属 treeScope</p>\n</li>\n<li>\n<p>通过已确定的节点⽗、⼦、兄弟关系，构建出 DOM 树</p>\n</li>\n</ol>\n<p>下图为以上描述过程的图示：</p>\n<img src="/images/image-20210220230003937.png" alt="image-20210220230003937" style="zoom:50%;" />\n<h2 id="浏览器重绘与重排的区别是什么" tabindex="-1"><a class="header-anchor" href="#浏览器重绘与重排的区别是什么" aria-hidden="true">#</a> 浏览器重绘与重排的区别是什么？</h2>\n<p><strong>重排</strong></p>\n<p>重排是指部分或整个渲染树需要重新分析，并且节点的尺⼨需要重新计算。</p>\n<p>表现为重新⽣成布局，重新排列元素。</p>\n<p><strong>重绘</strong></p>\n<p>重绘是由于节点的⼏何属性发⽣改变，或由于样式发⽣改变（例如：改变元素背景⾊）。</p>\n<p>表现为某些元素的外观被改变。</p>\n<p><strong>两者的关系</strong></p>\n<blockquote>\n<p>重绘不⼀定会出现重排，重排必定会出现重绘。</p>\n</blockquote>\n<p>只改变元素的外观不会引发⽹⻚重排；但若浏览器进行重排后，将会重绘受此次重排影响的部分。</p>\n<p>重排和重绘的代价都很⾼昂，破坏⽤户体验、让界面显示变迟缓。</p>\n<p>但相⽐之下，重排的性能影响会更⼤，在⽆法避免的情况下，⼀般宁可选择代价较⼩的重绘。</p>\n<h2 id="如何触发重排和重绘" tabindex="-1"><a class="header-anchor" href="#如何触发重排和重绘" aria-hidden="true">#</a> 如何触发重排和重绘？</h2>\n<p>改变任意的⽤于构建渲染树的信息，都会引发⼀次重排或重绘。比如：</p>\n<ul>\n<li>\n<p>添加、删除、更新 DOM 节点</p>\n</li>\n<li>\n<p>通过 <code>display: none</code> 隐藏 DOM 节点（同时会触发重排和重绘）</p>\n</li>\n<li>\n<p>通过 <code>visibility: hidden</code> 隐藏 DOM节点（只会触发重绘，因为没有⼏何变化 ）</p>\n</li>\n<li>\n<p>移动 DOM 节点，或是给⻚⾯中的 DOM 节点添加动画</p>\n</li>\n<li>\n<p>添加⼀个样式表，调整样式属性</p>\n</li>\n<li>\n<p>⽤户⾏为，例如：调整浏览器窗⼝的⼤⼩，改变字号，或者滚动页面</p>\n</li>\n</ul>\n<h2 id="如何避免重排或重绘" tabindex="-1"><a class="header-anchor" href="#如何避免重排或重绘" aria-hidden="true">#</a> 如何避免重排或重绘？</h2>\n<p>主要有三大方式来避免：</p>\n<ul>\n<li>集中修改样式</li>\n<li>使用文档碎片（DocumentFragment）</li>\n<li>将元素提升为合成层</li>\n</ul>\n<p><strong>集中修改样式</strong></p>\n<p>通常以改 class 的⽅式，实现样式的集中修改。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">\'className\'</span><span class="token punctuation">,</span> isDark <span class="token operator">?</span> <span class="token string">\'dark\'</span> <span class="token operator">:</span> <span class="token string">\'light\'</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>使用文档碎片</strong></p>\n<p>通过 <code>document.createDocumentFragment</code> 可创建⼀个游离于 DOM 树外的节点，在该节点上做批量操作后再将它插⼊ DOM 树中，只会引发⼀次重排。</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 创建碎片节点</span>\n<span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 多次操作碎片节点</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token keyword">const</span> node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span>\n  node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> i\n  fragment<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 一次性添加到 DOM 树中</span>\ndocument<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>fragment<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>将元素提升为合成层</strong></p>\n<p>将元素提升为合成层的最好⽅式是使⽤ CSS 的 <code>will-change</code> 属性：</p>\n<div class="language-css ext-css line-numbers-mode"><pre v-pre class="language-css"><code><span class="token selector">#target</span> <span class="token punctuation">{</span>\n  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>提升为合成层有下列几个优点：</p>\n<ul>\n<li>\n<p>合成层的位图会由 GPU 合成，⽐由 CPU 处理更快</p>\n</li>\n<li>\n<p>当需要重绘时只重绘本身，不影响其他层</p>\n</li>\n<li>\n<p><code>transform</code> 和 <code>opacity</code> 不会触发重排和重绘</p>\n</li>\n</ul>\n<h2 id="前端如何实现即时通讯" tabindex="-1"><a class="header-anchor" href="#前端如何实现即时通讯" aria-hidden="true">#</a> 前端如何实现即时通讯？</h2>\n<p>基于Web的前端，存在以下几种可实现即时通讯的方式：</p>\n<ul>\n<li>短轮询</li>\n<li>Comet</li>\n<li>SSE</li>\n<li>WebSocket</li>\n</ul>\n<p><strong>短轮询</strong></p>\n<p>短轮询就是客户端定时发送请求，获取服务器上的最新数据。不是真正的即时通讯，但一定程度上可以模拟即时通讯的效果。</p>\n<p>优缺点：</p>\n<ul>\n<li>优点：浏览器兼容性好，实现简单</li>\n<li>缺点：实时性不高，资源消耗高，存在较多无用请求，影响性能</li>\n</ul>\n<p><strong>Comet</strong></p>\n<p>有两种实现 Comet 的方式：</p>\n<ol>\n<li>使用 Ajax 长轮询（long-polling）</li>\n<li>使用 HTTP 长连接（基于 iframe 和 htmlfile 的流）</li>\n</ol>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：浏览器兼容性好，即时性好，不存在⽆⽤请求</p>\n</li>\n<li>\n<p>缺点：服务器压力较大（维护⻓连接会消耗较多服务器资源）</p>\n</li>\n</ul>\n<p><a href="http://www.52im.net/thread-334-1-1.html" target="_blank" rel="noopener noreferrer">参考文章：Comet技术详解<ExternalLinkIcon/></a></p>\n<p><strong>SSE</strong></p>\n<p>服务端推送事件（Server-Sent Event），它是⼀种允许服务端向客户端推送新数据的 HTML5 技术。</p>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：基于 HTTP，无需太多改造就能使⽤；相比 WebSocket 要简单方便很多</p>\n</li>\n<li>\n<p>缺点：基于⽂本传输，效率没有 WebSocket ⾼；不是严格的双向通信，客户端⽆法复⽤连接来向服务端发送请求，</p>\n<p>而是每次都需重新创建新请求</p>\n</li>\n</ul>\n<p><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener noreferrer">参考文章：SSE教程<ExternalLinkIcon/></a></p>\n<p><strong>WebSocket</strong></p>\n<p>这是基于 TCP 协议的全新、独⽴的协议，作⽤是在服务器和客户端之间建⽴实时的双向通信。</p>\n<p>WebSocket 协议与 HTTP 协议保持兼容，但它不会融⼊ HTTP 协议，仅作为 HTML 5 的⼀部分。</p>\n<p>优缺点：</p>\n<ul>\n<li>\n<p>优点：真正意义上的双向实时通信，性能好、延迟低</p>\n</li>\n<li>\n<p>缺点：由于是独⽴于 HTTP 的协议，因此要使用的话需要对项⽬作改造；使⽤复杂度较⾼，通常需要引⼊成熟的库；并且⽆法兼容低版本的浏览器</p>\n</li>\n</ul>\n<p>HTTP 和 WebSocket 的连接通信比较图：</p>\n<img src="/images/image-20210221101152845.png" alt="image-20210221101152845" style="zoom:30%;" />\n<h2 id="什么是浏览器的同源策略" tabindex="-1"><a class="header-anchor" href="#什么是浏览器的同源策略" aria-hidden="true">#</a> 什么是浏览器的同源策略？</h2>\n<p>首先，同源是指资源地址的 &quot;协议 + 域名 + 端⼝&quot; 三者都相同，即使两个不同域名指向了同⼀ IP 地址，也被判断为⾮同源。</p>\n<p>下面是一些地址的同源判断示例：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210221103114013" originSrc="/images/image-20210221103114013.png" data="aurora"></p>\n<p>了解了什么是同源，再来说同源策略。</p>\n<blockquote>\n<p>同源策略是一种⽤于隔离潜在恶意⽂件的重要安全保护机制，它用于限制从⼀个源加载的⽂档或脚本与来⾃另⼀个源的资源进⾏交互。</p>\n</blockquote>\n<p>在浏览器中，⼤部分内容都受同源策略限制，除了以下三个标签：</p>\n<ul>\n<li><code>&lt;img&gt;</code></li>\n<li><code>&lt;link&gt;</code></li>\n<li><code>script</code></li>\n</ul>\n<h2 id="如何实现跨域" tabindex="-1"><a class="header-anchor" href="#如何实现跨域" aria-hidden="true">#</a> 如何实现跨域？</h2>\n<p>历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：</p>\n<ul>\n<li>JSONP</li>\n<li>CORS</li>\n<li>服务器代理(webpack代理, Nginx反向代理)</li>\n</ul>\n<p><strong>JSONP</strong></p>\n<p>这是一种非常经典的跨域方案，它利用了<code>&lt;script&gt;</code> 标签不受同源策略的限制的特性，实现跨域效果。</p>\n<p>优点：</p>\n<ul>\n<li>实现简单</li>\n<li>兼容性好</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>只支持 GET 请求 （因为 <code>&lt;script&gt;</code> 标签只能发送 GET 请求）</li>\n<li>存在被 XSS 攻击的可能，缺乏安全性保证</li>\n<li>需要服务端配合改造</li>\n</ul>\n<p>实现示例：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 1. JSONP 发送请求的函数封装</span>\n<span class="token keyword">function</span> <span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackKey<span class="token punctuation">,</span> callback <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 在参数中指定 callback 名字 </span>\n  params <span class="token operator">=</span> params <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> params<span class="token punctuation">[</span>callbackKey<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">\'jsonpCallback\'</span>\n  \n  <span class="token comment">// 预留 callback </span>\n  window<span class="token punctuation">.</span>jsonpCallback <span class="token operator">=</span> callback \n  \n  <span class="token comment">// 拼接参数字符串</span>\n  <span class="token keyword">const</span> queryString <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=></span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">\'&amp;\'</span><span class="token punctuation">)</span>\n  \n  <span class="token comment">// 创建 script 标签</span>\n  <span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'script\'</span><span class="token punctuation">)</span> \n  script<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">\'src\'</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>queryString<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> \n  \n  <span class="token comment">// 插⼊ DOM 树</span>\n  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 调用示例</span>\n<span class="token constant">JSONP</span><span class="token punctuation">(</span><span class="token punctuation">{</span> \n  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">\'http://s.weibo.com/ajax/jsonp/suggestion\'</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  \t<span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token string">\'test\'</span>\n\t<span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">callbackKey</span><span class="token operator">:</span> <span class="token string">\'_cb\'</span><span class="token punctuation">,</span>\n  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span> \n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p><strong>CORS</strong></p>\n<p>跨域资源共享（CORS），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 HTTP 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。</p>\n<p>当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 HTTP 请求。</p>\n<p>如果你⽤的是 Node.js 的 Express 框架，则可以这样来进行设置：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 创建一个 CORS 中间件 </span>\n<span class="token keyword">function</span> <span class="token function">allowCrossDomain</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">\'Access-Control-Allow-Origin\'</span><span class="token punctuation">,</span> <span class="token string">\'http://example.com\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">\'Access-Control-Allow-Methods\'</span><span class="token punctuation">,</span> <span class="token string">\'GET,PUT,POST,DELETE\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">\'Access-Control-Allow-Headers\'</span><span class="token punctuation">,</span> <span class="token string">\'Content-Type\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token comment">//...</span>\n\napp<span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// ...</span>\n  \n  <span class="token comment">// 为 Express 配置 CORS 中间件</span>\n  app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>allowCrossDomain<span class="token punctuation">)</span><span class="token punctuation">;</span> \n  \n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在实际项目中，建议使用一些已经比较成熟的开源中间件。</p>\n<p><strong>Nginx反向代理</strong></p>\n<p>这是目前最方便，最推荐使用的跨域解决方案。Nginx 本身是⼀款极其强⼤的 Web 服务器，轻量级、启动快、⾼并发。</p>\n<p>现在的后端服务程序，通常会使用 Nginx 进行反向代理：</p>\n<img src="/images/image-20210221111025585.png" alt="image-20210221111025585" style="zoom:33%;" />\n<p>反向代理的原理其实很简单：</p>\n<blockquote>\n<p>Nginx 作为代理服务器，所有客户端的请求都必须先经过 Nginx 的处理，然后再将请求转发给其他后端程序（比如 Node.js 或Java 程序），这样就规避同源策略的影响</p>\n</blockquote>\n<p>下面是一个配置 Nginx 反向代理的示例配置文件：</p>\n<div class="language-nginx ext-nginx line-numbers-mode"><pre v-pre class="language-nginx"><code><span class="token comment"># 进程, 可更具 cpu 数量调整</span>\n<span class="token directive"><span class="token keyword">worker_processes</span> <span class="token number">1</span></span><span class="token punctuation">;</span> \n\n<span class="token directive"><span class="token keyword">events</span></span> <span class="token punctuation">{</span> \n  <span class="token comment"># 连接数 </span>\n  <span class="token directive"><span class="token keyword">worker_connections</span> <span class="token number">1024</span></span><span class="token punctuation">;</span> \n<span class="token punctuation">}</span>\n\n<span class="token directive"><span class="token keyword">http</span></span> <span class="token punctuation">{</span>\n  <span class="token directive"><span class="token keyword">include</span> mime.types</span><span class="token punctuation">;</span> \n  <span class="token directive"><span class="token keyword">default_type</span> application/octet-stream</span><span class="token punctuation">;</span>\n  \n  <span class="token directive"><span class="token keyword">sendfile</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>\n  \n  <span class="token comment">#连接超时时间，服务器会在这个时间过后关闭连接。 </span>\n  <span class="token directive"><span class="token keyword">keepalive_timeout</span> <span class="token number">10</span></span><span class="token punctuation">;</span>\n  \n  <span class="token comment"># 开启 Gzip 压缩</span>\n  <span class="token directive"><span class="token keyword">gzip</span> <span class="token boolean">on</span></span><span class="token punctuation">;</span>\n  \n  <span class="token comment"># 直接请求nginx也是会报跨域错误的这⾥设置允许跨域 </span>\n  <span class="token comment"># 如果代理地址已经允许跨域则不需要这些, 否则报错(虽然这样nginx跨域就没意义了) </span>\n  <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Origin *</span><span class="token punctuation">;</span> \n  <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Headers X-Requested-With</span><span class="token punctuation">;</span> \n  <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Methods GET,POST,OPTIONS</span><span class="token punctuation">;</span>\n  \n  <span class="token comment"># srever模块配置是http模块中的⼀个⼦模块，⽤来定义⼀个虚拟访问主机</span>\n  <span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span> \n    <span class="token directive"><span class="token keyword">listen</span> <span class="token number">80</span></span><span class="token punctuation">;</span> \n    <span class="token directive"><span class="token keyword">server_name</span> localhost</span><span class="token punctuation">;</span> \n    \n    <span class="token comment"># 根路径指到index.html </span>\n    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span> \n      <span class="token directive"><span class="token keyword">root</span> html</span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">index</span> index.html index.htm</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span>\n    \n    <span class="token comment"># 请求转发：</span>\n    <span class="token comment"># 例如 http://localhost/api 的请求会被转发到 http://192.168.0.103:8080</span>\n    <span class="token directive"><span class="token keyword">location</span> /api</span> <span class="token punctuation">{</span>\n      <span class="token directive"><span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span></span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Real-IP <span class="token variable">$remote_addr</span></span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">proxy_set_header</span> X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span></span><span class="token punctuation">;</span> \n      <span class="token directive"><span class="token keyword">proxy_pass</span> http://192.168.0.103:8080</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span>\n    \n    <span class="token comment"># 重定向错误⻚⾯到/50x.html </span>\n    <span class="token directive"><span class="token keyword">error_page</span> <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span> /50x.html</span><span class="token punctuation">;</span> \n    \n    <span class="token directive"><span class="token keyword">location</span> = /50x.html</span> <span class="token punctuation">{</span> \n      <span class="token directive"><span class="token keyword">root</span> html</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span> \n  <span class="token punctuation">}</span> \n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><p><a href="https://juejin.cn/post/6844903767226351623#heading-19" target="_blank" rel="noopener noreferrer">参考文章：跨域方式实现原理<ExternalLinkIcon/></a></p>\n<h1 id="前端工程化" tabindex="-1"><a class="header-anchor" href="#前端工程化" aria-hidden="true">#</a> 前端工程化</h1>\n<h2 id="babel的原理是什么" tabindex="-1"><a class="header-anchor" href="#babel的原理是什么" aria-hidden="true">#</a> Babel的原理是什么？</h2>\n<p>Babel 的主要工作是对代码进行转译。</p>\n<p>转译分为三阶段：</p>\n<ul>\n<li>\n<p>解析（Parse），将代码解析⽣成抽象语法树 AST，也就是词法分析与语法分析的过程</p>\n</li>\n<li>\n<p>转换（Transform），对 AST 进⾏变换方面的⼀系列操作。通过 babel-traverse，对 AST 进⾏遍历并作添加、更新、删除等操作</p>\n</li>\n<li>\n<p>⽣成（Generate），通过 babel-generator 将变换后的 AST 转换为 JS 代码</p>\n</li>\n</ul>\n<p>转译流程示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210221114506275" originSrc="/images/image-20210221114506275.png" data="aurora"></p>\n<h2 id="如何编写一个babel插件" tabindex="-1"><a class="header-anchor" href="#如何编写一个babel插件" aria-hidden="true">#</a> 如何编写一个Babel插件？</h2>\n<p>Babel 插件的主要工作阶段是在 Babel 将代码解析成 AST 之后，插件们对 AST 进行各种操作后，再由 Babel 输出最终的代码。</p>\n<p>要编写一个 Babel 插件模块，则需要为模块代码导出一个函数，且该函数返回一个对象，对象内应包含有 <code>visitor</code> 属性：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code>module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">babel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">visitor</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>visitor</code> 是针对各类 AST 节点作处理的地⽅。我们可以通过 <code>console.log</code> 打印或 <a href="https://astexplorer.net/" target="_blank" rel="noopener noreferrer">AST Explorer 工具<ExternalLinkIcon/></a> 来查看 Babel 具体生成的 AST 节点。</p>\n<p><strong>示例</strong></p>\n<p>我们来编写一个插件，其功能是能自动将源码中的数字字面量数学运算进行预计算处理，简化代码。例如：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 原来的代码</span>\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>\n\n<span class="token comment">// 处理后的代码</span>\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token number">3</span>    <span class="token comment">// 这样优化以后，在实际运行时可以减少一次加法操作</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们可以先通过 AST Explorer 来获取 JSON 格式的 AST 结构：</p>\n<div class="language-json ext-json line-numbers-mode"><pre v-pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>\n  <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n  <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n  <span class="token property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>\n      <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n      <span class="token property">"declarations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>\n          <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>\n          <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n          <span class="token property">"id"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>\n            <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>\n            <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>\n            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"result"</span>\n          <span class="token punctuation">}</span><span class="token punctuation">,</span>\n          <span class="token property">"init"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"BinaryExpression"</span><span class="token punctuation">,</span>\n            <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">15</span><span class="token punctuation">,</span>\n            <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n            <span class="token property">"left"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>\n              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">15</span><span class="token punctuation">,</span>\n              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>\n              <span class="token property">"value"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n              <span class="token property">"raw"</span><span class="token operator">:</span> <span class="token string">"1"</span>\n            <span class="token punctuation">}</span><span class="token punctuation">,</span>\n            <span class="token property">"operator"</span><span class="token operator">:</span> <span class="token string">"+"</span><span class="token punctuation">,</span>\n            <span class="token property">"right"</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n              <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>\n              <span class="token property">"start"</span><span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">,</span>\n              <span class="token property">"end"</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>\n              <span class="token property">"value"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>\n              <span class="token property">"raw"</span><span class="token operator">:</span> <span class="token string">"2"</span>\n            <span class="token punctuation">}</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">]</span><span class="token punctuation">,</span>\n      <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"const"</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token property">"sourceType"</span><span class="token operator">:</span> <span class="token string">"module"</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>从以上 AST 结构可以知道，<code>1 + 2</code> 是一个 <code>BinaryExpression</code> 类型的节点，那么在我们编写的插件代码中的 <code>visitor</code> 里就可以这样进行处理：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> babel <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'babel-core\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'babel-types\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n\n<span class="token keyword">var</span> visitor <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">BinaryExpression</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n    <span class="token keyword">const</span> node <span class="token operator">=</span> path<span class="token punctuation">.</span>node<span class="token punctuation">;</span>\n\n    <span class="token keyword">let</span> result<span class="token punctuation">;</span>\n\n    <span class="token comment">// 判断表达式两边，是否都是数字 </span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isNumericLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span><span class="token function">isNumericLiteral</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token comment">// 根据不同的操作符作运算 </span>\n      <span class="token keyword">switch</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>operator<span class="token punctuation">)</span> <span class="token punctuation">{</span> \n        <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">+</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">-</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span> \n        <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">*</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span> \n          result <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value <span class="token operator">/</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">break</span><span class="token punctuation">;</span> \n        <span class="token keyword">case</span> <span class="token string">"**"</span><span class="token operator">:</span> \n          <span class="token keyword">let</span> i <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> \n            result <span class="token operator">=</span> result <span class="token operator">||</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n            result <span class="token operator">=</span> result <span class="token operator">*</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>value<span class="token punctuation">;</span> \n          <span class="token punctuation">}</span>\n          <span class="token keyword">break</span><span class="token punctuation">;</span> \n        <span class="token keyword">default</span><span class="token operator">:</span> \n      <span class="token punctuation">}</span> \n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// 如果上⾯的运算有结果的话 </span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n      <span class="token comment">// 把表达式节点替换成number字⾯量 </span>\n      path<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">numericLiteral</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n    <span class="token punctuation">}</span> \n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">babel</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token keyword">return</span> <span class="token punctuation">{</span> visitor <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>      \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>这个插件的基本功能就完成了，来运行试试：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token keyword">const</span> babel <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"babel-core"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> result <span class="token operator">=</span> babel<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token string">"const result = 1 + 2;"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> \n  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span> \n    <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./index"</span><span class="token punctuation">)</span> \n  <span class="token punctuation">]</span> \n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>\t<span class="token comment">// 结果：const result = 3;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>转换结果符合预期。</p>\n<p>不过这个插件还不能完全正确的工作，在转换如 <code>const result = 1 + 2 + 3 + 4 + 5;</code> 这样的代码时，结果为 <code>const result = 3 + 3 + 4 + 5;</code>，也就是只转换了代码中的第一段表达式计算。</p>\n<p>如果用 AST Explorer 查看 AST 结构的话，会发现原来这个运算由层层嵌套的 <code>BinaryExpression</code> 组成：</p>\n<blockquote>\n<p>BinaryExpression(  BinaryExpression( BinaryExpression( BinaryExpression(1 + 2) + 3 ) + 4 ) + 5 )</p>\n</blockquote>\n<p>因此我们得改造一下之前的代码逻辑，进行遍历操作：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token comment">// 如果上⾯的运算有结果的话 </span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 把表达式节点替换成number字⾯量 </span>\n  path<span class="token punctuation">.</span><span class="token function">replaceWith</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">numericLiteral</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n  \n  <span class="token comment">// 向上遍历⽗级节点</span>\n  <span class="token keyword">let</span> parentPath <span class="token operator">=</span> path<span class="token punctuation">.</span>parentPath<span class="token punctuation">;</span> \n  parentPath <span class="token operator">&amp;&amp;</span> visitor<span class="token punctuation">.</span><span class="token function">BinaryExpression</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> parentPath<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span> \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这样就能正确工作了。</p>\n<p><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#builders" target="_blank" rel="noopener noreferrer">参考文档：Babel插件手册<ExternalLinkIcon/></a></p>\n<h2 id="你们的git工作流是什么样的" tabindex="-1"><a class="header-anchor" href="#你们的git工作流是什么样的" aria-hidden="true">#</a> 你们的Git工作流是什么样的？</h2>\n<p>每个公司采用的 Git 工作流都可能会有差别，有的比较规范，有的比较随意。在这里介绍一个名为 GitFlow 的 git 标准操作流程。</p>\n<p>在 GitFlow 标准下，我们的 git 仓库需要包含以下几个关键分支：</p>\n<ul>\n<li>master：主分支</li>\n<li>develop：主开发分⽀。包含确定即将发布的代码</li>\n<li>feature：新功能分⽀。⼀个新功能对应⼀个分⽀</li>\n<li>release：发布分⽀。发布时⽤的分⽀，⼀般测试阶段发现的 bug 在这个分⽀进⾏修复</li>\n<li>hotfix：热补丁分支。用于修改在线上版本中发现的严重紧急 bug</li>\n</ul>\n<p><strong>GitFlow 的主要优点</strong></p>\n<ol>\n<li>支持并⾏开发</li>\n</ol>\n<p>因为每个新功能都会建⽴⼀个新的 feature 分⽀，从⽽和其他已经完成的功能隔离开，且当只有在新功能完成开发的情况下，其对应的 feature 分⽀才会被合并到主开发分⽀（develop 分支）。</p>\n<p>另外，如果你正在开发某个功能的同时⼜有⼀个新功能需要开始开发，那么你只需把当前 feature 的代码提交后，新建另外⼀个 feature 分⽀即可开发新功能了。</p>\n<p>你也可以随时切回之前的其他 feature 分⽀继续完成该功能的开发。</p>\n<ul>\n<li>协作开发</li>\n</ul>\n<p>因为每个 feature 分⽀上改动的代码都只对该 feature 对应的功能生效，所以不同 feature 分支上的代码在开发时不会互相影响，大家可以相安无事的开发自己负责的功能。</p>\n<p>同时我们可以根据分支的名称，很容易知道每个⼈都在做什么功能。</p>\n<ul>\n<li>发布阶段</li>\n</ul>\n<p>当⼀个新 feature 开发完成时，它会被合并到 develop 分⽀，这就意味着 develop 分支上包含了所有已经开发完成的功能。</p>\n<p>因此，在开发新的 feature 时，我们只需从 develop 分⽀来创建新的分⽀，即可在新的 feature 分支中包含所有已完成的最新功能。</p>\n<ul>\n<li>⽀持紧急修复</li>\n</ul>\n<p>hotfix 分⽀是从某个已经发布的 Tag 上创建出来来，用于紧急修复 Bug。</p>\n<p>该紧急修复只影响这个已经发布的 Tag，⽽不会影响你正在开发的其他新 feature 。</p>\n<p><strong>注意点</strong></p>\n<ol>\n<li>\n<p>feature 分⽀都是从 develop 分⽀上创建的，开发完成后再合并到 develop 分⽀上，等待发布</p>\n</li>\n<li>\n<p>当需要发布时，我们要从 develop 分⽀上创建⼀个 release 分⽀，然后该 release 分⽀会发布到测试环境进⾏测试。如果发现问题的话，就会直接在该分⽀上进⾏修复。所有问题修复之前，会不停重复 <code>发布</code> &gt; <code>测试</code> &gt; <code>修复</code> &gt; <code>重新发布</code>  &gt; <code>重新测试</code> 流程。 发布结束，该 release 分⽀会被合并到 develop 以及 master 分⽀，从⽽保证不会有代码丢失</p>\n</li>\n<li>\n<p>master 分⽀只跟踪已经发布的代码，合并到 master 上的 commit 只能来⾃ release 分⽀和 hotfix 分⽀</p>\n</li>\n<li>\n<p>hotfix 分⽀的作⽤是紧急修复⼀些 Bug，它们都是从 master 分⽀上的某个 Tag 建⽴，修复结束后再会被合并到 develop 和 master 分⽀上</p>\n</li>\n</ol>\n<p><a href="https://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener noreferrer">参考文章：Git工作流<ExternalLinkIcon/></a></p>\n<h2 id="git的rebase和merge的区别是什么" tabindex="-1"><a class="header-anchor" href="#git的rebase和merge的区别是什么" aria-hidden="true">#</a> Git的rebase和merge的区别是什么？</h2>\n<p><code>git rebase</code> 和 <code>git merge</code> 两个命令都⽤于从⼀个分⽀获取内容并合并到当前分⽀。</p>\n<p>以一个 <code>feature/todo</code> 分⽀合并到 <code>master</code>主分⽀为例，我们来看一下分别⽤ <code>rebase</code> 和 <code>merge</code> 会有什么不同。</p>\n<p><strong>使用 Merge</strong></p>\n<img src="/images/image-20210222132936016.png" alt="image-20210222132936016" style="zoom:30%;" />\n<p><code>merge</code> 会⾃动创建⼀个新的 <code>commit</code>， 如果合并时遇到冲突的话，只需要修改后重新 <code>commit</code>。</p>\n<ul>\n<li>\n<p>优点：能记录真实的 <code>commit</code> 情况，包括每个分⽀的详情</p>\n</li>\n<li>\n<p>缺点：由于每次 <code>merge</code> 会⾃动产⽣⼀个 <code>merge commit</code>，因此在使⽤⼀些可视化的 git 工具时会看到这些自动产生的 <code>commit</code>，这些 <code>commit</code> 对于程序员来说没有什么特别的意义，反而会影响阅读</p>\n</li>\n</ul>\n<p><strong>使用 Rebase</strong></p>\n<img src="/images/image-20210222133524146.png" alt="image-20210222133524146" style="zoom:30%;" />\n<p><code>rebase</code> 会合并之前的 <code>commit</code> 历史。</p>\n<ul>\n<li>\n<p>优点：可以得到更简洁的提交历史，去掉了 <code>merge commit</code></p>\n</li>\n<li>\n<p>缺点：因为合并而产生的代码问题，就不容易定位，因为会重写提交历史信息</p>\n</li>\n</ul>\n<p><strong>建议</strong></p>\n<ul>\n<li>\n<p>当需要保留详细的合并信息时，建议使⽤ <code>git merge</code>，特别是需要将分⽀合并进 <code>master</code> 分⽀时</p>\n</li>\n<li>\n<p>当发现⾃⼰修改某个功能时提交比较频繁，并觉得过多的提交信息对自己来说没有必要，那么可尝试使用 <code>git rebase</code></p>\n</li>\n</ul>\n<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue" aria-hidden="true">#</a> Vue</h1>\n<h2 id="什么是mvvm" tabindex="-1"><a class="header-anchor" href="#什么是mvvm" aria-hidden="true">#</a> 什么是MVVM？</h2>\n<p>Model-View-ViewModel 模式，最早在 2005 年微软推出的基于 Windows 的⽤户界⾯框架 WPF 中提出，而最早采用 MVVM 的前端框架是 2010 年发布的 Knockout。</p>\n<img src="/images/image-20210223221853817.png" alt="image-20210223221853817" style="zoom:100%;" />\n<p><strong>Model 层</strong></p>\n<p>对应数据层的域模型，主要用来做域模型的同步。</p>\n<p>通过 <code>Ajax</code>、<code>fetch</code> 等 API 完成客户端和服务端业务模型的同步。</p>\n<p>在分层关系中，它主要⽤于抽象出 ViewModel 层中视图的 Model。</p>\n<p><strong>View 层</strong></p>\n<p>作为视图模板存在，其实在 MVVM 中整个 View 就是⼀个动态模板。</p>\n<p>除了用于定义结构和布局之外，它还展示了 ViewModel 层的数据和状态。</p>\n<p>View 层并不负责状态的实际处理，它只是做：数据绑定声明、 指令声明、 事件绑定声明。</p>\n<p><strong>ViewModel 层</strong></p>\n<p>负责暴露数据给 View 层，并对 View 层中的数据绑定声明、 指令声明、 事件绑定声明进行实际的业务逻辑。</p>\n<p>ViewModel 底层会做好绑定属性的监听，当 ViewModel 中的数据变化时，View 层会自动进行更新；⽽当 View 中声明了数据的双向绑定（表单元素），框架也会监听 View 层（表单元素）值的变化，⼀旦变化，则 View 层绑定的 ViewModel 中的数据也会得到⾃动更新。</p>\n<h2 id="mvvm的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#mvvm的优缺点有哪些" aria-hidden="true">#</a> MVVM的优缺点有哪些？</h2>\n<p><strong>优点</strong></p>\n<ol>\n<li>实现了视图（View）和模型（Model）的分离，降低代码耦合、提⾼视图或逻辑的复⽤性</li>\n</ol>\n<blockquote>\n<p>⽐如：View 可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定于不同的 &quot;View&quot;，当 View 发生变化时 Model 一定会随之改变，而当 Model 变化时则 View 可以不变。我们可以把⼀些视图逻辑放在⼀个 ViewModel ⾥，以此让多个 View 重⽤这段视图逻辑。</p>\n</blockquote>\n<ol start="2">\n<li>\n<p>提⾼了可测试性：ViewModel 的存在可以帮助开发者更好地编写测试代码</p>\n</li>\n<li>\n<p>能⾃动更新 DOM：利⽤双向绑定，数据更新后视图⾃动更新，让开发者从繁琐的⼿动操作 DOM 中解放出来</p>\n</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>\n<p>Bug 很难被调试：因为使⽤了双向绑定的模式，当我们看到界⾯发生异常了，有可能是 View 的代码产生的 Bug，也有可能是Model 代码的问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 模版中的，它们没办法打断点进行 Debug</p>\n</li>\n<li>\n<p>在⼀个⼤的模块中 Model 也会很⼤，虽然使⽤上来说⽅便了，也能很容易的保证了数据的⼀致性，但如果⻓期持有不释放内存，就会造成更多的内存消耗</p>\n</li>\n<li>\n<p>对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼</p>\n</li>\n</ol>\n<h2 id="谈谈对vue生命周期的理解" tabindex="-1"><a class="header-anchor" href="#谈谈对vue生命周期的理解" aria-hidden="true">#</a> 谈谈对Vue生命周期的理解？</h2>\n<p><strong>生命周期的概念</strong></p>\n<p>每个 Vue 实例都有⼀个完整的⽣命周期：</p>\n<ol>\n<li>开始创建</li>\n<li>初始化数据</li>\n<li>编译模版</li>\n<li>挂载 DOM</li>\n<li>渲染、更新数据 =&gt; 重新渲染</li>\n<li>卸载</li>\n</ol>\n<p>这⼀系列过程我们称之为 Vue 的⽣命周期。</p>\n<p><strong>各个生命周期的作用</strong></p>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>执行时机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beforeCreate</td>\n<td>在组件实例被创建之初、组件的属性⽣效之前被调用</td>\n</tr>\n<tr>\n<td>created</td>\n<td>在组件实例已创建完毕。此时属性也已绑定，但真实DOM还未⽣成，$el 还不可⽤</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>在组件挂载开始之前被调⽤。相关的 render 函数⾸次被调⽤</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>在 el 被新建的 vm.$el 替换并挂载到实例上之后被调用</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>在组件数据更新之前调⽤。发⽣在虚拟 DOM 打补丁之前</td>\n</tr>\n<tr>\n<td>update</td>\n<td>在组件数据更新之后被调用</td>\n</tr>\n<tr>\n<td>activited</td>\n<td>在组件被激活时调⽤（使用了 <code>&lt;keep-alive&gt;</code> 的情况下）</td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td>在组件被销毁时调⽤（使用了 <code>&lt;keep-alive&gt;</code> 的情况下）</td>\n</tr>\n<tr>\n<td>beforeDestory</td>\n<td>在组件销毁前调⽤</td>\n</tr>\n<tr>\n<td>destoryed</td>\n<td>在组件销毁后调⽤</td>\n</tr>\n</tbody>\n</table>\n<p><strong>生命周期示意图</strong></p>\n<img src="/images/image-20210224084130350.png" alt="image-20210224084130350"  />\n<h2 id="在vue中网络请求应该放在哪个生命周期中发起" tabindex="-1"><a class="header-anchor" href="#在vue中网络请求应该放在哪个生命周期中发起" aria-hidden="true">#</a> 在Vue中网络请求应该放在哪个生命周期中发起？</h2>\n<p>可以在 <code>mounted</code> 或 <code>created</code> 这两个⽣命周期中调⽤发起网络请求。</p>\n<h2 id="vue组件之间如何进行通信" tabindex="-1"><a class="header-anchor" href="#vue组件之间如何进行通信" aria-hidden="true">#</a> Vue组件之间如何进行通信？</h2>\n<p><strong><code>props</code> 和 <code>$emit + v-on</code></strong></p>\n<p>通过 <code>props</code> 将数据在组件树中进行⾃上⽽下的传递；</p>\n<p>通过 <code>$emit</code> 和 <code>v-on</code> 来作信息的向上传递。</p>\n<p><strong>EventBus</strong></p>\n<p>可通过 EventBus 进⾏信息的发布与订阅。</p>\n<p><strong>Vuex</strong></p>\n<p>全局状态管理库。可通过它来进行全局数据流的管理。</p>\n<p><strong><code>$attrs</code> 和 <code>$listeners</code></strong></p>\n<p>在 Vue 2.4 版本中加⼊的 <code>$attrs</code> 和 <code>$listeners</code> 可以用来作为跨级组件之间的通信机制。</p>\n<p><strong><code>provide</code> 和 <code>inject</code></strong></p>\n<p>由于 <code>provide</code> 和 <code>inject</code> 可以允许⼀个祖先组件向它的所有⼦孙组件注⼊⼀个依赖（不论组件层次有多深），并在其上下游关系成⽴的时间⾥始终⽣效，因此这种机制也就成为了一种跨组件通信的手段。</p>\n<blockquote>\n<p>另外还有一些方式使用场景有限，在此不介绍了。</p>\n<p>可以阅读参考文章：<a href="https://juejin.cn/post/6844903887162310669" target="_blank" rel="noopener noreferrer">Vue中的8种组件通信方式<ExternalLinkIcon/></a></p>\n</blockquote>\n<h2 id="computed和watch的区别是什么" tabindex="-1"><a class="header-anchor" href="#computed和watch的区别是什么" aria-hidden="true">#</a> computed和watch的区别是什么？</h2>\n<p><strong>computed</strong></p>\n<ol>\n<li>\n<p>它是计算属性。主要用于值的计算并一般会返回一个值。所以它更多⽤于计算值的场景</p>\n</li>\n<li>\n<p>它具有缓存性。当访问它来获取值时，它的 getter 函数所计算出来的值会进行缓存，只有当它依赖的属性值发生了改变，那下⼀次再访问时才会重新调⽤ getter 函数来计算</p>\n</li>\n<li>\n<p>它适⽤于计算⽐较消耗性能的计算场景</p>\n</li>\n</ol>\n<p><strong>watch</strong></p>\n<ol>\n<li>\n<p>它更多的是起到 “观察” 的作⽤，类似于对数据进行变化的监听并执行回调。主要⽤于观察 <code>props</code>、<code>$emit</code> 或本组件的值，当这些值发生变化时，执⾏回调</p>\n</li>\n<li>\n<p>它不具有缓存性。当⻚⾯重新渲染时，即使值没发生变化也会执⾏</p>\n</li>\n</ol>\n<p><strong>建议</strong></p>\n<ol>\n<li>\n<p>当目的是进⾏数值计算，且依赖于其他数据，那么推荐使用 <code>computed</code></p>\n</li>\n<li>\n<p>当需要在某个数据发生变化的同时做⼀些稍复杂的逻辑操作，那么推荐使⽤ <code>watch</code></p>\n</li>\n</ol>\n<h2 id="vue双向绑定原理" tabindex="-1"><a class="header-anchor" href="#vue双向绑定原理" aria-hidden="true">#</a> Vue双向绑定原理？</h2>\n<p>在 Vue 2.x 中，利⽤的是 <code>Object.defineProperty</code> 去劫持对象的访问器（Getter、Setter），当对象属性值发⽣变化时可获取变化，然后根据变化来作后续响应；</p>\n<p>在 Vue 3.0 中，则是通过 <code>Proxy</code> 代理对象进⾏类似的操作。</p>\n<h2 id="object-defineproperty和proxy的优缺点" tabindex="-1"><a class="header-anchor" href="#object-defineproperty和proxy的优缺点" aria-hidden="true">#</a> Object.defineProperty和Proxy的优缺点？</h2>\n<p><strong>Proxy</strong></p>\n<ul>\n<li>\n<p>可以直接监听整个对象，⽽⾮是对象的属性</p>\n</li>\n<li>\n<p>可以直接监听数组的变化</p>\n</li>\n<li>\n<p>拦截⽅法丰富：多达13种，不限于 <code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code> 等。比 <code>Object.defineProperty</code> 强大很多</p>\n</li>\n<li>\n<p>返回的是⼀个新对象，可以在不影响原对象的情况下，只操作新对象来达到⽬的；⽽ <code>Object.defineProperty</code> 只能遍历原对象属性并直接修改原对象</p>\n</li>\n<li>\n<p>受到各浏览器⼚商的重点持续性能优化，能享受到作为新标准的性能红利</p>\n</li>\n</ul>\n<p><strong>Object.defineProperty</strong></p>\n<ul>\n<li>兼容性较好（可⽀持到 IE9）</li>\n</ul>\n<h2 id="如何理解vue的响应式系统" tabindex="-1"><a class="header-anchor" href="#如何理解vue的响应式系统" aria-hidden="true">#</a> 如何理解Vue的响应式系统？</h2>\n<p>(考察MVVM)   M: model数据模型,    V:view视图模型,  VM: viewModel视图数据模型</p>\n<p>双向:</p>\n<ol>\n<li>视图变化了, 数据自动更新   =&gt;  监听原生的事件即可,  输入框变了,  监听输入框input事件</li>\n<li>数据变化了, 视图要自动更新  =&gt;  vue2 和 vue3</li>\n</ol>\n<h3 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h3>\n<p>vue2.0 数据劫持:  Object.defineProperty  (es5)</p>\n<p>vue3.0 数据劫持:  Proxy   (es6)</p>\n<p>分析 :此题考查 Vue的 MVVM 原理</p>\n<p>解答:  Vue的双向绑定原理其实就是 MVVM 的基本原理, Vuejs官网已经说明, 实际就是通过 Object.defineProperty方法 完成了对于Vue实例中数据的 <strong><code>劫持</code></strong>, 通过对于 data中数据 进行set的劫持监听, 然后通过**<code>观察者模式</code>**, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新</p>\n<p>简单概述 : 通过Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新</p>\n<h3 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式" aria-hidden="true">#</a> 观察者模式</h3>\n<p>观察者模式:  当对象间存在  <strong>一对多</strong>  关系时，则使用观察者模式（Observer Pattern）。</p>\n<p>比如，当一个对象或者数据被修改时，则会自动通知依赖它的对象。</p>\n<p>**意图：**定义对象间的一种 <code>一对多的依赖关系</code>，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n<p>拍卖会的时候，大家相互叫价，拍卖师(Dep)会观察最高标价(Object.defineProperty)，</p>\n<p>一旦最高价变化了, 然后通知给其它竞价者(watcher观察者 - 订阅者, 订阅了价格的变化)，这就是一个观察者模式</p>\n<p>下图为Vue框架在数据初始化中使用观察者模式的示意图：</p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20201208122803496" originSrc="images/image-20201208122803496.png" data="aurora"></p>\n<p>Dep要进行 <strong>依赖收集</strong>，并通过一个subs数组, 记录观察者Watcher,</p>\n<p>Watcher 分为渲染 watcher、计算属性 watcher、侦听器 watcher三种</p>\n<p>收集依赖: 简单点说就是谁借了我的钱，我就把那个人  <strong>记下来</strong>  ，以后我的钱少了 我就通知他们说我没钱了</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">   // Watcher1(渲染), 依赖于msg\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> car <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">   // Watcher2(渲染),  依赖于car\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token punctuation">{</span><span class="token punctuation">{</span> myMsg <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">   // Watcher3(渲染), 依赖于myMsg\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">myMsg</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'计算属性重新计算了\'</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">+</span> <span class="token string">\'20\'</span>  <span class="token comment">// Watcher4(计算属性中), 依赖于msg, msg变了重新计算</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token literal-property property">watch</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">msg</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'新的msg\'</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span> <span class="token comment">// Watcher5(侦听器), 将来msg变化, 这边要执行这个函数</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>\n\n<span class="token comment">// 收集依赖 (dep结构有点类似于二维数组, (Map结构))   arr.type="msgDep"</span>\n<span class="token literal-property property">dep</span><span class="token operator">:</span> <span class="token punctuation">[</span>\n  <span class="token literal-property property">msgDep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">Watcher5</span><span class="token punctuation">(</span>侦听器依赖<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Watcher4</span><span class="token punctuation">(</span>计算属性依赖<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Watcher1</span><span class="token punctuation">(</span>渲染<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">carDep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">Watcher2</span><span class="token punctuation">(</span>渲染<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n  <span class="token literal-property property">myMsgDep</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">Watcher3</span><span class="token punctuation">(</span>渲染<span class="token punctuation">)</span><span class="token punctuation">]</span>\n<span class="token punctuation">]</span>\n\n\n<span class="token comment">// Watcher</span>\n<span class="token punctuation">{</span>\n  <span class="token literal-property property">callback</span><span class="token operator">:</span> Function<span class="token punctuation">,</span> <span class="token punctuation">(</span>数据变化后<span class="token punctuation">,</span> 需要执行的回调<span class="token punctuation">)</span>\n  <span class="token literal-property property">isRenderWatcher</span><span class="token operator">:</span> Boolean<span class="token punctuation">,</span> <span class="token punctuation">(</span>是否是render的watcher<span class="token punctuation">,</span> 是否要触发视图的更新<span class="token punctuation">,</span> 往后放<span class="token punctuation">,</span> 最后统一虚拟dom对比<span class="token punctuation">,</span> 统一更新<span class="token punctuation">)</span>\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>比如: 假定数据 money 变了, 那么没有任何与money相关的观察者, 就不需要进行任何更新操作, 也不需要执行任何的监视函数</p>\n<p>然而: 假定数据 msg 变了, 就会通知到相关的Watcher, 且优先通知侦听器Watcher和计算属性Watcher, 后进行统一的渲染更新</p>\n<ol>\n<li>通知侦听器Watcher,  立刻执行配置的函数,  console.log(\'新的msg\', newValue)</li>\n<li>通知计算属性Watcher, 计算属性依赖的值变了, 需要重新计算\n且更新后, myMsg 变化了,  需要进行进行视图的渲染  (render)     (--- 要更新, 等着---)</li>\n<li>通过到watcher1, 渲染Watcher  (---要更新---)</li>\n<li>最后统一进行, 新旧虚拟dom的对比, 完成视图的更新</li>\n</ol>\n<p><strong>当数据状态发生改变时，会被 Object.defineProperty 监听劫持到, 会通知到 Dep,  并根据收集的依赖关系,</strong></p>\n<p><strong>让订阅者Watcher进行数据更新（update）操作 ,  派发更新</strong></p>\n<p>总结概述: vue采用的是观察者模式, 是一种一对多的关系,  一上来vue在解析渲染时, 会进行依赖收集, 会将渲染 watcher、计算属性 watcher、侦听器 watcher, 都收集到dep中,将来Object.defineProperty 监听到数据变化, 就根据依赖关系, 派发更新</p>\n<h2 id="vue中的key到底有什么用" tabindex="-1"><a class="header-anchor" href="#vue中的key到底有什么用" aria-hidden="true">#</a> Vue中的key到底有什么用？</h2>\n<p><code>key</code> 是为 Vue 中的虚拟 DOM 节点（vNode）标记唯⼀性的 id。</p>\n<p>作用:  给虚拟dom添加标识,  <strong>(优化复用对比策略, 优化渲染性能)</strong></p>\n<p>主要考察:</p>\n<ol>\n<li>\n<p>vue 的更新机制 (差异化更新) 对比新旧虚拟dom 进行更新视图</p>\n<p>为什么对比虚拟dom, 而不对比真实的dom ? 真实的dom太复杂, 对比起来性能太差</p>\n</li>\n<li>\n<p>虚拟dom: 使用 js 对象的方式, 模拟真实的 dom 结构</p>\n<p>属性的量大大的减少了, 没有真实dom的那么多无效的属性, 对比起来性能高很多</p>\n</li>\n<li>\n<p>diff 算法: 默认的对比(diff) 机制,  同层兄弟元素, 是按照下标进行对比的, 但是加了 key,  <strong>就相当于给虚拟dom加了个标识</strong></p>\n<p>对比策略, 就是对相同key的元素进行对比了, 在列表v-for中, key的使用尤为常见, 可以用于优化渲染性能</p>\n</li>\n</ol>\n<h3 id="diff算法" tabindex="-1"><a class="header-anchor" href="#diff算法" aria-hidden="true">#</a> diff算法</h3>\n<p>diff 算法的基本策略 (对比新旧虚拟dom差异的一种算法):</p>\n<ol>\n<li>\n<p>由于dom结构是一个树形结构, 就算是对比新旧虚拟dom, 一样是在对比树形结构</p>\n<p>而树形结构, 每往下都一层, 遍历成本就越高</p>\n</li>\n<li>\n<p>为了避免一些无效的对比, diff算法, (tree diff) 优先比较树的根节点</p>\n<p>如果根节点元素类型(组件), 是一致的, 才考虑复用元素内部的结构</p>\n<p>如果根节点元素类型(组件), 不一致, 直接销毁, 重新构建新的结构</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>旧\n&lt;div>\n\t&lt;span>我是内容&lt;/span>\n&lt;/div>\n\n\n新\n&lt;li>\n\t&lt;a href="#">我是内容&lt;/a>\n\t&lt;span>我是内容&lt;/span>\n&lt;/li>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>大大的提升了对比的效率</p>\n</li>\n<li>\n<p>同一根节点下,   同级兄弟元素, 默认的对比策略: 按照下标对比</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>旧\n&lt;div class="box">\n\t&lt;h1>大标题&lt;/h1>\n\t&lt;p>内容&lt;/p>\n&lt;/div>\n\n新\n&lt;div class="message">\n\t&lt;h1>测试标题&lt;/h1>\n\t&lt;p>内容&lt;/p>\n&lt;/div>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li>\n<li>\n<p>同一根节点下,   同级兄弟元素,  如果配置 key 属性, 那么对比的策略, 就不是按照下标, 而是按照key进行 一一对比</p>\n<div class="language-text ext-text line-numbers-mode"><pre v-pre class="language-text"><code>旧\n&lt;div class="box">\n\t&lt;h1 key="201">大标题&lt;/h1>\n\t&lt;p key="202">内容&lt;/p>\n&lt;/div>\n\n新\n&lt;div class="message">\n\t&lt;h1 key="200">大标题&lt;/h1>   // 新结构\n\t&lt;p key="202">内容&lt;/p>    // 对比出来, 原来结构有key="202", 进行对比, 完成了复用\n&lt;/div>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果你希望一个结构, 并不进行复用, 就是希望某个组件某个结构,  能够重新构建, 可以设置一个不同的 key</p>\n</li>\n</ol>\n<h3 id="key的常见应用场景" tabindex="-1"><a class="header-anchor" href="#key的常见应用场景" aria-hidden="true">#</a> key的常见应用场景</h3>\n<p>key 的常见应用场景 =&gt; v-for,  v-for 遍历的列表中的项的顺序, 非常的容易改变</p>\n<p>1 往后面加, 默认的对比策略, 按照下标,  没有任何问题</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 旧</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 新</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">王五</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>2 往前面加, 由于下标变了, 如果按照之前的下标对比, 元素是混乱的, 策略: 加上key</p>\n<p>​    一旦加上了key, 就是按照 key 进行新旧dom的对比了</p>\n<div class="language-jsx ext-jsx line-numbers-mode"><pre v-pre class="language-jsx"><code><span class="token comment">// 旧 </span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>17<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>31<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n\n<span class="token comment">// 新  [ { id: 17, name: \'张三\' }, ... ]</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>52<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">王五</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>17<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">张三</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>31<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">李四</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">\n</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>总结: key 就是给 虚拟dom 添加了一个 标识, 优化了对比策略!!!</strong></p>\n<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true">#</a> React</h1>\n<h2 id="react最新的生命周期是怎么样的" tabindex="-1"><a class="header-anchor" href="#react最新的生命周期是怎么样的" aria-hidden="true">#</a> React最新的生命周期是怎么样的？</h2>\n<p>在 React 16 版本中，三个之前的生命周期被标识为废弃，并在 React 17 中计划全部删除它们：</p>\n<ul>\n<li>\n<p>componentWillMount</p>\n</li>\n<li>\n<p>componentWillReceiveProps</p>\n</li>\n<li>\n<p>componentWillUpdate</p>\n</li>\n</ul>\n<p>当它们被删除后，将会只保留三个添加了<code>UNSAVE_</code>前缀的函数版本，作为向下兼容用途。因此我们在新项目中，要尽量避免使用这几个生命周期而使用最新的生命周期函数。</p>\n<p>⽬前 React 16.8+ 的⽣命周期分为三个阶段：挂载阶段、更新阶段、卸载阶段。</p>\n<p><strong>挂载阶段</strong></p>\n<p><code>constructor</code> ：组件的构造函数，它会最先被执⾏，我们通常在构造函数⾥初始化 <code>state</code> 状态对象、或给⾃定义⽅法绑定 <code>this</code></p>\n<p><code>getDerivedStateFromProps</code> ：这是个静态⽅法，当我们接收到新的属性后想要去修改 <code>state</code> 时可以使用</p>\n<p><code>render</code>：这是个只返回需要渲染内容的纯函数，不要包含其它的业务逻辑，可以返回原⽣的 DOM、React 组件、Fragment、Portals、字符串和数字、Boolean 值 和 null 值等内容</p>\n<p><code>componentDidMount</code> ：在组件装载后被调⽤，此时可以获取 DOM 节点并操作，对服务器的请求、订阅等操作都可以写在这个地方，但记得要在 <code>componentWillUnmount</code> 中取消订阅，即释放资源</p>\n<p><strong>更新阶段</strong></p>\n<p><code>getDerivedStateFromProps</code> ：此⽅法在更新个挂载阶段都可能会调⽤</p>\n<p><code>shouldComponentUpdate</code> ：该函数有两个参数 <code>nextProps</code> 和 <code>nextState</code>，表示新的属性和变化之后的状态；它返回⼀个布尔值，<code>true</code> 表示会触发重新渲染，<code>false</code> 则表示不会触发重新渲染，默认返回 <code>true</code>。我们通常利⽤该⽣命周期来优化 React 程序的性能</p>\n<p><code>render</code> ：更新阶段也会触发此⽣命周期</p>\n<p><code>getSnapshotBeforeUpdate</code> ：该⽅法在 <code>render</code> 之后、在 <code>componentDidUpdate</code> 之前被调⽤，它有两个参数 <code>prevProps</code> 和<code>prevState</code>，表示之前的属性和状态，并且该函数有⼀个返回值，返回值会作为第三个参数传给 <code>componentDidUpdate</code> ，如果不想要返回值则返回 <code>null</code> 即可。该⽣命周期必须与 <code>componentDidUpdate</code> 搭配使⽤</p>\n<p><code>componentDidUpdate</code> ：该⽅法在 <code>getSnapshotBeforeUpdate</code> ⽅法之后被调⽤，它有三个参数 <code>prevProps</code> 、<code>prevState</code> 、<code>snapshot</code> ，表示之前的属性、之前的状态、以及<code>snapshot</code>。第三个参数是 <code>getSnapshotBeforeUpdate</code> 所返回的，如果触发某些回调函数时需要⽤到 DOM 元素的状态，则将对⽐或计算的过程迁移⾄ <code>getSnapshotBeforeUpdate</code>，然后在 <code>componentDidUpdate</code> 中统⼀触发回调或更新状态</p>\n<p><strong>卸载阶段</strong></p>\n<p><code>componentWillUnmount</code> ：当组件被卸载或销毁时就会被调⽤，我们可以在这个函数⾥去做一些释放资源的操作，如：清除定时器、取消⽹络请求、清理⽆效的 DOM 元素等</p>\n<p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank" rel="noopener noreferrer">React生命周期图形示意工具<ExternalLinkIcon/></a></p>\n<h2 id="在react中网络请求应该放在哪个生命周期中发起" tabindex="-1"><a class="header-anchor" href="#在react中网络请求应该放在哪个生命周期中发起" aria-hidden="true">#</a> 在React中网络请求应该放在哪个生命周期中发起？</h2>\n<p>有人认为 React 中的网络异步请求，应该放在 <code>componentWillMount</code> 这个生命周期函数中发起，这样可以提前进⾏异步请求，以避免⽩屏现象。其实这个观点是有问题的。</p>\n<p>由于 JavaScript 中异步事件的性质，当进行异步 API 调⽤时，浏览器会在此期间继续执⾏其他⼯作。因此，当 React 渲染⼀个组件时，它并不会等待 <code>componentWillMount</code> 执行完成任何事情，而是继续往前执行并继续做 <code>render</code> ，没有办法 “暂停” 渲染以等待远程数据的返回。</p>\n<p>⽽且，在 <code>componentWillMount</code> 中发起请求会存在⼀系列潜在问题：</p>\n<ul>\n<li>\n<p>在用 React 作为服务器渲染（SSR）时，如果在 <code>componentWillMount</code> 中进行数据的获取，则 <code>fetch data</code> 会执⾏两次：⼀次在服务端，⼀次在客户端，这就造成了多余的请求</p>\n</li>\n<li>\n<p>在 React 16 使用 React Fiber 架构重写后，<code>componentWillMount</code> 可能会在⼀次渲染中被多次调⽤。</p>\n</li>\n</ul>\n<p><strong>⽬前官⽅推荐的是在 <code>componentDidmount</code> 中进行异步请求。</strong></p>\n<p>如遇到特殊需求，需要提前进行数据的请求，可考虑采用在 <code>constructor</code> 中进行。</p>\n<p>另外，由于在 React 17 之后 <code>componentWillMount</code> 被废弃仅保留 <code>UNSAFE_componentWillMount</code>，所以要慎用该生命周期。</p>\n<h2 id="setstate是同步的还是异步的" tabindex="-1"><a class="header-anchor" href="#setstate是同步的还是异步的" aria-hidden="true">#</a> setState是同步的还是异步的？</h2>\n<p>答案是：有时表现出异步，有时表现出同步！</p>\n<ul>\n<li>在合成事件和生命周期钩⼦函数中是异步的</li>\n<li>在原⽣事件和 <code>setTimeout</code> 中是同步的</li>\n</ul>\n<p><code>setState</code> 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。</p>\n<p>当然，我们可以通过使用第⼆个参数来拿到更新后的结果，它是个回调函数：</p>\n<div class="language-javascript ext-js line-numbers-mode"><pre v-pre class="language-javascript"><code><span class="token function">setState</span><span class="token punctuation">(</span>partialState<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>此外，<code>setState</code> 的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和 <code>setTimeout</code> 中不会批量更新。在异步中，如果对同⼀个值进⾏多次 <code>setState</code>，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时 <code>setState</code> 多个不同的值，则会在更新时对其进⾏合并批量更新。</p>\n<h2 id="react中如何实现组件间的通信" tabindex="-1"><a class="header-anchor" href="#react中如何实现组件间的通信" aria-hidden="true">#</a> React中如何实现组件间的通信？</h2>\n<p>组件间通信⽅式一共有如下几种：</p>\n<ol>\n<li>⽗组件向⼦组件通讯</li>\n</ol>\n<p>⽗组件可以通过向⼦组件传 <code>props</code> 的⽅式来实现父到子的通讯。</p>\n<ol start="2">\n<li>⼦组件向⽗组件通讯</li>\n</ol>\n<p>可以采用 <code>props + 回调</code> 的⽅式。</p>\n<p>当⽗组件向⼦组件传递 <code>props</code> 进⾏通讯时，可在该 <code>props</code> 中传递一个回调函数，当⼦组件调⽤该函数时，可将⼦组件中想要传递给父组件的信息作为参数传递给该函数。由于 <code>props</code> 中的函数作⽤域为⽗组件⾃身，因此可以通过该函数内的 <code>setState</code> 更新到⽗组件上。</p>\n<ol start="3">\n<li>兄弟组件通信</li>\n</ol>\n<p>可以通过兄弟节点的共同⽗节点，再结合以上2种⽅式，由⽗节点转发信息，实现兄弟间通信。</p>\n<ol start="4">\n<li>跨层级通信</li>\n</ol>\n<p>可以采用 React 中的 <code>Context</code> 来实现跨越多层的全局数据通信。</p>\n<p><code>Context</code> 设计的⽬的是为在⼀个组件树中共享 “全局” 数据，如：当前已登录的⽤户、界面主题、界面语⾔等信息。</p>\n<ol start="5">\n<li>发布订阅模式</li>\n</ol>\n<p>发布者发布事件，订阅者监听到事件后做出反应。</p>\n<p>我们可以通过引⼊ <code>event</code> 模块进⾏此种方式的通信。</p>\n<ol start="6">\n<li>全局状态管理⼯具</li>\n</ol>\n<p>可以借助 <code>Redux</code> 或 <code>Mobx</code> 等全局状态管理⼯具进⾏通信，它们会维护⼀个全局状态中⼼（Store），并可以根据不同的事件产⽣新的状态。</p>\n<img src="/images/image-20210223093430679.png" alt="image-20210223093430679" style="zoom:30%;" /> \n<h2 id="react存在哪些性能优化手段" tabindex="-1"><a class="header-anchor" href="#react存在哪些性能优化手段" aria-hidden="true">#</a> React存在哪些性能优化手段？</h2>\n<p>前端项目的性能手段，其实都是相通的。我们可以参考文章：<a href="https://blog.csdn.net/weixin_33976072/article/details/93168109" target="_blank" rel="noopener noreferrer">前端性能优化<ExternalLinkIcon/></a></p>\n<h2 id="react中如何进行组件和逻辑的复用" tabindex="-1"><a class="header-anchor" href="#react中如何进行组件和逻辑的复用" aria-hidden="true">#</a> React中如何进行组件和逻辑的复用？</h2>\n<p>React 中的组件抽象的技术有以下几种:</p>\n<ul>\n<li>\n<p>混合（mixin，官方已废弃）</p>\n</li>\n<li>\n<p>⾼阶组件（hoc）：属性代理、反向继承</p>\n</li>\n<li>\n<p>渲染属性（render props）</p>\n</li>\n<li>\n<p>React Hooks（配合函数式组件使用，函数拆分的复用理念）</p>\n</li>\n</ul>\n<h2 id="mixin、hoc、render-props、react-hooks的优缺点分别是什么" tabindex="-1"><a class="header-anchor" href="#mixin、hoc、render-props、react-hooks的优缺点分别是什么" aria-hidden="true">#</a> Mixin、HoC、Render props、React Hooks的优缺点分别是什么？</h2>\n<p><strong>Mixin</strong></p>\n<ul>\n<li>\n<p>组件与 Mixin 之间存在隐式依赖（Mixin 经常依赖于组件的特定⽅法，但在定义组件时并不知道这种依赖关系）</p>\n</li>\n<li>\n<p>多个 Mixin 之间可能产⽣冲突，⽐如：多个 Mixin 中定义了相同的 state 字段，在一个组件中同时引入这些 Mixin 后会产生字段冲突</p>\n</li>\n<li>\n<p>Mixin 倾向于增加更多状态，这降低了应⽤的可预测性，状态越多越难管理和溯源，复杂度剧增</p>\n</li>\n<li>\n<p>隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：</p>\n<ul>\n<li>\n<p>难以快速理解组件的⾏为，需要全盘了解所有依赖 Mixin 的扩展⾏为及其之间的相互影响</p>\n</li>\n<li>\n<p>33333组件⾃身的⽅法和 state 字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它</p>\n</li>\n<li>\n<p>Mixin 也难以维护，因为 Mixin 逻辑最后会被摊平合并到⼀起，很难搞清楚⼀个 Mixin 的输⼊输出</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>HoC</strong></p>\n<p>优点：</p>\n<p>相⽐ Mixin，HoC 通过外层组件传递 props 来影响内层组件的状态，⽽不是直接改变其 state，这就不存在冲突和互相⼲扰，降低了耦合度。不同于 Mixin 的打平 + 合并，HoC 天然具有层级结构（组件树结构），这⼜降低了复杂度。</p>\n<p>缺点：</p>\n<ul>\n<li>\n<p>扩展性限制：HoC ⽆法从外部访问⼦组件的 state，因此⽆法通过 <code>shouldComponentUpdate</code> 滤掉不必要的更新；React 在⽀持ES6 Class 之后提供了 <code>React.PureComponent</code> 解决了这个问题</p>\n</li>\n<li>\n<p>Ref 传递问题：Ref 被隔断。后来出现了 <code>React.forwardRef</code> 来解决了这个问题</p>\n</li>\n<li>\n<p>包装地狱（Wrapper Hell）：和回调函数类似，HoC 如果出现多层包裹组件的情况，就会和回调函数一样层层嵌套；而这种多层抽象同样也增加了复杂度和理解成本</p>\n</li>\n<li>\n<p>命名冲突：如果⾼阶组件多次嵌套而没有使⽤命名空间，就可能会产⽣冲突，覆盖⽼的属性</p>\n</li>\n<li>\n<p>不可⻅性：HoC 相当于在原有组件外层再包装⼀个组件，你有可能压根都不知道外层的包装是什么，对于你来说完全是⿊盒</p>\n</li>\n</ul>\n<p><strong>Render Props</strong></p>\n<p>优点：</p>\n<p>上述所说的 HoC 缺点，使用 Render Props 都可得到解决。</p>\n<p>缺点：</p>\n<ul>\n<li>\n<p>使⽤繁琐：HoC 使⽤只需要借助装饰器语法，通常⼀⾏代码就可以进⾏复⽤，而 Render Props ⽆法做到如此简单</p>\n</li>\n<li>\n<p>嵌套过深：Render Props 虽然摆脱了组件多层嵌套问题，但其又会走回到了回调函数的嵌套问题</p>\n</li>\n</ul>\n<p><strong>React Hooks</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>简洁：React Hooks 解决了 HoC 和 Render Props 的嵌套问题，代码更加简洁</p>\n</li>\n<li>\n<p>解耦：React Hooks 可以更⽅便地把 UI 和状态分离，做到更彻底的解耦</p>\n</li>\n<li>\n<p>组合：Hooks 中可以通过引⽤另外的 Hooks 以此形成新的 Hooks，变化丰富</p>\n</li>\n<li>\n<p>函数友好：React Hooks 为函数组件⽽⽣，从⽽解决了类组件的⼏⼤问题:</p>\n<ul>\n<li>\n<p>this 指向容易错误</p>\n</li>\n<li>\n<p>分割在不同声明周期中的逻辑会使得代码难以理解和维护</p>\n</li>\n<li>\n<p>代码复⽤成本⾼（⾼阶组件容易使代码量剧增）</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>有额外的学习成本（需要学习和区分类组件、函数组件）</p>\n</li>\n<li>\n<p>写法上有限制（不能出现在条件、循环中），并且这种写法限制会增加代码重构时的成本</p>\n</li>\n<li>\n<p>破坏了 <code>PureComponent</code>、<code>React.memo</code> 浅⽐较的性能优化效果（为了获取最新的 props 和 state，每次 <code>render()</code> 都要重新</p>\n</li>\n</ul>\n<p>创建事件处理函数）</p>\n<ul>\n<li>在闭包场景中可能会引⽤到旧的 state、props 值</li>\n<li>内部实现上不直观（依赖⼀份可变的全局状态，不再那么“纯”）</li>\n<li><code>React.memo</code> 并不能完全替代 <code>shouldComponentUpdate</code>（因为获取不到 state 的变化，只针对 props 的变化）</li>\n</ul>\n<h2 id="redux的工作流程是怎么样的" tabindex="-1"><a class="header-anchor" href="#redux的工作流程是怎么样的" aria-hidden="true">#</a> Redux的工作流程是怎么样的？</h2>\n<p><strong>核心概念</strong></p>\n<ul>\n<li>\n<p><code>Store</code>：一个保存数据的容器，整个应⽤只有⼀个 Store</p>\n</li>\n<li>\n<p><code>State</code>：Store 对象内包含所有数据，如想得到某一时间点的数据，就要对 Store ⽣成快照，这种时间点的数据集合，就叫 State</p>\n</li>\n<li>\n<p><code>Action</code>：State 的变化会导致 View 的变化，但⽤户是接触不到 State 的，只能接触到 View，所以 State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发⽣变化了</p>\n</li>\n<li>\n<p><code>Action Creator</code>：View 要发送多少种消息，就需要有多少种 Action，如果都⼿写会比较麻烦，因此我们通常会定义一个用于生成 Action 的函数，该函数就被称为 Action Creator</p>\n</li>\n<li>\n<p><code>Reducer</code>：在 Store 收到 Action 以后，必须给出⼀个新的 State，这样 View 才会发⽣变化。这种 State 的计算过程就叫做Reducer。Reducer 是⼀个函数，它接收 Action 和当前 State 作为参数，返回值是⼀个新的 State</p>\n</li>\n<li>\n<p><code>dispatch</code>：是 View 发送 Action 的唯⼀⽅法</p>\n</li>\n</ul>\n<p><strong>⼯作流程</strong></p>\n<img src="/images/image-20210223103127034.png" alt="image-20210223103127034" style="zoom:90%;" />\n<p>⼀次⽤户交互的流程如下：</p>\n<ol>\n<li>\n<p>⾸先，View（通过⽤户）发出 Action，发出⽅式就是使用 <code>dispatch</code> ⽅法</p>\n</li>\n<li>\n<p>然后，Store 调⽤ Reducer 并且传⼊两个参数（当前的 State 和收到的 Action），Reducer 处理后返回新的 State</p>\n</li>\n<li>\n<p>State ⼀旦有变化，则 Store 会调⽤监听函数来通知 View 进行更新</p>\n</li>\n</ol>\n<p>注意，在整个流程中，数据都是单向流动的，我们称之为单向数据流，这种⽅式可以保证流程的清晰性。</p>\n<h2 id="react-redux这个库是如何工作的" tabindex="-1"><a class="header-anchor" href="#react-redux这个库是如何工作的" aria-hidden="true">#</a> react-redux这个库是如何工作的？</h2>\n<p><strong>核心概念</strong></p>\n<p><strong><code>Provider</code></strong></p>\n<p>Provider 的作⽤是从最外部封装了整个应⽤，并向 <code>connect</code> 模块传递 <code>store</code> 。</p>\n<p><strong><code>connect</code></strong></p>\n<p>负责将 React 和 Redux 关联起来，它的作用主要如下：</p>\n<ul>\n<li>\n<p>获取 <code>state</code>：<code>connect</code> 先通过 <code>context</code> 来获取存放在 <code>Provider</code> 中的 <code>store</code>，然后通过 <code>store.getState()</code> 来获取整个 <code>store tree</code> 上所存放的 <code>state</code></p>\n</li>\n<li>\n<p>包装原组件：<code>connect</code> 将 <code>state</code> 和 <code>action</code> 通过 <code>props</code> 传⼊到原组件的内部，并调用 <code>wrapWithConnect</code> 函数来包装和返回⼀个 <code>Connect</code> 对象，<code>Connect</code> 对象重新 <code>render</code> 外部传⼊的原组件，并把 <code>connect</code> 中传⼊的 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 与组件原有的 <code>props</code> 合并后，通过属性的⽅式传给包装组件</p>\n</li>\n<li>\n<p>监听 <code>store tree</code> 变化：<code>connect</code> 缓存了 <code>store tree</code> 中 <code>state</code> 的状态，通过对比当前 <code>state </code> 和变更前 <code>state</code>，确定是否需要调⽤ <code>this.setState()</code> ⽅法，以此触发 <code>Connect</code> 及其⼦组件的重新渲染</p>\n</li>\n</ul>\n<p><strong>流程图</strong></p>\n<p><img src="https://ooszy.cco.vin/img/blog-public/ljz.gif" alt="image-20210223104924017" originSrc="/images/image-20210223104924017.png" data="aurora"></p>\n<h2 id="redux和mobx的区别" tabindex="-1"><a class="header-anchor" href="#redux和mobx的区别" aria-hidden="true">#</a> Redux和Mobx的区别？</h2>\n<table>\n<thead>\n<tr>\n<th>比较点</th>\n<th>Redux</th>\n<th>Mobx</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储方式</td>\n<td>保存在单⼀的 store 中</td>\n<td>保存在分散的多个 store 中</td>\n</tr>\n<tr>\n<td>数据结构</td>\n<td>使⽤ plain object 保存数据，需要⼿动处理变化后的操作</td>\n<td>使⽤ observable 保存数据，数据变化后⾃动处理响应的操作（类似 Vuex）</td>\n</tr>\n<tr>\n<td>数据可变性</td>\n<td>不可变状态，只读不能直接修改，应使⽤纯函数返回⼀个新状态</td>\n<td>状态是可变的，可直接进⾏修改</td>\n</tr>\n<tr>\n<td>难易度</td>\n<td>比较复杂<br />涉及函数式编程思想，掌握起来不那么容易，同时需借助⼀些中间件处理异步和副作⽤</td>\n<td>比较简单<br />使用面向对象的编程思维</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>容易<br />使用纯函数，并提供了时间回溯⼯具，因此调试直观方便</td>\n<td>⽐较困难<br />有更多的对象抽象和封装，调试会⽐较困难</td>\n</tr>\n</tbody>\n</table>\n<p><strong>使⽤场景</strong></p>\n<p><code>Mobx</code></p>\n<ul>\n<li>\n<p>更适合数据不复杂的应⽤。因为 mobx 难以调试，很多状态⽆法回溯，⾯对复杂度⾼的应⽤时往往⼒不从⼼</p>\n</li>\n<li>\n<p>适合短平快的项⽬。因为 mobx上⼿简单，样板代码少，很⼤程度上提⾼了开发效率</p>\n</li>\n</ul>\n<p><code>Redux</code></p>\n<ul>\n<li>适合有回溯需求的应⽤。⽐如，画板、表格等应⽤，一般有撤销、重做等操作，由于 Redux 具有不可变的特性，天然⽀持这些操作</li>\n</ul>\n<p>我们也可以在一个项目中同时使用 <code>Mobx</code> 和 <code>Redux</code> ，让两者发挥各自的长处，比如：</p>\n<ul>\n<li>使用 <code>Redux</code> 作为全局状态管理</li>\n<li>使⽤ <code>Mobx </code>作为组件的局部状态管理器</li>\n</ul>\n<h2 id="在redux中如何进行异步操作" tabindex="-1"><a class="header-anchor" href="#在redux中如何进行异步操作" aria-hidden="true">#</a> 在Redux中如何进行异步操作？</h2>\n<p>一般项目中，我们可以直接在 <code>componentDidMount</code> 中进⾏异步操作，比如发送网络请求，⽆须借助 Redux。但如果我们的项目上了一定的规模，这种方法再管理异步流的时候就比较困难。这个时候，我们会借助 Redux 的异步中间件来进⾏异步处理。</p>\n<p>Redux 其实有多种异步中间件，但当下主流的只有两种：<code>redux-thunk</code> 和 <code>redux-saga</code>。</p>\n<p><strong>redux-thunk</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>体积⼩：redux-thunk 的实现⽅式很简单，只有不到20⾏代码</p>\n</li>\n<li>\n<p>使⽤简单：redux-thunk 没有引⼊像 redux-saga 或者 redux-observable 额外的编程范式，上⼿非常简单</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>样板代码过多：与 redux 本身⼀样，通常发送⼀个请求就需要编写⼤量代码，⽽且很多都是重复性的</p>\n</li>\n<li>\n<p>耦合严重：异步操作与 redux 的 action 偶合在⼀起，不⽅便管理</p>\n</li>\n<li>\n<p>功能薄弱：实际开发中常⽤的⼀些功能都需要⾃⼰封装</p>\n</li>\n</ul>\n<p><strong>redux-saga</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>异步解耦：异步操作被被转移到了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中</p>\n</li>\n<li>\n<p>action 摆脱了 thunk function：dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满了 “⿊魔法” 的 thunk function</p>\n</li>\n<li>\n<p>异常处理：受益于 Generator Function 的 saga 实现，代码异常/请求失败都可直接通过 try/catch 捕获处理</p>\n</li>\n<li>\n<p>功能强⼤：redux-saga 提供了⼤量的 Saga 辅助函数和 Effect 创建器，开发者⽆须自行封装、或只要简单封装即可使⽤</p>\n</li>\n<li>\n<p>灵活：redux-saga 可将多个 Saga 进行串⾏或并⾏组合，形成⼀个⾮常实⽤的异步流程</p>\n</li>\n<li>\n<p>易测试：提供了各种测试⽅案，包括 mock task、分⽀覆盖等</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>额外的学习成本：redux-saga 不仅使⽤了难以理解的 Generator Function，⽽且存在数⼗个 API，学习成本远超 redux-thunk；最重要的是，这些额外的学习成本只能用于使用这个库的（而对于 redux-observable 来说，它虽也有学习成本，但它基于 rxjs ，这套编程思想和技术体系可以沿用到其他地方去）</p>\n</li>\n<li>\n<p>体积庞⼤：代码近 2000 ⾏（压缩后大约 25KB）</p>\n</li>\n<li>\n<p>功能过剩：其中提供的并发控制等功能，实际开发中很难会⽤到，但我们依然要引⼊这些代码</p>\n</li>\n<li>\n<p>对 TS ⽀持不友好：yield ⽆法返回 TS 类型</p>\n</li>\n</ul>\n<p><strong>redux-observable</strong></p>\n<p>优点：</p>\n<ul>\n<li>\n<p>功能最强：由于基于 rxjs 这个强⼤的响应式编程库，借助 rxjs 的操作符⼏乎可以做任何你能想到的异步处理</p>\n</li>\n<li>\n<p>知识沿用：如果你已学习过 rxjs，那么 redux-observable 的学习成本并不⾼；⽽且，随着 rxjs 的升级，redux-observable 也会变得更强⼤</p>\n</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>\n<p>学习成本奇⾼：对于还不会 rxjs 的开发者来说，需要额外的学习两个都较为复杂的库</p>\n</li>\n<li>\n<p>社区⼀般：redux-observable 下载量只有 redux-saga 的 1/5，社区不够活跃，而 redux-saga 仍处于领导地位</p>\n</li>\n</ul>\n',date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:"/前端面试手册/前端面试手册.html",pathLocale:"/",permalink:null,routeMeta:{},slug:"前端面试手册",filePath:"D:/桌面文件/Blog/blog-demo/docs/前端面试手册/前端面试手册.md",filePathRelative:"前端面试手册/前端面试手册.md",componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/前端面试手册/前端面试手册.html.vue",componentFilePathRelative:"pages/前端面试手册/前端面试手册.html.vue",componentFileChunkName:"v-0a97e47a",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/前端面试手册/前端面试手册.html.js",dataFilePathRelative:"pages/前端面试手册/前端面试手册.html.js",dataFileChunkName:"v-0a97e47a",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/前端面试手册/前端面试手册.html",htmlFilePathRelative:"前端面试手册/前端面试手册.html"},{data:{key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],git:{}},key:"v-3706649a",path:"/404.html",title:"",lang:"zh-CN",frontmatter:{layout:"404"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/404.html.vue",componentFilePathRelative:"pages/404.html.vue",componentFileChunkName:"v-3706649a",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/404.html.js",dataFilePathRelative:"pages/404.html.js",dataFileChunkName:"v-3706649a",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/404.html",htmlFilePathRelative:"404.html"},{data:{key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],git:{}},key:"v-8daa1a0e",path:"/",title:"",lang:"zh-CN",frontmatter:{layout:"Layout",home:!0},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/index.html.vue",componentFilePathRelative:"pages/index.html.vue",componentFileChunkName:"v-8daa1a0e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/index.html.js",dataFilePathRelative:"pages/index.html.js",dataFileChunkName:"v-8daa1a0e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/index.html",htmlFilePathRelative:"index.html"},{data:{key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],git:{}},key:"v-74bc627b",path:"/about/",title:"",lang:"zh-CN",frontmatter:{layout:"About",slug:"aurora-about"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/about/index.html.vue",componentFilePathRelative:"pages/about/index.html.vue",componentFileChunkName:"v-74bc627b",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/about/index.html.js",dataFilePathRelative:"pages/about/index.html.js",dataFileChunkName:"v-74bc627b",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/about/index.html",htmlFilePathRelative:"about/index.html"},{data:{key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],git:{}},key:"v-14f724bf",path:"/mood/",title:"",lang:"zh-CN",frontmatter:{layout:"Mood",slug:"aurora-mood"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/mood/index.html.vue",componentFilePathRelative:"pages/mood/index.html.vue",componentFileChunkName:"v-14f724bf",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/mood/index.html.js",dataFilePathRelative:"pages/mood/index.html.js",dataFileChunkName:"v-14f724bf",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/mood/index.html",htmlFilePathRelative:"mood/index.html"},{data:{key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],git:{}},key:"v-14e6501c",path:"/link/",title:"",lang:"zh-CN",frontmatter:{layout:"Link",slug:"aurora-link"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/link/index.html.vue",componentFilePathRelative:"pages/link/index.html.vue",componentFileChunkName:"v-14e6501c",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/link/index.html.js",dataFilePathRelative:"pages/link/index.html.js",dataFileChunkName:"v-14e6501c",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/link/index.html",htmlFilePathRelative:"link/index.html"},{data:{key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],git:{}},key:"v-744d024e",path:"/tag/",title:"",lang:"zh-CN",frontmatter:{layout:"Tag",slug:"aurora-tag"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/tag/index.html.vue",componentFilePathRelative:"pages/tag/index.html.vue",componentFileChunkName:"v-744d024e",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/tag/index.html.js",dataFilePathRelative:"pages/tag/index.html.js",dataFileChunkName:"v-744d024e",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/tag/index.html",htmlFilePathRelative:"tag/index.html"},{data:{key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],git:{}},key:"v-705c21a6",path:"/archive/",title:"",lang:"zh-CN",frontmatter:{layout:"Archive",slug:"aurora-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/archive/index.html.vue",componentFilePathRelative:"pages/archive/index.html.vue",componentFileChunkName:"v-705c21a6",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/archive/index.html.js",dataFilePathRelative:"pages/archive/index.html.js",dataFileChunkName:"v-705c21a6",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/archive/index.html",htmlFilePathRelative:"archive/index.html"},{data:{key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],git:{}},key:"v-3279cf61",path:"/aurora-archive/",title:"",lang:"zh-CN",frontmatter:{layout:"AuroraArchive",slug:"aurora-plugin-archive"},excerpt:"",headers:[],content:"",contentRendered:"",date:"0000-00-00",deps:[],hoistedTags:[],links:[],pathInferred:null,pathLocale:"/",permalink:null,routeMeta:{},slug:"",filePath:null,filePathRelative:null,componentFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/aurora-archive/index.html.vue",componentFilePathRelative:"pages/aurora-archive/index.html.vue",componentFileChunkName:"v-3279cf61",dataFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/.temp/pages/aurora-archive/index.html.js",dataFilePathRelative:"pages/aurora-archive/index.html.js",dataFileChunkName:"v-3279cf61",htmlFilePath:"D:/桌面文件/Blog/blog-demo/docs/.vuepress/dist/aurora-archive/index.html",htmlFilePathRelative:"aurora-archive/index.html"}]}},n=>{n.O(0,[254,231],(()=>(5698,n(n.s=5698)))),n.O()}]);